/* automatically generated by rust-bindgen 0.59.2 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MBEDTLS_CONFIG_FILE: &[u8; 9usize] = b"config.h\0";
pub const MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT: u32 = 0;
pub const MBEDTLS_SSL_MAX_EARLY_DATA_SIZE: u32 = 1024;
pub const MBEDTLS_SSL_TLS1_3_TICKET_AGE_TOLERANCE: u32 = 6000;
pub const MBEDTLS_SSL_TLS1_3_TICKET_NONCE_LENGTH: u32 = 32;
pub const MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS: u32 = 1;
pub const MBEDTLS_VERSION_MAJOR: u32 = 3;
pub const MBEDTLS_VERSION_MINOR: u32 = 4;
pub const MBEDTLS_VERSION_PATCH: u32 = 0;
pub const MBEDTLS_VERSION_NUMBER: u32 = 50593792;
pub const MBEDTLS_VERSION_STRING: &[u8; 6usize] = b"3.4.0\0";
pub const MBEDTLS_VERSION_STRING_FULL: &[u8; 15usize] = b"mbed TLS 3.4.0\0";
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const PSA_WANT_ALG_CCM: u32 = 1;
pub const PSA_WANT_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CMAC: u32 = 1;
pub const PSA_WANT_ALG_CMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDH: u32 = 1;
pub const PSA_WANT_ALG_ECDH: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA_ANY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_GCM: u32 = 1;
pub const PSA_WANT_ALG_GCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HMAC: u32 = 1;
pub const PSA_WANT_ALG_HMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF: u32 = 1;
pub const PSA_WANT_ALG_HKDF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXTRACT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXPAND: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PRF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_MD5: u32 = 1;
pub const PSA_WANT_ALG_MD5: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_PAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_JPAKE: u32 = 1;
pub const PSA_WANT_ALG_JPAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RIPEMD160: u32 = 1;
pub const PSA_WANT_ALG_RIPEMD160: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN_RAW: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_OAEP: u32 = 1;
pub const PSA_WANT_ALG_RSA_OAEP: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS: u32 = 1;
pub const PSA_WANT_ALG_RSA_PSS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_1: u32 = 1;
pub const PSA_WANT_ALG_SHA_1: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_224: u32 = 1;
pub const PSA_WANT_ALG_SHA_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_256: u32 = 1;
pub const PSA_WANT_ALG_SHA_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_384: u32 = 1;
pub const PSA_WANT_ALG_SHA_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_KEY_TYPE_AES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ARIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CAMELLIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CAMELLIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CHACHA20: u32 = 1;
pub const PSA_WANT_ALG_STREAM_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CHACHA20: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_STREAM_CIPHER: u32 = 1;
pub const PSA_WANT_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_CBC_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7: u32 = 1;
pub const PSA_WANT_ALG_CBC_PKCS7: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_ECB_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CFB: u32 = 1;
pub const PSA_WANT_ALG_CFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CTR: u32 = 1;
pub const PSA_WANT_ALG_CTR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_OFB: u32 = 1;
pub const PSA_WANT_ALG_OFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_255: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_448: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_521: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_256: u32 = 1;
pub const PSA_HAVE_FULL_ECDSA: u32 = 1;
pub const PSA_HAVE_FULL_JPAKE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DERIVE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD_HASH: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RAW_DATA: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _WANT_USE_LONG_TIME_T: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const ARG_MAX: u32 = 4096;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 2;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const MBEDTLS_ECP_DP_MAX: u32 = 14;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 4;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_MD_MAX_BLOCK_SIZE: u32 = 128;
pub const MBEDTLS_ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const MBEDTLS_ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const MBEDTLS_ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const MBEDTLS_ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const MBEDTLS_ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const MBEDTLS_ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const MBEDTLS_ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const MBEDTLS_ERR_RSA_RNG_FAILED: i32 = -17536;
pub const MBEDTLS_RSA_PKCS_V15: u32 = 0;
pub const MBEDTLS_RSA_PKCS_V21: u32 = 1;
pub const MBEDTLS_RSA_SIGN: u32 = 1;
pub const MBEDTLS_RSA_CRYPT: u32 = 2;
pub const MBEDTLS_RSA_SALT_LEN_ANY: i32 = -1;
pub const MBEDTLS_ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const MBEDTLS_ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const MBEDTLS_ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const MBEDTLS_ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const MBEDTLS_ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const MBEDTLS_ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const MBEDTLS_ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const MBEDTLS_ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const MBEDTLS_ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const MBEDTLS_ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const MBEDTLS_ERR_PK_INVALID_ALG: i32 = -14976;
pub const MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const MBEDTLS_ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const MBEDTLS_ERR_PK_BUFFER_TOO_SMALL: i32 = -14464;
pub const MBEDTLS_PK_SIGNATURE_MAX_SIZE: u32 = 0;
pub const MBEDTLS_PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_KEY_LENGTH: u32 = 64;
pub const MBEDTLS_TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 148;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 149;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256: u32 = 168;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384: u32 = 169;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 170;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 171;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 172;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 173;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA256: u32 = 176;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA384: u32 = 177;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 180;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 181;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 182;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 183;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 186;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 190;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 192;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49212;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49213;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49220;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49221;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49224;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49225;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49226;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49227;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49228;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49229;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49230;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49231;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49232;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49233;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49234;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49235;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49244;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49245;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49246;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49247;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49248;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49249;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49250;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49251;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49252;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49253;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49254;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49255;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49256;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49257;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49258;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49259;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49260;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49261;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49262;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49263;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49264;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49265;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49286;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49287;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49288;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49289;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49290;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49291;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49292;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49293;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49294;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49295;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49296;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49297;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49298;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49299;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49300;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49301;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49302;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49303;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49304;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49305;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49306;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49307;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM_8: u32 = 49322;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM_8: u32 = 49323;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8: u32 = 49407;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52392;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52393;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52394;
pub const MBEDTLS_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52395;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52396;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52397;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52398;
pub const MBEDTLS_TLS1_3_AES_128_GCM_SHA256: u32 = 4865;
pub const MBEDTLS_TLS1_3_AES_256_GCM_SHA384: u32 = 4866;
pub const MBEDTLS_TLS1_3_CHACHA20_POLY1305_SHA256: u32 = 4867;
pub const MBEDTLS_TLS1_3_AES_128_CCM_SHA256: u32 = 4868;
pub const MBEDTLS_TLS1_3_AES_128_CCM_8_SHA256: u32 = 4869;
pub const MBEDTLS_CIPHERSUITE_WEAK: u32 = 1;
pub const MBEDTLS_CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const MBEDTLS_CIPHERSUITE_NODTLS: u32 = 4;
pub const PSA_CRYPTO_API_VERSION_MAJOR: u32 = 1;
pub const PSA_CRYPTO_API_VERSION_MINOR: u32 = 0;
pub const PSA_MAC_TRUNCATION_OFFSET: u32 = 16;
pub const PSA_AEAD_TAG_LENGTH_OFFSET: u32 = 16;
pub const PSA_HASH_MAX_SIZE: u32 = 64;
pub const PSA_HMAC_MAX_HASH_BLOCK_SIZE: u32 = 128;
pub const PSA_MAC_MAX_SIZE: u32 = 64;
pub const PSA_AEAD_TAG_MAX_SIZE: u32 = 16;
pub const PSA_VENDOR_RSA_MAX_KEY_BITS: u32 = 4096;
pub const PSA_VENDOR_ECC_MAX_CURVE_BITS: u32 = 521;
pub const PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE: u32 = 128;
pub const PSA_TLS12_ECJPAKE_TO_PMS_INPUT_SIZE: u32 = 65;
pub const PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE: u32 = 32;
pub const PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_NONCE_MAX_SIZE: u32 = 13;
pub const PSA_AEAD_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_IV_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const MBEDTLS_AES_BLOCK_SIZE: u32 = 16;
pub const MBEDTLS_DES3_BLOCK_SIZE: u32 = 8;
pub const MBEDTLS_CIPHER_BLKSIZE_MAX: u32 = 16;
pub const MBEDTLS_GCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_GCM_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_GCM_AUTH_FAILED: i32 = -18;
pub const MBEDTLS_ERR_GCM_BAD_INPUT: i32 = -20;
pub const MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL: i32 = -22;
pub const MBEDTLS_CCM_DECRYPT: u32 = 0;
pub const MBEDTLS_CCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_CCM_STAR_DECRYPT: u32 = 2;
pub const MBEDTLS_CCM_STAR_ENCRYPT: u32 = 3;
pub const MBEDTLS_ERR_CCM_BAD_INPUT: i32 = -13;
pub const MBEDTLS_ERR_CCM_AUTH_FAILED: i32 = -15;
pub const MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const MBEDTLS_ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const MBEDTLS_ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const MBEDTLS_ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const MBEDTLS_ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const MBEDTLS_PSA_BUILTIN_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_AEAD: u32 = 1;
pub const MBEDTLS_PSA_JPAKE_BUFFER_SIZE: u32 = 336;
pub const PSA_MAX_KEY_BITS: u32 = 65528;
pub const MBEDTLS_PSA_KA_MASK_DUAL_USE: u32 = 0;
pub const PSA_CRYPTO_ITS_RANDOM_SEED_UID: u32 = 4294967122;
pub const MBEDTLS_PSA_KEY_SLOT_COUNT: u32 = 32;
pub const PSA_PAKE_OPERATION_STAGE_SETUP: u32 = 0;
pub const PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS: u32 = 1;
pub const PSA_PAKE_OPERATION_STAGE_COMPUTATION: u32 = 2;
pub const PSA_PAKE_OUTPUT_MAX_SIZE: u32 = 65;
pub const PSA_PAKE_INPUT_MAX_SIZE: u32 = 65;
pub const MBEDTLS_ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const MBEDTLS_ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const MBEDTLS_ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const MBEDTLS_ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const MBEDTLS_ERR_ASN1_INVALID_DATA: i32 = -104;
pub const MBEDTLS_ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const MBEDTLS_ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const MBEDTLS_ASN1_BOOLEAN: u32 = 1;
pub const MBEDTLS_ASN1_INTEGER: u32 = 2;
pub const MBEDTLS_ASN1_BIT_STRING: u32 = 3;
pub const MBEDTLS_ASN1_OCTET_STRING: u32 = 4;
pub const MBEDTLS_ASN1_NULL: u32 = 5;
pub const MBEDTLS_ASN1_OID: u32 = 6;
pub const MBEDTLS_ASN1_ENUMERATED: u32 = 10;
pub const MBEDTLS_ASN1_UTF8_STRING: u32 = 12;
pub const MBEDTLS_ASN1_SEQUENCE: u32 = 16;
pub const MBEDTLS_ASN1_SET: u32 = 17;
pub const MBEDTLS_ASN1_PRINTABLE_STRING: u32 = 19;
pub const MBEDTLS_ASN1_T61_STRING: u32 = 20;
pub const MBEDTLS_ASN1_IA5_STRING: u32 = 22;
pub const MBEDTLS_ASN1_UTC_TIME: u32 = 23;
pub const MBEDTLS_ASN1_GENERALIZED_TIME: u32 = 24;
pub const MBEDTLS_ASN1_UNIVERSAL_STRING: u32 = 28;
pub const MBEDTLS_ASN1_BMP_STRING: u32 = 30;
pub const MBEDTLS_ASN1_PRIMITIVE: u32 = 0;
pub const MBEDTLS_ASN1_CONSTRUCTED: u32 = 32;
pub const MBEDTLS_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const MBEDTLS_ASN1_TAG_CLASS_MASK: u32 = 192;
pub const MBEDTLS_ASN1_TAG_PC_MASK: u32 = 32;
pub const MBEDTLS_ASN1_TAG_VALUE_MASK: u32 = 31;
pub const MBEDTLS_X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const MBEDTLS_ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const MBEDTLS_ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const MBEDTLS_ERR_X509_INVALID_VERSION: i32 = -8704;
pub const MBEDTLS_ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const MBEDTLS_ERR_X509_INVALID_ALG: i32 = -8960;
pub const MBEDTLS_ERR_X509_INVALID_NAME: i32 = -9088;
pub const MBEDTLS_ERR_X509_INVALID_DATE: i32 = -9216;
pub const MBEDTLS_ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const MBEDTLS_ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const MBEDTLS_ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const MBEDTLS_ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const MBEDTLS_ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const MBEDTLS_ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const MBEDTLS_ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const MBEDTLS_ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const MBEDTLS_ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const MBEDTLS_ERR_X509_FATAL_ERROR: i32 = -12288;
pub const MBEDTLS_X509_BADCERT_EXPIRED: u32 = 1;
pub const MBEDTLS_X509_BADCERT_REVOKED: u32 = 2;
pub const MBEDTLS_X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const MBEDTLS_X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const MBEDTLS_X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const MBEDTLS_X509_BADCRL_EXPIRED: u32 = 32;
pub const MBEDTLS_X509_BADCERT_MISSING: u32 = 64;
pub const MBEDTLS_X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const MBEDTLS_X509_BADCERT_OTHER: u32 = 256;
pub const MBEDTLS_X509_BADCERT_FUTURE: u32 = 512;
pub const MBEDTLS_X509_BADCRL_FUTURE: u32 = 1024;
pub const MBEDTLS_X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const MBEDTLS_X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const MBEDTLS_X509_BADCERT_BAD_MD: u32 = 16384;
pub const MBEDTLS_X509_BADCERT_BAD_PK: u32 = 32768;
pub const MBEDTLS_X509_BADCERT_BAD_KEY: u32 = 65536;
pub const MBEDTLS_X509_BADCRL_BAD_MD: u32 = 131072;
pub const MBEDTLS_X509_BADCRL_BAD_PK: u32 = 262144;
pub const MBEDTLS_X509_BADCRL_BAD_KEY: u32 = 524288;
pub const MBEDTLS_X509_SAN_OTHER_NAME: u32 = 0;
pub const MBEDTLS_X509_SAN_RFC822_NAME: u32 = 1;
pub const MBEDTLS_X509_SAN_DNS_NAME: u32 = 2;
pub const MBEDTLS_X509_SAN_X400_ADDRESS_NAME: u32 = 3;
pub const MBEDTLS_X509_SAN_DIRECTORY_NAME: u32 = 4;
pub const MBEDTLS_X509_SAN_EDI_PARTY_NAME: u32 = 5;
pub const MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: u32 = 6;
pub const MBEDTLS_X509_SAN_IP_ADDRESS: u32 = 7;
pub const MBEDTLS_X509_SAN_REGISTERED_ID: u32 = 8;
pub const MBEDTLS_X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const MBEDTLS_X509_KU_NON_REPUDIATION: u32 = 64;
pub const MBEDTLS_X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const MBEDTLS_X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const MBEDTLS_X509_KU_KEY_AGREEMENT: u32 = 8;
pub const MBEDTLS_X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const MBEDTLS_X509_KU_CRL_SIGN: u32 = 2;
pub const MBEDTLS_X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const MBEDTLS_X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const MBEDTLS_X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const MBEDTLS_X509_FORMAT_DER: u32 = 1;
pub const MBEDTLS_X509_FORMAT_PEM: u32 = 2;
pub const MBEDTLS_X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const MBEDTLS_X509_CRT_VERSION_1: u32 = 0;
pub const MBEDTLS_X509_CRT_VERSION_2: u32 = 1;
pub const MBEDTLS_X509_CRT_VERSION_3: u32 = 2;
pub const MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN: u32 = 20;
pub const MBEDTLS_X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const MBEDTLS_X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE: u32 = 10;
pub const MBEDTLS_ERR_DHM_BAD_INPUT_DATA: i32 = -12416;
pub const MBEDTLS_ERR_DHM_READ_PARAMS_FAILED: i32 = -12544;
pub const MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED: i32 = -12672;
pub const MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED: i32 = -12800;
pub const MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED: i32 = -12928;
pub const MBEDTLS_ERR_DHM_CALC_SECRET_FAILED: i32 = -13056;
pub const MBEDTLS_ERR_DHM_INVALID_FORMAT: i32 = -13184;
pub const MBEDTLS_ERR_DHM_ALLOC_FAILED: i32 = -13312;
pub const MBEDTLS_ERR_DHM_FILE_IO_ERROR: i32 = -13440;
pub const MBEDTLS_ERR_DHM_SET_GROUP_FAILED: i32 = -13696;
pub const MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS: i32 = -28672;
pub const MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const MBEDTLS_ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const MBEDTLS_ERR_SSL_INVALID_MAC: i32 = -29056;
pub const MBEDTLS_ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const MBEDTLS_ERR_SSL_CONN_EOF: i32 = -29312;
pub const MBEDTLS_ERR_SSL_DECODE_ERROR: i32 = -29440;
pub const MBEDTLS_ERR_SSL_NO_RNG: i32 = -29696;
pub const MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION: i32 = -29952;
pub const MBEDTLS_ERR_SSL_NO_APPLICATION_PROTOCOL: i32 = -30080;
pub const MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const MBEDTLS_ERR_SSL_UNRECOGNIZED_NAME: i32 = -30720;
pub const MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const MBEDTLS_ERR_SSL_BAD_CERTIFICATE: i32 = -31232;
pub const MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET: i32 = -31488;
pub const MBEDTLS_ERR_SSL_CANNOT_READ_EARLY_DATA: i32 = -31616;
pub const MBEDTLS_ERR_SSL_CANNOT_WRITE_EARLY_DATA: i32 = -31744;
pub const MBEDTLS_ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION: i32 = -28288;
pub const MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE: i32 = -28160;
pub const MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const MBEDTLS_ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const MBEDTLS_ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const MBEDTLS_ERR_SSL_WANT_READ: i32 = -26880;
pub const MBEDTLS_ERR_SSL_WANT_WRITE: i32 = -26752;
pub const MBEDTLS_ERR_SSL_TIMEOUT: i32 = -26624;
pub const MBEDTLS_ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const MBEDTLS_ERR_SSL_NON_FATAL: i32 = -26240;
pub const MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER: i32 = -26112;
pub const MBEDTLS_ERR_SSL_CONTINUE_PROCESSING: i32 = -25984;
pub const MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS: i32 = -25856;
pub const MBEDTLS_ERR_SSL_EARLY_MESSAGE: i32 = -25728;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_CID: i32 = -24576;
pub const MBEDTLS_ERR_SSL_VERSION_MISMATCH: i32 = -24320;
pub const MBEDTLS_ERR_SSL_BAD_CONFIG: i32 = -24192;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_PURE: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_ECDHE: u32 = 1;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_NONE: u32 = 0;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192K1: u32 = 18;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192R1: u32 = 19;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224K1: u32 = 20;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224R1: u32 = 21;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256K1: u32 = 22;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1: u32 = 23;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP384R1: u32 = 24;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP521R1: u32 = 25;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP256R1: u32 = 26;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP384R1: u32 = 27;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP512R1: u32 = 28;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X25519: u32 = 29;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X448: u32 = 30;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE2048: u32 = 256;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE3072: u32 = 257;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE4096: u32 = 258;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE6144: u32 = 259;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE8192: u32 = 260;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK: u32 = 1;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL: u32 = 2;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL: u32 = 4;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL: u32 = 7;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL: u32 = 5;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL: u32 = 6;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAJOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_4: u32 = 4;
pub const MBEDTLS_SSL_TRANSPORT_STREAM: u32 = 0;
pub const MBEDTLS_SSL_TRANSPORT_DATAGRAM: u32 = 1;
pub const MBEDTLS_SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_LIST_LEN: u32 = 65535;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const MBEDTLS_SSL_IS_CLIENT: u32 = 0;
pub const MBEDTLS_SSL_IS_SERVER: u32 = 1;
pub const MBEDTLS_SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CID_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_CID_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ETM_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ETM_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_COMPRESS_NULL: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_NONE: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_OPTIONAL: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_REQUIRED: u32 = 2;
pub const MBEDTLS_SSL_VERIFY_UNSET: u32 = 3;
pub const MBEDTLS_SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const MBEDTLS_SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const MBEDTLS_SSL_SESSION_TICKETS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_SESSION_TICKETS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_PRESET_DEFAULT: u32 = 0;
pub const MBEDTLS_SSL_PRESET_SUITEB: u32 = 2;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_UNSUPPORTED: u32 = 0;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_TICKET_RESUMPTION_KEY_LEN: u32 = 48;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_DTLS_MAX_BUFFERING: u32 = 32768;
pub const MBEDTLS_SSL_CID_IN_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_OUT_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_TLS1_3_PADDING_GRANULARITY: u32 = 16;
pub const MBEDTLS_SSL_VERIFY_DATA_MAX_LEN: u32 = 12;
pub const MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const MBEDTLS_SSL_HASH_NONE: u32 = 0;
pub const MBEDTLS_SSL_HASH_MD5: u32 = 1;
pub const MBEDTLS_SSL_HASH_SHA1: u32 = 2;
pub const MBEDTLS_SSL_HASH_SHA224: u32 = 3;
pub const MBEDTLS_SSL_HASH_SHA256: u32 = 4;
pub const MBEDTLS_SSL_HASH_SHA384: u32 = 5;
pub const MBEDTLS_SSL_HASH_SHA512: u32 = 6;
pub const MBEDTLS_SSL_SIG_ANON: u32 = 0;
pub const MBEDTLS_SSL_SIG_RSA: u32 = 1;
pub const MBEDTLS_SSL_SIG_ECDSA: u32 = 3;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA256: u32 = 1025;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA384: u32 = 1281;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA512: u32 = 1537;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP256R1_SHA256: u32 = 1027;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP384R1_SHA384: u32 = 1283;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP521R1_SHA512: u32 = 1539;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA256: u32 = 2052;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA384: u32 = 2053;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA512: u32 = 2054;
pub const MBEDTLS_TLS1_3_SIG_ED25519: u32 = 2055;
pub const MBEDTLS_TLS1_3_SIG_ED448: u32 = 2056;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA256: u32 = 2057;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA384: u32 = 2058;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA512: u32 = 2059;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA1: u32 = 513;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SHA1: u32 = 515;
pub const MBEDTLS_TLS1_3_SIG_NONE: u32 = 0;
pub const MBEDTLS_SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const MBEDTLS_SSL_MSG_ALERT: u32 = 21;
pub const MBEDTLS_SSL_MSG_HANDSHAKE: u32 = 22;
pub const MBEDTLS_SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const MBEDTLS_SSL_MSG_CID: u32 = 25;
pub const MBEDTLS_SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const MBEDTLS_SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const MBEDTLS_SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const MBEDTLS_SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const MBEDTLS_SSL_ALERT_MSG_MISSING_EXTENSION: u32 = 109;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REQUIRED: u32 = 116;
pub const MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const MBEDTLS_SSL_HS_HELLO_REQUEST: u32 = 0;
pub const MBEDTLS_SSL_HS_CLIENT_HELLO: u32 = 1;
pub const MBEDTLS_SSL_HS_SERVER_HELLO: u32 = 2;
pub const MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const MBEDTLS_SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const MBEDTLS_SSL_HS_END_OF_EARLY_DATA: u32 = 5;
pub const MBEDTLS_SSL_HS_ENCRYPTED_EXTENSIONS: u32 = 8;
pub const MBEDTLS_SSL_HS_CERTIFICATE: u32 = 11;
pub const MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const MBEDTLS_SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const MBEDTLS_SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const MBEDTLS_SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const MBEDTLS_SSL_HS_FINISHED: u32 = 20;
pub const MBEDTLS_SSL_HS_MESSAGE_HASH: u32 = 254;
pub const MBEDTLS_TLS_EXT_SERVERNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const MBEDTLS_TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const MBEDTLS_TLS_EXT_STATUS_REQUEST: u32 = 5;
pub const MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_GROUPS: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const MBEDTLS_TLS_EXT_SIG_ALG: u32 = 13;
pub const MBEDTLS_TLS_EXT_USE_SRTP: u32 = 14;
pub const MBEDTLS_TLS_EXT_HEARTBEAT: u32 = 15;
pub const MBEDTLS_TLS_EXT_ALPN: u32 = 16;
pub const MBEDTLS_TLS_EXT_SCT: u32 = 18;
pub const MBEDTLS_TLS_EXT_CLI_CERT_TYPE: u32 = 19;
pub const MBEDTLS_TLS_EXT_SERV_CERT_TYPE: u32 = 20;
pub const MBEDTLS_TLS_EXT_PADDING: u32 = 21;
pub const MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const MBEDTLS_TLS_EXT_RECORD_SIZE_LIMIT: u32 = 28;
pub const MBEDTLS_TLS_EXT_SESSION_TICKET: u32 = 35;
pub const MBEDTLS_TLS_EXT_PRE_SHARED_KEY: u32 = 41;
pub const MBEDTLS_TLS_EXT_EARLY_DATA: u32 = 42;
pub const MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS: u32 = 43;
pub const MBEDTLS_TLS_EXT_COOKIE: u32 = 44;
pub const MBEDTLS_TLS_EXT_PSK_KEY_EXCHANGE_MODES: u32 = 45;
pub const MBEDTLS_TLS_EXT_CERT_AUTH: u32 = 47;
pub const MBEDTLS_TLS_EXT_OID_FILTERS: u32 = 48;
pub const MBEDTLS_TLS_EXT_POST_HANDSHAKE_AUTH: u32 = 49;
pub const MBEDTLS_TLS_EXT_SIG_ALG_CERT: u32 = 50;
pub const MBEDTLS_TLS_EXT_KEY_SHARE: u32 = 51;
pub const MBEDTLS_TLS_EXT_CID: u32 = 54;
pub const MBEDTLS_TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const MBEDTLS_TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const MBEDTLS_PSK_MAX_LEN: u32 = 48;
pub const MBEDTLS_TLS1_3_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_SSL_SEQUENCE_NUMBER_LEN: u32 = 8;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_PSK_RESUMPTION: u32 = 1;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_PSK_EPHEMERAL_RESUMPTION: u32 = 4;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_EARLY_DATA: u32 = 8;
pub const MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK: u32 = 13;
pub const MBEDTLS_SSL_UNEXPECTED_CID_IGNORE: u32 = 0;
pub const MBEDTLS_SSL_UNEXPECTED_CID_FAIL: u32 = 1;
pub const MBEDTLS_ERR_ENTROPY_SOURCE_FAILED: i32 = -60;
pub const MBEDTLS_ERR_ENTROPY_MAX_SOURCES: i32 = -62;
pub const MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED: i32 = -64;
pub const MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE: i32 = -61;
pub const MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR: i32 = -63;
pub const MBEDTLS_ENTROPY_MAX_SOURCES: u32 = 20;
pub const MBEDTLS_ENTROPY_MAX_GATHER: u32 = 128;
pub const MBEDTLS_ENTROPY_BLOCK_SIZE: u32 = 64;
pub const MBEDTLS_ENTROPY_MAX_SEED_SIZE: u32 = 1024;
pub const MBEDTLS_ENTROPY_SOURCE_MANUAL: u32 = 20;
pub const MBEDTLS_ENTROPY_SOURCE_STRONG: u32 = 1;
pub const MBEDTLS_ENTROPY_SOURCE_WEAK: u32 = 0;
pub const MBEDTLS_PRINTF_SIZET: &[u8; 3usize] = b"zu\0";
pub const MBEDTLS_PRINTF_LONGLONG: &[u8; 4usize] = b"lld\0";
pub const MBEDTLS_AES_ENCRYPT: u32 = 1;
pub const MBEDTLS_AES_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_AES_INVALID_KEY_LENGTH: i32 = -32;
pub const MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH: i32 = -34;
pub const MBEDTLS_ERR_AES_BAD_INPUT_DATA: i32 = -33;
pub const MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED: i32 = -52;
pub const MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG: i32 = -54;
pub const MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG: i32 = -56;
pub const MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR: i32 = -58;
pub const MBEDTLS_CTR_DRBG_BLOCKSIZE: u32 = 16;
pub const MBEDTLS_CTR_DRBG_KEYSIZE: u32 = 32;
pub const MBEDTLS_CTR_DRBG_KEYBITS: u32 = 256;
pub const MBEDTLS_CTR_DRBG_SEEDLEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_ENTROPY_LEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const MBEDTLS_CTR_DRBG_MAX_INPUT: u32 = 256;
pub const MBEDTLS_CTR_DRBG_MAX_REQUEST: u32 = 1024;
pub const MBEDTLS_CTR_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const MBEDTLS_CTR_DRBG_PR_OFF: u32 = 0;
pub const MBEDTLS_CTR_DRBG_PR_ON: u32 = 1;
pub const MBEDTLS_CTR_DRBG_ENTROPY_NONCE_LEN: u32 = 0;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type size_t = crate::c_types::c_uint;
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
pub type mbedtls_iso_c_forbids_empty_translation_units = crate::c_types::c_int;
extern "C" {
    #[doc = " \\brief       Securely zeroize a buffer"]
    #[doc = ""]
    #[doc = "              The function is meant to wipe the data contained in a buffer so"]
    #[doc = "              that it can no longer be recovered even if the program memory"]
    #[doc = "              is later compromised. Call this function on sensitive data"]
    #[doc = "              stored on the stack before returning from a function, and on"]
    #[doc = "              sensitive data stored on the heap before freeing the heap"]
    #[doc = "              object."]
    #[doc = ""]
    #[doc = "              It is extremely difficult to guarantee that calls to"]
    #[doc = "              mbedtls_platform_zeroize() are not removed by aggressive"]
    #[doc = "              compiler optimizations in a portable way. For this reason, Mbed"]
    #[doc = "              TLS provides the configuration option"]
    #[doc = "              MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure"]
    #[doc = "              mbedtls_platform_zeroize() to use a suitable implementation for"]
    #[doc = "              their platform and needs"]
    #[doc = ""]
    #[doc = " \\param buf   Buffer to be zeroized"]
    #[doc = " \\param len   Length of the buffer in bytes"]
    #[doc = ""]
    pub fn mbedtls_platform_zeroize(buf: *mut crate::c_types::c_void, len: size_t);
}
pub type mbedtls_mpi_sint = i32;
pub type mbedtls_mpi_uint = u32;
pub type mbedtls_t_udbl = u64;
#[doc = " \\brief          MPI structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_mpi {
    pub private_s: crate::c_types::c_int,
    pub private_n: size_t,
    pub private_p: *mut mbedtls_mpi_uint,
}
extern "C" {
    #[doc = " \\brief           Initialize an MPI context."]
    #[doc = ""]
    #[doc = "                  This makes the MPI ready to be set or freed,"]
    #[doc = "                  but does not define a value for the MPI."]
    #[doc = ""]
    #[doc = " \\param X         The MPI context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_mpi_init(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an MPI context."]
    #[doc = ""]
    #[doc = " \\param X        The MPI context to be cleared. This may be \\c NULL,"]
    #[doc = "                 in which case this function is a no-op. If it is"]
    #[doc = "                 not \\c NULL, it must point to an initialized MPI."]
    pub fn mbedtls_mpi_free(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Enlarge an MPI to the specified number of limbs."]
    #[doc = ""]
    #[doc = " \\note           This function does nothing if the MPI is"]
    #[doc = "                 already large enough."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to grow. It must be initialized."]
    #[doc = " \\param nblimbs  The target number of limbs."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_grow(X: *mut mbedtls_mpi, nblimbs: size_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function resizes an MPI downwards, keeping at least the"]
    #[doc = "                 specified number of limbs."]
    #[doc = ""]
    #[doc = "                 If \\c X is smaller than \\c nblimbs, it is resized up"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to shrink. This must point to an initialized MPI."]
    #[doc = " \\param nblimbs  The minimum number of limbs to keep."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    #[doc = "                 (this can only happen when resizing up)."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_shrink(X: *mut mbedtls_mpi, nblimbs: size_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Make a copy of an MPI."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param Y        The source MPI. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\note           The limb-buffer in the destination MPI is enlarged"]
    #[doc = "                 if necessary to hold the value in the source MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_copy(X: *mut mbedtls_mpi, Y: *const mbedtls_mpi) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Swap the contents of two MPIs."]
    #[doc = ""]
    #[doc = " \\param X        The first MPI. It must be initialized."]
    #[doc = " \\param Y        The second MPI. It must be initialized."]
    pub fn mbedtls_mpi_swap(X: *mut mbedtls_mpi, Y: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional copy of MPI which doesn't"]
    #[doc = "                 reveal whether the condition was true or not."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to conditionally assign to. This must point"]
    #[doc = "                 to an initialized MPI."]
    #[doc = " \\param Y        The MPI to be assigned from. This must point to an"]
    #[doc = "                 initialized MPI."]
    #[doc = " \\param assign   The condition deciding whether to perform the"]
    #[doc = "                 assignment or not. Must be either 0 or 1:"]
    #[doc = "                 * \\c 1: Perform the assignment `X = Y`."]
    #[doc = "                 * \\c 0: Keep the original value of \\p X."]
    #[doc = ""]
    #[doc = " \\note           This function is equivalent to"]
    #[doc = "                      `if( assign ) mbedtls_mpi_copy( X, Y );`"]
    #[doc = "                 except that it avoids leaking any information about whether"]
    #[doc = "                 the assignment was done or not (the above code may leak"]
    #[doc = "                 information through branch prediction and/or memory access"]
    #[doc = "                 patterns analysis)."]
    #[doc = ""]
    #[doc = " \\warning        If \\p assign is neither 0 nor 1, the result of this function"]
    #[doc = "                 is indeterminate, and the resulting value in \\p X might be"]
    #[doc = "                 neither its original value nor the value in \\p Y."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_safe_cond_assign(
        X: *mut mbedtls_mpi,
        Y: *const mbedtls_mpi,
        assign: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional swap which doesn't"]
    #[doc = "                 reveal whether the condition was true or not."]
    #[doc = ""]
    #[doc = " \\param X        The first MPI. This must be initialized."]
    #[doc = " \\param Y        The second MPI. This must be initialized."]
    #[doc = " \\param swap     The condition deciding whether to perform"]
    #[doc = "                 the swap or not. Must be either 0 or 1:"]
    #[doc = "                 * \\c 1: Swap the values of \\p X and \\p Y."]
    #[doc = "                 * \\c 0: Keep the original values of \\p X and \\p Y."]
    #[doc = ""]
    #[doc = " \\note           This function is equivalent to"]
    #[doc = "                      if( swap ) mbedtls_mpi_swap( X, Y );"]
    #[doc = "                 except that it avoids leaking any information about whether"]
    #[doc = "                 the swap was done or not (the above code may leak"]
    #[doc = "                 information through branch prediction and/or memory access"]
    #[doc = "                 patterns analysis)."]
    #[doc = ""]
    #[doc = " \\warning        If \\p swap is neither 0 nor 1, the result of this function"]
    #[doc = "                 is indeterminate, and both \\p X and \\p Y might end up with"]
    #[doc = "                 values different to either of the original ones."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[doc = ""]
    pub fn mbedtls_mpi_safe_cond_swap(
        X: *mut mbedtls_mpi,
        Y: *mut mbedtls_mpi,
        swap: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Store integer value in MPI."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to set. This must be initialized."]
    #[doc = " \\param z        The value to use."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_lset(X: *mut mbedtls_mpi, z: mbedtls_mpi_sint) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Get a specific bit from an MPI."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to query. This must be initialized."]
    #[doc = " \\param pos      Zero-based index of the bit to query."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 or \\c 1 on success, depending on whether bit \\c pos"]
    #[doc = "                 of \\c X is unset or set."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_mpi_get_bit(X: *const mbedtls_mpi, pos: size_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Modify a specific bit in an MPI."]
    #[doc = ""]
    #[doc = " \\note           This function will grow the target MPI if necessary to set a"]
    #[doc = "                 bit to \\c 1 in a not yet existing limb. It will not grow if"]
    #[doc = "                 the bit should be set to \\c 0."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to modify. This must be initialized."]
    #[doc = " \\param pos      Zero-based index of the bit to modify."]
    #[doc = " \\param val      The desired value of bit \\c pos: \\c 0 or \\c 1."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_set_bit(
        X: *mut mbedtls_mpi,
        pos: size_t,
        val: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits of value \\c 0 before the"]
    #[doc = "                 least significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " \\note           This is the same as the zero-based index of"]
    #[doc = "                 the least significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to query."]
    #[doc = ""]
    #[doc = " \\return         The number of bits of value \\c 0 before the least significant"]
    #[doc = "                 bit of value \\c 1 in \\p X."]
    pub fn mbedtls_mpi_lsb(X: *const mbedtls_mpi) -> size_t;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits up to and including the most"]
    #[doc = "                 significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " * \\note         This is same as the one-based index of the most"]
    #[doc = "                 significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to query. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         The number of bits up to and including the most"]
    #[doc = "                 significant bit of value \\c 1."]
    pub fn mbedtls_mpi_bitlen(X: *const mbedtls_mpi) -> size_t;
}
extern "C" {
    #[doc = " \\brief          Return the total size of an MPI value in bytes."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to use. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\note           The value returned by this function may be less than"]
    #[doc = "                 the number of bytes used to store \\p X internally."]
    #[doc = "                 This happens if and only if there are trailing bytes"]
    #[doc = "                 of value zero."]
    #[doc = ""]
    #[doc = " \\return         The least number of bytes capable of storing"]
    #[doc = "                 the absolute value of \\p X."]
    pub fn mbedtls_mpi_size(X: *const mbedtls_mpi) -> size_t;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from an ASCII string."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param radix    The numeric base of the input string."]
    #[doc = " \\param s        Null-terminated string buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_mpi_read_string(
        X: *mut mbedtls_mpi,
        radix: crate::c_types::c_int,
        s: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export an MPI to an ASCII string."]
    #[doc = ""]
    #[doc = " \\param X        The source MPI. This must point to an initialized MPI."]
    #[doc = " \\param radix    The numeric base of the output string."]
    #[doc = " \\param buf      The buffer to write the string to. This must be writable"]
    #[doc = "                 buffer of length \\p buflen Bytes."]
    #[doc = " \\param buflen   The available size in Bytes of \\p buf."]
    #[doc = " \\param olen     The address at which to store the length of the string"]
    #[doc = "                 written, including the  final \\c NULL byte. This must"]
    #[doc = "                 not be \\c NULL."]
    #[doc = ""]
    #[doc = " \\note           You can call this function with `buflen == 0` to obtain the"]
    #[doc = "                 minimum required buffer size in `*olen`."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the target buffer \\p buf"]
    #[doc = "                 is too small to hold the value of \\p X in the desired base."]
    #[doc = "                 In this case, `*olen` is nonetheless updated to contain the"]
    #[doc = "                 size of \\p buf required for a successful call."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_string(
        X: *const mbedtls_mpi,
        radix: crate::c_types::c_int,
        buf: *mut crate::c_types::c_char,
        buflen: size_t,
        olen: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from unsigned big endian binary data."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The input buffer. This must be a readable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The length of the input buffer \\p p in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_read_binary(
        X: *mut mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Import X from unsigned binary data, little endian"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The input buffer. This must be a readable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The length of the input buffer \\p p in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_read_binary_le(
        X: *mut mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, big endian."]
    #[doc = "                 Always fills the whole buffer, which will start with zeros"]
    #[doc = "                 if the number is smaller."]
    #[doc = ""]
    #[doc = " \\param X        The source MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The output buffer. This must be a writable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The size of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't"]
    #[doc = "                 large enough to hold the value of \\p X."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_binary(
        X: *const mbedtls_mpi,
        buf: *mut crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, little endian."]
    #[doc = "                 Always fills the whole buffer, which will end with zeros"]
    #[doc = "                 if the number is smaller."]
    #[doc = ""]
    #[doc = " \\param X        The source MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The output buffer. This must be a writable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The size of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't"]
    #[doc = "                 large enough to hold the value of \\p X."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_binary_le(
        X: *const mbedtls_mpi,
        buf: *mut crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a left-shift on an MPI: X <<= count"]
    #[doc = ""]
    #[doc = " \\param X        The MPI to shift. This must point to an initialized MPI."]
    #[doc = " \\param count    The number of bits to shift by."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_shift_l(X: *mut mbedtls_mpi, count: size_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a right-shift on an MPI: X >>= count"]
    #[doc = ""]
    #[doc = " \\param X        The MPI to shift. This must point to an initialized MPI."]
    #[doc = " \\param count    The number of bits to shift by."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_shift_r(X: *mut mbedtls_mpi, count: size_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare the absolute values of two MPIs."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI."]
    #[doc = " \\param Y        The right-hand MPI. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if `|X|` is greater than `|Y|`."]
    #[doc = " \\return         \\c -1 if `|X|` is lesser than `|Y|`."]
    #[doc = " \\return         \\c 0 if `|X|` is equal to `|Y|`."]
    pub fn mbedtls_mpi_cmp_abs(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare two MPIs."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI."]
    #[doc = " \\param Y        The right-hand MPI. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if \\p X is greater than \\p Y."]
    #[doc = " \\return         \\c -1 if \\p X is lesser than \\p Y."]
    #[doc = " \\return         \\c 0 if \\p X is equal to \\p Y."]
    pub fn mbedtls_mpi_cmp_mpi(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check if an MPI is less than the other in constant time."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI"]
    #[doc = "                 with the same allocated length as Y."]
    #[doc = " \\param Y        The right-hand MPI. This must point to an initialized MPI"]
    #[doc = "                 with the same allocated length as X."]
    #[doc = " \\param ret      The result of the comparison:"]
    #[doc = "                 \\c 1 if \\p X is less than \\p Y."]
    #[doc = "                 \\c 0 if \\p X is greater than or equal to \\p Y."]
    #[doc = ""]
    #[doc = " \\return         0 on success."]
    #[doc = " \\return         MBEDTLS_ERR_MPI_BAD_INPUT_DATA if the allocated length of"]
    #[doc = "                 the two input MPIs is not the same."]
    pub fn mbedtls_mpi_lt_mpi_ct(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
        ret: *mut crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare an MPI with an integer."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI."]
    #[doc = " \\param z        The integer value to compare \\p X to."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if \\p X is greater than \\p z."]
    #[doc = " \\return         \\c -1 if \\p X is lesser than \\p z."]
    #[doc = " \\return         \\c 0 if \\p X is equal to \\p z."]
    pub fn mbedtls_mpi_cmp_int(X: *const mbedtls_mpi, z: mbedtls_mpi_sint)
        -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned addition of MPIs: X = |A| + |B|"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first summand. This must point to an initialized MPI."]
    #[doc = " \\param B        The second summand. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned subtraction of MPIs: X = |A| - |B|"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The minuend. This must point to an initialized MPI."]
    #[doc = " \\param B        The subtrahend. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is greater than \\p A."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    pub fn mbedtls_mpi_sub_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of MPIs: X = A + B"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first summand. This must point to an initialized MPI."]
    #[doc = " \\param B        The second summand. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of MPIs: X = A - B"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The minuend. This must point to an initialized MPI."]
    #[doc = " \\param B        The subtrahend. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_sub_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of an MPI and an integer: X = A + b"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first summand. This must point to an initialized MPI."]
    #[doc = " \\param b        The second summand."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of an MPI and an integer:"]
    #[doc = "                 X = A - b"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The minuend. This must point to an initialized MPI."]
    #[doc = " \\param b        The subtrahend."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_sub_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of two MPIs: X = A * B"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first factor. This must point to an initialized MPI."]
    #[doc = " \\param B        The second factor. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    pub fn mbedtls_mpi_mul_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of an MPI with an unsigned integer:"]
    #[doc = "                 X = A * b"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first factor. This must point to an initialized MPI."]
    #[doc = " \\param b        The second factor."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    pub fn mbedtls_mpi_mul_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of two MPIs:"]
    #[doc = "                 A = Q * B + R"]
    #[doc = ""]
    #[doc = " \\param Q        The destination MPI for the quotient."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 quotient is not needed. This must not alias A or B."]
    #[doc = " \\param R        The destination MPI for the remainder value."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 remainder is not needed. This must not alias A or B."]
    #[doc = " \\param A        The dividend. This must point to an initialized MPI."]
    #[doc = " \\param B        The divisor. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_div_mpi(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of an MPI by an integer:"]
    #[doc = "                 A = Q * b + R"]
    #[doc = ""]
    #[doc = " \\param Q        The destination MPI for the quotient."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 quotient is not needed.  This must not alias A."]
    #[doc = " \\param R        The destination MPI for the remainder value."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 remainder is not needed.  This must not alias A."]
    #[doc = " \\param A        The dividend. This must point to an initialized MPi."]
    #[doc = " \\param b        The divisor."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_div_int(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction. R = A mod B"]
    #[doc = ""]
    #[doc = " \\param R        The destination MPI for the residue value."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param A        The MPI to compute the residue of."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param B        The base of the modular reduction."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is negative."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    pub fn mbedtls_mpi_mod_mpi(
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction with respect to an integer."]
    #[doc = "                 r = A mod b"]
    #[doc = ""]
    #[doc = " \\param r        The address at which to store the residue."]
    #[doc = "                 This must not be \\c NULL."]
    #[doc = " \\param A        The MPI to compute the residue of."]
    #[doc = "                 This must point to an initialized MPi."]
    #[doc = " \\param b        The integer base of the modular reduction."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p b is negative."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_mod_int(
        r: *mut mbedtls_mpi_uint,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a sliding-window exponentiation: X = A^E mod N"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = "                 This must not alias E or N."]
    #[doc = " \\param A        The base of the exponentiation."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param E        The exponent MPI. This must point to an initialized MPI."]
    #[doc = " \\param N        The base for the modular reduction. This must point to an"]
    #[doc = "                 initialized MPI."]
    #[doc = " \\param prec_RR  A helper MPI depending solely on \\p N which can be used to"]
    #[doc = "                 speed-up multiple modular exponentiations for the same value"]
    #[doc = "                 of \\p N. This may be \\c NULL. If it is not \\c NULL, it must"]
    #[doc = "                 point to an initialized MPI. If it hasn't been used after"]
    #[doc = "                 the call to mbedtls_mpi_init(), this function will compute"]
    #[doc = "                 the helper value and store it in \\p prec_RR for reuse on"]
    #[doc = "                 subsequent calls to this function. Otherwise, the function"]
    #[doc = "                 will assume that \\p prec_RR holds the helper value set by a"]
    #[doc = "                 previous call to mbedtls_mpi_exp_mod(), and reuse it."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\c N is negative or"]
    #[doc = "                 even, or if \\c E is negative."]
    #[doc = " \\return         Another negative error code on different kinds of failures."]
    #[doc = ""]
    pub fn mbedtls_mpi_exp_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        prec_RR: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Fill an MPI with a number of random bytes."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param size     The number of random bytes to generate."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on failure."]
    #[doc = ""]
    #[doc = " \\note           The bytes obtained from the RNG are interpreted"]
    #[doc = "                 as a big-endian representation of an MPI; this can"]
    #[doc = "                 be relevant in applications like deterministic ECDSA."]
    pub fn mbedtls_mpi_fill_random(
        X: *mut mbedtls_mpi,
        size: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " Generate a random number uniformly in a range."]
    #[doc = ""]
    #[doc = " This function generates a random number between \\p min inclusive and"]
    #[doc = " \\p N exclusive."]
    #[doc = ""]
    #[doc = " The procedure complies with RFC 6979 3.3 (deterministic ECDSA)"]
    #[doc = " when the RNG is a suitably parametrized instance of HMAC_DRBG"]
    #[doc = " and \\p min is \\c 1."]
    #[doc = ""]
    #[doc = " \\note           There are `N - min` possible outputs. The lower bound"]
    #[doc = "                 \\p min can be reached, but the upper bound \\p N cannot."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param min      The minimum value to return."]
    #[doc = "                 It must be nonnegative."]
    #[doc = " \\param N        The upper bound of the range, exclusive."]
    #[doc = "                 In other words, this is one plus the maximum value to return."]
    #[doc = "                 \\p N must be strictly larger than \\p min."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p min or \\p N is invalid"]
    #[doc = "                 or if they are incompatible."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if the implementation was"]
    #[doc = "                 unable to find a suitable value within a limited number"]
    #[doc = "                 of attempts. This has a negligible probability if \\p N"]
    #[doc = "                 is significantly larger than \\p min, which is the case"]
    #[doc = "                 for all usual cryptographic applications."]
    #[doc = " \\return         Another negative error code on failure."]
    pub fn mbedtls_mpi_random(
        X: *mut mbedtls_mpi,
        min: mbedtls_mpi_sint,
        N: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the greatest common divisor: G = gcd(A, B)"]
    #[doc = ""]
    #[doc = " \\param G        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first operand. This must point to an initialized MPI."]
    #[doc = " \\param B        The second operand. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_gcd(
        G: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the modular inverse: X = A^-1 mod N"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The MPI to calculate the modular inverse of. This must point"]
    #[doc = "                 to an initialized MPI."]
    #[doc = " \\param N        The base of the modular inversion. This must point to an"]
    #[doc = "                 initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p N is less than"]
    #[doc = "                 or equal to one."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p has no modular inverse"]
    #[doc = "                 with respect to \\p N."]
    pub fn mbedtls_mpi_inv_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Miller-Rabin primality test."]
    #[doc = ""]
    #[doc = " \\warning        If \\p X is potentially generated by an adversary, for example"]
    #[doc = "                 when validating cryptographic parameters that you didn't"]
    #[doc = "                 generate yourself and that are supposed to be prime, then"]
    #[doc = "                 \\p rounds should be at least the half of the security"]
    #[doc = "                 strength of the cryptographic algorithm. On the other hand,"]
    #[doc = "                 if \\p X is chosen uniformly or non-adversarially (as is the"]
    #[doc = "                 case when mbedtls_mpi_gen_prime calls this function), then"]
    #[doc = "                 \\p rounds can be much lower."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to check for primality."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param rounds   The number of bases to perform the Miller-Rabin primality"]
    #[doc = "                 test for. The probability of returning 0 on a composite is"]
    #[doc = "                 at most 2<sup>-2*\\p rounds</sup>."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng."]
    #[doc = "                 This may be \\c NULL if \\p f_rng doesn't use"]
    #[doc = "                 a context parameter."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful, i.e. \\p X is probably prime."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p X is not prime."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_is_prime_ext(
        X: *const mbedtls_mpi,
        rounds: crate::c_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
#[doc = "< (X-1)/2 is prime too"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_DH: mbedtls_mpi_gen_prime_flag_t =
    1;
#[doc = "< lower error rate from 2<sup>-80</sup> to 2<sup>-128</sup>"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR:
    mbedtls_mpi_gen_prime_flag_t = 2;
#[doc = " \\brief Flags for mbedtls_mpi_gen_prime()"]
#[doc = ""]
#[doc = " Each of these flags is a constraint on the result X returned by"]
#[doc = " mbedtls_mpi_gen_prime()."]
pub type mbedtls_mpi_gen_prime_flag_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " \\brief          Generate a prime number."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI to store the generated prime in."]
    #[doc = "                 This must point to an initialized MPi."]
    #[doc = " \\param nbits    The required size of the destination MPI in bits."]
    #[doc = "                 This must be between \\c 3 and #MBEDTLS_MPI_MAX_BITS."]
    #[doc = " \\param flags    A mask of flags of type #mbedtls_mpi_gen_prime_flag_t."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng."]
    #[doc = "                 This may be \\c NULL if \\p f_rng doesn't use"]
    #[doc = "                 a context parameter."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful, in which case \\p X holds a"]
    #[doc = "                 probably prime number."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if `nbits` is not between"]
    #[doc = "                 \\c 3 and #MBEDTLS_MPI_MAX_BITS."]
    pub fn mbedtls_mpi_gen_prime(
        X: *mut mbedtls_mpi,
        nbits: size_t,
        flags: crate::c_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_mpi_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< Curve not defined."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
#[doc = "< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
#[doc = "< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
#[doc = "< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
#[doc = "< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
#[doc = "< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
#[doc = "< Domain parameters for 256-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
#[doc = "< Domain parameters for 384-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
#[doc = "< Domain parameters for 512-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
#[doc = "< Domain parameters for Curve25519."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
#[doc = "< Domain parameters for 192-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
#[doc = "< Domain parameters for 224-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
#[doc = "< Domain parameters for 256-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
#[doc = "< Domain parameters for Curve448."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE448: mbedtls_ecp_group_id = 13;
#[doc = " Domain-parameter identifiers: curve, subgroup, and generator."]
#[doc = ""]
#[doc = " \\note Only curves over prime fields are supported."]
#[doc = ""]
#[doc = " \\warning This library does not support validation of arbitrary domain"]
#[doc = " parameters. Therefore, only standardized domain parameters from trusted"]
#[doc = " sources should be used. See mbedtls_ecp_group_load()."]
pub type mbedtls_ecp_group_id = crate::c_types::c_uint;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_NONE: mbedtls_ecp_curve_type = 0;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS: mbedtls_ecp_curve_type = 1;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_MONTGOMERY: mbedtls_ecp_curve_type = 2;
pub type mbedtls_ecp_curve_type = crate::c_types::c_uint;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_NONE: mbedtls_ecp_modulus_type = 0;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_COORDINATE: mbedtls_ecp_modulus_type = 1;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_SCALAR: mbedtls_ecp_modulus_type = 2;
pub type mbedtls_ecp_modulus_type = crate::c_types::c_uint;
#[doc = " Curve information, for use by other modules."]
#[doc = ""]
#[doc = " The fields of this structure are part of the public API and can be"]
#[doc = " accessed directly by applications. Future versions of the library may"]
#[doc = " add extra fields or reorder existing fields."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
    #[doc = "< An internal identifier."]
    pub grp_id: mbedtls_ecp_group_id,
    #[doc = "< The TLS NamedCurve identifier."]
    pub tls_id: u16,
    #[doc = "< The curve size in bits."]
    pub bit_size: u16,
    #[doc = "< A human-friendly name."]
    pub name: *const crate::c_types::c_char,
}
#[doc = " \\brief           The ECP point structure, in Jacobian coordinates."]
#[doc = ""]
#[doc = " \\note            All functions expect and return points satisfying"]
#[doc = "                  the following condition: <code>Z == 0</code> or"]
#[doc = "                  <code>Z == 1</code>. Other values of \\p Z are"]
#[doc = "                  used only by internal functions."]
#[doc = "                  The point is zero, or \"at infinity\", if <code>Z == 0</code>."]
#[doc = "                  Otherwise, \\p X and \\p Y are its standard (affine)"]
#[doc = "                  coordinates."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_point {
    pub private_X: mbedtls_mpi,
    pub private_Y: mbedtls_mpi,
    pub private_Z: mbedtls_mpi,
}
#[doc = " \\brief           The ECP group structure."]
#[doc = ""]
#[doc = " We consider two types of curve equations:"]
#[doc = " <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>"]
#[doc = " (SEC1 + RFC-4492)</li>"]
#[doc = " <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,"]
#[doc = " Curve448)</li></ul>"]
#[doc = " In both cases, the generator (\\p G) for a prime-order subgroup is fixed."]
#[doc = ""]
#[doc = " For Short Weierstrass, this subgroup is the whole curve, and its"]
#[doc = " cardinality is denoted by \\p N. Our code requires that \\p N is an"]
#[doc = " odd prime as mbedtls_ecp_mul() requires an odd number, and"]
#[doc = " mbedtls_ecdsa_sign() requires that it is prime for blinding purposes."]
#[doc = ""]
#[doc = " For Montgomery curves, we do not store \\p A, but <code>(A + 2) / 4</code>,"]
#[doc = " which is the quantity used in the formulas. Additionally, \\p nbits is"]
#[doc = " not the size of \\p N but the required size for private keys."]
#[doc = ""]
#[doc = " If \\p modp is NULL, reduction modulo \\p P is done using a generic algorithm."]
#[doc = " Otherwise, \\p modp must point to a function that takes an \\p mbedtls_mpi in the"]
#[doc = " range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer"]
#[doc = " which is congruent mod \\p P to the given MPI, and is close enough to \\p pbits"]
#[doc = " in size, so that it may be efficiently brought in the 0..P-1 range by a few"]
#[doc = " additions or subtractions. Therefore, it is only an approximative modular"]
#[doc = " reduction. It must return 0 on success and non-zero on failure."]
#[doc = ""]
#[doc = " \\note        Alternative implementations of the ECP module must obey the"]
#[doc = "              following constraints."]
#[doc = "              * Group IDs must be distinct: if two group structures have"]
#[doc = "                the same ID, then they must be identical."]
#[doc = "              * The fields \\c id, \\c P, \\c A, \\c B, \\c G, \\c N,"]
#[doc = "                \\c pbits and \\c nbits must have the same type and semantics"]
#[doc = "                as in the built-in implementation."]
#[doc = "                They must be available for reading, but direct modification"]
#[doc = "                of these fields does not need to be supported."]
#[doc = "                They do not need to be at the same offset in the structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_group {
    #[doc = "< An internal group identifier."]
    pub id: mbedtls_ecp_group_id,
    #[doc = "< The prime modulus of the base field."]
    pub P: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p A in the equation. For"]
    #[doc = "Montgomery curves: <code>(A + 2) / 4</code>."]
    pub A: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p B in the equation."]
    #[doc = "For Montgomery curves: unused."]
    pub B: mbedtls_mpi,
    #[doc = "< The generator of the subgroup used."]
    pub G: mbedtls_ecp_point,
    #[doc = "< The order of \\p G."]
    pub N: mbedtls_mpi,
    #[doc = "< The number of bits in \\p P."]
    pub pbits: size_t,
    #[doc = "< For Short Weierstrass: The number of bits in \\p P."]
    #[doc = "For Montgomery curves: the number of bits in the"]
    #[doc = "private keys."]
    pub nbits: size_t,
    pub private_h: crate::c_types::c_uint,
    pub private_modp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> crate::c_types::c_int,
    >,
    pub private_t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub private_t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub private_t_data: *mut crate::c_types::c_void,
    pub private_T: *mut mbedtls_ecp_point,
    pub private_T_size: size_t,
}
pub type mbedtls_ecp_restart_ctx = crate::c_types::c_void;
#[doc = " \\brief    The ECP key-pair structure."]
#[doc = ""]
#[doc = " A generic key-pair that may be used for ECDSA and fixed ECDH, for example."]
#[doc = ""]
#[doc = " \\note    Members are deliberately in the same order as in the"]
#[doc = "          ::mbedtls_ecdsa_context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_keypair {
    pub private_grp: mbedtls_ecp_group,
    pub private_d: mbedtls_mpi,
    pub private_Q: mbedtls_ecp_point,
}
extern "C" {
    pub fn mbedtls_ecp_get_type(grp: *const mbedtls_ecp_group) -> mbedtls_ecp_curve_type;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the information defined in"]
    #[doc = "                  mbedtls_ecp_curve_info() for all supported curves."]
    #[doc = ""]
    #[doc = " \\note            This function returns information about all curves"]
    #[doc = "                  supported by the library. Some curves may not be"]
    #[doc = "                  supported for all algorithms. Call mbedtls_ecdh_can_do()"]
    #[doc = "                  or mbedtls_ecdsa_can_do() to check if a curve is"]
    #[doc = "                  supported for ECDH or ECDSA."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array. The last entry is 0."]
    pub fn mbedtls_ecp_curve_list() -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the list of internal group"]
    #[doc = "                  identifiers of all supported curves in the order of"]
    #[doc = "                  preference."]
    #[doc = ""]
    #[doc = " \\note            This function returns information about all curves"]
    #[doc = "                  supported by the library. Some curves may not be"]
    #[doc = "                  supported for all algorithms. Call mbedtls_ecdh_can_do()"]
    #[doc = "                  or mbedtls_ecdsa_can_do() to check if a curve is"]
    #[doc = "                  supported for ECDH or ECDSA."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array,"]
    #[doc = "                  terminated with MBEDTLS_ECP_DP_NONE."]
    pub fn mbedtls_ecp_grp_id_list() -> *const mbedtls_ecp_group_id;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from an internal"]
    #[doc = "                  group identifier."]
    #[doc = ""]
    #[doc = " \\param grp_id    An \\c MBEDTLS_ECP_DP_XXX value."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_grp_id(
        grp_id: mbedtls_ecp_group_id,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a TLS"]
    #[doc = "                  NamedCurve value."]
    #[doc = ""]
    #[doc = " \\param tls_id    An \\c MBEDTLS_ECP_DP_XXX value."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_tls_id(tls_id: u16) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a"]
    #[doc = "                  human-readable name."]
    #[doc = ""]
    #[doc = " \\param name      The human-readable name."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_name(
        name: *const crate::c_types::c_char,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function initializes a point as zero."]
    #[doc = ""]
    #[doc = " \\param pt        The point to initialize."]
    pub fn mbedtls_ecp_point_init(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECP group context"]
    #[doc = "                  without loading any domain parameters."]
    #[doc = ""]
    #[doc = " \\note            After this function is called, domain parameters"]
    #[doc = "                  for various ECP groups can be loaded through the"]
    #[doc = "                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()"]
    #[doc = "                  functions."]
    pub fn mbedtls_ecp_group_init(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function initializes a key pair as an invalid one."]
    #[doc = ""]
    #[doc = " \\param key       The key pair to initialize."]
    pub fn mbedtls_ecp_keypair_init(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a point."]
    #[doc = ""]
    #[doc = " \\param pt        The point to free."]
    pub fn mbedtls_ecp_point_free(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of an ECP group."]
    #[doc = ""]
    #[doc = " \\param grp       The group to free. This may be \\c NULL, in which"]
    #[doc = "                  case this function returns immediately. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized ECP group."]
    pub fn mbedtls_ecp_group_free(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a key pair."]
    #[doc = ""]
    #[doc = " \\param key       The key pair to free. This may be \\c NULL, in which"]
    #[doc = "                  case this function returns immediately. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized ECP key pair."]
    pub fn mbedtls_ecp_keypair_free(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of point \\p Q into"]
    #[doc = "                  point \\p P."]
    #[doc = ""]
    #[doc = " \\param P         The destination point. This must be initialized."]
    #[doc = " \\param Q         The source point. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code for other kinds of failure."]
    pub fn mbedtls_ecp_copy(
        P: *mut mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of group \\p src into"]
    #[doc = "                  group \\p dst."]
    #[doc = ""]
    #[doc = " \\param dst       The destination group. This must be initialized."]
    #[doc = " \\param src       The source group. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_group_copy(
        dst: *mut mbedtls_ecp_group,
        src: *const mbedtls_ecp_group,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets a point to the point at infinity."]
    #[doc = ""]
    #[doc = " \\param pt        The point to set. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_set_zero(pt: *mut mbedtls_ecp_point) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks if a point is the point at infinity."]
    #[doc = ""]
    #[doc = " \\param pt        The point to test. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 1 if the point is zero."]
    #[doc = " \\return          \\c 0 if the point is non-zero."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecp_is_zero(pt: *mut mbedtls_ecp_point) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function compares two points."]
    #[doc = ""]
    #[doc = " \\note            This assumes that the points are normalized. Otherwise,"]
    #[doc = "                  they may compare as \"not equal\" even if they are."]
    #[doc = ""]
    #[doc = " \\param P         The first point to compare. This must be initialized."]
    #[doc = " \\param Q         The second point to compare. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the points are equal."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal."]
    pub fn mbedtls_ecp_point_cmp(
        P: *const mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a non-zero point from two ASCII"]
    #[doc = "                  strings."]
    #[doc = ""]
    #[doc = " \\param P         The destination point. This must be initialized."]
    #[doc = " \\param radix     The numeric base of the input."]
    #[doc = " \\param x         The first affine coordinate, as a null-terminated string."]
    #[doc = " \\param y         The second affine coordinate, as a null-terminated string."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on failure."]
    pub fn mbedtls_ecp_point_read_string(
        P: *mut mbedtls_ecp_point,
        radix: crate::c_types::c_int,
        x: *const crate::c_types::c_char,
        y: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point into unsigned binary data."]
    #[doc = ""]
    #[doc = " \\param grp       The group to which the point should belong."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param P         The point to export. This must be initialized."]
    #[doc = " \\param format    The point format. This must be either"]
    #[doc = "                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED."]
    #[doc = "                  (For groups without these formats, this parameter is"]
    #[doc = "                  ignored. But it still has to be either of the above"]
    #[doc = "                  values.)"]
    #[doc = " \\param olen      The address at which to store the length of"]
    #[doc = "                  the output in Bytes. This must not be \\c NULL."]
    #[doc = " \\param buf       The output buffer. This must be a writable buffer"]
    #[doc = "                  of length \\p buflen Bytes."]
    #[doc = " \\param buflen    The length of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer"]
    #[doc = "                  is too small to hold the point."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format"]
    #[doc = "                  or the export for the given group is not implemented."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_point_write_binary(
        grp: *const mbedtls_ecp_group,
        P: *const mbedtls_ecp_point,
        format: crate::c_types::c_int,
        olen: *mut size_t,
        buf: *mut crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from unsigned binary data."]
    #[doc = ""]
    #[doc = " \\note            This function does not check that the point actually"]
    #[doc = "                  belongs to the given group, see mbedtls_ecp_check_pubkey()"]
    #[doc = "                  for that."]
    #[doc = ""]
    #[doc = " \\note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for"]
    #[doc = "                  limitations."]
    #[doc = ""]
    #[doc = " \\param grp       The group to which the point should belong."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param P         The destination context to import the point to."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param buf       The input buffer. This must be a readable buffer"]
    #[doc = "                  of length \\p ilen Bytes."]
    #[doc = " \\param ilen      The length of the input buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the import for the"]
    #[doc = "                  given group is not implemented."]
    pub fn mbedtls_ecp_point_read_binary(
        grp: *const mbedtls_ecp_group,
        P: *mut mbedtls_ecp_point,
        buf: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from a TLS ECPoint record."]
    #[doc = ""]
    #[doc = " \\note            On function return, \\p *buf is updated to point immediately"]
    #[doc = "                  after the ECPoint record."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param pt        The destination point."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization"]
    #[doc = "                  failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    pub fn mbedtls_ecp_tls_read_point(
        grp: *const mbedtls_ecp_group,
        pt: *mut mbedtls_ecp_point,
        buf: *mut *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point as a TLS ECPoint record"]
    #[doc = "                  defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param pt        The point to be exported. This must be initialized."]
    #[doc = " \\param format    The point format to use. This must be either"]
    #[doc = "                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED."]
    #[doc = " \\param olen      The address at which to store the length in Bytes"]
    #[doc = "                  of the data written."]
    #[doc = " \\param buf       The target buffer. This must be a writable buffer of"]
    #[doc = "                  length \\p blen Bytes."]
    #[doc = " \\param blen      The length of the target buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer"]
    #[doc = "                  is too small to hold the exported point."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_write_point(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
        format: crate::c_types::c_int,
        olen: *mut size_t,
        buf: *mut crate::c_types::c_uchar,
        blen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context"]
    #[doc = "                  from a standardized set of domain parameters."]
    #[doc = ""]
    #[doc = " \\note            The index should be a value of the NamedCurve enum,"]
    #[doc = "                  as defined in <em>RFC-4492: Elliptic Curve Cryptography"]
    #[doc = "                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,"]
    #[doc = "                  usually in the form of an \\c MBEDTLS_ECP_DP_XXX macro."]
    #[doc = ""]
    #[doc = " \\param grp       The group context to setup. This must be initialized."]
    #[doc = " \\param id        The identifier of the domain parameter set to load."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p id doesn't"]
    #[doc = "                  correspond to a known group."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_group_load(
        grp: *mut mbedtls_ecp_group,
        id: mbedtls_ecp_group_id,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context from a TLS"]
    #[doc = "                  ECParameters record as defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\note            The read pointer \\p buf is updated to point right after"]
    #[doc = "                  the ECParameters record on exit."]
    #[doc = ""]
    #[doc = " \\param grp       The group context to setup. This must be initialized."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the input buffer \\c *buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not"]
    #[doc = "                  recognized."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_read_group(
        grp: *mut mbedtls_ecp_group,
        buf: *mut *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts an elliptic curve group ID from a"]
    #[doc = "                  TLS ECParameters record as defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\note            The read pointer \\p buf is updated to point right after"]
    #[doc = "                  the ECParameters record on exit."]
    #[doc = ""]
    #[doc = " \\param grp       The address at which to store the group id."]
    #[doc = "                  This must not be \\c NULL."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the input buffer \\c *buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not"]
    #[doc = "                  recognized."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_read_group_id(
        grp: *mut mbedtls_ecp_group_id,
        buf: *mut *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve as a TLS"]
    #[doc = "                  ECParameters record as defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to be exported."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param olen      The address at which to store the number of Bytes written."]
    #[doc = "                  This must not be \\c NULL."]
    #[doc = " \\param buf       The buffer to write to. This must be a writable buffer"]
    #[doc = "                  of length \\p blen Bytes."]
    #[doc = " \\param blen      The length of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output"]
    #[doc = "                  buffer is too small to hold the exported group."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_write_group(
        grp: *const mbedtls_ecp_group,
        olen: *mut size_t,
        buf: *mut crate::c_types::c_uchar,
        blen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a scalar multiplication of a point"]
    #[doc = "                  by an integer: \\p R = \\p m * \\p P."]
    #[doc = ""]
    #[doc = "                  It is not thread-safe to use same group in multiple threads."]
    #[doc = ""]
    #[doc = " \\note            To prevent timing attacks, this function"]
    #[doc = "                  executes the exact same sequence of base-field"]
    #[doc = "                  operations for any valid \\p m. It avoids any if-branch or"]
    #[doc = "                  array index depending on the value of \\p m. It also uses"]
    #[doc = "                  \\p f_rng to randomize some intermediate results."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply. This must be initialized."]
    #[doc = " \\param P         The point to multiply. This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c"]
    #[doc = "                  NULL if \\p f_rng doesn't need a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private"]
    #[doc = "                  key, or \\p P is not a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_mul(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication of a point by"]
    #[doc = "                  an integer: \\p R = \\p m * \\p P in a restartable way."]
    #[doc = ""]
    #[doc = " \\see             mbedtls_ecp_mul()"]
    #[doc = ""]
    #[doc = " \\note            This function does the same as \\c mbedtls_ecp_mul(), but"]
    #[doc = "                  it can return early and restart according to the limit set"]
    #[doc = "                  with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply. This must be initialized."]
    #[doc = " \\param P         The point to multiply. This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c"]
    #[doc = "                  NULL if \\p f_rng doesn't need a context."]
    #[doc = " \\param rs_ctx    The restart context (NULL disables restart)."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private"]
    #[doc = "                  key, or \\p P is not a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_mul_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two"]
    #[doc = "                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q"]
    #[doc = ""]
    #[doc = "                  It is not thread-safe to use same group in multiple threads."]
    #[doc = ""]
    #[doc = " \\note            In contrast to mbedtls_ecp_mul(), this function does not"]
    #[doc = "                  guarantee a constant execution flow and timing."]
    #[doc = ""]
    #[doc = " \\note            This function is only defined for short Weierstrass curves."]
    #[doc = "                  It may not be included in builds without any short"]
    #[doc = "                  Weierstrass curve."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply \\p P."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param P         The point to multiply by \\p m. This must be initialized."]
    #[doc = " \\param n         The integer by which to multiply \\p Q."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The point to be multiplied by \\p n."]
    #[doc = "                  This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not"]
    #[doc = "                  valid private keys, or \\p P or \\p Q are not valid public"]
    #[doc = "                  keys."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not"]
    #[doc = "                  designate a short Weierstrass curve."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_muladd(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two"]
    #[doc = "                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q in a"]
    #[doc = "                  restartable way."]
    #[doc = ""]
    #[doc = " \\see             \\c mbedtls_ecp_muladd()"]
    #[doc = ""]
    #[doc = " \\note            This function works the same as \\c mbedtls_ecp_muladd(),"]
    #[doc = "                  but it can return early and restart according to the limit"]
    #[doc = "                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\note            This function is only defined for short Weierstrass curves."]
    #[doc = "                  It may not be included in builds without any short"]
    #[doc = "                  Weierstrass curve."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply \\p P."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param P         The point to multiply by \\p m. This must be initialized."]
    #[doc = " \\param n         The integer by which to multiply \\p Q."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The point to be multiplied by \\p n."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param rs_ctx    The restart context (NULL disables restart)."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not"]
    #[doc = "                  valid private keys, or \\p P or \\p Q are not valid public"]
    #[doc = "                  keys."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not"]
    #[doc = "                  designate a short Weierstrass curve."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_muladd_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that a point is a valid public key"]
    #[doc = "                  on this curve."]
    #[doc = ""]
    #[doc = "                  It only checks that the point is non-zero, has"]
    #[doc = "                  valid coordinates and lies on the curve. It does not verify"]
    #[doc = "                  that it is indeed a multiple of \\p G. This additional"]
    #[doc = "                  check is computationally more expensive, is not required"]
    #[doc = "                  by standards, and should not be necessary if the group"]
    #[doc = "                  used has a small cofactor. In particular, it is useless for"]
    #[doc = "                  the NIST groups which all have a cofactor of 1."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure, to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group the point should belong to."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param pt        The point to check. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the point is a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not"]
    #[doc = "                  a valid public key for the given curve."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_check_pubkey(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that an \\p mbedtls_mpi is a"]
    #[doc = "                  valid private key for this curve."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group the private key should belong to."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param d         The integer to check. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the point is a valid private key."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid"]
    #[doc = "                  private key for the given curve."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_check_privkey(
        grp: *const mbedtls_ecp_group,
        d: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a private key."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to generate a private key for."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param d         The destination MPI (secret part). This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    pub fn mbedtls_ecp_gen_privkey(
        grp: *const mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a keypair with a configurable base"]
    #[doc = "                  point."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to generate a key pair for."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param G         The base point to use. This must be initialized"]
    #[doc = "                  and belong to \\p grp. It replaces the default base"]
    #[doc = "                  point \\c grp->G used by mbedtls_ecp_gen_keypair()."]
    #[doc = " \\param d         The destination MPI (secret part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The destination point (public part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                  be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    pub fn mbedtls_ecp_gen_keypair_base(
        grp: *mut mbedtls_ecp_group,
        G: *const mbedtls_ecp_point,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP keypair."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to generate a key pair for."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param d         The destination MPI (secret part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The destination point (public part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                  be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    pub fn mbedtls_ecp_gen_keypair(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP key."]
    #[doc = ""]
    #[doc = " \\param grp_id    The ECP group identifier."]
    #[doc = " \\param key       The destination key. This must be initialized."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                  be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    pub fn mbedtls_ecp_gen_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads an elliptic curve private key."]
    #[doc = ""]
    #[doc = " \\param grp_id    The ECP group identifier."]
    #[doc = " \\param key       The destination key."]
    #[doc = " \\param buf       The buffer containing the binary representation of the"]
    #[doc = "                  key. (Big endian integer for Weierstrass curves, byte"]
    #[doc = "                  string for Montgomery curves.)"]
    #[doc = " \\param buflen    The length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY error if the key is"]
    #[doc = "                  invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for"]
    #[doc = "                  the group is not implemented."]
    #[doc = " \\return          Another negative error code on different kinds of failure."]
    pub fn mbedtls_ecp_read_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve private key."]
    #[doc = ""]
    #[doc = " \\param key       The private key."]
    #[doc = " \\param buf       The output buffer for containing the binary representation"]
    #[doc = "                  of the key. (Big endian integer for Weierstrass curves, byte"]
    #[doc = "                  string for Montgomery curves.)"]
    #[doc = " \\param buflen    The total length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the \\p key"]
    #[doc = "representation is larger than the available space in \\p buf."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for"]
    #[doc = "                  the group is not implemented."]
    #[doc = " \\return          Another negative error code on different kinds of failure."]
    pub fn mbedtls_ecp_write_key(
        key: *mut mbedtls_ecp_keypair,
        buf: *mut crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that the keypair objects"]
    #[doc = "                  \\p pub and \\p prv have the same group and the"]
    #[doc = "                  same public point, and that the private key in"]
    #[doc = "                  \\p prv is consistent with the public key."]
    #[doc = ""]
    #[doc = " \\param pub       The keypair structure holding the public key. This"]
    #[doc = "                  must be initialized. If it contains a private key, that"]
    #[doc = "                  part is ignored."]
    #[doc = " \\param prv       The keypair structure holding the full keypair."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c"]
    #[doc = "                  NULL if \\p f_rng doesn't need a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success, meaning that the keys are valid and match."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or an \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on calculation failure."]
    pub fn mbedtls_ecp_check_pub_priv(
        pub_: *const mbedtls_ecp_keypair,
        prv: *const mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports generic key-pair parameters."]
    #[doc = ""]
    #[doc = " \\param key       The key pair to export from."]
    #[doc = " \\param grp       Slot for exported ECP group."]
    #[doc = "                  It must point to an initialized ECP group."]
    #[doc = " \\param d         Slot for the exported secret value."]
    #[doc = "                  It must point to an initialized mpi."]
    #[doc = " \\param Q         Slot for the exported public value."]
    #[doc = "                  It must point to an initialized ECP point."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success,"]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if key id doesn't"]
    #[doc = "                  correspond to a known group."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_export(
        key: *const mbedtls_ecp_keypair,
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The ECP checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_ecp_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< None."]
pub const mbedtls_md_type_t_MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
#[doc = "< The MD5 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_MD5: mbedtls_md_type_t = 1;
#[doc = "< The SHA-1 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA1: mbedtls_md_type_t = 2;
#[doc = "< The SHA-224 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA224: mbedtls_md_type_t = 3;
#[doc = "< The SHA-256 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA256: mbedtls_md_type_t = 4;
#[doc = "< The SHA-384 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA384: mbedtls_md_type_t = 5;
#[doc = "< The SHA-512 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA512: mbedtls_md_type_t = 6;
#[doc = "< The RIPEMD-160 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 7;
#[doc = " \\brief     Supported message digests."]
#[doc = ""]
#[doc = " \\warning   MD5 and SHA-1 are considered weak message digests and"]
#[doc = "            their use constitutes a security risk. We recommend considering"]
#[doc = "            stronger message digests instead."]
#[doc = ""]
pub type mbedtls_md_type_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md_info_t {
    _unused: [u8; 0],
}
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_LEGACY: mbedtls_md_engine_t = 0;
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_PSA: mbedtls_md_engine_t = 1;
#[doc = " Used internally to indicate whether a context uses legacy or PSA."]
#[doc = ""]
#[doc = " Internal use only."]
pub type mbedtls_md_engine_t = crate::c_types::c_uint;
#[doc = " The generic message-digest context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md_context_t {
    pub private_md_info: *const mbedtls_md_info_t,
    pub private_md_ctx: *mut crate::c_types::c_void,
    pub private_hmac_ctx: *mut crate::c_types::c_void,
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information"]
    #[doc = "                  associated with the given digest type."]
    #[doc = ""]
    #[doc = " \\param md_type   The type of digest to search for."]
    #[doc = ""]
    #[doc = " \\return          The message-digest information associated with \\p md_type."]
    #[doc = " \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_type(md_type: mbedtls_md_type_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function initializes a message-digest context without"]
    #[doc = "                  binding it to a particular message-digest algorithm."]
    #[doc = ""]
    #[doc = "                  This function should always be called first. It prepares the"]
    #[doc = "                  context for mbedtls_md_setup() for binding it to a"]
    #[doc = "                  message-digest algorithm."]
    pub fn mbedtls_md_init(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function clears the internal structure of \\p ctx and"]
    #[doc = "                  frees any embedded internal structure, but does not free"]
    #[doc = "                  \\p ctx itself."]
    #[doc = ""]
    #[doc = "                  If you have called mbedtls_md_setup() on \\p ctx, you must"]
    #[doc = "                  call mbedtls_md_free() when you are no longer using the"]
    #[doc = "                  context."]
    #[doc = "                  Calling this function if you have previously"]
    #[doc = "                  called mbedtls_md_init() and nothing else is optional."]
    #[doc = "                  You must not call this function if you have not called"]
    #[doc = "                  mbedtls_md_init()."]
    pub fn mbedtls_md_free(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function selects the message digest algorithm to use,"]
    #[doc = "                  and allocates internal structures."]
    #[doc = ""]
    #[doc = "                  It should be called after mbedtls_md_init() or"]
    #[doc = "                  mbedtls_md_free(). Makes it necessary to call"]
    #[doc = "                  mbedtls_md_free() later."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to set up."]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = " \\param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),"]
    #[doc = "                  or non-zero: HMAC is used with this context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_md_setup(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
        hmac: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clones the state of a message-digest"]
    #[doc = "                  context."]
    #[doc = ""]
    #[doc = " \\note            You must call mbedtls_md_setup() on \\c dst before calling"]
    #[doc = "                  this function."]
    #[doc = ""]
    #[doc = " \\note            The two contexts must have the same type,"]
    #[doc = "                  for example, both are SHA-256."]
    #[doc = ""]
    #[doc = " \\warning         This function clones the message-digest state, not the"]
    #[doc = "                  HMAC state."]
    #[doc = ""]
    #[doc = " \\param dst       The destination context."]
    #[doc = " \\param src       The context to be cloned."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE if both contexts are"]
    #[doc = "                  not using the same engine. This can be avoided by moving"]
    #[doc = "                  the call to psa_crypto_init() before the first call to"]
    #[doc = "                  mbedtls_md_setup()."]
    pub fn mbedtls_md_clone(
        dst: *mut mbedtls_md_context_t,
        src: *const mbedtls_md_context_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest size from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The size of the message-digest output in Bytes."]
    pub fn mbedtls_md_get_size(md_info: *const mbedtls_md_info_t) -> crate::c_types::c_uchar;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest type from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The type of the message digest."]
    pub fn mbedtls_md_get_type(md_info: *const mbedtls_md_info_t) -> mbedtls_md_type_t;
}
extern "C" {
    #[doc = " \\brief           This function starts a message-digest computation."]
    #[doc = ""]
    #[doc = "                  You must call this function after setting up the context"]
    #[doc = "                  with mbedtls_md_setup(), and before passing data with"]
    #[doc = "                  mbedtls_md_update()."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_starts(ctx: *mut mbedtls_md_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing"]
    #[doc = "                  message-digest computation."]
    #[doc = ""]
    #[doc = "                  You must call mbedtls_md_starts() before calling this"]
    #[doc = "                  function. You may call this function multiple times."]
    #[doc = "                  Afterwards, call mbedtls_md_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param ilen      The length of the input data."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the digest operation,"]
    #[doc = "                  and writes the result to the output buffer."]
    #[doc = ""]
    #[doc = "                  Call this function after a call to mbedtls_md_starts(),"]
    #[doc = "                  followed by any number of calls to mbedtls_md_update()."]
    #[doc = "                  Afterwards, you may either clear the context with"]
    #[doc = "                  mbedtls_md_free(), or call mbedtls_md_starts() to reuse"]
    #[doc = "                  the context for another digest operation with the same"]
    #[doc = "                  algorithm."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = " \\param output    The buffer for the generic message-digest checksum result."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the message-digest of a buffer,"]
    #[doc = "                 with respect to a configurable message-digest algorithm"]
    #[doc = "                 in a single call."]
    #[doc = ""]
    #[doc = "                 The result is calculated as"]
    #[doc = "                 Output = message_digest(input buffer)."]
    #[doc = ""]
    #[doc = " \\param md_info  The information structure of the message-digest algorithm"]
    #[doc = "                 to use."]
    #[doc = " \\param input    The buffer holding the data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The generic message-digest checksum result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                 failure."]
    pub fn mbedtls_md(
        md_info: *const mbedtls_md_info_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function returns the list of digests supported by the"]
    #[doc = "                  generic digest module."]
    #[doc = ""]
    #[doc = " \\note            The list starts with the strongest available hashes."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array of digests. Each element"]
    #[doc = "                  in the returned list is an integer belonging to the"]
    #[doc = "                  message-digest enumeration #mbedtls_md_type_t."]
    #[doc = "                  The last entry is 0."]
    pub fn mbedtls_md_list() -> *const crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information"]
    #[doc = "                  associated with the given digest name."]
    #[doc = ""]
    #[doc = " \\param md_name   The name of the digest to search for."]
    #[doc = ""]
    #[doc = " \\return          The message-digest information associated with \\p md_name."]
    #[doc = " \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_string(
        md_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest name from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The name of the message digest."]
    pub fn mbedtls_md_get_name(md_info: *const mbedtls_md_info_t) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information"]
    #[doc = "                  from the given context."]
    #[doc = ""]
    #[doc = " \\param ctx       The context from which to extract the information."]
    #[doc = "                  This must be initialized (or \\c NULL)."]
    #[doc = ""]
    #[doc = " \\return          The message-digest information associated with \\p ctx."]
    #[doc = " \\return          \\c NULL if \\p ctx is \\c NULL."]
    pub fn mbedtls_md_info_from_ctx(ctx: *const mbedtls_md_context_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function sets the HMAC key and prepares to"]
    #[doc = "                  authenticate a new message."]
    #[doc = ""]
    #[doc = "                  Call this function after mbedtls_md_setup(), to use"]
    #[doc = "                  the MD context for an HMAC calculation, then call"]
    #[doc = "                  mbedtls_md_hmac_update() to provide the input data, and"]
    #[doc = "                  mbedtls_md_hmac_finish() to get the HMAC value."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param key       The HMAC secret key."]
    #[doc = " \\param keylen    The length of the HMAC key in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_starts(
        ctx: *mut mbedtls_md_context_t,
        key: *const crate::c_types::c_uchar,
        keylen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing HMAC"]
    #[doc = "                  computation."]
    #[doc = ""]
    #[doc = "                  Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()"]
    #[doc = "                  before calling this function."]
    #[doc = "                  You may call this function multiple times to pass the"]
    #[doc = "                  input piecewise."]
    #[doc = "                  Afterwards, call mbedtls_md_hmac_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param ilen      The length of the input data."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the HMAC operation, and writes"]
    #[doc = "                  the result to the output buffer."]
    #[doc = ""]
    #[doc = "                  Call this function after mbedtls_md_hmac_starts() and"]
    #[doc = "                  mbedtls_md_hmac_update() to get the HMAC value. Afterwards"]
    #[doc = "                  you may either call mbedtls_md_free() to clear the context,"]
    #[doc = "                  or call mbedtls_md_hmac_reset() to reuse the context with"]
    #[doc = "                  the same HMAC key."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param output    The generic HMAC checksum result."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function prepares to authenticate a new message with"]
    #[doc = "                  the same key as the previous HMAC operation."]
    #[doc = ""]
    #[doc = "                  You may call this function after mbedtls_md_hmac_finish()."]
    #[doc = "                  Afterwards call mbedtls_md_hmac_update() to pass the new"]
    #[doc = "                  input."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_reset(ctx: *mut mbedtls_md_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the full generic HMAC"]
    #[doc = "                 on the input buffer with the provided key."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The HMAC result is calculated as"]
    #[doc = "                 output = generic HMAC(hmac key, input buffer)."]
    #[doc = ""]
    #[doc = " \\param md_info  The information structure of the message-digest algorithm"]
    #[doc = "                 to use."]
    #[doc = " \\param key      The HMAC secret key."]
    #[doc = " \\param keylen   The length of the HMAC secret key in Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The generic HMAC result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                 failure."]
    pub fn mbedtls_md_hmac(
        md_info: *const mbedtls_md_info_t,
        key: *const crate::c_types::c_uchar,
        keylen: size_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief   The RSA context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_rsa_context {
    pub private_ver: crate::c_types::c_int,
    pub private_len: size_t,
    pub private_N: mbedtls_mpi,
    pub private_E: mbedtls_mpi,
    pub private_D: mbedtls_mpi,
    pub private_P: mbedtls_mpi,
    pub private_Q: mbedtls_mpi,
    pub private_DP: mbedtls_mpi,
    pub private_DQ: mbedtls_mpi,
    pub private_QP: mbedtls_mpi,
    pub private_RN: mbedtls_mpi,
    pub private_RP: mbedtls_mpi,
    pub private_RQ: mbedtls_mpi,
    pub private_Vi: mbedtls_mpi,
    pub private_Vf: mbedtls_mpi,
    pub private_padding: crate::c_types::c_int,
    pub private_hash_id: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes an RSA context."]
    #[doc = ""]
    #[doc = " \\note           This function initializes the padding and the hash"]
    #[doc = "                 identifier to respectively #MBEDTLS_RSA_PKCS_V15 and"]
    #[doc = "                 #MBEDTLS_MD_NONE. See mbedtls_rsa_set_padding() for more"]
    #[doc = "                 information about those parameters."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_rsa_init(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    #[doc = " \\brief          This function sets padding for an already initialized RSA"]
    #[doc = "                 context."]
    #[doc = ""]
    #[doc = " \\note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP"]
    #[doc = "                 encryption scheme and the RSASSA-PSS signature scheme."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id parameter is ignored when using"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V15 padding."]
    #[doc = ""]
    #[doc = " \\note           The choice of padding mode is strictly enforced for private"]
    #[doc = "                 key operations, since there might be security concerns in"]
    #[doc = "                 mixing padding modes. For public key operations it is"]
    #[doc = "                 a default value, which can be overridden by calling specific"]
    #[doc = "                 \\c mbedtls_rsa_rsaes_xxx or \\c mbedtls_rsa_rsassa_xxx"]
    #[doc = "                 functions."]
    #[doc = ""]
    #[doc = " \\note           The hash selected in \\p hash_id is always used for OEAP"]
    #[doc = "                 encryption. For PSS signatures, it is always used for"]
    #[doc = "                 making signatures, but can be overridden for verifying them."]
    #[doc = "                 If set to #MBEDTLS_MD_NONE, it is always overridden."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to be configured."]
    #[doc = " \\param padding  The padding mode to use. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21."]
    #[doc = " \\param hash_id  The hash identifier for PSS or OAEP, if \\p padding is"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V21. #MBEDTLS_MD_NONE is accepted by this"]
    #[doc = "                 function but may be not suitable for some operations."]
    #[doc = "                 Ignored if \\p padding is #MBEDTLS_RSA_PKCS_V15."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_RSA_INVALID_PADDING failure:"]
    #[doc = "                 \\p padding or \\p hash_id is invalid."]
    pub fn mbedtls_rsa_set_padding(
        ctx: *mut mbedtls_rsa_context,
        padding: crate::c_types::c_int,
        hash_id: mbedtls_md_type_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function retrieves padding mode of initialized"]
    #[doc = "                 RSA context."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = ""]
    #[doc = " \\return         RSA padding mode."]
    #[doc = ""]
    pub fn mbedtls_rsa_get_padding_mode(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function retrieves hash identifier of mbedtls_md_type_t"]
    #[doc = "                 type."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = ""]
    #[doc = " \\return         Hash identifier of mbedtls_md_type_t type."]
    #[doc = ""]
    pub fn mbedtls_rsa_get_md_alg(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports a set of core parameters into an"]
    #[doc = "                 RSA context."]
    #[doc = ""]
    #[doc = " \\note           This function can be called multiple times for successive"]
    #[doc = "                 imports, if the parameters are not simultaneously present."]
    #[doc = ""]
    #[doc = "                 Any sequence of calls to this function should be followed"]
    #[doc = "                 by a call to mbedtls_rsa_complete(), which checks and"]
    #[doc = "                 completes the provided information to a ready-for-use"]
    #[doc = "                 public or private RSA key."]
    #[doc = ""]
    #[doc = " \\note           See mbedtls_rsa_complete() for more information on which"]
    #[doc = "                 parameters are necessary to set up a private or public"]
    #[doc = "                 RSA key."]
    #[doc = ""]
    #[doc = " \\note           The imported parameters are copied and need not be preserved"]
    #[doc = "                 for the lifetime of the RSA context being set up."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to store the parameters in."]
    #[doc = " \\param N        The RSA modulus. This may be \\c NULL."]
    #[doc = " \\param P        The first prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param Q        The second prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param D        The private exponent. This may be \\c NULL."]
    #[doc = " \\param E        The public exponent. This may be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import(
        ctx: *mut mbedtls_rsa_context,
        N: *const mbedtls_mpi,
        P: *const mbedtls_mpi,
        Q: *const mbedtls_mpi,
        D: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports core RSA parameters, in raw big-endian"]
    #[doc = "                 binary format, into an RSA context."]
    #[doc = ""]
    #[doc = " \\note           This function can be called multiple times for successive"]
    #[doc = "                 imports, if the parameters are not simultaneously present."]
    #[doc = ""]
    #[doc = "                 Any sequence of calls to this function should be followed"]
    #[doc = "                 by a call to mbedtls_rsa_complete(), which checks and"]
    #[doc = "                 completes the provided information to a ready-for-use"]
    #[doc = "                 public or private RSA key."]
    #[doc = ""]
    #[doc = " \\note           See mbedtls_rsa_complete() for more information on which"]
    #[doc = "                 parameters are necessary to set up a private or public"]
    #[doc = "                 RSA key."]
    #[doc = ""]
    #[doc = " \\note           The imported parameters are copied and need not be preserved"]
    #[doc = "                 for the lifetime of the RSA context being set up."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to store the parameters in."]
    #[doc = " \\param N        The RSA modulus. This may be \\c NULL."]
    #[doc = " \\param N_len    The Byte length of \\p N; it is ignored if \\p N == NULL."]
    #[doc = " \\param P        The first prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param P_len    The Byte length of \\p P; it is ignored if \\p P == NULL."]
    #[doc = " \\param Q        The second prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param Q_len    The Byte length of \\p Q; it is ignored if \\p Q == NULL."]
    #[doc = " \\param D        The private exponent. This may be \\c NULL."]
    #[doc = " \\param D_len    The Byte length of \\p D; it is ignored if \\p D == NULL."]
    #[doc = " \\param E        The public exponent. This may be \\c NULL."]
    #[doc = " \\param E_len    The Byte length of \\p E; it is ignored if \\p E == NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import_raw(
        ctx: *mut mbedtls_rsa_context,
        N: *const crate::c_types::c_uchar,
        N_len: size_t,
        P: *const crate::c_types::c_uchar,
        P_len: size_t,
        Q: *const crate::c_types::c_uchar,
        Q_len: size_t,
        D: *const crate::c_types::c_uchar,
        D_len: size_t,
        E: *const crate::c_types::c_uchar,
        E_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function completes an RSA context from"]
    #[doc = "                 a set of imported core parameters."]
    #[doc = ""]
    #[doc = "                 To setup an RSA public key, precisely \\p N and \\p E"]
    #[doc = "                 must have been imported."]
    #[doc = ""]
    #[doc = "                 To setup an RSA private key, sufficient information must"]
    #[doc = "                 be present for the other parameters to be derivable."]
    #[doc = ""]
    #[doc = "                 The default implementation supports the following:"]
    #[doc = "                 <ul><li>Derive \\p P, \\p Q from \\p N, \\p D, \\p E.</li>"]
    #[doc = "                 <li>Derive \\p N, \\p D from \\p P, \\p Q, \\p E.</li></ul>"]
    #[doc = "                 Alternative implementations need not support these."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, it guarantees that"]
    #[doc = "                 the RSA context can be used for RSA operations without"]
    #[doc = "                 the risk of failure or crash."]
    #[doc = ""]
    #[doc = " \\warning        This function need not perform consistency checks"]
    #[doc = "                 for the imported parameters. In particular, parameters that"]
    #[doc = "                 are not needed by the implementation might be silently"]
    #[doc = "                 discarded and left unchecked. To check the consistency"]
    #[doc = "                 of the key material, see mbedtls_rsa_check_privkey()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context holding imported parameters."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_RSA_BAD_INPUT_DATA if the attempted derivations"]
    #[doc = "                 failed."]
    #[doc = ""]
    pub fn mbedtls_rsa_complete(ctx: *mut mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports the core parameters of an RSA key."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, the non-NULL buffers"]
    #[doc = "                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully"]
    #[doc = "                 written, with additional unused space filled leading by"]
    #[doc = "                 zero Bytes."]
    #[doc = ""]
    #[doc = "                 Possible reasons for returning"]
    #[doc = "                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>"]
    #[doc = "                 <li>An alternative RSA implementation is in use, which"]
    #[doc = "                 stores the key externally, and either cannot or should"]
    #[doc = "                 not export it into RAM.</li>"]
    #[doc = "                 <li>A SW or HW implementation might not support a certain"]
    #[doc = "                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,"]
    #[doc = "                 and \\p E if the former are not part of the"]
    #[doc = "                 implementation.</li></ul>"]
    #[doc = ""]
    #[doc = "                 If the function fails due to an unsupported operation,"]
    #[doc = "                 the RSA context stays intact and remains usable."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param N        The MPI to hold the RSA modulus."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param P        The MPI to hold the first prime factor of \\p N."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param Q        The MPI to hold the second prime factor of \\p N."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param D        The MPI to hold the private exponent."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param E        The MPI to hold the public exponent."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the"]
    #[doc = "                 requested parameters cannot be done due to missing"]
    #[doc = "                 functionality or because of security policies."]
    #[doc = " \\return         A non-zero return code on any other failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_export(
        ctx: *const mbedtls_rsa_context,
        N: *mut mbedtls_mpi,
        P: *mut mbedtls_mpi,
        Q: *mut mbedtls_mpi,
        D: *mut mbedtls_mpi,
        E: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports core parameters of an RSA key"]
    #[doc = "                 in raw big-endian binary format."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, the non-NULL buffers"]
    #[doc = "                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully"]
    #[doc = "                 written, with additional unused space filled leading by"]
    #[doc = "                 zero Bytes."]
    #[doc = ""]
    #[doc = "                 Possible reasons for returning"]
    #[doc = "                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>"]
    #[doc = "                 <li>An alternative RSA implementation is in use, which"]
    #[doc = "                 stores the key externally, and either cannot or should"]
    #[doc = "                 not export it into RAM.</li>"]
    #[doc = "                 <li>A SW or HW implementation might not support a certain"]
    #[doc = "                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,"]
    #[doc = "                 and \\p E if the former are not part of the"]
    #[doc = "                 implementation.</li></ul>"]
    #[doc = "                 If the function fails due to an unsupported operation,"]
    #[doc = "                 the RSA context stays intact and remains usable."]
    #[doc = ""]
    #[doc = " \\note           The length parameters are ignored if the corresponding"]
    #[doc = "                 buffer pointers are NULL."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param N        The Byte array to store the RSA modulus,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param N_len    The size of the buffer for the modulus."]
    #[doc = " \\param P        The Byte array to hold the first prime factor of \\p N,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param P_len    The size of the buffer for the first prime factor."]
    #[doc = " \\param Q        The Byte array to hold the second prime factor of \\p N,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param Q_len    The size of the buffer for the second prime factor."]
    #[doc = " \\param D        The Byte array to hold the private exponent,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param D_len    The size of the buffer for the private exponent."]
    #[doc = " \\param E        The Byte array to hold the public exponent,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param E_len    The size of the buffer for the public exponent."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the"]
    #[doc = "                 requested parameters cannot be done due to missing"]
    #[doc = "                 functionality or because of security policies."]
    #[doc = " \\return         A non-zero return code on any other failure."]
    pub fn mbedtls_rsa_export_raw(
        ctx: *const mbedtls_rsa_context,
        N: *mut crate::c_types::c_uchar,
        N_len: size_t,
        P: *mut crate::c_types::c_uchar,
        P_len: size_t,
        Q: *mut crate::c_types::c_uchar,
        Q_len: size_t,
        D: *mut crate::c_types::c_uchar,
        D_len: size_t,
        E: *mut crate::c_types::c_uchar,
        E_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports CRT parameters of a private RSA key."]
    #[doc = ""]
    #[doc = " \\note           Alternative RSA implementations not using CRT-parameters"]
    #[doc = "                 internally can implement this function based on"]
    #[doc = "                 mbedtls_rsa_deduce_opt()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param DP       The MPI to hold \\c D modulo `P-1`,"]
    #[doc = "                 or \\c NULL if it need not be exported."]
    #[doc = " \\param DQ       The MPI to hold \\c D modulo `Q-1`,"]
    #[doc = "                 or \\c NULL if it need not be exported."]
    #[doc = " \\param QP       The MPI to hold modular inverse of \\c Q modulo \\c P,"]
    #[doc = "                 or \\c NULL if it need not be exported."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_export_crt(
        ctx: *const mbedtls_rsa_context,
        DP: *mut mbedtls_mpi,
        DQ: *mut mbedtls_mpi,
        QP: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function retrieves the length of RSA modulus in Bytes."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = ""]
    #[doc = " \\return         The length of the RSA modulus in Bytes."]
    #[doc = ""]
    pub fn mbedtls_rsa_get_len(ctx: *const mbedtls_rsa_context) -> size_t;
}
extern "C" {
    #[doc = " \\brief          This function generates an RSA keypair."]
    #[doc = ""]
    #[doc = " \\note           mbedtls_rsa_init() must be called before this function,"]
    #[doc = "                 to set up the RSA context."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context used to hold the key."]
    #[doc = " \\param f_rng    The RNG function to be used for key generation."]
    #[doc = "                 This is mandatory and must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng."]
    #[doc = "                 This may be \\c NULL if \\p f_rng doesn't need a context."]
    #[doc = " \\param nbits    The size of the public key in bits."]
    #[doc = " \\param exponent The public exponent to use. For example, \\c 65537."]
    #[doc = "                 This must be odd and greater than \\c 1."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_gen_key(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        nbits: crate::c_types::c_uint,
        exponent: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks if a context contains at least an RSA"]
    #[doc = "                 public key."]
    #[doc = ""]
    #[doc = "                 If the function runs successfully, it is guaranteed that"]
    #[doc = "                 enough information is present to perform an RSA public key"]
    #[doc = "                 operation using mbedtls_rsa_public()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to check."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_check_pubkey(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function checks if a context contains an RSA private key"]
    #[doc = "             and perform basic consistency checks."]
    #[doc = ""]
    #[doc = " \\note       The consistency checks performed by this function not only"]
    #[doc = "             ensure that mbedtls_rsa_private() can be called successfully"]
    #[doc = "             on the given context, but that the various parameters are"]
    #[doc = "             mutually consistent with high probability, in the sense that"]
    #[doc = "             mbedtls_rsa_public() and mbedtls_rsa_private() are inverses."]
    #[doc = ""]
    #[doc = " \\warning    This function should catch accidental misconfigurations"]
    #[doc = "             like swapping of parameters, but it cannot establish full"]
    #[doc = "             trust in neither the quality nor the consistency of the key"]
    #[doc = "             material that was used to setup the given RSA context:"]
    #[doc = "             <ul><li>Consistency: Imported parameters that are irrelevant"]
    #[doc = "             for the implementation might be silently dropped. If dropped,"]
    #[doc = "             the current function does not have access to them,"]
    #[doc = "             and therefore cannot check them. See mbedtls_rsa_complete()."]
    #[doc = "             If you want to check the consistency of the entire"]
    #[doc = "             content of a PKCS1-encoded RSA private key, for example, you"]
    #[doc = "             should use mbedtls_rsa_validate_params() before setting"]
    #[doc = "             up the RSA context."]
    #[doc = "             Additionally, if the implementation performs empirical checks,"]
    #[doc = "             these checks substantiate but do not guarantee consistency.</li>"]
    #[doc = "             <li>Quality: This function is not expected to perform"]
    #[doc = "             extended quality assessments like checking that the prime"]
    #[doc = "             factors are safe. Additionally, it is the responsibility of the"]
    #[doc = "             user to ensure the trustworthiness of the source of his RSA"]
    #[doc = "             parameters, which goes beyond what is effectively checkable"]
    #[doc = "             by the library.</li></ul>"]
    #[doc = ""]
    #[doc = " \\param ctx  The initialized RSA context to check."]
    #[doc = ""]
    #[doc = " \\return     \\c 0 on success."]
    #[doc = " \\return     An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_privkey(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks a public-private RSA key pair."]
    #[doc = ""]
    #[doc = "                 It checks each of the contexts, and makes sure they match."]
    #[doc = ""]
    #[doc = " \\param pub      The initialized RSA context holding the public key."]
    #[doc = " \\param prv      The initialized RSA context holding the private key."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_pub_priv(
        pub_: *const mbedtls_rsa_context,
        prv: *const mbedtls_rsa_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA public key operation."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param input    The input buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\note           This function does not handle message padding."]
    #[doc = ""]
    #[doc = " \\note           Make sure to set \\p input[0] = 0 or ensure that"]
    #[doc = "                 input is smaller than \\p N."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_public(
        ctx: *mut mbedtls_rsa_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA private key operation."]
    #[doc = ""]
    #[doc = " \\note           Blinding is used if and only if a PRNG is provided."]
    #[doc = ""]
    #[doc = " \\note           If blinding is used, both the base of exponentiation"]
    #[doc = "                 and the exponent are blinded, providing protection"]
    #[doc = "                 against some side-channel attacks."]
    #[doc = ""]
    #[doc = " \\warning        It is deprecated and a security risk to not provide"]
    #[doc = "                 a PRNG here and thereby prevent the use of blinding."]
    #[doc = "                 Future versions of the library may enforce the presence"]
    #[doc = "                 of a PRNG."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function, used for blinding. It is mandatory."]
    #[doc = " \\param p_rng    The RNG context to pass to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context."]
    #[doc = " \\param input    The input buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_private(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function adds the message padding, then performs an RSA"]
    #[doc = "                 operation."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1 encryption"]
    #[doc = "                 operation."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG to use. It is used for padding generation"]
    #[doc = "                 and it is mandatory."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. May be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param ilen     The length of the plaintext in Bytes."]
    #[doc = " \\param input    The input data to encrypt. This must be a readable"]
    #[doc = "                 buffer of size \\p ilen Bytes. It may be \\c NULL if"]
    #[doc = "                 `ilen == 0`."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        ilen: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 encryption operation"]
    #[doc = "                 (RSAES-PKCS1-v1_5-ENCRYPT)."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function to use. It is mandatory and used for"]
    #[doc = "                 padding generation."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                 be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param ilen     The length of the plaintext in Bytes."]
    #[doc = " \\param input    The input data to encrypt. This must be a readable"]
    #[doc = "                 buffer of size \\p ilen Bytes. It may be \\c NULL if"]
    #[doc = "                 `ilen == 0`."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        ilen: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP encryption"]
    #[doc = "                   operation (RSAES-OAEP-ENCRYPT)."]
    #[doc = ""]
    #[doc = " \\note             The output buffer must be as large as the size"]
    #[doc = "                   of ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\param ctx        The initialized RSA context to use."]
    #[doc = " \\param f_rng      The RNG function to use. This is needed for padding"]
    #[doc = "                   generation and is mandatory."]
    #[doc = " \\param p_rng      The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                   be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param label      The buffer holding the custom label to use."]
    #[doc = "                   This must be a readable buffer of length \\p label_len"]
    #[doc = "                   Bytes. It may be \\c NULL if \\p label_len is \\c 0."]
    #[doc = " \\param label_len  The length of the label in Bytes."]
    #[doc = " \\param ilen       The length of the plaintext buffer \\p input in Bytes."]
    #[doc = " \\param input      The input data to encrypt. This must be a readable"]
    #[doc = "                   buffer of size \\p ilen Bytes. It may be \\c NULL if"]
    #[doc = "                   `ilen == 0`."]
    #[doc = " \\param output     The output buffer. This must be a writable buffer"]
    #[doc = "                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                   for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return           \\c 0 on success."]
    #[doc = " \\return           An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        label: *const crate::c_types::c_uchar,
        label_len: size_t,
        ilen: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA operation, then removes the"]
    #[doc = "                 message padding."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1 decryption"]
    #[doc = "                 operation."]
    #[doc = ""]
    #[doc = " \\note           The output buffer length \\c output_max_len should be"]
    #[doc = "                 as large as the size \\p ctx->len of \\p ctx->N (for example,"]
    #[doc = "                 128 Bytes if RSA-1024 is used) to be able to hold an"]
    #[doc = "                 arbitrary decrypted message. If it is not large enough to"]
    #[doc = "                 hold the decryption of the particular ciphertext provided,"]
    #[doc = "                 the function returns \\c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. This is used for blinding and is"]
    #[doc = "                 mandatory; see mbedtls_rsa_private() for more."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context."]
    #[doc = " \\param olen     The address at which to store the length of"]
    #[doc = "                 the plaintext. This must not be \\c NULL."]
    #[doc = " \\param input    The ciphertext buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The buffer used to hold the plaintext. This must"]
    #[doc = "                 be a writable buffer of length \\p output_max_len Bytes."]
    #[doc = " \\param output_max_len The length in Bytes of the output buffer \\p output."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        olen: *mut size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 decryption"]
    #[doc = "                 operation (RSAES-PKCS1-v1_5-DECRYPT)."]
    #[doc = ""]
    #[doc = " \\note           The output buffer length \\c output_max_len should be"]
    #[doc = "                 as large as the size \\p ctx->len of \\p ctx->N, for example,"]
    #[doc = "                 128 Bytes if RSA-1024 is used, to be able to hold an"]
    #[doc = "                 arbitrary decrypted message. If it is not large enough to"]
    #[doc = "                 hold the decryption of the particular ciphertext provided,"]
    #[doc = "                 the function returns #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. This is used for blinding and is"]
    #[doc = "                 mandatory; see mbedtls_rsa_private() for more."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context."]
    #[doc = " \\param olen     The address at which to store the length of"]
    #[doc = "                 the plaintext. This must not be \\c NULL."]
    #[doc = " \\param input    The ciphertext buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The buffer used to hold the plaintext. This must"]
    #[doc = "                 be a writable buffer of length \\p output_max_len Bytes."]
    #[doc = " \\param output_max_len The length in Bytes of the output buffer \\p output."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        olen: *mut size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP decryption"]
    #[doc = "                   operation (RSAES-OAEP-DECRYPT)."]
    #[doc = ""]
    #[doc = " \\note             The output buffer length \\c output_max_len should be"]
    #[doc = "                   as large as the size \\p ctx->len of \\p ctx->N, for"]
    #[doc = "                   example, 128 Bytes if RSA-1024 is used, to be able to"]
    #[doc = "                   hold an arbitrary decrypted message. If it is not"]
    #[doc = "                   large enough to hold the decryption of the particular"]
    #[doc = "                   ciphertext provided, the function returns"]
    #[doc = "                   #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\param ctx        The initialized RSA context to use."]
    #[doc = " \\param f_rng      The RNG function. This is used for blinding and is"]
    #[doc = "                   mandatory."]
    #[doc = " \\param p_rng      The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                   \\c NULL if \\p f_rng doesn't need a context."]
    #[doc = " \\param label      The buffer holding the custom label to use."]
    #[doc = "                   This must be a readable buffer of length \\p label_len"]
    #[doc = "                   Bytes. It may be \\c NULL if \\p label_len is \\c 0."]
    #[doc = " \\param label_len  The length of the label in Bytes."]
    #[doc = " \\param olen       The address at which to store the length of"]
    #[doc = "                   the plaintext. This must not be \\c NULL."]
    #[doc = " \\param input      The ciphertext buffer. This must be a readable buffer"]
    #[doc = "                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                   for an 2048-bit RSA modulus."]
    #[doc = " \\param output     The buffer used to hold the plaintext. This must"]
    #[doc = "                   be a writable buffer of length \\p output_max_len Bytes."]
    #[doc = " \\param output_max_len The length in Bytes of the output buffer \\p output."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        label: *const crate::c_types::c_uchar,
        label_len: size_t,
        olen: *mut size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a private RSA operation to sign"]
    #[doc = "                 a message digest using PKCS#1."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1"]
    #[doc = "                 signature."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           For PKCS#1 v2.1 encoding, see comments on"]
    #[doc = "                 mbedtls_rsa_rsassa_pss_sign() for details on"]
    #[doc = "                 \\p md_alg and \\p hash_id."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function to use. This is mandatory and"]
    #[doc = "                 must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param sig      The buffer to hold the signature. This must be a writable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus. A buffer length of"]
    #[doc = "                 #MBEDTLS_MPI_MAX_SIZE is always safe."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 signature"]
    #[doc = "                 operation (RSASSA-PKCS1-v1_5-SIGN)."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. This is used for blinding and is"]
    #[doc = "                 mandatory; see mbedtls_rsa_private() for more."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param sig      The buffer to hold the signature. This must be a writable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus. A buffer length of"]
    #[doc = "                 #MBEDTLS_MPI_MAX_SIZE is always safe."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature"]
    #[doc = "                 operation (RSASSA-PSS-SIGN)."]
    #[doc = ""]
    #[doc = " \\note           The \\c hash_id set in \\p ctx by calling"]
    #[doc = "                 mbedtls_rsa_set_padding() selects the hash used for the"]
    #[doc = "                 encoding operation and for the mask generation function"]
    #[doc = "                 (MGF1). For more details on the encoding operation and the"]
    #[doc = "                 mask generation function, consult <em>RFC-3447: Public-Key"]
    #[doc = "                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                 Specifications</em>."]
    #[doc = ""]
    #[doc = " \\note           This function enforces that the provided salt length complies"]
    #[doc = "                 with FIPS 186-4 5.5 (e) and RFC 8017 (PKCS#1 v2.2) 9.1.1"]
    #[doc = "                 step 3. The constraint is that the hash length plus the salt"]
    #[doc = "                 length plus 2 bytes must be at most the key length. If this"]
    #[doc = "                 constraint is not met, this function returns"]
    #[doc = "                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. It is mandatory and must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param saltlen  The length of the salt that should be used."]
    #[doc = "                 If passed #MBEDTLS_RSA_SALT_LEN_ANY, the function will use"]
    #[doc = "                 the largest possible salt length up to the hash length,"]
    #[doc = "                 which is the largest permitted by some standards including"]
    #[doc = "                 FIPS 186-4 5.5."]
    #[doc = " \\param sig      The buffer to hold the signature. This must be a writable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus. A buffer length of"]
    #[doc = "                 #MBEDTLS_MPI_MAX_SIZE is always safe."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_sign_ext(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        saltlen: crate::c_types::c_int,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature"]
    #[doc = "                 operation (RSASSA-PSS-SIGN)."]
    #[doc = ""]
    #[doc = " \\note           The \\c hash_id set in \\p ctx by calling"]
    #[doc = "                 mbedtls_rsa_set_padding() selects the hash used for the"]
    #[doc = "                 encoding operation and for the mask generation function"]
    #[doc = "                 (MGF1). For more details on the encoding operation and the"]
    #[doc = "                 mask generation function, consult <em>RFC-3447: Public-Key"]
    #[doc = "                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                 Specifications</em>."]
    #[doc = ""]
    #[doc = " \\note           This function always uses the maximum possible salt size,"]
    #[doc = "                 up to the length of the payload hash. This choice of salt"]
    #[doc = "                 size complies with FIPS 186-4 5.5 (e) and RFC 8017 (PKCS#1"]
    #[doc = "                 v2.2) 9.1.1 step 3. Furthermore this function enforces a"]
    #[doc = "                 minimum salt size which is the hash size minus 2 bytes. If"]
    #[doc = "                 this minimum size is too large given the key size (the salt"]
    #[doc = "                 size, plus the hash size, plus 2 bytes must be no more than"]
    #[doc = "                 the key size in bytes), this function returns"]
    #[doc = "                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. It is mandatory and must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param sig      The buffer to hold the signature. This must be a writable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus. A buffer length of"]
    #[doc = "                 #MBEDTLS_MPI_MAX_SIZE is always safe."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a public RSA operation and checks"]
    #[doc = "                 the message digest."]
    #[doc = ""]
    #[doc = "                 This is the generic wrapper for performing a PKCS#1"]
    #[doc = "                 verification."]
    #[doc = ""]
    #[doc = " \\note           For PKCS#1 v2.1 encoding, see comments on"]
    #[doc = "                 mbedtls_rsa_rsassa_pss_verify() about \\p md_alg and"]
    #[doc = "                 \\p hash_id."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 verification"]
    #[doc = "                 operation (RSASSA-PKCS1-v1_5-VERIFY)."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification"]
    #[doc = "                 operation (RSASSA-PSS-VERIFY)."]
    #[doc = ""]
    #[doc = " \\note           The \\c hash_id set in \\p ctx by calling"]
    #[doc = "                 mbedtls_rsa_set_padding() selects the hash used for the"]
    #[doc = "                 encoding operation and for the mask generation function"]
    #[doc = "                 (MGF1). For more details on the encoding operation and the"]
    #[doc = "                 mask generation function, consult <em>RFC-3447: Public-Key"]
    #[doc = "                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                 Specifications</em>. If the \\c hash_id set in \\p ctx by"]
    #[doc = "                 mbedtls_rsa_set_padding() is #MBEDTLS_MD_NONE, the \\p md_alg"]
    #[doc = "                 parameter is used."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification"]
    #[doc = "                 operation (RSASSA-PSS-VERIFY)."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           The \\c hash_id set in \\p ctx by mbedtls_rsa_set_padding() is"]
    #[doc = "                 ignored."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest or raw data in Bytes."]
    #[doc = "                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the"]
    #[doc = "                 output length of the corresponding hash algorithm."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 This must be a readable buffer of at least \\p hashlen Bytes."]
    #[doc = " \\param mgf1_hash_id      The message digest algorithm used for the"]
    #[doc = "                          verification operation and the mask generation"]
    #[doc = "                          function (MGF1). For more details on the encoding"]
    #[doc = "                          operation and the mask generation function, consult"]
    #[doc = "                          <em>RFC-3447: Public-Key Cryptography Standards"]
    #[doc = "                          (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                          Specifications</em>."]
    #[doc = " \\param expected_salt_len The length of the salt used in padding. Use"]
    #[doc = "                          #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify_ext(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        mgf1_hash_id: mbedtls_md_type_t,
        expected_salt_len: crate::c_types::c_int,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function copies the components of an RSA context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context. This must be initialized."]
    #[doc = " \\param src      The source context. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory allocation failure."]
    pub fn mbedtls_rsa_copy(
        dst: *mut mbedtls_rsa_context,
        src: *const mbedtls_rsa_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an RSA key."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context to free. May be \\c NULL, in which case"]
    #[doc = "                 this function is a no-op. If it is not \\c NULL, it must"]
    #[doc = "                 point to an initialized RSA context."]
    pub fn mbedtls_rsa_free(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    #[doc = " \\brief          The RSA checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_rsa_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief    The ECP key-pair structure."]
#[doc = ""]
#[doc = " A generic key-pair that may be used for ECDSA and fixed ECDH, for example."]
#[doc = ""]
#[doc = " \\note    Members are deliberately in the same order as in the"]
#[doc = "          ::mbedtls_ecdsa_context structure."]
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
pub type mbedtls_ecdsa_restart_ctx = crate::c_types::c_void;
extern "C" {
    #[doc = " \\brief          This function checks whether a given group can be used"]
    #[doc = "                 for ECDSA."]
    #[doc = ""]
    #[doc = " \\param gid      The ECP group ID to check."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    pub fn mbedtls_ecdsa_can_do(gid: mbedtls_ecp_group_id) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a"]
    #[doc = "                  previously-hashed message."]
    #[doc = ""]
    #[doc = " \\note            The deterministic version implemented in"]
    #[doc = "                  mbedtls_ecdsa_sign_det_ext() is usually preferred."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated"]
    #[doc = "                  as defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The context for the elliptic curve to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param r         The MPI context in which to store the first part"]
    #[doc = "                  the signature. This must be initialized."]
    #[doc = " \\param s         The MPI context in which to store the second part"]
    #[doc = "                  the signature. This must be initialized."]
    #[doc = " \\param d         The private signing key. This must be initialized."]
    #[doc = " \\param buf       The content to be signed. This is usually the hash of"]
    #[doc = "                  the original data to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                  \\p blen is zero."]
    #[doc = " \\param blen      The length of \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX"]
    #[doc = "                  or \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdsa_sign(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a"]
    #[doc = "                  previously-hashed message, deterministic version."]
    #[doc = ""]
    #[doc = "                  For more information, see <em>RFC-6979: Deterministic"]
    #[doc = "                  Usage of the Digital Signature Algorithm (DSA) and Elliptic"]
    #[doc = "                  Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp           The context for the elliptic curve to use."]
    #[doc = "                      This must be initialized and have group parameters"]
    #[doc = "                      set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param r             The MPI context in which to store the first part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param s             The MPI context in which to store the second part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param d             The private signing key. This must be initialized"]
    #[doc = "                      and setup, for example through mbedtls_ecp_gen_privkey()."]
    #[doc = " \\param buf           The hashed content to be signed. This must be a readable"]
    #[doc = "                      buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                      \\p blen is zero."]
    #[doc = " \\param blen          The length of \\p buf in Bytes."]
    #[doc = " \\param md_alg        The hash algorithm used to hash the original data."]
    #[doc = " \\param f_rng_blind   The RNG function used for blinding. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = " \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                      \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure."]
    pub fn mbedtls_ecdsa_sign_det_ext(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: size_t,
        md_alg: mbedtls_md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function computes the ECDSA signature of a"]
    #[doc = "                      previously-hashed message, in a restartable way."]
    #[doc = ""]
    #[doc = " \\note                The deterministic version implemented in"]
    #[doc = "                      mbedtls_ecdsa_sign_det_restartable() is usually"]
    #[doc = "                      preferred."]
    #[doc = ""]
    #[doc = " \\note                This function is like \\c mbedtls_ecdsa_sign() but"]
    #[doc = "                      it can return early and restart according to the"]
    #[doc = "                      limit set with \\c mbedtls_ecp_set_max_ops() to"]
    #[doc = "                      reduce blocking."]
    #[doc = ""]
    #[doc = " \\note                If the bitlength of the message hash is larger"]
    #[doc = "                      than the bitlength of the group order, then the"]
    #[doc = "                      hash is truncated as defined in <em>Standards for"]
    #[doc = "                      Efficient Cryptography Group (SECG): SEC1 Elliptic"]
    #[doc = "                      Curve Cryptography</em>, section 4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see                 ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp           The context for the elliptic curve to use."]
    #[doc = "                      This must be initialized and have group parameters"]
    #[doc = "                      set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param r             The MPI context in which to store the first part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param s             The MPI context in which to store the second part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param d             The private signing key. This must be initialized"]
    #[doc = "                      and setup, for example through"]
    #[doc = "                      mbedtls_ecp_gen_privkey()."]
    #[doc = " \\param buf           The hashed content to be signed. This must be a readable"]
    #[doc = "                      buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                      \\p blen is zero."]
    #[doc = " \\param blen          The length of \\p buf in Bytes."]
    #[doc = " \\param f_rng         The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng         The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                      \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = " \\param f_rng_blind   The RNG function used for blinding. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = " \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                      \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = " \\param rs_ctx        The restart context to use. This may be \\c NULL"]
    #[doc = "                      to disable restarting. If it is not \\c NULL, it"]
    #[doc = "                      must point to an initialized restart context."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                      operations was reached: see \\c"]
    #[doc = "                      mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return              Another \\c MBEDTLS_ERR_ECP_XXX, \\c"]
    #[doc = "                      MBEDTLS_ERR_MPI_XXX or \\c MBEDTLS_ERR_ASN1_XXX"]
    #[doc = "                      error code on failure."]
    pub fn mbedtls_ecdsa_sign_restartable(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function computes the ECDSA signature of a"]
    #[doc = "                      previously-hashed message, in a restartable way."]
    #[doc = ""]
    #[doc = " \\note                This function is like \\c"]
    #[doc = "                      mbedtls_ecdsa_sign_det_ext() but it can return"]
    #[doc = "                      early and restart according to the limit set with"]
    #[doc = "                      \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\note                If the bitlength of the message hash is larger"]
    #[doc = "                      than the bitlength of the group order, then the"]
    #[doc = "                      hash is truncated as defined in <em>Standards for"]
    #[doc = "                      Efficient Cryptography Group (SECG): SEC1 Elliptic"]
    #[doc = "                      Curve Cryptography</em>, section 4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see                 ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp           The context for the elliptic curve to use."]
    #[doc = "                      This must be initialized and have group parameters"]
    #[doc = "                      set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param r             The MPI context in which to store the first part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param s             The MPI context in which to store the second part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param d             The private signing key. This must be initialized"]
    #[doc = "                      and setup, for example through"]
    #[doc = "                      mbedtls_ecp_gen_privkey()."]
    #[doc = " \\param buf           The hashed content to be signed. This must be a readable"]
    #[doc = "                      buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                      \\p blen is zero."]
    #[doc = " \\param blen          The length of \\p buf in Bytes."]
    #[doc = " \\param f_rng_blind   The RNG function used for blinding. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = " \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                      \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = " \\param rs_ctx        The restart context to use. This may be \\c NULL"]
    #[doc = "                      to disable restarting. If it is not \\c NULL, it"]
    #[doc = "                      must point to an initialized restart context."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                      operations was reached: see \\c"]
    #[doc = "                      mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return              Another \\c MBEDTLS_ERR_ECP_XXX, \\c"]
    #[doc = "                      MBEDTLS_ERR_MPI_XXX or \\c MBEDTLS_ERR_ASN1_XXX"]
    #[doc = "                      error code on failure."]
    pub fn mbedtls_ecdsa_sign_det_restartable(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: size_t,
        md_alg: mbedtls_md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function verifies the ECDSA signature of a"]
    #[doc = "                  previously-hashed message."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.4, step 3."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param buf       The hashed content that was signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                  \\p blen is zero."]
    #[doc = " \\param blen      The length of \\p buf in Bytes."]
    #[doc = " \\param Q         The public key to use for verification. This must be"]
    #[doc = "                  initialized and setup."]
    #[doc = " \\param r         The first integer of the signature."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param s         The second integer of the signature."]
    #[doc = "                  This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure."]
    pub fn mbedtls_ecdsa_verify(
        grp: *mut mbedtls_ecp_group,
        buf: *const crate::c_types::c_uchar,
        blen: size_t,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function verifies the ECDSA signature of a"]
    #[doc = "                  previously-hashed message, in a restartable manner"]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.4, step 3."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param buf       The hashed content that was signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                  \\p blen is zero."]
    #[doc = " \\param blen      The length of \\p buf in Bytes."]
    #[doc = " \\param Q         The public key to use for verification. This must be"]
    #[doc = "                  initialized and setup."]
    #[doc = " \\param r         The first integer of the signature."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param s         The second integer of the signature."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param rs_ctx    The restart context to use. This may be \\c NULL to disable"]
    #[doc = "                  restarting. If it is not \\c NULL, it must point to an"]
    #[doc = "                  initialized restart context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure."]
    pub fn mbedtls_ecdsa_verify_restartable(
        grp: *mut mbedtls_ecp_group,
        buf: *const crate::c_types::c_uchar,
        blen: size_t,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it"]
    #[doc = "                  to a buffer, serialized as defined in <em>RFC-4492:"]
    #[doc = "                  Elliptic Curve Cryptography (ECC) Cipher Suites for"]
    #[doc = "                  Transport Layer Security (TLS)</em>."]
    #[doc = ""]
    #[doc = " \\warning         It is not thread-safe to use the same context in"]
    #[doc = "                  multiple threads."]
    #[doc = ""]
    #[doc = " \\note            The deterministic version is used if"]
    #[doc = "                  #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more"]
    #[doc = "                  information, see <em>RFC-6979: Deterministic Usage"]
    #[doc = "                  of the Digital Signature Algorithm (DSA) and Elliptic"]
    #[doc = "                  Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and private key bound to it, for example"]
    #[doc = "                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair()."]
    #[doc = " \\param md_alg    The message digest that was used to hash the message."]
    #[doc = " \\param hash      The message hash to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes."]
    #[doc = " \\param hlen      The length of the hash \\p hash in Bytes."]
    #[doc = " \\param sig       The buffer to which to write the signature. This must be a"]
    #[doc = "                  writable buffer of length at least twice as large as the"]
    #[doc = "                  size of the curve used, plus 9. For example, 73 Bytes if"]
    #[doc = "                  a 256-bit curve is used. A buffer length of"]
    #[doc = "                  #MBEDTLS_ECDSA_MAX_LEN is always safe."]
    #[doc = " \\param sig_size  The size of the \\p sig buffer in bytes."]
    #[doc = " \\param slen      The address at which to store the actual length of"]
    #[doc = "                  the signature written. Must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL if"]
    #[doc = "                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,"]
    #[doc = "                  it is used only for blinding and may be set to \\c NULL, but"]
    #[doc = "                  doing so is DEPRECATED."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or"]
    #[doc = "                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hlen: size_t,
        sig: *mut crate::c_types::c_uchar,
        sig_size: size_t,
        slen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it"]
    #[doc = "                  to a buffer, in a restartable way."]
    #[doc = ""]
    #[doc = " \\see             \\c mbedtls_ecdsa_write_signature()"]
    #[doc = ""]
    #[doc = " \\note            This function is like \\c mbedtls_ecdsa_write_signature()"]
    #[doc = "                  but it can return early and restart according to the limit"]
    #[doc = "                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and private key bound to it, for example"]
    #[doc = "                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair()."]
    #[doc = " \\param md_alg    The message digest that was used to hash the message."]
    #[doc = " \\param hash      The message hash to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes."]
    #[doc = " \\param hlen      The length of the hash \\p hash in Bytes."]
    #[doc = " \\param sig       The buffer to which to write the signature. This must be a"]
    #[doc = "                  writable buffer of length at least twice as large as the"]
    #[doc = "                  size of the curve used, plus 9. For example, 73 Bytes if"]
    #[doc = "                  a 256-bit curve is used. A buffer length of"]
    #[doc = "                  #MBEDTLS_ECDSA_MAX_LEN is always safe."]
    #[doc = " \\param sig_size  The size of the \\p sig buffer in bytes."]
    #[doc = " \\param slen      The address at which to store the actual length of"]
    #[doc = "                  the signature written. Must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL if"]
    #[doc = "                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,"]
    #[doc = "                  it is unused and may be set to \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context."]
    #[doc = " \\param rs_ctx    The restart context to use. This may be \\c NULL to disable"]
    #[doc = "                  restarting. If it is not \\c NULL, it must point to an"]
    #[doc = "                  initialized restart context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or"]
    #[doc = "                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hlen: size_t,
        sig: *mut crate::c_types::c_uchar,
        sig_size: size_t,
        slen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.4, step 3."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and public key bound to it."]
    #[doc = " \\param hash      The message hash that was signed. This must be a readable"]
    #[doc = "                  buffer of length \\p size Bytes."]
    #[doc = " \\param hlen      The size of the hash \\p hash."]
    #[doc = " \\param sig       The signature to read and verify. This must be a readable"]
    #[doc = "                  buffer of length \\p slen Bytes."]
    #[doc = " \\param slen      The size of \\p sig in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in \\p sig, but its length is less than \\p siglen."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_read_signature(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const crate::c_types::c_uchar,
        hlen: size_t,
        sig: *const crate::c_types::c_uchar,
        slen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature,"]
    #[doc = "                  in a restartable way."]
    #[doc = ""]
    #[doc = " \\see             \\c mbedtls_ecdsa_read_signature()"]
    #[doc = ""]
    #[doc = " \\note            This function is like \\c mbedtls_ecdsa_read_signature()"]
    #[doc = "                  but it can return early and restart according to the limit"]
    #[doc = "                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and public key bound to it."]
    #[doc = " \\param hash      The message hash that was signed. This must be a readable"]
    #[doc = "                  buffer of length \\p size Bytes."]
    #[doc = " \\param hlen      The size of the hash \\p hash."]
    #[doc = " \\param sig       The signature to read and verify. This must be a readable"]
    #[doc = "                  buffer of length \\p slen Bytes."]
    #[doc = " \\param slen      The size of \\p sig in Bytes."]
    #[doc = " \\param rs_ctx    The restart context to use. This may be \\c NULL to disable"]
    #[doc = "                  restarting. If it is not \\c NULL, it must point to an"]
    #[doc = "                  initialized restart context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in \\p sig, but its length is less than \\p siglen."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_read_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const crate::c_types::c_uchar,
        hlen: size_t,
        sig: *const crate::c_types::c_uchar,
        slen: size_t,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates an ECDSA keypair on the given curve."]
    #[doc = ""]
    #[doc = " \\see            ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx      The ECDSA context to store the keypair in."]
    #[doc = "                 This must be initialized."]
    #[doc = " \\param gid      The elliptic curve to use. One of the various"]
    #[doc = "                 \\c MBEDTLS_ECP_DP_XXX macros depending on configuration."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_genkey(
        ctx: *mut mbedtls_ecdsa_context,
        gid: mbedtls_ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDSA context from an EC key pair."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to setup. This must be initialized."]
    #[doc = " \\param key       The EC key to use. This must be initialized and hold"]
    #[doc = "                  a private-public key pair or a public key. In the former"]
    #[doc = "                  case, the ECDSA context may be used for signature creation"]
    #[doc = "                  and verification after this call. In the latter case, it"]
    #[doc = "                  may be used for signature verification."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_from_keypair(
        ctx: *mut mbedtls_ecdsa_context,
        key: *const mbedtls_ecp_keypair,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDSA context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    pub fn mbedtls_ecdsa_init(ctx: *mut mbedtls_ecdsa_context);
}
extern "C" {
    #[doc = " \\brief           This function frees an ECDSA context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to free. This may be \\c NULL,"]
    #[doc = "                  in which case this function does nothing. If it"]
    #[doc = "                  is not \\c NULL, it must be initialized."]
    pub fn mbedtls_ecdsa_free(ctx: *mut mbedtls_ecdsa_context);
}
pub const mbedtls_pk_type_t_MBEDTLS_PK_NONE: mbedtls_pk_type_t = 0;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA: mbedtls_pk_type_t = 1;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY: mbedtls_pk_type_t = 2;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY_DH: mbedtls_pk_type_t = 3;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECDSA: mbedtls_pk_type_t = 4;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA_ALT: mbedtls_pk_type_t = 5;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSASSA_PSS: mbedtls_pk_type_t = 6;
pub const mbedtls_pk_type_t_MBEDTLS_PK_OPAQUE: mbedtls_pk_type_t = 7;
#[doc = " \\brief          Public key types"]
pub type mbedtls_pk_type_t = crate::c_types::c_uint;
#[doc = " \\brief           Options for RSASSA-PSS signature verification."]
#[doc = "                  See \\c mbedtls_rsa_rsassa_pss_verify_ext()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_rsassa_pss_options {
    #[doc = " The digest to use for MGF1 in PSS."]
    #[doc = ""]
    #[doc = " \\note When #MBEDTLS_USE_PSA_CRYPTO is enabled and #MBEDTLS_RSA_C is"]
    #[doc = "       disabled, this must be equal to the \\c md_alg argument passed"]
    #[doc = "       to mbedtls_pk_verify_ext(). In a future version of the library,"]
    #[doc = "       this constraint may apply whenever #MBEDTLS_USE_PSA_CRYPTO is"]
    #[doc = "       enabled regardless of the status of #MBEDTLS_RSA_C."]
    pub mgf1_hash_id: mbedtls_md_type_t,
    #[doc = " The expected length of the salt, in bytes. This may be"]
    #[doc = " #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length."]
    #[doc = ""]
    #[doc = " \\note When #MBEDTLS_USE_PSA_CRYPTO is enabled, only"]
    #[doc = "       #MBEDTLS_RSA_SALT_LEN_ANY is valid. Any other value may be"]
    #[doc = "       ignored (allowing any salt length)."]
    pub expected_salt_len: crate::c_types::c_int,
}
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_NONE: mbedtls_pk_debug_type = 0;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_MPI: mbedtls_pk_debug_type = 1;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_ECP: mbedtls_pk_debug_type = 2;
#[doc = " \\brief           Types for interfacing with the debug module"]
pub type mbedtls_pk_debug_type = crate::c_types::c_uint;
#[doc = " \\brief           Item to send to the debug module"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_debug_item {
    pub private_type: mbedtls_pk_debug_type,
    pub private_name: *const crate::c_types::c_char,
    pub private_value: *mut crate::c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_info_t {
    _unused: [u8; 0],
}
#[doc = " \\brief           Public key container"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_context {
    pub private_pk_info: *const mbedtls_pk_info_t,
    pub private_pk_ctx: *mut crate::c_types::c_void,
}
pub type mbedtls_pk_restart_ctx = crate::c_types::c_void;
#[doc = " \\brief           Types for RSA-alt abstraction"]
pub type mbedtls_pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        olen: *mut size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: size_t,
    ) -> crate::c_types::c_int,
>;
pub type mbedtls_pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
pub type mbedtls_pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void) -> size_t>;
extern "C" {
    #[doc = " \\brief           Return information associated with the given PK type"]
    #[doc = ""]
    #[doc = " \\param pk_type   PK type to search for."]
    #[doc = ""]
    #[doc = " \\return          The PK info associated with the type or NULL if not found."]
    pub fn mbedtls_pk_info_from_type(pk_type: mbedtls_pk_type_t) -> *const mbedtls_pk_info_t;
}
extern "C" {
    #[doc = " \\brief           Initialize a #mbedtls_pk_context (as NONE)."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    pub fn mbedtls_pk_init(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Free the components of a #mbedtls_pk_context."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to clear. It must have been initialized."]
    #[doc = "                  If this is \\c NULL, this function does nothing."]
    #[doc = ""]
    #[doc = " \\note            For contexts that have been set up with"]
    #[doc = "                  mbedtls_pk_setup_opaque(), this does not free the underlying"]
    #[doc = "                  PSA key and you still need to call psa_destroy_key()"]
    #[doc = "                  independently if you want to destroy that key."]
    pub fn mbedtls_pk_free(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Initialize a PK context with the information given"]
    #[doc = "                  and allocates the type-specific PK subcontext."]
    #[doc = ""]
    #[doc = " \\param ctx       Context to initialize. It must not have been set"]
    #[doc = "                  up yet (type #MBEDTLS_PK_NONE)."]
    #[doc = " \\param info      Information to use"]
    #[doc = ""]
    #[doc = " \\return          0 on success,"]
    #[doc = "                  MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,"]
    #[doc = "                  MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure."]
    #[doc = ""]
    #[doc = " \\note            For contexts holding an RSA-alt key, use"]
    #[doc = "                  \\c mbedtls_pk_setup_rsa_alt() instead."]
    pub fn mbedtls_pk_setup(
        ctx: *mut mbedtls_pk_context,
        info: *const mbedtls_pk_info_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Initialize an RSA-alt context"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to initialize. It must not have been set"]
    #[doc = "                  up yet (type #MBEDTLS_PK_NONE)."]
    #[doc = " \\param key       RSA key pointer"]
    #[doc = " \\param decrypt_func  Decryption function"]
    #[doc = " \\param sign_func     Signing function"]
    #[doc = " \\param key_len_func  Function returning key length in bytes"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the"]
    #[doc = "                  context wasn't already initialized as RSA_ALT."]
    #[doc = ""]
    #[doc = " \\note            This function replaces \\c mbedtls_pk_setup() for RSA-alt."]
    pub fn mbedtls_pk_setup_rsa_alt(
        ctx: *mut mbedtls_pk_context,
        key: *mut crate::c_types::c_void,
        decrypt_func: mbedtls_pk_rsa_alt_decrypt_func,
        sign_func: mbedtls_pk_rsa_alt_sign_func,
        key_len_func: mbedtls_pk_rsa_alt_key_len_func,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Get the size in bits of the underlying key"]
    #[doc = ""]
    #[doc = " \\param ctx       The context to query. It must have been initialized."]
    #[doc = ""]
    #[doc = " \\return          Key size in bits, or 0 on error"]
    pub fn mbedtls_pk_get_bitlen(ctx: *const mbedtls_pk_context) -> size_t;
}
extern "C" {
    #[doc = " \\brief           Tell if a context can do the operation given by type"]
    #[doc = ""]
    #[doc = " \\param ctx       The context to query. It must have been initialized."]
    #[doc = " \\param type      The desired type."]
    #[doc = ""]
    #[doc = " \\return          1 if the context can do operations on the given type."]
    #[doc = " \\return          0 if the context cannot do the operations on the given"]
    #[doc = "                  type. This is always the case for a context that has"]
    #[doc = "                  been initialized but not set up, or that has been"]
    #[doc = "                  cleared with mbedtls_pk_free()."]
    pub fn mbedtls_pk_can_do(
        ctx: *const mbedtls_pk_context,
        type_: mbedtls_pk_type_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param md_alg    Hash algorithm used."]
    #[doc = "                  This can be #MBEDTLS_MD_NONE if the signature algorithm"]
    #[doc = "                  does not rely on a hash algorithm (non-deterministic"]
    #[doc = "                  ECDSA, RSA PKCS#1 v1.5)."]
    #[doc = "                  For PKCS#1 v1.5, if \\p md_alg is #MBEDTLS_MD_NONE, then"]
    #[doc = "                  \\p hash is the DigestInfo structure used by RFC 8017"]
    #[doc = "                  &sect;9.2 steps 3&ndash;6. If \\p md_alg is a valid hash"]
    #[doc = "                  algorithm then \\p hash is the digest itself, and this"]
    #[doc = "                  function calculates the DigestInfo encoding internally."]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = ""]
    #[doc = " \\return          0 on success (signature is valid),"]
    #[doc = "                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in sig but its length is less than \\p siglen,"]
    #[doc = "                  or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = "                  Use \\c mbedtls_pk_verify_ext( MBEDTLS_PK_RSASSA_PSS, ... )"]
    #[doc = "                  to verify RSASSA_PSS signatures."]
    pub fn mbedtls_pk_verify(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: size_t,
        sig: *const crate::c_types::c_uchar,
        sig_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_verify()"]
    #[doc = ""]
    #[doc = " \\note            Performs the same job as \\c mbedtls_pk_verify(), but can"]
    #[doc = "                  return early and restart according to the limit set with"]
    #[doc = "                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC"]
    #[doc = "                  operations. For RSA, same as \\c mbedtls_pk_verify()."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = " \\param rs_ctx    Restart context (NULL to disable restart)"]
    #[doc = ""]
    #[doc = " \\return          See \\c mbedtls_pk_verify(), or"]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_pk_verify_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: size_t,
        sig: *const crate::c_types::c_uchar,
        sig_len: size_t,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature, with options."]
    #[doc = "                  (Includes verification of the padding depending on type.)"]
    #[doc = ""]
    #[doc = " \\param type      Signature type (inc. possible padding type) to verify"]
    #[doc = " \\param options   Pointer to type-specific options, or NULL"]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = ""]
    #[doc = " \\return          0 on success (signature is valid),"]
    #[doc = "                  #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be"]
    #[doc = "                  used for this type of signatures,"]
    #[doc = "                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in sig but its length is less than \\p siglen,"]
    #[doc = "                  or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            If hash_len is 0, then the length associated with md_alg"]
    #[doc = "                  is used instead, or an error returned if it is invalid."]
    #[doc = ""]
    #[doc = " \\note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0"]
    #[doc = ""]
    #[doc = " \\note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point"]
    #[doc = "                  to a mbedtls_pk_rsassa_pss_options structure,"]
    #[doc = "                  otherwise it must be NULL. Note that if"]
    #[doc = "                  #MBEDTLS_USE_PSA_CRYPTO is defined, the salt length is not"]
    #[doc = "                  verified as PSA_ALG_RSA_PSS_ANY_SALT is used."]
    pub fn mbedtls_pk_verify_ext(
        type_: mbedtls_pk_type_t,
        options: *const crate::c_types::c_void,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: size_t,
        sig: *const crate::c_types::c_uchar,
        sig_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature, including padding if relevant."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up"]
    #[doc = "                  with a private key."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length"]
    #[doc = " \\param sig       Place to write the signature."]
    #[doc = "                  It must have enough room for the signature."]
    #[doc = "                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough."]
    #[doc = "                  You may use a smaller buffer if it is large enough"]
    #[doc = "                  given the key type."]
    #[doc = " \\param sig_size  The size of the \\p sig buffer in bytes."]
    #[doc = " \\param sig_len   On successful return,"]
    #[doc = "                  the number of bytes written to \\p sig."]
    #[doc = " \\param f_rng     RNG function, must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = "                  There is no interface in the PK module to make RSASSA-PSS"]
    #[doc = "                  signatures yet."]
    #[doc = ""]
    #[doc = " \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0."]
    #[doc = "                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE."]
    pub fn mbedtls_pk_sign(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: size_t,
        sig: *mut crate::c_types::c_uchar,
        sig_size: size_t,
        sig_len: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature given a signature type."]
    #[doc = ""]
    #[doc = " \\param pk_type   Signature type."]
    #[doc = " \\param ctx       The PK context to use. It must have been set up"]
    #[doc = "                  with a private key."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length"]
    #[doc = " \\param sig       Place to write the signature."]
    #[doc = "                  It must have enough room for the signature."]
    #[doc = "                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough."]
    #[doc = "                  You may use a smaller buffer if it is large enough"]
    #[doc = "                  given the key type."]
    #[doc = " \\param sig_size  The size of the \\p sig buffer in bytes."]
    #[doc = " \\param sig_len   On successful return,"]
    #[doc = "                  the number of bytes written to \\p sig."]
    #[doc = " \\param f_rng     RNG function, must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            When \\p pk_type is #MBEDTLS_PK_RSASSA_PSS,"]
    #[doc = "                  see #PSA_ALG_RSA_PSS for a description of PSS options used."]
    #[doc = ""]
    #[doc = " \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0."]
    #[doc = "                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE."]
    #[doc = ""]
    pub fn mbedtls_pk_sign_ext(
        pk_type: mbedtls_pk_type_t,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: size_t,
        sig: *mut crate::c_types::c_uchar,
        sig_size: size_t,
        sig_len: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_sign()"]
    #[doc = ""]
    #[doc = " \\note            Performs the same job as \\c mbedtls_pk_sign(), but can"]
    #[doc = "                  return early and restart according to the limit set with"]
    #[doc = "                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC"]
    #[doc = "                  operations. For RSA, same as \\c mbedtls_pk_sign()."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up"]
    #[doc = "                  with a private key."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes for mbedtls_pk_sign())"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length"]
    #[doc = " \\param sig       Place to write the signature."]
    #[doc = "                  It must have enough room for the signature."]
    #[doc = "                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough."]
    #[doc = "                  You may use a smaller buffer if it is large enough"]
    #[doc = "                  given the key type."]
    #[doc = " \\param sig_size  The size of the \\p sig buffer in bytes."]
    #[doc = " \\param sig_len   On successful return,"]
    #[doc = "                  the number of bytes written to \\p sig."]
    #[doc = " \\param f_rng     RNG function, must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = " \\param rs_ctx    Restart context (NULL to disable restart)"]
    #[doc = ""]
    #[doc = " \\return          See \\c mbedtls_pk_sign()."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_pk_sign_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: size_t,
        sig: *mut crate::c_types::c_uchar,
        sig_size: size_t,
        sig_len: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Decrypt message (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up"]
    #[doc = "                  with a private key."]
    #[doc = " \\param input     Input to decrypt"]
    #[doc = " \\param ilen      Input size"]
    #[doc = " \\param output    Decrypted output"]
    #[doc = " \\param olen      Decrypted message length"]
    #[doc = " \\param osize     Size of the output buffer"]
    #[doc = " \\param f_rng     RNG function, must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_decrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        olen: *mut size_t,
        osize: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Encrypt message (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param input     Message to encrypt"]
    #[doc = " \\param ilen      Message size"]
    #[doc = " \\param output    Encrypted output"]
    #[doc = " \\param olen      Encrypted output length"]
    #[doc = " \\param osize     Size of the output buffer"]
    #[doc = " \\param f_rng     RNG function, must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\note            \\p f_rng is used for padding generation."]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_encrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        olen: *mut size_t,
        osize: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if a public-private pair of keys matches."]
    #[doc = ""]
    #[doc = " \\param pub       Context holding a public key."]
    #[doc = " \\param prv       Context holding a private (and public) key."]
    #[doc = " \\param f_rng     RNG function, must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success (keys were checked and match each other)."]
    #[doc = " \\return          #MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE if the keys could not"]
    #[doc = "                  be checked - in that case they may or may not match."]
    #[doc = " \\return          #MBEDTLS_ERR_PK_BAD_INPUT_DATA if a context is invalid."]
    #[doc = " \\return          Another non-zero value if the keys do not match."]
    pub fn mbedtls_pk_check_pair(
        pub_: *const mbedtls_pk_context,
        prv: *const mbedtls_pk_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Export debug information"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been initialized."]
    #[doc = " \\param items     Place to write debug items"]
    #[doc = ""]
    #[doc = " \\return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA"]
    pub fn mbedtls_pk_debug(
        ctx: *const mbedtls_pk_context,
        items: *mut mbedtls_pk_debug_item,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Access the type name"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been initialized."]
    #[doc = ""]
    #[doc = " \\return          Type name on success, or \"invalid PK\""]
    pub fn mbedtls_pk_get_name(ctx: *const mbedtls_pk_context) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief           Get the key type"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been initialized."]
    #[doc = ""]
    #[doc = " \\return          Type on success."]
    #[doc = " \\return          #MBEDTLS_PK_NONE for a context that has not been set up."]
    pub fn mbedtls_pk_get_type(ctx: *const mbedtls_pk_context) -> mbedtls_pk_type_t;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Parse a private key in PEM or DER format"]
    #[doc = ""]
    #[doc = " \\note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                  subsystem must have been initialized by calling"]
    #[doc = "                  psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to fill. It must have been initialized"]
    #[doc = "                  but not set up."]
    #[doc = " \\param key       Input buffer to parse."]
    #[doc = "                  The buffer must contain the input exactly, with no"]
    #[doc = "                  extra trailing material. For PEM, the buffer must"]
    #[doc = "                  contain a null-terminated string."]
    #[doc = " \\param keylen    Size of \\b key in bytes."]
    #[doc = "                  For PEM data, this includes the terminating null byte,"]
    #[doc = "                  so \\p keylen must be equal to `strlen(key) + 1`."]
    #[doc = " \\param pwd       Optional password for decryption."]
    #[doc = "                  Pass \\c NULL if expecting a non-encrypted key."]
    #[doc = "                  Pass a string of \\p pwdlen bytes if expecting an encrypted"]
    #[doc = "                  key; a non-encrypted key will also be accepted."]
    #[doc = "                  The empty password is not supported."]
    #[doc = " \\param pwdlen    Size of the password in bytes."]
    #[doc = "                  Ignored if \\p pwd is \\c NULL."]
    #[doc = " \\param f_rng     RNG function, must not be \\c NULL. Used for blinding."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a"]
    #[doc = "                  specific key type, check the result with mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_key(
        ctx: *mut mbedtls_pk_context,
        key: *const crate::c_types::c_uchar,
        keylen: size_t,
        pwd: *const crate::c_types::c_uchar,
        pwdlen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Parse a public key in PEM or DER format"]
    #[doc = ""]
    #[doc = " \\note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                  subsystem must have been initialized by calling"]
    #[doc = "                  psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to fill. It must have been initialized"]
    #[doc = "                  but not set up."]
    #[doc = " \\param key       Input buffer to parse."]
    #[doc = "                  The buffer must contain the input exactly, with no"]
    #[doc = "                  extra trailing material. For PEM, the buffer must"]
    #[doc = "                  contain a null-terminated string."]
    #[doc = " \\param keylen    Size of \\b key in bytes."]
    #[doc = "                  For PEM data, this includes the terminating null byte,"]
    #[doc = "                  so \\p keylen must be equal to `strlen(key) + 1`."]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a"]
    #[doc = "                  specific key type, check the result with mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for"]
    #[doc = "                  limitations."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_public_key(
        ctx: *mut mbedtls_pk_context,
        key: *const crate::c_types::c_uchar,
        keylen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid private key."]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    pub fn mbedtls_pk_write_key_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a SubjectPublicKeyInfo DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid public or private key."]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    pub fn mbedtls_pk_write_pubkey_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid public or private key."]
    #[doc = " \\param buf       Buffer to write to. The output includes a"]
    #[doc = "                  terminating null byte."]
    #[doc = " \\param size      Size of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_pubkey_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid private key."]
    #[doc = " \\param buf       Buffer to write to. The output includes a"]
    #[doc = "                  terminating null byte."]
    #[doc = " \\param size      Size of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_key_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Parse a SubjectPublicKeyInfo DER structure"]
    #[doc = ""]
    #[doc = " \\param p         the position in the ASN.1 data"]
    #[doc = " \\param end       end of the buffer"]
    #[doc = " \\param pk        The PK context to fill. It must have been initialized"]
    #[doc = "                  but not set up."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK error code"]
    pub fn mbedtls_pk_parse_subpubkey(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        pk: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a subjectPublicKey to ASN.1 data"]
    #[doc = "                  Note: function works backwards in data buffer"]
    #[doc = ""]
    #[doc = " \\param p         reference to current position pointer"]
    #[doc = " \\param start     start of the buffer (for bounds-checking)"]
    #[doc = " \\param key       PK context which must contain a valid public or private key."]
    #[doc = ""]
    #[doc = " \\return          the length written or a negative error code"]
    pub fn mbedtls_pk_write_pubkey(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        key: *const mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
#[doc = "< Placeholder to mark the end of cipher ID lists."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
#[doc = "< The identity cipher, treated as a stream cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
#[doc = "< The AES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
#[doc = "< The DES cipher. \\warning DES is considered weak."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
#[doc = "< The Triple DES cipher. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
#[doc = "< The Camellia cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
#[doc = "< The Aria cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARIA: mbedtls_cipher_id_t = 6;
#[doc = "< The ChaCha20 cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CHACHA20: mbedtls_cipher_id_t = 7;
#[doc = " \\brief     Supported cipher types."]
#[doc = ""]
#[doc = " \\warning   DES/3DES are considered weak ciphers and their use"]
#[doc = "            constitutes a security risk. We recommend considering stronger"]
#[doc = "            ciphers instead."]
pub type mbedtls_cipher_id_t = crate::c_types::c_uint;
#[doc = "< Placeholder to mark the end of cipher-pair lists."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
#[doc = "< The identity stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
#[doc = "< AES cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
#[doc = "< AES cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
#[doc = "< AES cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
#[doc = "< AES cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
#[doc = "< AES cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
#[doc = "< AES cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
#[doc = "< AES cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
#[doc = "< AES cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
#[doc = "< AES cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
#[doc = "< AES cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
#[doc = "< AES cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
#[doc = "< AES cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
#[doc = "< AES cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
#[doc = "< AES cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
#[doc = "< AES cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
#[doc = "< Camellia cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
#[doc = "< Camellia cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
#[doc = "< Camellia cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
#[doc = "< Camellia cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
#[doc = "< Camellia cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
#[doc = "< Camellia cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
#[doc = "< Camellia cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
#[doc = "< Camellia cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
#[doc = "< Camellia cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
#[doc = "< Camellia cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
#[doc = "< Camellia cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
#[doc = "< Camellia cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
#[doc = "< Camellia cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
#[doc = "< Camellia cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
#[doc = "< Camellia cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
#[doc = "< DES cipher with ECB mode. \\warning DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
#[doc = "< DES cipher with CBC mode. \\warning DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
#[doc = "< DES cipher with EDE ECB mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
#[doc = "< DES cipher with EDE CBC mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
#[doc = "< DES cipher with EDE3 ECB mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
#[doc = "< DES cipher with EDE3 CBC mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
#[doc = "< AES cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 38;
#[doc = "< AES cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 39;
#[doc = "< AES cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 40;
#[doc = "< AES cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 41;
#[doc = "< AES cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 42;
#[doc = "< AES cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 43;
#[doc = "< Camellia cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 44;
#[doc = "< Camellia cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 45;
#[doc = "< Camellia cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 46;
#[doc = "< Camellia cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    47;
#[doc = "< Camellia cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    48;
#[doc = "< Camellia cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    49;
#[doc = "< Aria cipher with 128-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_ECB: mbedtls_cipher_type_t = 50;
#[doc = "< Aria cipher with 192-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_ECB: mbedtls_cipher_type_t = 51;
#[doc = "< Aria cipher with 256-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_ECB: mbedtls_cipher_type_t = 52;
#[doc = "< Aria cipher with 128-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CBC: mbedtls_cipher_type_t = 53;
#[doc = "< Aria cipher with 192-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CBC: mbedtls_cipher_type_t = 54;
#[doc = "< Aria cipher with 256-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CBC: mbedtls_cipher_type_t = 55;
#[doc = "< Aria cipher with 128-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CFB128: mbedtls_cipher_type_t = 56;
#[doc = "< Aria cipher with 192-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CFB128: mbedtls_cipher_type_t = 57;
#[doc = "< Aria cipher with 256-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CFB128: mbedtls_cipher_type_t = 58;
#[doc = "< Aria cipher with 128-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CTR: mbedtls_cipher_type_t = 59;
#[doc = "< Aria cipher with 192-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CTR: mbedtls_cipher_type_t = 60;
#[doc = "< Aria cipher with 256-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CTR: mbedtls_cipher_type_t = 61;
#[doc = "< Aria cipher with 128-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_GCM: mbedtls_cipher_type_t = 62;
#[doc = "< Aria cipher with 192-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_GCM: mbedtls_cipher_type_t = 63;
#[doc = "< Aria cipher with 256-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_GCM: mbedtls_cipher_type_t = 64;
#[doc = "< Aria cipher with 128-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM: mbedtls_cipher_type_t = 65;
#[doc = "< Aria cipher with 192-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM: mbedtls_cipher_type_t = 66;
#[doc = "< Aria cipher with 256-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM: mbedtls_cipher_type_t = 67;
#[doc = "< Aria cipher with 128-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 68;
#[doc = "< Aria cipher with 192-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 69;
#[doc = "< Aria cipher with 256-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 70;
#[doc = "< AES 128-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_OFB: mbedtls_cipher_type_t = 71;
#[doc = "< AES 192-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_OFB: mbedtls_cipher_type_t = 72;
#[doc = "< AES 256-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_OFB: mbedtls_cipher_type_t = 73;
#[doc = "< AES 128-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_XTS: mbedtls_cipher_type_t = 74;
#[doc = "< AES 256-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_XTS: mbedtls_cipher_type_t = 75;
#[doc = "< ChaCha20 stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20: mbedtls_cipher_type_t = 76;
#[doc = "< ChaCha20-Poly1305 AEAD cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20_POLY1305: mbedtls_cipher_type_t = 77;
#[doc = "< AES cipher with 128-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KW: mbedtls_cipher_type_t = 78;
#[doc = "< AES cipher with 192-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KW: mbedtls_cipher_type_t = 79;
#[doc = "< AES cipher with 256-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KW: mbedtls_cipher_type_t = 80;
#[doc = "< AES cipher with 128-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KWP: mbedtls_cipher_type_t = 81;
#[doc = "< AES cipher with 192-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KWP: mbedtls_cipher_type_t = 82;
#[doc = "< AES cipher with 256-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KWP: mbedtls_cipher_type_t = 83;
#[doc = " \\brief     Supported {cipher type, cipher mode} pairs."]
#[doc = ""]
#[doc = " \\warning   DES/3DES are considered weak ciphers and their use"]
#[doc = "            constitutes a security risk. We recommend considering stronger"]
#[doc = "            ciphers instead."]
pub type mbedtls_cipher_type_t = crate::c_types::c_uint;
#[doc = "< None."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
#[doc = "< The ECB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
#[doc = "< The CBC cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
#[doc = "< The CFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
#[doc = "< The OFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
#[doc = "< The CTR cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
#[doc = "< The GCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
#[doc = "< The stream cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
#[doc = "< The CCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
#[doc = "< The CCM*-no-tag cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM_STAR_NO_TAG: mbedtls_cipher_mode_t = 9;
#[doc = "< The XTS cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_XTS: mbedtls_cipher_mode_t = 10;
#[doc = "< The ChaCha-Poly cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CHACHAPOLY: mbedtls_cipher_mode_t = 11;
#[doc = "< The SP800-38F KW mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KW: mbedtls_cipher_mode_t = 12;
#[doc = "< The SP800-38F KWP mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KWP: mbedtls_cipher_mode_t = 13;
#[doc = " Supported cipher modes."]
pub type mbedtls_cipher_mode_t = crate::c_types::c_uint;
#[doc = "< PKCS7 padding (default)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
#[doc = "< ISO/IEC 7816-4 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
#[doc = "< ANSI X.923 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
#[doc = "< Zero padding (not reversible)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
#[doc = "< Never pad (full blocks only)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
#[doc = " Supported cipher padding types."]
pub type mbedtls_cipher_padding_t = crate::c_types::c_uint;
pub const mbedtls_operation_t_MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const mbedtls_operation_t_MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const mbedtls_operation_t_MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
#[doc = " Type of operation."]
pub type mbedtls_operation_t = crate::c_types::c_int;
#[doc = " Undefined key length."]
pub const MBEDTLS_KEY_LENGTH_NONE: crate::c_types::c_uint = 0;
#[doc = " Key length, in bits (including parity), for DES keys. \\warning DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES: crate::c_types::c_uint = 64;
#[doc = " Key length in bits, including parity, for DES in two-key EDE. \\warning 3DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE: crate::c_types::c_uint = 128;
#[doc = " Key length in bits, including parity, for DES in three-key EDE. \\warning 3DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: crate::c_types::c_uint = 192;
pub type _bindgen_ty_1 = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_base_t {
    _unused: [u8; 0],
}
#[doc = " Cipher information. Allows calling cipher functions"]
#[doc = " in a generic way."]
#[doc = ""]
#[doc = " \\note        The library does not support custom cipher info structures,"]
#[doc = "              only built-in structures returned by the functions"]
#[doc = "              mbedtls_cipher_info_from_string(),"]
#[doc = "              mbedtls_cipher_info_from_type(),"]
#[doc = "              mbedtls_cipher_info_from_values(),"]
#[doc = "              mbedtls_cipher_info_from_psa()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_info_t {
    pub private_type: mbedtls_cipher_type_t,
    pub private_mode: mbedtls_cipher_mode_t,
    pub private_key_bitlen: crate::c_types::c_uint,
    pub private_name: *const crate::c_types::c_char,
    pub private_iv_size: crate::c_types::c_uint,
    pub private_flags: crate::c_types::c_int,
    pub private_block_size: crate::c_types::c_uint,
    pub private_base: *const mbedtls_cipher_base_t,
}
#[doc = " Generic cipher context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_context_t {
    pub private_cipher_info: *const mbedtls_cipher_info_t,
    pub private_key_bitlen: crate::c_types::c_int,
    pub private_operation: mbedtls_operation_t,
    pub private_add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut crate::c_types::c_uchar, olen: size_t, data_len: size_t),
    >,
    pub private_get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut crate::c_types::c_uchar,
            ilen: size_t,
            data_len: *mut size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_unprocessed_data: [crate::c_types::c_uchar; 16usize],
    pub private_unprocessed_len: size_t,
    pub private_iv: [crate::c_types::c_uchar; 16usize],
    pub private_iv_size: size_t,
    pub private_cipher_ctx: *mut crate::c_types::c_void,
    pub private_cmac_ctx: *mut mbedtls_cmac_context_t,
}
extern "C" {
    #[doc = " \\brief This function retrieves the list of ciphers supported"]
    #[doc = "        by the generic cipher module."]
    #[doc = ""]
    #[doc = "        For any cipher identifier in the returned list, you can"]
    #[doc = "        obtain the corresponding generic cipher information structure"]
    #[doc = "        via mbedtls_cipher_info_from_type(), which can then be used"]
    #[doc = "        to prepare a cipher context via mbedtls_cipher_setup()."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\return      A statically-allocated array of cipher identifiers"]
    #[doc = "              of type cipher_type_t. The last entry is zero."]
    pub fn mbedtls_cipher_list() -> *const crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher name."]
    #[doc = ""]
    #[doc = " \\param cipher_name   Name of the cipher to search for. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_name."]
    #[doc = " \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_string(
        cipher_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher type."]
    #[doc = ""]
    #[doc = " \\param cipher_type   Type of the cipher to search for."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_type."]
    #[doc = " \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_type(
        cipher_type: mbedtls_cipher_type_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher ID,"]
    #[doc = "                      key size and mode."]
    #[doc = ""]
    #[doc = " \\param cipher_id     The ID of the cipher to search for. For example,"]
    #[doc = "                      #MBEDTLS_CIPHER_ID_AES."]
    #[doc = " \\param key_bitlen    The length of the key in bits."]
    #[doc = " \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_id."]
    #[doc = " \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_values(
        cipher_id: mbedtls_cipher_id_t,
        key_bitlen: crate::c_types::c_int,
        mode: mbedtls_cipher_mode_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function initializes a \\p cipher_context as NONE."]
    #[doc = ""]
    #[doc = " \\param ctx           The context to be initialized. This must not be \\c NULL."]
    pub fn mbedtls_cipher_init(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function frees and clears the cipher-specific"]
    #[doc = "                      context of \\p ctx. Freeing \\p ctx itself remains the"]
    #[doc = "                      responsibility of the caller."]
    #[doc = ""]
    #[doc = " \\param ctx           The context to be freed. If this is \\c NULL, the"]
    #[doc = "                      function has no effect, otherwise this must point to an"]
    #[doc = "                      initialized context."]
    pub fn mbedtls_cipher_free(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function prepares a cipher context for"]
    #[doc = "                      use with the given cipher primitive."]
    #[doc = ""]
    #[doc = " \\note                After calling this function, you should call"]
    #[doc = "                      mbedtls_cipher_setkey() and, if the mode uses padding,"]
    #[doc = "                      mbedtls_cipher_set_padding_mode(), then for each"]
    #[doc = "                      message to encrypt or decrypt with this key, either:"]
    #[doc = "                      - mbedtls_cipher_crypt() for one-shot processing with"]
    #[doc = "                      non-AEAD modes;"]
    #[doc = "                      - mbedtls_cipher_auth_encrypt_ext() or"]
    #[doc = "                      mbedtls_cipher_auth_decrypt_ext() for one-shot"]
    #[doc = "                      processing with AEAD modes or NIST_KW;"]
    #[doc = "                      - for multi-part processing, see the documentation of"]
    #[doc = "                      mbedtls_cipher_reset()."]
    #[doc = ""]
    #[doc = " \\param ctx           The context to prepare. This must be initialized by"]
    #[doc = "                      a call to mbedtls_cipher_init() first."]
    #[doc = " \\param cipher_info   The cipher to use."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the"]
    #[doc = "                      cipher-specific context fails."]
    pub fn mbedtls_cipher_setup(
        ctx: *mut mbedtls_cipher_context_t,
        cipher_info: *const mbedtls_cipher_info_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the key to use with the given context."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a cipher information structure."]
    #[doc = " \\param key           The key to use. This must be a readable buffer of at"]
    #[doc = "                      least \\p key_bitlen Bits."]
    #[doc = " \\param key_bitlen    The key length to use, in Bits."]
    #[doc = " \\param operation     The operation that the key will be used for:"]
    #[doc = "                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_setkey(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const crate::c_types::c_uchar,
        key_bitlen: crate::c_types::c_int,
        operation: mbedtls_operation_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the padding mode, for cipher modes"]
    #[doc = "                      that use padding."]
    #[doc = ""]
    #[doc = "                      The default passing mode is PKCS7 padding."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a cipher information structure."]
    #[doc = " \\param mode          The padding mode."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE"]
    #[doc = "                      if the selected padding mode is not supported."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode"]
    #[doc = "                      does not support padding."]
    pub fn mbedtls_cipher_set_padding_mode(
        ctx: *mut mbedtls_cipher_context_t,
        mode: mbedtls_cipher_padding_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the initialization vector (IV)"]
    #[doc = "                  or nonce."]
    #[doc = ""]
    #[doc = " \\note            Some ciphers do not use IVs nor nonce. For these"]
    #[doc = "                  ciphers, this function has no effect."]
    #[doc = ""]
    #[doc = " \\note            For #MBEDTLS_CIPHER_CHACHA20, the nonce length must"]
    #[doc = "                  be 12, and the initial counter value is 0."]
    #[doc = ""]
    #[doc = " \\note            For #MBEDTLS_CIPHER_CHACHA20_POLY1305, the nonce length"]
    #[doc = "                  must be 12."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic cipher context. This must be initialized and"]
    #[doc = "                  bound to a cipher information structure."]
    #[doc = " \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers. This"]
    #[doc = "                  must be a readable buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The IV length for ciphers with variable-size IV."]
    #[doc = "                  This parameter is discarded by ciphers with fixed-size IV."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                  parameter-verification failure."]
    pub fn mbedtls_cipher_set_iv(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief         This function resets the cipher state."]
    #[doc = ""]
    #[doc = " \\note          With non-AEAD ciphers, the order of calls for each message"]
    #[doc = "                is as follows:"]
    #[doc = "                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce."]
    #[doc = "                2. mbedtls_cipher_reset()"]
    #[doc = "                3. mbedtls_cipher_update() one or more times"]
    #[doc = "                4. mbedtls_cipher_finish()"]
    #[doc = "                ."]
    #[doc = "                This sequence can be repeated to encrypt or decrypt multiple"]
    #[doc = "                messages with the same key."]
    #[doc = ""]
    #[doc = " \\note          With AEAD ciphers, the order of calls for each message"]
    #[doc = "                is as follows:"]
    #[doc = "                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce."]
    #[doc = "                2. mbedtls_cipher_reset()"]
    #[doc = "                3. mbedtls_cipher_update_ad()"]
    #[doc = "                4. mbedtls_cipher_update() one or more times"]
    #[doc = "                5. mbedtls_cipher_finish()"]
    #[doc = "                6. mbedtls_cipher_check_tag() (for decryption) or"]
    #[doc = "                mbedtls_cipher_write_tag() (for encryption)."]
    #[doc = "                ."]
    #[doc = "                This sequence can be repeated to encrypt or decrypt multiple"]
    #[doc = "                messages with the same key."]
    #[doc = ""]
    #[doc = " \\param ctx     The generic cipher context. This must be bound to a key."]
    #[doc = ""]
    #[doc = " \\return        \\c 0 on success."]
    #[doc = " \\return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                parameter-verification failure."]
    pub fn mbedtls_cipher_reset(ctx: *mut mbedtls_cipher_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function adds additional data for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized."]
    #[doc = " \\param ad            The additional data to use. This must be a readable"]
    #[doc = "                      buffer of at least \\p ad_len Bytes."]
    #[doc = " \\param ad_len        The length of \\p ad in Bytes."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_update_ad(
        ctx: *mut mbedtls_cipher_context_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher update function. It encrypts or"]
    #[doc = "                      decrypts using the given cipher context. Writes as"]
    #[doc = "                      many block-sized blocks of data as possible to output."]
    #[doc = "                      Any data that cannot be written immediately is either"]
    #[doc = "                      added to the next block, or flushed when"]
    #[doc = "                      mbedtls_cipher_finish() is called."]
    #[doc = "                      Exception: For MBEDTLS_MODE_ECB, expects a single block"]
    #[doc = "                      in size. For example, 16 Bytes for AES."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a key."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data. This must be able to"]
    #[doc = "                      hold at least `ilen + block_size`. This must not be the"]
    #[doc = "                      same buffer as \\p input."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an"]
    #[doc = "                      unsupported mode for a cipher."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        olen: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher finalization function. If data still"]
    #[doc = "                      needs to be flushed from an incomplete block, the data"]
    #[doc = "                      contained in it is padded to the size of"]
    #[doc = "                      the last block, and written to the \\p output buffer."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a key."]
    #[doc = " \\param output        The buffer to write data to. This needs to be a writable"]
    #[doc = "                      buffer of at least \\p block_size Bytes."]
    #[doc = " \\param olen          The length of the data written to the \\p output buffer."]
    #[doc = "                      This may not be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption"]
    #[doc = "                      expecting a full block but not receiving one."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding"]
    #[doc = "                      while decrypting."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut crate::c_types::c_uchar,
        olen: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function writes a tag for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      This must be called after mbedtls_cipher_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized,"]
    #[doc = "                      bound to a key, and have just completed a cipher"]
    #[doc = "                      operation through mbedtls_cipher_finish() the tag for"]
    #[doc = "                      which should be written."]
    #[doc = " \\param tag           The buffer to write the tag to. This must be a writable"]
    #[doc = "                      buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len       The length of the tag to write."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_write_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *mut crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function checks the tag for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      This must be called after mbedtls_cipher_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized."]
    #[doc = " \\param tag           The buffer holding the tag. This must be a readable"]
    #[doc = "                      buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len       The length of the tag to check."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_check_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *const crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic all-in-one encryption/decryption function,"]
    #[doc = "                      for all ciphers except AEAD constructs."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized."]
    #[doc = " \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = "                      This must be a readable buffer of at least \\p iv_len"]
    #[doc = "                      Bytes."]
    #[doc = " \\param iv_len        The IV length for ciphers with variable-size IV."]
    #[doc = "                      This parameter is discarded by ciphers with fixed-size"]
    #[doc = "                      IV."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes."]
    #[doc = " \\param ilen          The length of the input data in Bytes."]
    #[doc = " \\param output        The buffer for the output data. This must be able to"]
    #[doc = "                      hold at least `ilen + block_size`. This must not be the"]
    #[doc = "                      same buffer as \\p input."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = ""]
    #[doc = " \\note                Some ciphers do not use IVs nor nonce. For these"]
    #[doc = "                      ciphers, use \\p iv = NULL and \\p iv_len = 0."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption"]
    #[doc = "                      expecting a full block but not receiving one."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding"]
    #[doc = "                      while decrypting."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_crypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        olen: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function."]
    #[doc = ""]
    #[doc = " \\note                For AEAD modes, the tag will be appended to the"]
    #[doc = "                      ciphertext, as recommended by RFC 5116."]
    #[doc = "                      (NIST_KW doesn't have a separate tag.)"]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a key, with an AEAD algorithm or NIST_KW."]
    #[doc = " \\param iv            The nonce to use. This must be a readable buffer of"]
    #[doc = "                      at least \\p iv_len Bytes and may be \\c NULL if \\p"]
    #[doc = "                      iv_len is \\c 0."]
    #[doc = " \\param iv_len        The length of the nonce. For AEAD ciphers, this must"]
    #[doc = "                      satisfy the constraints imposed by the cipher used."]
    #[doc = "                      For NIST_KW, this must be \\c 0."]
    #[doc = " \\param ad            The additional data to authenticate. This must be a"]
    #[doc = "                      readable buffer of at least \\p ad_len Bytes, and may"]
    #[doc = "                      be \\c NULL is \\p ad_len is \\c 0."]
    #[doc = " \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes, and may be"]
    #[doc = "                      \\c NULL if \\p ilen is \\c 0."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data. This must be a"]
    #[doc = "                      writable buffer of at least \\p output_len Bytes, and"]
    #[doc = "                      must not be \\c NULL."]
    #[doc = " \\param output_len    The length of the \\p output buffer in Bytes. For AEAD"]
    #[doc = "                      ciphers, this must be at least \\p ilen + \\p tag_len."]
    #[doc = "                      For NIST_KW, this must be at least \\p ilen + 8"]
    #[doc = "                      (rounded up to a multiple of 8 if KWP is used);"]
    #[doc = "                      \\p ilen + 15 is always a safe value."]
    #[doc = " \\param olen          This will be filled with the actual number of Bytes"]
    #[doc = "                      written to the \\p output buffer. This must point to a"]
    #[doc = "                      writable object of type \\c size_t."]
    #[doc = " \\param tag_len       The desired length of the authentication tag. For AEAD"]
    #[doc = "                      ciphers, this must match the constraints imposed by"]
    #[doc = "                      the cipher used, and in particular must not be \\c 0."]
    #[doc = "                      For NIST_KW, this must be \\c 0."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_encrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        output_len: size_t,
        olen: *mut size_t,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function."]
    #[doc = ""]
    #[doc = " \\note                If the data is not authentic, then the output buffer"]
    #[doc = "                      is zeroed out to prevent the unauthentic plaintext being"]
    #[doc = "                      used, making this interface safer."]
    #[doc = ""]
    #[doc = " \\note                For AEAD modes, the tag must be appended to the"]
    #[doc = "                      ciphertext, as recommended by RFC 5116."]
    #[doc = "                      (NIST_KW doesn't have a separate tag.)"]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a key, with an AEAD algorithm or NIST_KW."]
    #[doc = " \\param iv            The nonce to use. This must be a readable buffer of"]
    #[doc = "                      at least \\p iv_len Bytes and may be \\c NULL if \\p"]
    #[doc = "                      iv_len is \\c 0."]
    #[doc = " \\param iv_len        The length of the nonce. For AEAD ciphers, this must"]
    #[doc = "                      satisfy the constraints imposed by the cipher used."]
    #[doc = "                      For NIST_KW, this must be \\c 0."]
    #[doc = " \\param ad            The additional data to authenticate. This must be a"]
    #[doc = "                      readable buffer of at least \\p ad_len Bytes, and may"]
    #[doc = "                      be \\c NULL is \\p ad_len is \\c 0."]
    #[doc = " \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes, and may be"]
    #[doc = "                      \\c NULL if \\p ilen is \\c 0."]
    #[doc = " \\param ilen          The length of the input data. For AEAD ciphers this"]
    #[doc = "                      must be at least \\p tag_len. For NIST_KW this must be"]
    #[doc = "                      at least \\c 8."]
    #[doc = " \\param output        The buffer for the output data. This must be a"]
    #[doc = "                      writable buffer of at least \\p output_len Bytes, and"]
    #[doc = "                      may be \\c NULL if \\p output_len is \\c 0."]
    #[doc = " \\param output_len    The length of the \\p output buffer in Bytes. For AEAD"]
    #[doc = "                      ciphers, this must be at least \\p ilen - \\p tag_len."]
    #[doc = "                      For NIST_KW, this must be at least \\p ilen - 8."]
    #[doc = " \\param olen          This will be filled with the actual number of Bytes"]
    #[doc = "                      written to the \\p output buffer. This must point to a"]
    #[doc = "                      writable object of type \\c size_t."]
    #[doc = " \\param tag_len       The actual length of the authentication tag. For AEAD"]
    #[doc = "                      ciphers, this must match the constraints imposed by"]
    #[doc = "                      the cipher used, and in particular must not be \\c 0."]
    #[doc = "                      For NIST_KW, this must be \\c 0."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_decrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        output_len: size_t,
        olen: *mut size_t,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_NONE: mbedtls_key_exchange_type_t = 0;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA: mbedtls_key_exchange_type_t = 1;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_RSA: mbedtls_key_exchange_type_t = 2;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: mbedtls_key_exchange_type_t =
    3;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
    mbedtls_key_exchange_type_t = 4;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_PSK: mbedtls_key_exchange_type_t = 5;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_PSK: mbedtls_key_exchange_type_t = 6;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA_PSK: mbedtls_key_exchange_type_t = 7;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_PSK: mbedtls_key_exchange_type_t =
    8;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: mbedtls_key_exchange_type_t =
    9;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: mbedtls_key_exchange_type_t =
    10;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECJPAKE: mbedtls_key_exchange_type_t =
    11;
pub type mbedtls_key_exchange_type_t = crate::c_types::c_uint;
#[doc = " \\brief   This structure is used for storing ciphersuite information"]
#[doc = ""]
#[doc = " \\note    members are defined using integral types instead of enums"]
#[doc = "          in order to pack structure and reduce memory usage by internal"]
#[doc = "          \\c ciphersuite_definitions[]"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_ciphersuite_t {
    pub private_id: crate::c_types::c_int,
    pub private_name: *const crate::c_types::c_char,
    pub private_cipher: u8,
    pub private_mac: u8,
    pub private_key_exchange: u8,
    pub private_flags: u8,
    pub private_min_tls_version: u16,
    pub private_max_tls_version: u16,
}
extern "C" {
    pub fn mbedtls_ssl_list_ciphersuites() -> *const crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_string(
        ciphersuite_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_id(
        ciphersuite_id: crate::c_types::c_int,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_pk_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_ec(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_psk(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_get_cipher_key_bitlen(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> size_t;
}
#[doc = " The type of the context passed to mbedtls_psa_external_get_random()."]
#[doc = ""]
#[doc = " Mbed TLS initializes the context to all-bits-zero before calling"]
#[doc = " mbedtls_psa_external_get_random() for the first time."]
#[doc = ""]
#[doc = " The definition of this type in the Mbed TLS source code is for"]
#[doc = " demonstration purposes. Implementers of mbedtls_psa_external_get_random()"]
#[doc = " are expected to replace it with a custom definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_external_random_context_t {
    pub private_opaque: [usize; 2usize],
}
pub type psa_status_t = i32;
#[doc = " \\brief Encoding of a key type."]
#[doc = ""]
#[doc = " Values of this type are generally constructed by macros called"]
#[doc = " `PSA_KEY_TYPE_xxx`."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_key_type_t = u16;
#[doc = " The type of PSA elliptic curve family identifiers."]
#[doc = ""]
#[doc = " Values of this type are generally constructed by macros called"]
#[doc = " `PSA_ECC_FAMILY_xxx`."]
#[doc = ""]
#[doc = " The curve identifier is required to create an ECC key using the"]
#[doc = " PSA_KEY_TYPE_ECC_KEY_PAIR() or PSA_KEY_TYPE_ECC_PUBLIC_KEY()"]
#[doc = " macros."]
#[doc = ""]
#[doc = " Values defined by this standard will never be in the range 0x80-0xff."]
#[doc = " Vendors who define additional families must use an encoding in this range."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_ecc_family_t = u8;
#[doc = " The type of PSA Diffie-Hellman group family identifiers."]
#[doc = ""]
#[doc = " Values of this type are generally constructed by macros called"]
#[doc = " `PSA_DH_FAMILY_xxx`."]
#[doc = ""]
#[doc = " The group identifier is required to create a Diffie-Hellman key using the"]
#[doc = " PSA_KEY_TYPE_DH_KEY_PAIR() or PSA_KEY_TYPE_DH_PUBLIC_KEY()"]
#[doc = " macros."]
#[doc = ""]
#[doc = " Values defined by this standard will never be in the range 0x80-0xff."]
#[doc = " Vendors who define additional families must use an encoding in this range."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_dh_family_t = u8;
#[doc = " \\brief Encoding of a cryptographic algorithm."]
#[doc = ""]
#[doc = " Values of this type are generally constructed by macros called"]
#[doc = " `PSA_ALG_xxx`."]
#[doc = ""]
#[doc = " For algorithms that can be applied to multiple key types, this type"]
#[doc = " does not encode the key type. For example, for symmetric ciphers"]
#[doc = " based on a block cipher, #psa_algorithm_t encodes the block cipher"]
#[doc = " mode and the padding mode while the block cipher itself is encoded"]
#[doc = " via #psa_key_type_t."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_algorithm_t = u32;
#[doc = " Encoding of key lifetimes."]
#[doc = ""]
#[doc = " The lifetime of a key indicates where it is stored and what system actions"]
#[doc = " may create and destroy it."]
#[doc = ""]
#[doc = " Lifetime values have the following structure:"]
#[doc = " - Bits 0-7 (#PSA_KEY_LIFETIME_GET_PERSISTENCE(\\c lifetime)):"]
#[doc = "   persistence level. This value indicates what device management"]
#[doc = "   actions can cause it to be destroyed. In particular, it indicates"]
#[doc = "   whether the key is _volatile_ or _persistent_."]
#[doc = "   See ::psa_key_persistence_t for more information."]
#[doc = " - Bits 8-31 (#PSA_KEY_LIFETIME_GET_LOCATION(\\c lifetime)):"]
#[doc = "   location indicator. This value indicates which part of the system"]
#[doc = "   has access to the key material and can perform operations using the key."]
#[doc = "   See ::psa_key_location_t for more information."]
#[doc = ""]
#[doc = " Volatile keys are automatically destroyed when the application instance"]
#[doc = " terminates or on a power reset of the device. Persistent keys are"]
#[doc = " preserved until the application explicitly destroys them or until an"]
#[doc = " integration-specific device management event occurs (for example,"]
#[doc = " a factory reset)."]
#[doc = ""]
#[doc = " Persistent keys have a key identifier of type #mbedtls_svc_key_id_t."]
#[doc = " This identifier remains valid throughout the lifetime of the key,"]
#[doc = " even if the application instance that created the key terminates."]
#[doc = " The application can call psa_open_key() to open a persistent key that"]
#[doc = " it created previously."]
#[doc = ""]
#[doc = " The default lifetime of a key is #PSA_KEY_LIFETIME_VOLATILE. The lifetime"]
#[doc = " #PSA_KEY_LIFETIME_PERSISTENT is supported if persistent storage is"]
#[doc = " available. Other lifetime values may be supported depending on the"]
#[doc = " library configuration."]
#[doc = ""]
#[doc = " Values of this type are generally constructed by macros called"]
#[doc = " `PSA_KEY_LIFETIME_xxx`."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_key_lifetime_t = u32;
#[doc = " Encoding of key persistence levels."]
#[doc = ""]
#[doc = " What distinguishes different persistence levels is what device management"]
#[doc = " events may cause keys to be destroyed. _Volatile_ keys are destroyed"]
#[doc = " by a power reset. Persistent keys may be destroyed by events such as"]
#[doc = " a transfer of ownership or a factory reset. What management events"]
#[doc = " actually affect persistent keys at different levels is outside the"]
#[doc = " scope of the PSA Cryptography specification."]
#[doc = ""]
#[doc = " The PSA Cryptography specification defines the following values of"]
#[doc = " persistence levels:"]
#[doc = " - \\c 0 = #PSA_KEY_PERSISTENCE_VOLATILE: volatile key."]
#[doc = "   A volatile key is automatically destroyed by the implementation when"]
#[doc = "   the application instance terminates. In particular, a volatile key"]
#[doc = "   is automatically destroyed on a power reset of the device."]
#[doc = " - \\c 1 = #PSA_KEY_PERSISTENCE_DEFAULT:"]
#[doc = "   persistent key with a default lifetime."]
#[doc = " - \\c 2-254: currently not supported by Mbed TLS."]
#[doc = " - \\c 255 = #PSA_KEY_PERSISTENCE_READ_ONLY:"]
#[doc = "   read-only or write-once key."]
#[doc = "   A key with this persistence level cannot be destroyed."]
#[doc = "   Mbed TLS does not currently offer a way to create such keys, but"]
#[doc = "   integrations of Mbed TLS can use it for built-in keys that the"]
#[doc = "   application cannot modify (for example, a hardware unique key (HUK))."]
#[doc = ""]
#[doc = " \\note Key persistence levels are 8-bit values. Key management"]
#[doc = "       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which"]
#[doc = "       encode the persistence as the lower 8 bits of a 32-bit value."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_key_persistence_t = u8;
#[doc = " Encoding of key location indicators."]
#[doc = ""]
#[doc = " If an integration of Mbed TLS can make calls to external"]
#[doc = " cryptoprocessors such as secure elements, the location of a key"]
#[doc = " indicates which secure element performs the operations on the key."]
#[doc = " Depending on the design of the secure element, the key"]
#[doc = " material may be stored either in the secure element, or"]
#[doc = " in wrapped (encrypted) form alongside the key metadata in the"]
#[doc = " primary local storage."]
#[doc = ""]
#[doc = " The PSA Cryptography API specification defines the following values of"]
#[doc = " location indicators:"]
#[doc = " - \\c 0: primary local storage."]
#[doc = "   This location is always available."]
#[doc = "   The primary local storage is typically the same storage area that"]
#[doc = "   contains the key metadata."]
#[doc = " - \\c 1: primary secure element."]
#[doc = "   Integrations of Mbed TLS should support this value if there is a secure"]
#[doc = "   element attached to the operating environment."]
#[doc = "   As a guideline, secure elements may provide higher resistance against"]
#[doc = "   side channel and physical attacks than the primary local storage, but may"]
#[doc = "   have restrictions on supported key types, sizes, policies and operations"]
#[doc = "   and may have different performance characteristics."]
#[doc = " - \\c 2-0x7fffff: other locations defined by a PSA specification."]
#[doc = "   The PSA Cryptography API does not currently assign any meaning to these"]
#[doc = "   locations, but future versions of that specification or other PSA"]
#[doc = "   specifications may do so."]
#[doc = " - \\c 0x800000-0xffffff: vendor-defined locations."]
#[doc = "   No PSA specification will assign a meaning to locations in this range."]
#[doc = ""]
#[doc = " \\note Key location indicators are 24-bit values. Key management"]
#[doc = "       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which"]
#[doc = "       encode the location as the upper 24 bits of a 32-bit value."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_key_location_t = u32;
#[doc = " Encoding of identifiers of persistent keys."]
#[doc = ""]
#[doc = " - Applications may freely choose key identifiers in the range"]
#[doc = "   #PSA_KEY_ID_USER_MIN to #PSA_KEY_ID_USER_MAX."]
#[doc = " - The implementation may define additional key identifiers in the range"]
#[doc = "   #PSA_KEY_ID_VENDOR_MIN to #PSA_KEY_ID_VENDOR_MAX."]
#[doc = " - 0 is reserved as an invalid key identifier."]
#[doc = " - Key identifiers outside these ranges are reserved for future use."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to how values are allocated must require careful"]
#[doc = "       consideration to allow backward compatibility."]
pub type psa_key_id_t = u32;
pub type mbedtls_svc_key_id_t = psa_key_id_t;
#[doc = " \\brief Encoding of permitted usage on a key."]
#[doc = ""]
#[doc = " Values of this type are generally constructed as bitwise-ors of macros"]
#[doc = " called `PSA_KEY_USAGE_xxx`."]
#[doc = ""]
#[doc = " \\note Values of this type are encoded in the persistent key store."]
#[doc = "       Any changes to existing values will require bumping the storage"]
#[doc = "       format version and providing a translation when reading the old"]
#[doc = "       format."]
pub type psa_key_usage_t = u32;
#[doc = " The type of a structure containing key attributes."]
#[doc = ""]
#[doc = " This is an opaque structure that can represent the metadata of a key"]
#[doc = " object. Metadata that can be stored in attributes includes:"]
#[doc = " - The location of the key in storage, indicated by its key identifier"]
#[doc = "   and its lifetime."]
#[doc = " - The key's policy, comprising usage flags and a specification of"]
#[doc = "   the permitted algorithm(s)."]
#[doc = " - Information about the key itself: the key type and its size."]
#[doc = " - Additional implementation-defined attributes."]
#[doc = ""]
#[doc = " The actual key material is not considered an attribute of a key."]
#[doc = " Key attributes do not contain information that is generally considered"]
#[doc = " highly confidential."]
#[doc = ""]
#[doc = " An attribute structure works like a simple data structure where each function"]
#[doc = " `psa_set_key_xxx` sets a field and the corresponding function"]
#[doc = " `psa_get_key_xxx` retrieves the value of the corresponding field."]
#[doc = " However, a future version of the library  may report values that are"]
#[doc = " equivalent to the original one, but have a different encoding. Invalid"]
#[doc = " values may be mapped to different, also invalid values."]
#[doc = ""]
#[doc = " An attribute structure may contain references to auxiliary resources,"]
#[doc = " for example pointers to allocated memory or indirect references to"]
#[doc = " pre-calculated values. In order to free such resources, the application"]
#[doc = " must call psa_reset_key_attributes(). As an exception, calling"]
#[doc = " psa_reset_key_attributes() on an attribute structure is optional if"]
#[doc = " the structure has only been modified by the following functions"]
#[doc = " since it was initialized or last reset with psa_reset_key_attributes():"]
#[doc = " - psa_set_key_id()"]
#[doc = " - psa_set_key_lifetime()"]
#[doc = " - psa_set_key_type()"]
#[doc = " - psa_set_key_bits()"]
#[doc = " - psa_set_key_usage_flags()"]
#[doc = " - psa_set_key_algorithm()"]
#[doc = ""]
#[doc = " Before calling any function on a key attribute structure, the application"]
#[doc = " must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes;"]
#[doc = "   memset(&attributes, 0, sizeof(attributes));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_KEY_ATTRIBUTES_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_key_attributes_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes;"]
#[doc = "   attributes = psa_key_attributes_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " A freshly initialized attribute structure contains the following"]
#[doc = " values:"]
#[doc = ""]
#[doc = " - lifetime: #PSA_KEY_LIFETIME_VOLATILE."]
#[doc = " - key identifier: 0 (which is not a valid key identifier)."]
#[doc = " - type: \\c 0 (meaning that the type is unspecified)."]
#[doc = " - key size: \\c 0 (meaning that the size is unspecified)."]
#[doc = " - usage flags: \\c 0 (which allows no usage except exporting a public key)."]
#[doc = " - algorithm: \\c 0 (which allows no cryptographic usage, but allows"]
#[doc = "   exporting)."]
#[doc = ""]
#[doc = " A typical sequence to create a key is as follows:"]
#[doc = " -# Create and initialize an attribute structure."]
#[doc = " -# If the key is persistent, call psa_set_key_id()."]
#[doc = "    Also call psa_set_key_lifetime() to place the key in a non-default"]
#[doc = "    location."]
#[doc = " -# Set the key policy with psa_set_key_usage_flags() and"]
#[doc = "    psa_set_key_algorithm()."]
#[doc = " -# Set the key type with psa_set_key_type()."]
#[doc = "    Skip this step if copying an existing key with psa_copy_key()."]
#[doc = " -# When generating a random key with psa_generate_key() or deriving a key"]
#[doc = "    with psa_key_derivation_output_key(), set the desired key size with"]
#[doc = "    psa_set_key_bits()."]
#[doc = " -# Call a key creation function: psa_import_key(), psa_generate_key(),"]
#[doc = "    psa_key_derivation_output_key() or psa_copy_key(). This function reads"]
#[doc = "    the attribute structure, creates a key with these attributes, and"]
#[doc = "    outputs a key identifier to the newly created key."]
#[doc = " -# The attribute structure is now no longer necessary."]
#[doc = "    You may call psa_reset_key_attributes(), although this is optional"]
#[doc = "    with the workflow presented here because the attributes currently"]
#[doc = "    defined in this specification do not require any additional resources"]
#[doc = "    beyond the structure itself."]
#[doc = ""]
#[doc = " A typical sequence to query a key's attributes is as follows:"]
#[doc = " -# Call psa_get_key_attributes()."]
#[doc = " -# Call `psa_get_key_xxx` functions to retrieve the attribute(s) that"]
#[doc = "    you are interested in."]
#[doc = " -# Call psa_reset_key_attributes() to free any resources that may be"]
#[doc = "    used by the attribute structure."]
#[doc = ""]
#[doc = " Once a key has been created, it is impossible to change its attributes."]
pub type psa_key_attributes_t = psa_key_attributes_s;
#[doc = " \\brief Encoding of the step of a key derivation."]
#[doc = ""]
#[doc = " Values of this type are generally constructed by macros called"]
#[doc = " `PSA_KEY_DERIVATION_INPUT_xxx`."]
pub type psa_key_derivation_step_t = u16;
extern "C" {
    #[doc = " \\brief Library initialization."]
    #[doc = ""]
    #[doc = " Applications must call this function before calling any other"]
    #[doc = " function in this module."]
    #[doc = ""]
    #[doc = " Applications may call this function more than once. Once a call"]
    #[doc = " succeeds, subsequent calls are guaranteed to succeed."]
    #[doc = ""]
    #[doc = " If the application calls other functions before calling psa_crypto_init(),"]
    #[doc = " the behavior is undefined. Implementations are encouraged to either perform"]
    #[doc = " the operation as if the library had been initialized or to return"]
    #[doc = " #PSA_ERROR_BAD_STATE or some other applicable error. In particular,"]
    #[doc = " implementations should not return a success status if the lack of"]
    #[doc = " initialization may have security implications, for example due to improper"]
    #[doc = " seeding of the random number generator."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    pub fn psa_crypto_init() -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the attributes of a key."]
    #[doc = ""]
    #[doc = " This function first resets the attribute structure as with"]
    #[doc = " psa_reset_key_attributes(). It then copies the attributes of"]
    #[doc = " the given key into the given attribute structure."]
    #[doc = ""]
    #[doc = " \\note This function may allocate memory or other resources."]
    #[doc = "       Once you have called this function on an attribute structure,"]
    #[doc = "       you must call psa_reset_key_attributes() to free these resources."]
    #[doc = ""]
    #[doc = " \\param[in] key               Identifier of the key to query."]
    #[doc = " \\param[in,out] attributes    On success, the attributes of the key."]
    #[doc = "                              On failure, equivalent to a"]
    #[doc = "                              freshly-initialized structure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_get_key_attributes(
        key: mbedtls_svc_key_id_t,
        attributes: *mut psa_key_attributes_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Reset a key attribute structure to a freshly initialized state."]
    #[doc = ""]
    #[doc = " You must initialize the attribute structure as described in the"]
    #[doc = " documentation of the type #psa_key_attributes_t before calling this"]
    #[doc = " function. Once the structure has been initialized, you may call this"]
    #[doc = " function at any time."]
    #[doc = ""]
    #[doc = " This function frees any auxiliary resources that the structure"]
    #[doc = " may contain."]
    #[doc = ""]
    #[doc = " \\param[in,out] attributes    The attribute structure to reset."]
    pub fn psa_reset_key_attributes(attributes: *mut psa_key_attributes_t);
}
extern "C" {
    #[doc = " Remove non-essential copies of key material from memory."]
    #[doc = ""]
    #[doc = " If the key identifier designates a volatile key, this functions does not do"]
    #[doc = " anything and returns successfully."]
    #[doc = ""]
    #[doc = " If the key identifier designates a persistent key, then this function will"]
    #[doc = " free all resources associated with the key in volatile memory. The key"]
    #[doc = " data in persistent storage is not affected and the key can still be used."]
    #[doc = ""]
    #[doc = " \\param key Identifier of the key to purge."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The key material will have been removed from memory if it is not"]
    #[doc = "         currently required."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not a valid key identifier."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_purge_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Make a copy of a key."]
    #[doc = ""]
    #[doc = " Copy key material from one location to another."]
    #[doc = ""]
    #[doc = " This function is primarily useful to copy a key from one location"]
    #[doc = " to another, since it populates a key using the material from"]
    #[doc = " another key which may have a different lifetime."]
    #[doc = ""]
    #[doc = " This function may be used to share a key with a different party,"]
    #[doc = " subject to implementation-defined restrictions on key sharing."]
    #[doc = ""]
    #[doc = " The policy on the source key must have the usage flag"]
    #[doc = " #PSA_KEY_USAGE_COPY set."]
    #[doc = " This flag is sufficient to permit the copy if the key has the lifetime"]
    #[doc = " #PSA_KEY_LIFETIME_VOLATILE or #PSA_KEY_LIFETIME_PERSISTENT."]
    #[doc = " Some secure elements do not provide a way to copy a key without"]
    #[doc = " making it extractable from the secure element. If a key is located"]
    #[doc = " in such a secure element, then the key must have both usage flags"]
    #[doc = " #PSA_KEY_USAGE_COPY and #PSA_KEY_USAGE_EXPORT in order to make"]
    #[doc = " a copy of the key outside the secure element."]
    #[doc = ""]
    #[doc = " The resulting key may only be used in a way that conforms to"]
    #[doc = " both the policy of the original key and the policy specified in"]
    #[doc = " the \\p attributes parameter:"]
    #[doc = " - The usage flags on the resulting key are the bitwise-and of the"]
    #[doc = "   usage flags on the source policy and the usage flags in \\p attributes."]
    #[doc = " - If both allow the same algorithm or wildcard-based"]
    #[doc = "   algorithm policy, the resulting key has the same algorithm policy."]
    #[doc = " - If either of the policies allows an algorithm and the other policy"]
    #[doc = "   allows a wildcard-based algorithm policy that includes this algorithm,"]
    #[doc = "   the resulting key allows the same algorithm."]
    #[doc = " - If the policies do not allow any algorithm in common, this function"]
    #[doc = "   fails with the status #PSA_ERROR_INVALID_ARGUMENT."]
    #[doc = ""]
    #[doc = " The effect of this function on implementation-defined attributes is"]
    #[doc = " implementation-defined."]
    #[doc = ""]
    #[doc = " \\param source_key        The key to copy. It must allow the usage"]
    #[doc = "                          #PSA_KEY_USAGE_COPY. If a private or secret key is"]
    #[doc = "                          being copied outside of a secure element it must"]
    #[doc = "                          also allow #PSA_KEY_USAGE_EXPORT."]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = "                          They are used as follows:"]
    #[doc = "                          - The key type and size may be 0. If either is"]
    #[doc = "                            nonzero, it must match the corresponding"]
    #[doc = "                            attribute of the source key."]
    #[doc = "                          - The key location (the lifetime and, for"]
    #[doc = "                            persistent keys, the key identifier) is"]
    #[doc = "                            used directly."]
    #[doc = "                          - The policy constraints (usage flags and"]
    #[doc = "                            algorithm policy) are combined from"]
    #[doc = "                            the source key and \\p attributes so that"]
    #[doc = "                            both sets of restrictions apply, as"]
    #[doc = "                            described in the documentation of this function."]
    #[doc = " \\param[out] target_key   On success, an identifier for the newly created"]
    #[doc = "                          key. For persistent keys, this is the key"]
    #[doc = "                          identifier defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         \\p source_key is invalid."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The lifetime or identifier in \\p attributes are invalid, or"]
    #[doc = "         the policy constraints on the source and specified in"]
    #[doc = "         \\p attributes are incompatible, or"]
    #[doc = "         \\p attributes specifies a key type or key size"]
    #[doc = "         which does not match the attributes of the source key."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The source key does not have the #PSA_KEY_USAGE_COPY usage flag, or"]
    #[doc = "         the source key is not exportable and its lifetime does not"]
    #[doc = "         allow copying it to the target's lifetime."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_copy_key(
        source_key: mbedtls_svc_key_id_t,
        attributes: *const psa_key_attributes_t,
        target_key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Destroy a key."]
    #[doc = ""]
    #[doc = " This function destroys a key from both volatile"]
    #[doc = " memory and, if applicable, non-volatile storage. Implementations shall"]
    #[doc = " make a best effort to ensure that the key material cannot be recovered."]
    #[doc = ""]
    #[doc = " This function also erases any metadata such as policies and frees"]
    #[doc = " resources associated with the key."]
    #[doc = ""]
    #[doc = " If a key is currently in use in a multipart operation, then destroying the"]
    #[doc = " key will cause the multipart operation to fail."]
    #[doc = ""]
    #[doc = " \\param key  Identifier of the key to erase. If this is \\c 0, do nothing and"]
    #[doc = "             return #PSA_SUCCESS."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         \\p key was a valid identifier and the key material that it"]
    #[doc = "         referred to has been erased. Alternatively, \\p key is \\c 0."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key cannot be erased because it is"]
    #[doc = "         read-only, either due to a policy or due to physical restrictions."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         \\p key is not a valid identifier nor \\c 0."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = "         There was a failure in communication with the cryptoprocessor."]
    #[doc = "         The key material may still be present in the cryptoprocessor."]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = "         This error is typically a result of either storage corruption on a"]
    #[doc = "         cleartext storage backend, or an attempt to read data that was"]
    #[doc = "         written by an incompatible version of the library."]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The storage is corrupted. Implementations shall make a best effort"]
    #[doc = "         to erase key material even in this stage, however applications"]
    #[doc = "         should be aware that it may be impossible to guarantee that the"]
    #[doc = "         key material is not recoverable in such cases."]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = "         An unexpected condition which is not a storage corruption or"]
    #[doc = "         a communication failure occurred. The cryptoprocessor may have"]
    #[doc = "         been compromised."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_destroy_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Import a key in binary format."]
    #[doc = ""]
    #[doc = " This function supports any output from psa_export_key(). Refer to the"]
    #[doc = " documentation of psa_export_public_key() for the format of public keys"]
    #[doc = " and to the documentation of psa_export_key() for the format for"]
    #[doc = " other key types."]
    #[doc = ""]
    #[doc = " The key data determines the key size. The attributes may optionally"]
    #[doc = " specify a key size; in this case it must match the size determined"]
    #[doc = " from the key data. A key size of 0 in \\p attributes indicates that"]
    #[doc = " the key size is solely determined by the key data."]
    #[doc = ""]
    #[doc = " Implementations must reject an attempt to import a key of size 0."]
    #[doc = ""]
    #[doc = " This specification supports a single format for each key type."]
    #[doc = " Implementations may support other formats as long as the standard"]
    #[doc = " format is supported. Implementations that support other formats"]
    #[doc = " should ensure that the formats are clearly unambiguous so as to"]
    #[doc = " minimize the risk that an invalid input is accidentally interpreted"]
    #[doc = " according to a different format."]
    #[doc = ""]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = "                          The key size is always determined from the"]
    #[doc = "                          \\p data buffer."]
    #[doc = "                          If the key size in \\p attributes is nonzero,"]
    #[doc = "                          it must be equal to the size from \\p data."]
    #[doc = " \\param[out] key          On success, an identifier to the newly created key."]
    #[doc = "                          For persistent keys, this is the key identifier"]
    #[doc = "                          defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = " \\param[in] data    Buffer containing the key data. The content of this"]
    #[doc = "                    buffer is interpreted according to the type declared"]
    #[doc = "                    in \\p attributes."]
    #[doc = "                    All implementations must support at least the format"]
    #[doc = "                    described in the documentation"]
    #[doc = "                    of psa_export_key() or psa_export_public_key() for"]
    #[doc = "                    the chosen type. Implementations may allow other"]
    #[doc = "                    formats, but should be conservative: implementations"]
    #[doc = "                    should err on the side of rejecting content if it"]
    #[doc = "                    may be erroneous (e.g. wrong type or truncated data)."]
    #[doc = " \\param data_length Size of the \\p data buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = "         If the key is persistent, the key material and the key's metadata"]
    #[doc = "         have been saved to persistent storage."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The key type or key size is not supported, either by the"]
    #[doc = "         implementation in general or in this particular persistent location."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key attributes, as a whole, are invalid, or"]
    #[doc = "         the key data is not correctly formatted, or"]
    #[doc = "         the size in \\p attributes is nonzero and does not match the size"]
    #[doc = "         of the key data."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_import_key(
        attributes: *const psa_key_attributes_t,
        data: *const u8,
        data_length: size_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a key in binary format."]
    #[doc = ""]
    #[doc = " The output of this function can be passed to psa_import_key() to"]
    #[doc = " create an equivalent object."]
    #[doc = ""]
    #[doc = " If the implementation of psa_import_key() supports other formats"]
    #[doc = " beyond the format specified here, the output from psa_export_key()"]
    #[doc = " must use the representation specified here, not the original"]
    #[doc = " representation."]
    #[doc = ""]
    #[doc = " For standard key types, the output format is as follows:"]
    #[doc = ""]
    #[doc = " - For symmetric keys (including MAC keys), the format is the"]
    #[doc = "   raw bytes of the key."]
    #[doc = " - For DES, the key data consists of 8 bytes. The parity bits must be"]
    #[doc = "   correct."]
    #[doc = " - For Triple-DES, the format is the concatenation of the"]
    #[doc = "   two or three DES keys."]
    #[doc = " - For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format"]
    #[doc = "   is the non-encrypted DER encoding of the representation defined by"]
    #[doc = "   PKCS\\#1 (RFC 8017) as `RSAPrivateKey`, version 0."]
    #[doc = "   ```"]
    #[doc = "   RSAPrivateKey ::= SEQUENCE {"]
    #[doc = "       version             INTEGER,  -- must be 0"]
    #[doc = "       modulus             INTEGER,  -- n"]
    #[doc = "       publicExponent      INTEGER,  -- e"]
    #[doc = "       privateExponent     INTEGER,  -- d"]
    #[doc = "       prime1              INTEGER,  -- p"]
    #[doc = "       prime2              INTEGER,  -- q"]
    #[doc = "       exponent1           INTEGER,  -- d mod (p-1)"]
    #[doc = "       exponent2           INTEGER,  -- d mod (q-1)"]
    #[doc = "       coefficient         INTEGER,  -- (inverse of q) mod p"]
    #[doc = "   }"]
    #[doc = "   ```"]
    #[doc = " - For elliptic curve key pairs (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is"]
    #[doc = "   a representation of the private value as a `ceiling(m/8)`-byte string"]
    #[doc = "   where `m` is the bit size associated with the curve, i.e. the bit size"]
    #[doc = "   of the order of the curve's coordinate field. This byte string is"]
    #[doc = "   in little-endian order for Montgomery curves (curve types"]
    #[doc = "   `PSA_ECC_FAMILY_CURVEXXX`), and in big-endian order for Weierstrass"]
    #[doc = "   curves (curve types `PSA_ECC_FAMILY_SECTXXX`, `PSA_ECC_FAMILY_SECPXXX`"]
    #[doc = "   and `PSA_ECC_FAMILY_BRAINPOOL_PXXX`)."]
    #[doc = "   For Weierstrass curves, this is the content of the `privateKey` field of"]
    #[doc = "   the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,"]
    #[doc = "   the format is defined by RFC 7748, and output is masked according to 5."]
    #[doc = "   For twisted Edwards curves, the private key is as defined by RFC 8032"]
    #[doc = "   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448)."]
    #[doc = " - For Diffie-Hellman key exchange key pairs (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the"]
    #[doc = "   format is the representation of the private key `x` as a big-endian byte"]
    #[doc = "   string. The length of the byte string is the private key size in bytes"]
    #[doc = "   (leading zeroes are not stripped)."]
    #[doc = " - For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is"]
    #[doc = "   true), the format is the same as for psa_export_public_key()."]
    #[doc = ""]
    #[doc = " The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to export. It must allow the"]
    #[doc = "                          usage #PSA_KEY_USAGE_EXPORT, unless it is a public"]
    #[doc = "                          key."]
    #[doc = " \\param[out] data         Buffer where the key data is to be written."]
    #[doc = " \\param data_size         Size of the \\p data buffer in bytes."]
    #[doc = " \\param[out] data_length  On success, the number of bytes"]
    #[doc = "                          that make up the key data."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_EXPORT flag."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p data buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling"]
    #[doc = "         #PSA_EXPORT_KEY_OUTPUT_SIZE(\\c type, \\c bits)"]
    #[doc = "         where \\c type is the key type"]
    #[doc = "         and \\c bits is the key size in bits."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_export_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: size_t,
        data_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a public key or the public part of a key pair in binary format."]
    #[doc = ""]
    #[doc = " The output of this function can be passed to psa_import_key() to"]
    #[doc = " create an object that is equivalent to the public key."]
    #[doc = ""]
    #[doc = " This specification supports a single format for each key type."]
    #[doc = " Implementations may support other formats as long as the standard"]
    #[doc = " format is supported. Implementations that support other formats"]
    #[doc = " should ensure that the formats are clearly unambiguous so as to"]
    #[doc = " minimize the risk that an invalid input is accidentally interpreted"]
    #[doc = " according to a different format."]
    #[doc = ""]
    #[doc = " For standard key types, the output format is as follows:"]
    #[doc = " - For RSA public keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY), the DER encoding of"]
    #[doc = "   the representation defined by RFC 3279 &sect;2.3.1 as `RSAPublicKey`."]
    #[doc = "   ```"]
    #[doc = "   RSAPublicKey ::= SEQUENCE {"]
    #[doc = "      modulus            INTEGER,    -- n"]
    #[doc = "      publicExponent     INTEGER  }  -- e"]
    #[doc = "   ```"]
    #[doc = " - For elliptic curve keys on a twisted Edwards curve (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY"]
    #[doc = "   returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined"]
    #[doc = "   by RFC 8032"]
    #[doc = "   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448)."]
    #[doc = " - For other elliptic curve public keys (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed"]
    #[doc = "   representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint."]
    #[doc = "   Let `m` be the bit size associated with the curve, i.e. the bit size of"]
    #[doc = "   `q` for a curve over `F_q`. The representation consists of:"]
    #[doc = "      - The byte 0x04;"]
    #[doc = "      - `x_P` as a `ceiling(m/8)`-byte string, big-endian;"]
    #[doc = "      - `y_P` as a `ceiling(m/8)`-byte string, big-endian."]
    #[doc = " - For Diffie-Hellman key exchange public keys (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_DH_PUBLIC_KEY is true),"]
    #[doc = "   the format is the representation of the public key `y = g^x mod p` as a"]
    #[doc = "   big-endian byte string. The length of the byte string is the length of the"]
    #[doc = "   base prime `p` in bytes."]
    #[doc = ""]
    #[doc = " Exporting a public key object or the public part of a key pair is"]
    #[doc = " always permitted, regardless of the key's usage flags."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to export."]
    #[doc = " \\param[out] data         Buffer where the key data is to be written."]
    #[doc = " \\param data_size         Size of the \\p data buffer in bytes."]
    #[doc = " \\param[out] data_length  On success, the number of bytes"]
    #[doc = "                          that make up the key data."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key is neither a public key nor a key pair."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p data buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling"]
    #[doc = "         #PSA_EXPORT_KEY_OUTPUT_SIZE(#PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(\\c type), \\c bits)"]
    #[doc = "         where \\c type is the key type"]
    #[doc = "         and \\c bits is the key size in bits."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_export_public_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: size_t,
        data_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message."]
    #[doc = ""]
    #[doc = " \\note To verify the hash of a message against an"]
    #[doc = "       expected value, use psa_hash_compare() instead."]
    #[doc = ""]
    #[doc = " \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_HASH(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the message to hash."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] hash         Buffer where the hash is to be written."]
    #[doc = " \\param hash_size         Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[out] hash_length  On success, the number of bytes"]
    #[doc = "                          that make up the hash value. This is always"]
    #[doc = "                          #PSA_HASH_LENGTH(\\p alg)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p hash_size is too small"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_compute(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        hash: *mut u8,
        hash_size: size_t,
        hash_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message and compare it with a"]
    #[doc = " reference value."]
    #[doc = ""]
    #[doc = " \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_HASH(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the message to hash."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] hash         Buffer containing the expected hash value."]
    #[doc = " \\param hash_length       Size of the \\p hash buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected hash is identical to the actual hash of the input."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The hash of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected hash."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p input_length or \\p hash_length do not match the hash size for \\p alg"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_compare(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        hash: *const u8,
        hash_length: size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart hash operations."]
#[doc = ""]
#[doc = " Before calling any function on a hash operation object, the application must"]
#[doc = " initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_HASH_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_hash_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation;"]
#[doc = "   operation = psa_hash_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_hash_operation_t = psa_hash_operation_s;
extern "C" {
    #[doc = " Set up a multipart hash operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to calculate a hash (message digest)"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_hash_operation_t, e.g. #PSA_HASH_OPERATION_INIT."]
    #[doc = " -# Call psa_hash_setup() to specify the algorithm."]
    #[doc = " -# Call psa_hash_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time. The hash that is calculated is the hash"]
    #[doc = "    of the concatenation of these messages in order."]
    #[doc = " -# To calculate the hash, call psa_hash_finish()."]
    #[doc = "    To compare the hash with an expected value, call psa_hash_verify()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_hash_setup(), the"]
    #[doc = " operation will need to be reset by a call to psa_hash_abort(). The"]
    #[doc = " application may call psa_hash_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_hash_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_hash_finish() or psa_hash_verify()."]
    #[doc = " - A call to psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The operation object to set up. It must have"]
    #[doc = "                          been initialized as per the documentation for"]
    #[doc = "                          #psa_hash_operation_t and not yet in use."]
    #[doc = " \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_HASH(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not a supported hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p alg is not a hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_setup(
        operation: *mut psa_hash_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart hash operation."]
    #[doc = ""]
    #[doc = " The application must call psa_hash_setup() before calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active hash operation."]
    #[doc = " \\param[in] input         Buffer containing the message fragment to hash."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_update(
        operation: *mut psa_hash_operation_t,
        input: *const u8,
        input_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message."]
    #[doc = ""]
    #[doc = " The application must call psa_hash_setup() before calling this function."]
    #[doc = " This function calculates the hash of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_hash_update()."]
    #[doc = ""]
    #[doc = " When this function returns successfully, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\warning Applications should not call this function if they expect"]
    #[doc = "          a specific value for the hash. Call psa_hash_verify() instead."]
    #[doc = "          Beware that comparing integrity or authenticity data such as"]
    #[doc = "          hash values with a function such as \\c memcmp is risky"]
    #[doc = "          because the time taken by the comparison may leak information"]
    #[doc = "          about the hashed data which could allow an attacker to guess"]
    #[doc = "          a valid hash and thereby bypass security controls."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active hash operation."]
    #[doc = " \\param[out] hash             Buffer where the hash is to be written."]
    #[doc = " \\param hash_size             Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[out] hash_length      On success, the number of bytes"]
    #[doc = "                              that make up the hash value. This is always"]
    #[doc = "                              #PSA_HASH_LENGTH(\\c alg) where \\c alg is the"]
    #[doc = "                              hash algorithm that is calculated."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p hash buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling #PSA_HASH_LENGTH(\\c alg)"]
    #[doc = "         where \\c alg is the hash algorithm that is calculated."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_finish(
        operation: *mut psa_hash_operation_t,
        hash: *mut u8,
        hash_size: size_t,
        hash_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message and compare it with"]
    #[doc = " an expected value."]
    #[doc = ""]
    #[doc = " The application must call psa_hash_setup() before calling this function."]
    #[doc = " This function calculates the hash of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_hash_update(). It then"]
    #[doc = " compares the calculated hash with the expected hash passed as a"]
    #[doc = " parameter to this function."]
    #[doc = ""]
    #[doc = " When this function returns successfully, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\note Implementations shall make the best effort to ensure that the"]
    #[doc = " comparison between the actual hash and the expected hash is performed"]
    #[doc = " in constant time."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active hash operation."]
    #[doc = " \\param[in] hash              Buffer containing the expected hash value."]
    #[doc = " \\param hash_length           Size of the \\p hash buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected hash is identical to the actual hash of the message."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The hash of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected hash."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_verify(
        operation: *mut psa_hash_operation_t,
        hash: *const u8,
        hash_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a hash operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_hash_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized by one of the methods described in #psa_hash_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_hash_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_hash_abort(), psa_hash_finish() or"]
    #[doc = " psa_hash_verify() is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Initialized hash operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_abort(operation: *mut psa_hash_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Clone a hash operation."]
    #[doc = ""]
    #[doc = " This function copies the state of an ongoing hash operation to"]
    #[doc = " a new operation object. In other words, this function is equivalent"]
    #[doc = " to calling psa_hash_setup() on \\p target_operation with the same"]
    #[doc = " algorithm that \\p source_operation was set up for, then"]
    #[doc = " psa_hash_update() on \\p target_operation with the same input that"]
    #[doc = " that was passed to \\p source_operation. After this function returns, the"]
    #[doc = " two objects are independent, i.e. subsequent calls involving one of"]
    #[doc = " the objects do not affect the other object."]
    #[doc = ""]
    #[doc = " \\param[in] source_operation      The active hash operation to clone."]
    #[doc = " \\param[in,out] target_operation  The operation object to set up."]
    #[doc = "                                  It must be initialized but not active."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The \\p source_operation state is not valid (it must be active), or"]
    #[doc = "         the \\p target_operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_clone(
        source_operation: *const psa_hash_operation_t,
        target_operation: *mut psa_hash_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC (message authentication code) of a message."]
    #[doc = ""]
    #[doc = " \\note To verify the MAC of a message against an"]
    #[doc = "       expected value, use psa_mac_verify() instead."]
    #[doc = "       Beware that comparing integrity or authenticity data such as"]
    #[doc = "       MAC values with a function such as \\c memcmp is risky"]
    #[doc = "       because the time taken by the comparison may leak information"]
    #[doc = "       about the MAC value which could allow an attacker to guess"]
    #[doc = "       a valid MAC and thereby bypass security controls."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the input message."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] mac          Buffer where the MAC value is to be written."]
    #[doc = " \\param mac_size          Size of the \\p mac buffer in bytes."]
    #[doc = " \\param[out] mac_length   On success, the number of bytes"]
    #[doc = "                          that make up the MAC value."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p mac_size is too small"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_compute(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        mac: *mut u8,
        mac_size: size_t,
        mac_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC of a message and compare it with a reference value."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must allow the usage PSA_KEY_USAGE_VERIFY_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the input message."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] mac          Buffer containing the expected MAC value."]
    #[doc = " \\param mac_length        Size of the \\p mac buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected MAC is identical to the actual MAC of the input."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The MAC of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected value."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_verify(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        mac: *const u8,
        mac_length: size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart MAC operations."]
#[doc = ""]
#[doc = " Before calling any function on a MAC operation object, the application must"]
#[doc = " initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_MAC_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_mac_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation;"]
#[doc = "   operation = psa_mac_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_mac_operation_t = psa_mac_operation_s;
extern "C" {
    #[doc = " Set up a multipart MAC calculation operation."]
    #[doc = ""]
    #[doc = " This function sets up the calculation of the MAC"]
    #[doc = " (message authentication code) of a byte string."]
    #[doc = " To verify the MAC of a message against an"]
    #[doc = " expected value, use psa_mac_verify_setup() instead."]
    #[doc = ""]
    #[doc = " The sequence of operations to calculate a MAC is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT."]
    #[doc = " -# Call psa_mac_sign_setup() to specify the algorithm and key."]
    #[doc = " -# Call psa_mac_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time. The MAC that is calculated is the MAC"]
    #[doc = "    of the concatenation of these messages in order."]
    #[doc = " -# At the end of the message, call psa_mac_sign_finish() to finish"]
    #[doc = "    calculating the MAC value and retrieve it."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_mac_sign_setup(), the"]
    #[doc = " operation will need to be reset by a call to psa_mac_abort(). The"]
    #[doc = " application may call psa_mac_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_mac_sign_setup(), the application must"]
    #[doc = " eventually terminate the operation through one of the following methods:"]
    #[doc = " - A successful call to psa_mac_sign_finish()."]
    #[doc = " - A call to psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The operation object to set up. It must have"]
    #[doc = "                          been initialized as per the documentation for"]
    #[doc = "                          #psa_mac_operation_t and not yet in use."]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must remain valid until the operation terminates."]
    #[doc = "                          It must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_sign_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set up a multipart MAC verification operation."]
    #[doc = ""]
    #[doc = " This function sets up the verification of the MAC"]
    #[doc = " (message authentication code) of a byte string against an expected value."]
    #[doc = ""]
    #[doc = " The sequence of operations to verify a MAC is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT."]
    #[doc = " -# Call psa_mac_verify_setup() to specify the algorithm and key."]
    #[doc = " -# Call psa_mac_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time. The MAC that is calculated is the MAC"]
    #[doc = "    of the concatenation of these messages in order."]
    #[doc = " -# At the end of the message, call psa_mac_verify_finish() to finish"]
    #[doc = "    calculating the actual MAC of the message and verify it against"]
    #[doc = "    the expected value."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_mac_verify_setup(), the"]
    #[doc = " operation will need to be reset by a call to psa_mac_abort(). The"]
    #[doc = " application may call psa_mac_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_mac_verify_setup(), the application must"]
    #[doc = " eventually terminate the operation through one of the following methods:"]
    #[doc = " - A successful call to psa_mac_verify_finish()."]
    #[doc = " - A call to psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The operation object to set up. It must have"]
    #[doc = "                          been initialized as per the documentation for"]
    #[doc = "                          #psa_mac_operation_t and not yet in use."]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must remain valid until the operation terminates."]
    #[doc = "                          It must allow the usage"]
    #[doc = "                          PSA_KEY_USAGE_VERIFY_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c key is not compatible with \\c alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\c alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_verify_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart MAC operation."]
    #[doc = ""]
    #[doc = " The application must call psa_mac_sign_setup() or psa_mac_verify_setup()"]
    #[doc = " before calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active MAC operation."]
    #[doc = " \\param[in] input         Buffer containing the message fragment to add to"]
    #[doc = "                          the MAC calculation."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_update(
        operation: *mut psa_mac_operation_t,
        input: *const u8,
        input_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message."]
    #[doc = ""]
    #[doc = " The application must call psa_mac_sign_setup() before calling this function."]
    #[doc = " This function calculates the MAC of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_mac_update()."]
    #[doc = ""]
    #[doc = " When this function returns successfully, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\warning Applications should not call this function if they expect"]
    #[doc = "          a specific value for the MAC. Call psa_mac_verify_finish() instead."]
    #[doc = "          Beware that comparing integrity or authenticity data such as"]
    #[doc = "          MAC values with a function such as \\c memcmp is risky"]
    #[doc = "          because the time taken by the comparison may leak information"]
    #[doc = "          about the MAC value which could allow an attacker to guess"]
    #[doc = "          a valid MAC and thereby bypass security controls."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active MAC operation."]
    #[doc = " \\param[out] mac          Buffer where the MAC value is to be written."]
    #[doc = " \\param mac_size          Size of the \\p mac buffer in bytes."]
    #[doc = " \\param[out] mac_length   On success, the number of bytes"]
    #[doc = "                          that make up the MAC value. This is always"]
    #[doc = "                          #PSA_MAC_LENGTH(\\c key_type, \\c key_bits, \\c alg)"]
    #[doc = "                          where \\c key_type and \\c key_bits are the type and"]
    #[doc = "                          bit-size respectively of the key and \\c alg is the"]
    #[doc = "                          MAC algorithm that is calculated."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p mac buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling PSA_MAC_LENGTH()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active mac sign"]
    #[doc = "         operation), or the library has not been previously initialized"]
    #[doc = "         by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_sign_finish(
        operation: *mut psa_mac_operation_t,
        mac: *mut u8,
        mac_size: size_t,
        mac_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message and compare it with"]
    #[doc = " an expected value."]
    #[doc = ""]
    #[doc = " The application must call psa_mac_verify_setup() before calling this function."]
    #[doc = " This function calculates the MAC of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_mac_update(). It then"]
    #[doc = " compares the calculated MAC with the expected MAC passed as a"]
    #[doc = " parameter to this function."]
    #[doc = ""]
    #[doc = " When this function returns successfully, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\note Implementations shall make the best effort to ensure that the"]
    #[doc = " comparison between the actual MAC and the expected MAC is performed"]
    #[doc = " in constant time."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active MAC operation."]
    #[doc = " \\param[in] mac           Buffer containing the expected MAC value."]
    #[doc = " \\param mac_length        Size of the \\p mac buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected MAC is identical to the actual MAC of the message."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The MAC of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected MAC."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active mac verify"]
    #[doc = "         operation), or the library has not been previously initialized"]
    #[doc = "         by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_verify_finish(
        operation: *mut psa_mac_operation_t,
        mac: *const u8,
        mac_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a MAC operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_mac_sign_setup() or psa_mac_verify_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized by one of the methods described in #psa_mac_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_mac_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_mac_abort(), psa_mac_sign_finish() or"]
    #[doc = " psa_mac_verify_finish() is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Initialized MAC operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_abort(operation: *mut psa_mac_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt a message using a symmetric cipher."]
    #[doc = ""]
    #[doc = " This function encrypts a message with a random IV (initialization"]
    #[doc = " vector). Use the multipart operation interface with a"]
    #[doc = " #psa_cipher_operation_t object to provide other forms of IV."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must allow the usage #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = " \\param[in] input             Buffer containing the message to encrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = "                              The output contains the IV followed by"]
    #[doc = "                              the ciphertext proper."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Decrypt a message using a symmetric cipher."]
    #[doc = ""]
    #[doc = " This function decrypts a message encrypted with a symmetric cipher."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = " \\param[in] input             Buffer containing the message to decrypt."]
    #[doc = "                              This consists of the IV followed by the"]
    #[doc = "                              ciphertext proper."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the plaintext is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart cipher operations."]
#[doc = ""]
#[doc = " Before calling any function on a cipher operation object, the application"]
#[doc = " must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_CIPHER_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_cipher_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation;"]
#[doc = "   operation = psa_cipher_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_cipher_operation_t = psa_cipher_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart symmetric encryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to encrypt a message with a symmetric cipher"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_cipher_operation_t, e.g."]
    #[doc = "    #PSA_CIPHER_OPERATION_INIT."]
    #[doc = " -# Call psa_cipher_encrypt_setup() to specify the algorithm and key."]
    #[doc = " -# Call either psa_cipher_generate_iv() or psa_cipher_set_iv() to"]
    #[doc = "    generate or set the IV (initialization vector). You should use"]
    #[doc = "    psa_cipher_generate_iv() unless the protocol you are implementing"]
    #[doc = "    requires a specific IV value."]
    #[doc = " -# Call psa_cipher_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time."]
    #[doc = " -# Call psa_cipher_finish()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_cipher_encrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_cipher_abort(). The"]
    #[doc = " application may call psa_cipher_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_cipher_encrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_cipher_finish()."]
    #[doc = " - A call to psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_cipher_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_encrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart symmetric decryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to decrypt a message with a symmetric cipher"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_cipher_operation_t, e.g."]
    #[doc = "    #PSA_CIPHER_OPERATION_INIT."]
    #[doc = " -# Call psa_cipher_decrypt_setup() to specify the algorithm and key."]
    #[doc = " -# Call psa_cipher_set_iv() with the IV (initialization vector) for the"]
    #[doc = "    decryption. If the IV is prepended to the ciphertext, you can call"]
    #[doc = "    psa_cipher_update() on a buffer containing the IV followed by the"]
    #[doc = "    beginning of the message."]
    #[doc = " -# Call psa_cipher_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time."]
    #[doc = " -# Call psa_cipher_finish()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_cipher_decrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_cipher_abort(). The"]
    #[doc = " application may call psa_cipher_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_cipher_decrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_cipher_finish()."]
    #[doc = " - A call to psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_cipher_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_decrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate an IV for a symmetric encryption operation."]
    #[doc = ""]
    #[doc = " This function generates a random IV (initialization vector), nonce"]
    #[doc = " or initial counter value for the encryption operation as appropriate"]
    #[doc = " for the chosen algorithm, key type and key size."]
    #[doc = ""]
    #[doc = " The application must call psa_cipher_encrypt_setup() before"]
    #[doc = " calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[out] iv               Buffer where the generated IV is to be written."]
    #[doc = " \\param iv_size               Size of the \\p iv buffer in bytes."]
    #[doc = " \\param[out] iv_length        On success, the number of bytes of the"]
    #[doc = "                              generated IV."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p iv buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with no IV set),"]
    #[doc = "         or the library has not been previously initialized"]
    #[doc = "         by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_generate_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *mut u8,
        iv_size: size_t,
        iv_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the IV for a symmetric encryption or decryption operation."]
    #[doc = ""]
    #[doc = " This function sets the IV (initialization vector), nonce"]
    #[doc = " or initial counter value for the encryption or decryption operation."]
    #[doc = ""]
    #[doc = " The application must call psa_cipher_encrypt_setup() before"]
    #[doc = " calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\note When encrypting, applications should use psa_cipher_generate_iv()"]
    #[doc = " instead of this function, unless implementing a protocol that requires"]
    #[doc = " a non-random IV."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[in] iv                Buffer containing the IV to use."]
    #[doc = " \\param iv_length             Size of the IV in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The size of \\p iv is not acceptable for the chosen algorithm,"]
    #[doc = "         or the chosen algorithm does not use an IV."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active cipher"]
    #[doc = "         encrypt operation, with no IV set), or the library has not been"]
    #[doc = "         previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_set_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *const u8,
        iv_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active cipher operation."]
    #[doc = ""]
    #[doc = " Before calling this function, you must:"]
    #[doc = " 1. Call either psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup()."]
    #[doc = "    The choice of setup function determines whether this function"]
    #[doc = "    encrypts or decrypts its input."]
    #[doc = " 2. If the algorithm requires an IV, call psa_cipher_generate_iv()"]
    #[doc = "    (recommended when encrypting) or psa_cipher_set_iv()."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[in] input             Buffer containing the message fragment to"]
    #[doc = "                              encrypt or decrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with an IV set"]
    #[doc = "         if required for the algorithm), or the library has not been"]
    #[doc = "         previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_update(
        operation: *mut psa_cipher_operation_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting or decrypting a message in a cipher operation."]
    #[doc = ""]
    #[doc = " The application must call psa_cipher_encrypt_setup() or"]
    #[doc = " psa_cipher_decrypt_setup() before calling this function. The choice"]
    #[doc = " of setup function determines whether this function encrypts or"]
    #[doc = " decrypts its input."]
    #[doc = ""]
    #[doc = " This function finishes the encryption or decryption of the message"]
    #[doc = " formed by concatenating the inputs passed to preceding calls to"]
    #[doc = " psa_cipher_update()."]
    #[doc = ""]
    #[doc = " When this function returns successfully, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total input size passed to this operation is not valid for"]
    #[doc = "         this particular algorithm. For example, the algorithm is a based"]
    #[doc = "         on block cipher and requires a whole number of blocks, but the"]
    #[doc = "         total input size is not a multiple of the block size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_PADDING"]
    #[doc = "         This is a decryption operation for an algorithm that includes"]
    #[doc = "         padding, and the ciphertext does not contain valid padding."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with an IV set"]
    #[doc = "         if required for the algorithm), or the library has not been"]
    #[doc = "         previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_finish(
        operation: *mut psa_cipher_operation_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a cipher operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized as described in #psa_cipher_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_cipher_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_cipher_abort() or psa_cipher_finish()"]
    #[doc = " is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Initialized cipher operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_abort(operation: *mut psa_cipher_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated encryption operation."]
    #[doc = ""]
    #[doc = " \\param key                     Identifier of the key to use for the"]
    #[doc = "                                operation. It must allow the usage"]
    #[doc = "                                #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                     The AEAD algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = " \\param[in] nonce               Nonce or IV to use."]
    #[doc = " \\param nonce_length            Size of the \\p nonce buffer in bytes."]
    #[doc = " \\param[in] additional_data     Additional data that will be authenticated"]
    #[doc = "                                but not encrypted."]
    #[doc = " \\param additional_data_length  Size of \\p additional_data in bytes."]
    #[doc = " \\param[in] plaintext           Data that will be authenticated and"]
    #[doc = "                                encrypted."]
    #[doc = " \\param plaintext_length        Size of \\p plaintext in bytes."]
    #[doc = " \\param[out] ciphertext         Output buffer for the authenticated and"]
    #[doc = "                                encrypted data. The additional data is not"]
    #[doc = "                                part of this output. For algorithms where the"]
    #[doc = "                                encrypted data and the authentication tag"]
    #[doc = "                                are defined as separate outputs, the"]
    #[doc = "                                authentication tag is appended to the"]
    #[doc = "                                encrypted data."]
    #[doc = " \\param ciphertext_size         Size of the \\p ciphertext buffer in bytes."]
    #[doc = "                                This must be appropriate for the selected"]
    #[doc = "                                algorithm and key:"]
    #[doc = "                                - A sufficient output size is"]
    #[doc = "                                  #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                  \\p alg, \\p plaintext_length) where"]
    #[doc = "                                  \\c key_type is the type of \\p key."]
    #[doc = "                                - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p"]
    #[doc = "                                  plaintext_length) evaluates to the maximum"]
    #[doc = "                                  ciphertext size of any supported AEAD"]
    #[doc = "                                  encryption."]
    #[doc = " \\param[out] ciphertext_length  On success, the size of the output"]
    #[doc = "                                in the \\p ciphertext buffer."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p ciphertext_size is too small."]
    #[doc = "         #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,"]
    #[doc = "         \\p plaintext_length) or"]
    #[doc = "         #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p plaintext_length) can be used to"]
    #[doc = "         determine the required buffer size."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: size_t,
        additional_data: *const u8,
        additional_data_length: size_t,
        plaintext: *const u8,
        plaintext_length: size_t,
        ciphertext: *mut u8,
        ciphertext_size: size_t,
        ciphertext_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated decryption operation."]
    #[doc = ""]
    #[doc = " \\param key                     Identifier of the key to use for the"]
    #[doc = "                                operation. It must allow the usage"]
    #[doc = "                                #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                     The AEAD algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = " \\param[in] nonce               Nonce or IV to use."]
    #[doc = " \\param nonce_length            Size of the \\p nonce buffer in bytes."]
    #[doc = " \\param[in] additional_data     Additional data that has been authenticated"]
    #[doc = "                                but not encrypted."]
    #[doc = " \\param additional_data_length  Size of \\p additional_data in bytes."]
    #[doc = " \\param[in] ciphertext          Data that has been authenticated and"]
    #[doc = "                                encrypted. For algorithms where the"]
    #[doc = "                                encrypted data and the authentication tag"]
    #[doc = "                                are defined as separate inputs, the buffer"]
    #[doc = "                                must contain the encrypted data followed"]
    #[doc = "                                by the authentication tag."]
    #[doc = " \\param ciphertext_length       Size of \\p ciphertext in bytes."]
    #[doc = " \\param[out] plaintext          Output buffer for the decrypted data."]
    #[doc = " \\param plaintext_size          Size of the \\p plaintext buffer in bytes."]
    #[doc = "                                This must be appropriate for the selected"]
    #[doc = "                                algorithm and key:"]
    #[doc = "                                - A sufficient output size is"]
    #[doc = "                                  #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                  \\p alg, \\p ciphertext_length) where"]
    #[doc = "                                  \\c key_type is the type of \\p key."]
    #[doc = "                                - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p"]
    #[doc = "                                  ciphertext_length) evaluates to the maximum"]
    #[doc = "                                  plaintext size of any supported AEAD"]
    #[doc = "                                  decryption."]
    #[doc = " \\param[out] plaintext_length   On success, the size of the output"]
    #[doc = "                                in the \\p plaintext buffer."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The ciphertext is not authentic."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p plaintext_size is too small."]
    #[doc = "         #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,"]
    #[doc = "         \\p ciphertext_length) or"]
    #[doc = "         #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p ciphertext_length) can be used"]
    #[doc = "         to determine the required buffer size."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: size_t,
        additional_data: *const u8,
        additional_data_length: size_t,
        ciphertext: *const u8,
        ciphertext_length: size_t,
        plaintext: *mut u8,
        plaintext_size: size_t,
        plaintext_length: *mut size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart AEAD operations."]
#[doc = ""]
#[doc = " Before calling any function on an AEAD operation object, the application"]
#[doc = " must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_AEAD_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_aead_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation;"]
#[doc = "   operation = psa_aead_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_aead_operation_t = psa_aead_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart authenticated encryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to encrypt a message with authentication"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_aead_operation_t, e.g."]
    #[doc = "    #PSA_AEAD_OPERATION_INIT."]
    #[doc = " -# Call psa_aead_encrypt_setup() to specify the algorithm and key."]
    #[doc = " -# If needed, call psa_aead_set_lengths() to specify the length of the"]
    #[doc = "    inputs to the subsequent calls to psa_aead_update_ad() and"]
    #[doc = "    psa_aead_update(). See the documentation of psa_aead_set_lengths()"]
    #[doc = "    for details."]
    #[doc = " -# Call either psa_aead_generate_nonce() or psa_aead_set_nonce() to"]
    #[doc = "    generate or set the nonce. You should use"]
    #[doc = "    psa_aead_generate_nonce() unless the protocol you are implementing"]
    #[doc = "    requires a specific nonce value."]
    #[doc = " -# Call psa_aead_update_ad() zero, one or more times, passing a fragment"]
    #[doc = "    of the non-encrypted additional authenticated data each time."]
    #[doc = " -# Call psa_aead_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message to encrypt each time."]
    #[doc = " -# Call psa_aead_finish()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_aead_encrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_aead_abort(). The"]
    #[doc = " application may call psa_aead_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_aead_encrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_aead_finish()."]
    #[doc = " - A call to psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_aead_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   The AEAD algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_encrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart authenticated decryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to decrypt a message with authentication"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_aead_operation_t, e.g."]
    #[doc = "    #PSA_AEAD_OPERATION_INIT."]
    #[doc = " -# Call psa_aead_decrypt_setup() to specify the algorithm and key."]
    #[doc = " -# If needed, call psa_aead_set_lengths() to specify the length of the"]
    #[doc = "    inputs to the subsequent calls to psa_aead_update_ad() and"]
    #[doc = "    psa_aead_update(). See the documentation of psa_aead_set_lengths()"]
    #[doc = "    for details."]
    #[doc = " -# Call psa_aead_set_nonce() with the nonce for the decryption."]
    #[doc = " -# Call psa_aead_update_ad() zero, one or more times, passing a fragment"]
    #[doc = "    of the non-encrypted additional authenticated data each time."]
    #[doc = " -# Call psa_aead_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the ciphertext to decrypt each time."]
    #[doc = " -# Call psa_aead_verify()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_aead_decrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_aead_abort(). The"]
    #[doc = " application may call psa_aead_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_aead_decrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_aead_verify()."]
    #[doc = " - A call to psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_aead_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   The AEAD algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or the"]
    #[doc = "         library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_decrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate a random nonce for an authenticated encryption operation."]
    #[doc = ""]
    #[doc = " This function generates a random nonce for the authenticated encryption"]
    #[doc = " operation with an appropriate size for the chosen algorithm, key type"]
    #[doc = " and key size."]
    #[doc = ""]
    #[doc = " The application must call psa_aead_encrypt_setup() before"]
    #[doc = " calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[out] nonce            Buffer where the generated nonce is to be"]
    #[doc = "                              written."]
    #[doc = " \\param nonce_size            Size of the \\p nonce buffer in bytes."]
    #[doc = " \\param[out] nonce_length     On success, the number of bytes of the"]
    #[doc = "                              generated nonce."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p nonce buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active aead encrypt"]
    #[doc = "         operation, with no nonce set), or the library has not been"]
    #[doc = "         previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_generate_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *mut u8,
        nonce_size: size_t,
        nonce_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the nonce for an authenticated encryption or decryption operation."]
    #[doc = ""]
    #[doc = " This function sets the nonce for the authenticated"]
    #[doc = " encryption or decryption operation."]
    #[doc = ""]
    #[doc = " The application must call psa_aead_encrypt_setup() or"]
    #[doc = " psa_aead_decrypt_setup() before calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\note When encrypting, applications should use psa_aead_generate_nonce()"]
    #[doc = " instead of this function, unless implementing a protocol that requires"]
    #[doc = " a non-random IV."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[in] nonce             Buffer containing the nonce to use."]
    #[doc = " \\param nonce_length          Size of the nonce in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The size of \\p nonce is not acceptable for the chosen algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with no nonce"]
    #[doc = "         set), or the library has not been previously initialized"]
    #[doc = "         by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_set_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *const u8,
        nonce_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Declare the lengths of the message and additional data for AEAD."]
    #[doc = ""]
    #[doc = " The application must call this function before calling"]
    #[doc = " psa_aead_update_ad() or psa_aead_update() if the algorithm for"]
    #[doc = " the operation requires it. If the algorithm does not require it,"]
    #[doc = " calling this function is optional, but if this function is called"]
    #[doc = " then the implementation must enforce the lengths."]
    #[doc = ""]
    #[doc = " You may call this function before or after setting the nonce with"]
    #[doc = " psa_aead_set_nonce() or psa_aead_generate_nonce()."]
    #[doc = ""]
    #[doc = " - For #PSA_ALG_CCM, calling this function is required."]
    #[doc = " - For the other AEAD algorithms defined in this specification, calling"]
    #[doc = "   this function is not required."]
    #[doc = " - For vendor-defined algorithm, refer to the vendor documentation."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param ad_length             Size of the non-encrypted additional"]
    #[doc = "                              authenticated data in bytes."]
    #[doc = " \\param plaintext_length      Size of the plaintext to encrypt in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         At least one of the lengths is not acceptable for the chosen"]
    #[doc = "         algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, and"]
    #[doc = "         psa_aead_update_ad() and psa_aead_update() must not have been"]
    #[doc = "         called yet), or the library has not been previously initialized"]
    #[doc = "         by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_set_lengths(
        operation: *mut psa_aead_operation_t,
        ad_length: size_t,
        plaintext_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Pass additional data to an active AEAD operation."]
    #[doc = ""]
    #[doc = " Additional data is authenticated, but not encrypted."]
    #[doc = ""]
    #[doc = " You may call this function multiple times to pass successive fragments"]
    #[doc = " of the additional data. You may not call this function after passing"]
    #[doc = " data to encrypt or decrypt with psa_aead_update()."]
    #[doc = ""]
    #[doc = " Before calling this function, you must:"]
    #[doc = " 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup()."]
    #[doc = " 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce()."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,"]
    #[doc = "          there is no guarantee that the input is valid. Therefore, until"]
    #[doc = "          you have called psa_aead_verify() and it has returned #PSA_SUCCESS,"]
    #[doc = "          treat the input as untrusted and prepare to undo any action that"]
    #[doc = "          depends on the input if psa_aead_verify() returns an error status."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[in] input             Buffer containing the fragment of"]
    #[doc = "                              additional data."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total input length overflows the additional data length that"]
    #[doc = "         was previously specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, have a nonce"]
    #[doc = "         set, have lengths set if required by the algorithm, and"]
    #[doc = "         psa_aead_update() must not have been called yet), or the library"]
    #[doc = "         has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_update_ad(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active AEAD operation."]
    #[doc = ""]
    #[doc = " Before calling this function, you must:"]
    #[doc = " 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup()."]
    #[doc = "    The choice of setup function determines whether this function"]
    #[doc = "    encrypts or decrypts its input."]
    #[doc = " 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce()."]
    #[doc = " 3. Call psa_aead_update_ad() to pass all the additional data."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,"]
    #[doc = "          there is no guarantee that the input is valid. Therefore, until"]
    #[doc = "          you have called psa_aead_verify() and it has returned #PSA_SUCCESS:"]
    #[doc = "          - Do not use the output in any way other than storing it in a"]
    #[doc = "            confidential location. If you take any action that depends"]
    #[doc = "            on the tentative decrypted data, this action will need to be"]
    #[doc = "            undone if the input turns out not to be valid. Furthermore,"]
    #[doc = "            if an adversary can observe that this action took place"]
    #[doc = "            (for example through timing), they may be able to use this"]
    #[doc = "            fact as an oracle to decrypt any message encrypted with the"]
    #[doc = "            same key."]
    #[doc = "          - In particular, do not copy the output anywhere but to a"]
    #[doc = "            memory or storage space that you have exclusive access to."]
    #[doc = ""]
    #[doc = " This function does not require the input to be aligned to any"]
    #[doc = " particular block boundary. If the implementation can only process"]
    #[doc = " a whole block at a time, it must consume all the input provided, but"]
    #[doc = " it may delay the end of the corresponding output until a subsequent"]
    #[doc = " call to psa_aead_update(), psa_aead_finish() or psa_aead_verify()"]
    #[doc = " provides sufficient input. The amount of data that can be delayed"]
    #[doc = " in this way is bounded by #PSA_AEAD_UPDATE_OUTPUT_SIZE."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[in] input             Buffer containing the message fragment to"]
    #[doc = "                              encrypt or decrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected"]
    #[doc = "                                algorithm and key:"]
    #[doc = "                                - A sufficient output size is"]
    #[doc = "                                  #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                  \\c alg, \\p input_length) where"]
    #[doc = "                                  \\c key_type is the type of key and \\c alg is"]
    #[doc = "                                  the algorithm that were used to set up the"]
    #[doc = "                                  operation."]
    #[doc = "                                - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p"]
    #[doc = "                                  input_length) evaluates to the maximum"]
    #[doc = "                                  output size of any supported AEAD"]
    #[doc = "                                  algorithm."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small."]
    #[doc = "         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type, \\c alg, \\p input_length) or"]
    #[doc = "         #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p input_length) can be used to"]
    #[doc = "         determine the required buffer size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update_ad() so far is"]
    #[doc = "         less than the additional data length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths(), or"]
    #[doc = "         the total input length overflows the plaintext length that"]
    #[doc = "         was previously specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, have a nonce"]
    #[doc = "         set, and have lengths set if required by the algorithm), or the"]
    #[doc = "         library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_update(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting a message in an AEAD operation."]
    #[doc = ""]
    #[doc = " The operation must have been set up with psa_aead_encrypt_setup()."]
    #[doc = ""]
    #[doc = " This function finishes the authentication of the additional data"]
    #[doc = " formed by concatenating the inputs passed to preceding calls to"]
    #[doc = " psa_aead_update_ad() with the plaintext formed by concatenating the"]
    #[doc = " inputs passed to preceding calls to psa_aead_update()."]
    #[doc = ""]
    #[doc = " This function has two output buffers:"]
    #[doc = " - \\p ciphertext contains trailing ciphertext that was buffered from"]
    #[doc = "   preceding calls to psa_aead_update()."]
    #[doc = " - \\p tag contains the authentication tag."]
    #[doc = ""]
    #[doc = " When this function returns successfully, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[out] ciphertext       Buffer where the last part of the ciphertext"]
    #[doc = "                              is to be written."]
    #[doc = " \\param ciphertext_size       Size of the \\p ciphertext buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected"]
    #[doc = "                              algorithm and key:"]
    #[doc = "                              - A sufficient output size is"]
    #[doc = "                                #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                \\c alg) where \\c key_type is the type of key"]
    #[doc = "                                and \\c alg is the algorithm that were used to"]
    #[doc = "                                set up the operation."]
    #[doc = "                              - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to"]
    #[doc = "                                the maximum output size of any supported AEAD"]
    #[doc = "                                algorithm."]
    #[doc = " \\param[out] ciphertext_length On success, the number of bytes of"]
    #[doc = "                              returned ciphertext."]
    #[doc = " \\param[out] tag              Buffer where the authentication tag is"]
    #[doc = "                              to be written."]
    #[doc = " \\param tag_size              Size of the \\p tag buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected"]
    #[doc = "                              algorithm and key:"]
    #[doc = "                              - The exact tag size is #PSA_AEAD_TAG_LENGTH(\\c"]
    #[doc = "                                key_type, \\c key_bits, \\c alg) where"]
    #[doc = "                                \\c key_type and \\c key_bits are the type and"]
    #[doc = "                                bit-size of the key, and \\c alg is the"]
    #[doc = "                                algorithm that were used in the call to"]
    #[doc = "                                psa_aead_encrypt_setup()."]
    #[doc = "                              - #PSA_AEAD_TAG_MAX_SIZE evaluates to the"]
    #[doc = "                                maximum tag size of any supported AEAD"]
    #[doc = "                                algorithm."]
    #[doc = " \\param[out] tag_length       On success, the number of bytes"]
    #[doc = "                              that make up the returned tag."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p ciphertext or \\p tag buffer is too small."]
    #[doc = "         #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type, \\c alg) or"]
    #[doc = "         #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the"]
    #[doc = "         required \\p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\\c key_type,"]
    #[doc = "         \\c key_bits, \\c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to"]
    #[doc = "         determine the required \\p tag buffer size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update_ad() so far is"]
    #[doc = "         less than the additional data length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths(), or"]
    #[doc = "         the total length of input to psa_aead_update() so far is"]
    #[doc = "         less than the plaintext length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active encryption"]
    #[doc = "         operation with a nonce set), or the library has not been previously"]
    #[doc = "         initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_finish(
        operation: *mut psa_aead_operation_t,
        ciphertext: *mut u8,
        ciphertext_size: size_t,
        ciphertext_length: *mut size_t,
        tag: *mut u8,
        tag_size: size_t,
        tag_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish authenticating and decrypting a message in an AEAD operation."]
    #[doc = ""]
    #[doc = " The operation must have been set up with psa_aead_decrypt_setup()."]
    #[doc = ""]
    #[doc = " This function finishes the authenticated decryption of the message"]
    #[doc = " components:"]
    #[doc = ""]
    #[doc = " -  The additional data consisting of the concatenation of the inputs"]
    #[doc = "    passed to preceding calls to psa_aead_update_ad()."]
    #[doc = " -  The ciphertext consisting of the concatenation of the inputs passed to"]
    #[doc = "    preceding calls to psa_aead_update()."]
    #[doc = " -  The tag passed to this function call."]
    #[doc = ""]
    #[doc = " If the authentication tag is correct, this function outputs any remaining"]
    #[doc = " plaintext and reports success. If the authentication tag is not correct,"]
    #[doc = " this function returns #PSA_ERROR_INVALID_SIGNATURE."]
    #[doc = ""]
    #[doc = " When this function returns successfully, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\note Implementations shall make the best effort to ensure that the"]
    #[doc = " comparison between the actual tag and the expected tag is performed"]
    #[doc = " in constant time."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[out] plaintext        Buffer where the last part of the plaintext"]
    #[doc = "                              is to be written. This is the remaining data"]
    #[doc = "                              from previous calls to psa_aead_update()"]
    #[doc = "                              that could not be processed until the end"]
    #[doc = "                              of the input."]
    #[doc = " \\param plaintext_size        Size of the \\p plaintext buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected algorithm and key:"]
    #[doc = "                              - A sufficient output size is"]
    #[doc = "                                #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                \\c alg) where \\c key_type is the type of key"]
    #[doc = "                                and \\c alg is the algorithm that were used to"]
    #[doc = "                                set up the operation."]
    #[doc = "                              - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to"]
    #[doc = "                                the maximum output size of any supported AEAD"]
    #[doc = "                                algorithm."]
    #[doc = " \\param[out] plaintext_length On success, the number of bytes of"]
    #[doc = "                              returned plaintext."]
    #[doc = " \\param[in] tag               Buffer containing the authentication tag."]
    #[doc = " \\param tag_length            Size of the \\p tag buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The calculations were successful, but the authentication tag is"]
    #[doc = "         not correct."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p plaintext buffer is too small."]
    #[doc = "         #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type, \\c alg) or"]
    #[doc = "         #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the"]
    #[doc = "         required buffer size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update_ad() so far is"]
    #[doc = "         less than the additional data length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths(), or"]
    #[doc = "         the total length of input to psa_aead_update() so far is"]
    #[doc = "         less than the plaintext length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active decryption"]
    #[doc = "         operation with a nonce set), or the library has not been previously"]
    #[doc = "         initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_verify(
        operation: *mut psa_aead_operation_t,
        plaintext: *mut u8,
        plaintext_size: size_t,
        plaintext_length: *mut size_t,
        tag: *const u8,
        tag_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort an AEAD operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_aead_encrypt_setup() or psa_aead_decrypt_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized as described in #psa_aead_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_aead_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_aead_abort(), psa_aead_finish() or"]
    #[doc = " psa_aead_verify() is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Initialized AEAD operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_abort(operation: *mut psa_aead_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a message with a private key. For hash-and-sign algorithms,"]
    #[doc = "        this includes the hashing step."]
    #[doc = ""]
    #[doc = " \\note To perform a multi-part hash-and-sign signature algorithm, first use"]
    #[doc = "       a multi-part hash operation and then pass the resulting hash to"]
    #[doc = "       psa_sign_hash(). PSA_ALG_GET_HASH(\\p alg) can be used to determine the"]
    #[doc = "       hash algorithm to use."]
    #[doc = ""]
    #[doc = " \\param[in]  key              Identifier of the key to use for the operation."]
    #[doc = "                              It must be an asymmetric key pair. The key must"]
    #[doc = "                              allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE."]
    #[doc = " \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)"]
    #[doc = "                              is true), that is compatible with the type of"]
    #[doc = "                              \\p key."]
    #[doc = " \\param[in]  input            The input message to sign."]
    #[doc = " \\param[in]  input_length     Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] signature        Buffer where the signature is to be written."]
    #[doc = " \\param[in]  signature_size   Size of the \\p signature buffer in bytes. This"]
    #[doc = "                              must be appropriate for the selected"]
    #[doc = "                              algorithm and key:"]
    #[doc = "                              - The required signature size is"]
    #[doc = "                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "                                where \\c key_type and \\c key_bits are the type and"]
    #[doc = "                                bit-size respectively of key."]
    #[doc = "                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the"]
    #[doc = "                                maximum signature size of any supported"]
    #[doc = "                                signature algorithm."]
    #[doc = " \\param[out] signature_length On success, the number of bytes that make up"]
    #[doc = "                              the returned signature value."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,"]
    #[doc = "         or it does not permit the requested algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p signature buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_sign_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        signature: *mut u8,
        signature_size: size_t,
        signature_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a message with a public key, using"]
    #[doc = "         a hash-and-sign verification algorithm."]
    #[doc = ""]
    #[doc = " \\note To perform a multi-part hash-and-sign signature verification"]
    #[doc = "       algorithm, first use a multi-part hash operation to hash the message"]
    #[doc = "       and then pass the resulting hash to psa_verify_hash()."]
    #[doc = "       PSA_ALG_GET_HASH(\\p alg) can be used to determine the hash algorithm"]
    #[doc = "       to use."]
    #[doc = ""]
    #[doc = " \\param[in]  key              Identifier of the key to use for the operation."]
    #[doc = "                              It must be a public key or an asymmetric key"]
    #[doc = "                              pair. The key must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_VERIFY_MESSAGE."]
    #[doc = " \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)"]
    #[doc = "                              is true), that is compatible with the type of"]
    #[doc = "                              \\p key."]
    #[doc = " \\param[in]  input            The message whose signature is to be verified."]
    #[doc = " \\param[in]  input_length     Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] signature        Buffer containing the signature to verify."]
    #[doc = " \\param[in]  signature_length Size of the \\p signature buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,"]
    #[doc = "         or it does not permit the requested algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The calculation was performed successfully, but the passed signature"]
    #[doc = "         is not a valid signature."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_verify_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        signature: *const u8,
        signature_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a hash or short message with a private key."]
    #[doc = ""]
    #[doc = " Note that to perform a hash-and-sign signature algorithm, you must"]
    #[doc = " first calculate the hash by calling psa_hash_setup(), psa_hash_update()"]
    #[doc = " and psa_hash_finish(), or alternatively by calling psa_hash_compute()."]
    #[doc = " Then pass the resulting hash as the \\p hash"]
    #[doc = " parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)"]
    #[doc = " to determine the hash algorithm to use."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must be an asymmetric key pair. The key must"]
    #[doc = "                              allow the usage #PSA_KEY_USAGE_SIGN_HASH."]
    #[doc = " \\param alg                   A signature algorithm (PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)"]
    #[doc = "                              is true), that is compatible with"]
    #[doc = "                              the type of \\p key."]
    #[doc = " \\param[in] hash              The hash or message to sign."]
    #[doc = " \\param hash_length           Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[out] signature        Buffer where the signature is to be written."]
    #[doc = " \\param signature_size        Size of the \\p signature buffer in bytes."]
    #[doc = " \\param[out] signature_length On success, the number of bytes"]
    #[doc = "                              that make up the returned signature value."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p signature buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_sign_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: size_t,
        signature: *mut u8,
        signature_size: size_t,
        signature_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a hash or short message using a public key."]
    #[doc = ""]
    #[doc = " Note that to perform a hash-and-sign signature algorithm, you must"]
    #[doc = " first calculate the hash by calling psa_hash_setup(), psa_hash_update()"]
    #[doc = " and psa_hash_finish(), or alternatively by calling psa_hash_compute()."]
    #[doc = " Then pass the resulting hash as the \\p hash"]
    #[doc = " parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)"]
    #[doc = " to determine the hash algorithm to use."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must be a public key or an asymmetric key pair. The"]
    #[doc = "                          key must allow the usage"]
    #[doc = "                          #PSA_KEY_USAGE_VERIFY_HASH."]
    #[doc = " \\param alg               A signature algorithm (PSA_ALG_XXX"]
    #[doc = "                          value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)"]
    #[doc = "                          is true), that is compatible with"]
    #[doc = "                          the type of \\p key."]
    #[doc = " \\param[in] hash          The hash or message whose signature is to be"]
    #[doc = "                          verified."]
    #[doc = " \\param hash_length       Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[in] signature     Buffer containing the signature to verify."]
    #[doc = " \\param signature_length  Size of the \\p signature buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The signature is valid."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The calculation was performed successfully, but the passed"]
    #[doc = "         signature is not a valid signature."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_verify_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: size_t,
        signature: *const u8,
        signature_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Encrypt a short message with a public key."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must be a public key or an asymmetric key"]
    #[doc = "                              pair. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   An asymmetric encryption algorithm that is"]
    #[doc = "                              compatible with the type of \\p key."]
    #[doc = " \\param[in] input             The message to encrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[in] salt              A salt or label, if supported by the"]
    #[doc = "                              encryption algorithm."]
    #[doc = "                              If the algorithm does not support a"]
    #[doc = "                              salt, pass \\c NULL."]
    #[doc = "                              If the algorithm supports an optional"]
    #[doc = "                              salt and you do not want to pass a salt,"]
    #[doc = "                              pass \\c NULL."]
    #[doc = ""]
    #[doc = "                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is"]
    #[doc = "                                supported."]
    #[doc = " \\param salt_length           Size of the \\p salt buffer in bytes."]
    #[doc = "                              If \\p salt is \\c NULL, pass 0."]
    #[doc = " \\param[out] output           Buffer where the encrypted message is to"]
    #[doc = "                              be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_asymmetric_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        salt: *const u8,
        salt_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Decrypt a short message with a private key."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must be an asymmetric key pair. It must"]
    #[doc = "                              allow the usage #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   An asymmetric encryption algorithm that is"]
    #[doc = "                              compatible with the type of \\p key."]
    #[doc = " \\param[in] input             The message to decrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[in] salt              A salt or label, if supported by the"]
    #[doc = "                              encryption algorithm."]
    #[doc = "                              If the algorithm does not support a"]
    #[doc = "                              salt, pass \\c NULL."]
    #[doc = "                              If the algorithm supports an optional"]
    #[doc = "                              salt and you do not want to pass a salt,"]
    #[doc = "                              pass \\c NULL."]
    #[doc = ""]
    #[doc = "                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is"]
    #[doc = "                                supported."]
    #[doc = " \\param salt_length           Size of the \\p salt buffer in bytes."]
    #[doc = "                              If \\p salt is \\c NULL, pass 0."]
    #[doc = " \\param[out] output           Buffer where the decrypted message is to"]
    #[doc = "                              be written."]
    #[doc = " \\param output_size           Size of the \\c output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_PADDING \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_asymmetric_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        salt: *const u8,
        salt_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for key derivation operations."]
#[doc = ""]
#[doc = " Before calling any function on a key derivation operation object, the"]
#[doc = " application must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_KEY_DERIVATION_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation = PSA_KEY_DERIVATION_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_key_derivation_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation;"]
#[doc = "   operation = psa_key_derivation_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_key_derivation_operation_t = psa_key_derivation_s;
extern "C" {
    #[doc = " Set up a key derivation operation."]
    #[doc = ""]
    #[doc = " A key derivation algorithm takes some inputs and uses them to generate"]
    #[doc = " a byte stream in a deterministic way."]
    #[doc = " This byte stream can be used to produce keys and other"]
    #[doc = " cryptographic material."]
    #[doc = ""]
    #[doc = " To derive a key:"]
    #[doc = " -# Start with an initialized object of type #psa_key_derivation_operation_t."]
    #[doc = " -# Call psa_key_derivation_setup() to select the algorithm."]
    #[doc = " -# Provide the inputs for the key derivation by calling"]
    #[doc = "    psa_key_derivation_input_bytes() or psa_key_derivation_input_key()"]
    #[doc = "    as appropriate. Which inputs are needed, in what order, and whether"]
    #[doc = "    they may be keys and if so of what type depends on the algorithm."]
    #[doc = " -# Optionally set the operation's maximum capacity with"]
    #[doc = "    psa_key_derivation_set_capacity(). You may do this before, in the middle"]
    #[doc = "    of or after providing inputs. For some algorithms, this step is mandatory"]
    #[doc = "    because the output depends on the maximum capacity."]
    #[doc = " -# To derive a key, call psa_key_derivation_output_key()."]
    #[doc = "    To derive a byte string for a different purpose, call"]
    #[doc = "    psa_key_derivation_output_bytes()."]
    #[doc = "    Successive calls to these functions use successive output bytes"]
    #[doc = "    calculated by the key derivation algorithm."]
    #[doc = " -# Clean up the key derivation operation object with"]
    #[doc = "    psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " If this function returns an error, the key derivation operation object is"]
    #[doc = " not changed."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_key_derivation_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " Implementations must reject an attempt to derive a key of size 0."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object"]
    #[doc = "                                to set up. It must"]
    #[doc = "                                have been initialized but not set up yet."]
    #[doc = " \\param alg                     The key derivation algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_KEY_DERIVATION(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c alg is not a key derivation algorithm."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\c alg is not supported or is not a key derivation algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_setup(
        operation: *mut psa_key_derivation_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the current capacity of a key derivation operation."]
    #[doc = ""]
    #[doc = " The capacity of a key derivation is the maximum number of bytes that it can"]
    #[doc = " return. When you get *N* bytes of output from a key derivation operation,"]
    #[doc = " this reduces its capacity by *N*."]
    #[doc = ""]
    #[doc = " \\param[in] operation     The operation to query."]
    #[doc = " \\param[out] capacity     On success, the capacity of the operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_get_capacity(
        operation: *const psa_key_derivation_operation_t,
        capacity: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the maximum capacity of a key derivation operation."]
    #[doc = ""]
    #[doc = " The capacity of a key derivation operation is the maximum number of bytes"]
    #[doc = " that the key derivation operation can return from this point onwards."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to modify."]
    #[doc = " \\param capacity          The new capacity of the operation."]
    #[doc = "                          It must be less or equal to the operation's"]
    #[doc = "                          current capacity."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p capacity is larger than the operation's current capacity."]
    #[doc = "         In this case, the operation object remains valid and its capacity"]
    #[doc = "         remains unchanged."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active), or the"]
    #[doc = "         library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_set_capacity(
        operation: *mut psa_key_derivation_operation_t,
        capacity: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation or key agreement."]
    #[doc = ""]
    #[doc = " Which inputs are required and in what order depends on the algorithm."]
    #[doc = " Refer to the documentation of each key derivation or key agreement"]
    #[doc = " algorithm for information."]
    #[doc = ""]
    #[doc = " This function passes direct inputs, which is usually correct for"]
    #[doc = " non-secret inputs. To pass a secret input, which should be in a key"]
    #[doc = " object, call psa_key_derivation_input_key() instead of this function."]
    #[doc = " Refer to the documentation of individual step types"]
    #[doc = " (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() and must not"]
    #[doc = "                                have produced any output yet."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param[in] data                Input data to use."]
    #[doc = " \\param data_length             Size of the \\p data buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step is not compatible with the operation's algorithm, or"]
    #[doc = "         \\c step does not allow direct inputs."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this input \\p step, or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_input_bytes(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        data: *const u8,
        data_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide a numeric input for key derivation or key agreement."]
    #[doc = ""]
    #[doc = " Which inputs are required and in what order depends on the algorithm."]
    #[doc = " However, when an algorithm requires a particular order, numeric inputs"]
    #[doc = " usually come first as they tend to be configuration parameters."]
    #[doc = " Refer to the documentation of each key derivation or key agreement"]
    #[doc = " algorithm for information."]
    #[doc = ""]
    #[doc = " This function is used for inputs which are fixed-size non-negative"]
    #[doc = " integers."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() and must not"]
    #[doc = "                                have produced any output yet."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param[in] value               The value of the numeric input."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step is not compatible with the operation's algorithm, or"]
    #[doc = "         \\c step does not allow numeric inputs."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this input \\p step, or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_input_integer(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        value: u64,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation in the form of a key."]
    #[doc = ""]
    #[doc = " Which inputs are required and in what order depends on the algorithm."]
    #[doc = " Refer to the documentation of each key derivation or key agreement"]
    #[doc = " algorithm for information."]
    #[doc = ""]
    #[doc = " This function obtains input from a key object, which is usually correct for"]
    #[doc = " secret inputs or for non-secret personalization strings kept in the key"]
    #[doc = " store. To pass a non-secret parameter which is not in the key store,"]
    #[doc = " call psa_key_derivation_input_bytes() instead of this function."]
    #[doc = " Refer to the documentation of individual step types"]
    #[doc = " (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() and must not"]
    #[doc = "                                have produced any output yet."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param key                     Identifier of the key. It must have an"]
    #[doc = "                                appropriate type for step and must allow the"]
    #[doc = "                                usage #PSA_KEY_USAGE_DERIVE or"]
    #[doc = "                                #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)"]
    #[doc = "                                and the algorithm used by the operation."]
    #[doc = ""]
    #[doc = " \\note Once all inputs steps are completed, the operations will allow:"]
    #[doc = " - psa_key_derivation_output_bytes() if each input was either a direct input"]
    #[doc = "   or  a key with #PSA_KEY_USAGE_DERIVE set;"]
    #[doc = " - psa_key_derivation_output_key() if the input for step"]
    #[doc = "   #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD"]
    #[doc = "   was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was"]
    #[doc = "   either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;"]
    #[doc = " - psa_key_derivation_verify_bytes() if each input was either a direct input"]
    #[doc = "   or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;"]
    #[doc = " - psa_key_derivation_verify_key() under the same conditions as"]
    #[doc = "   psa_key_derivation_verify_bytes()."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key allows neither #PSA_KEY_USAGE_DERIVE nor"]
    #[doc = "         #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this"]
    #[doc = "         algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step is not compatible with the operation's algorithm, or"]
    #[doc = "         \\c step does not allow key inputs of the given type"]
    #[doc = "         or does not allow key inputs at all."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this input \\p step, or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_input_key(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        key: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and use the shared secret as input to a key"]
    #[doc = " derivation."]
    #[doc = ""]
    #[doc = " A key agreement algorithm takes two inputs: a private key \\p private_key"]
    #[doc = " a public key \\p peer_key."]
    #[doc = " The result of this function is passed as input to a key derivation."]
    #[doc = " The output of this key derivation can be extracted by reading from the"]
    #[doc = " resulting operation to produce keys and other cryptographic material."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() with a"]
    #[doc = "                                key agreement and derivation algorithm"]
    #[doc = "                                \\c alg (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_KEY_AGREEMENT(\\c alg) is true"]
    #[doc = "                                and #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\c alg)"]
    #[doc = "                                is false)."]
    #[doc = "                                The operation must be ready for an"]
    #[doc = "                                input of the type given by \\p step."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param private_key             Identifier of the private key to use. It must"]
    #[doc = "                                allow the usage #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\param[in] peer_key      Public key of the peer. The peer key must be in the"]
    #[doc = "                          same format that psa_import_key() accepts for the"]
    #[doc = "                          public key type corresponding to the type of"]
    #[doc = "                          private_key. That is, this function performs the"]
    #[doc = "                          equivalent of"]
    #[doc = "                          #psa_import_key(...,"]
    #[doc = "                          `peer_key`, `peer_key_length`) where"]
    #[doc = "                          with key attributes indicating the public key"]
    #[doc = "                          type corresponding to the type of `private_key`."]
    #[doc = "                          For example, for EC keys, this means that peer_key"]
    #[doc = "                          is interpreted as a point on the curve that the"]
    #[doc = "                          private key is on. The standard formats for public"]
    #[doc = "                          keys are documented in the documentation of"]
    #[doc = "                          psa_export_public_key()."]
    #[doc = " \\param peer_key_length         Size of \\p peer_key in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c private_key is not compatible with \\c alg,"]
    #[doc = "         or \\p peer_key is not valid for \\c alg or not compatible with"]
    #[doc = "         \\c private_key, or \\c step does not allow an input resulting"]
    #[doc = "         from a key agreement."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\c alg is not supported or is not a key derivation algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this key agreement \\p step,"]
    #[doc = "         or the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_key_agreement(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Read some data from a key derivation operation."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm and"]
    #[doc = " return those bytes."]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads the requested number of bytes from the"]
    #[doc = " stream."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[out] output       Buffer where the output will be written."]
    #[doc = " \\param output_length     Number of bytes to output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         One of the inputs was a key whose policy didn't allow"]
    #[doc = "         #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "                          The operation's capacity was less than"]
    #[doc = "                          \\p output_length bytes. Note that in this case,"]
    #[doc = "                          no output is written to the output buffer."]
    #[doc = "                          The operation's capacity is set to 0, thus"]
    #[doc = "                          subsequent calls to this function will not"]
    #[doc = "                          succeed, even with a smaller output buffer."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps), or the library has not been previously"]
    #[doc = "         initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_output_bytes(
        operation: *mut psa_key_derivation_operation_t,
        output: *mut u8,
        output_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Derive a key from an ongoing key derivation operation."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm"]
    #[doc = " and uses those bytes to generate a key deterministically."]
    #[doc = " The key's location, usage policy, type and size are taken from"]
    #[doc = " \\p attributes."]
    #[doc = ""]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads as many bytes as required from the"]
    #[doc = " stream."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " How much output is produced and consumed from the operation, and how"]
    #[doc = " the key is derived, depends on the key type and on the key size"]
    #[doc = " (denoted \\c bits below):"]
    #[doc = ""]
    #[doc = " - For key types for which the key is an arbitrary sequence of bytes"]
    #[doc = "   of a given size, this function is functionally equivalent to"]
    #[doc = "   calling #psa_key_derivation_output_bytes"]
    #[doc = "   and passing the resulting output to #psa_import_key."]
    #[doc = "   However, this function has a security benefit:"]
    #[doc = "   if the implementation provides an isolation boundary then"]
    #[doc = "   the key material is not exposed outside the isolation boundary."]
    #[doc = "   As a consequence, for these key types, this function always consumes"]
    #[doc = "   exactly (\\c bits / 8) bytes from the operation."]
    #[doc = "   The following key types defined in this specification follow this scheme:"]
    #[doc = ""]
    #[doc = "     - #PSA_KEY_TYPE_AES;"]
    #[doc = "     - #PSA_KEY_TYPE_ARIA;"]
    #[doc = "     - #PSA_KEY_TYPE_CAMELLIA;"]
    #[doc = "     - #PSA_KEY_TYPE_DERIVE;"]
    #[doc = "     - #PSA_KEY_TYPE_HMAC;"]
    #[doc = "     - #PSA_KEY_TYPE_PASSWORD_HASH."]
    #[doc = ""]
    #[doc = " - For ECC keys on a Montgomery elliptic curve"]
    #[doc = "   (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a"]
    #[doc = "   Montgomery curve), this function always draws a byte string whose"]
    #[doc = "   length is determined by the curve, and sets the mandatory bits"]
    #[doc = "   accordingly. That is:"]
    #[doc = ""]
    #[doc = "     - Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte"]
    #[doc = "       string and process it as specified in RFC 7748 &sect;5."]
    #[doc = "     - Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte"]
    #[doc = "       string and process it as specified in RFC 7748 &sect;5."]
    #[doc = ""]
    #[doc = " - For key types for which the key is represented by a single sequence of"]
    #[doc = "   \\c bits bits with constraints as to which bit sequences are acceptable,"]
    #[doc = "   this function draws a byte string of length (\\c bits / 8) bytes rounded"]
    #[doc = "   up to the nearest whole number of bytes. If the resulting byte string"]
    #[doc = "   is acceptable, it becomes the key, otherwise the drawn bytes are discarded."]
    #[doc = "   This process is repeated until an acceptable byte string is drawn."]
    #[doc = "   The byte string drawn from the operation is interpreted as specified"]
    #[doc = "   for the output produced by psa_export_key()."]
    #[doc = "   The following key types defined in this specification follow this scheme:"]
    #[doc = ""]
    #[doc = "     - #PSA_KEY_TYPE_DES."]
    #[doc = "       Force-set the parity bits, but discard forbidden weak keys."]
    #[doc = "       For 2-key and 3-key triple-DES, the three keys are generated"]
    #[doc = "       successively (for example, for 3-key triple-DES,"]
    #[doc = "       if the first 8 bytes specify a weak key and the next 8 bytes do not,"]
    #[doc = "       discard the first 8 bytes, use the next 8 bytes as the first key,"]
    #[doc = "       and continue reading output from the operation to derive the other"]
    #[doc = "       two keys)."]
    #[doc = "     - Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\\c group)"]
    #[doc = "       where \\c group designates any Diffie-Hellman group) and"]
    #[doc = "       ECC keys on a Weierstrass elliptic curve"]
    #[doc = "       (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a"]
    #[doc = "       Weierstrass curve)."]
    #[doc = "       For these key types, interpret the byte string as integer"]
    #[doc = "       in big-endian order. Discard it if it is not in the range"]
    #[doc = "       [0, *N* - 2] where *N* is the boundary of the private key domain"]
    #[doc = "       (the prime *p* for Diffie-Hellman, the subprime *q* for DSA,"]
    #[doc = "       or the order of the curve's base point for ECC)."]
    #[doc = "       Add 1 to the resulting integer and use this as the private key *x*."]
    #[doc = "       This method allows compliance to NIST standards, specifically"]
    #[doc = "       the methods titled \"key-pair generation by testing candidates\""]
    #[doc = "       in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman,"]
    #[doc = "       in FIPS 186-4 &sect;B.1.2 for DSA, and"]
    #[doc = "       in NIST SP 800-56A &sect;5.6.1.2.2 or"]
    #[doc = "       FIPS 186-4 &sect;B.4.2 for elliptic curve keys."]
    #[doc = ""]
    #[doc = " - For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,"]
    #[doc = "   the way in which the operation output is consumed is"]
    #[doc = "   implementation-defined."]
    #[doc = ""]
    #[doc = " In all cases, the data that is read is discarded from the operation."]
    #[doc = " The operation's capacity is decreased by the number of bytes read."]
    #[doc = ""]
    #[doc = " For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,"]
    #[doc = " the input to that step must be provided with psa_key_derivation_input_key()."]
    #[doc = " Future versions of this specification may include additional restrictions"]
    #[doc = " on the derived key based on the attributes and strength of the secret key."]
    #[doc = ""]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = "                          If the key type to be created is"]
    #[doc = "                          #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in"]
    #[doc = "                          the policy must be the same as in the current"]
    #[doc = "                          operation."]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[out] key          On success, an identifier for the newly created"]
    #[doc = "                          key. For persistent keys, this is the key"]
    #[doc = "                          identifier defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = "         If the key is persistent, the key material and the key's metadata"]
    #[doc = "         have been saved to persistent storage."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "         There was not enough data to create the desired key."]
    #[doc = "         Note that in this case, no output is written to the output buffer."]
    #[doc = "         The operation's capacity is set to 0, thus subsequent calls to"]
    #[doc = "         this function will not succeed, even with a smaller output buffer."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The key type or key size is not supported, either by the"]
    #[doc = "         implementation in general or in this particular location."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The provided key attributes are not valid for the operation."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The #PSA_KEY_DERIVATION_INPUT_SECRET or"]
    #[doc = "         #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a"]
    #[doc = "         key; or one of the inputs was a key whose policy didn't allow"]
    #[doc = "         #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps), or the library has not been previously"]
    #[doc = "         initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_output_key(
        attributes: *const psa_key_attributes_t,
        operation: *mut psa_key_derivation_operation_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm and"]
    #[doc = " compares those bytes to an expected value in constant time."]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads the expected number of bytes from the"]
    #[doc = " stream before comparing them."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " This is functionally equivalent to the following code:"]
    #[doc = " \\code"]
    #[doc = " psa_key_derivation_output_bytes(operation, tmp, output_length);"]
    #[doc = " if (memcmp(output, tmp, output_length) != 0)"]
    #[doc = "     return PSA_ERROR_INVALID_SIGNATURE;"]
    #[doc = " \\endcode"]
    #[doc = " except (1) it works even if the key's policy does not allow outputting the"]
    #[doc = " bytes, and (2) the comparison will be done in constant time."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,"]
    #[doc = " the operation enters an error state and must be aborted by calling"]
    #[doc = " psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[in] expected_output Buffer containing the expected derivation output."]
    #[doc = " \\param output_length     Length of the expected output; this is also the"]
    #[doc = "                          number of bytes that will be read."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The output was read successfully, but it differs from the expected"]
    #[doc = "         output."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         One of the inputs was a key whose policy didn't allow"]
    #[doc = "         #PSA_KEY_USAGE_VERIFY_DERIVATION."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "                          The operation's capacity was less than"]
    #[doc = "                          \\p output_length bytes. Note that in this case,"]
    #[doc = "                          the operation's capacity is set to 0, thus"]
    #[doc = "                          subsequent calls to this function will not"]
    #[doc = "                          succeed, even with a smaller expected output."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps), or the library has not been previously"]
    #[doc = "         initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_verify_bytes(
        operation: *mut psa_key_derivation_operation_t,
        expected_output: *const u8,
        output_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value"]
    #[doc = " stored in a key object."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm and"]
    #[doc = " compares those bytes to an expected value, provided as key of type"]
    #[doc = " #PSA_KEY_TYPE_PASSWORD_HASH."]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads the number of bytes corresponding to the"]
    #[doc = " length of the expected value from the stream before comparing them."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " This is functionally equivalent to exporting the key and calling"]
    #[doc = " psa_key_derivation_verify_bytes() on the result, except that it"]
    #[doc = " works even if the key cannot be exported."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,"]
    #[doc = " the operation enters an error state and must be aborted by calling"]
    #[doc = " psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH"]
    #[doc = "                          containing the expected output. Its policy must"]
    #[doc = "                          include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag"]
    #[doc = "                          and the permitted algorithm must match the"]
    #[doc = "                          operation. The value of this key was likely"]
    #[doc = "                          computed by a previous call to"]
    #[doc = "                          psa_key_derivation_output_key()."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The output was read successfully, but if differs from the expected"]
    #[doc = "         output."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         The key passed as the expected value does not exist."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key passed as the expected value has an invalid type."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key passed as the expected value does not allow this usage or"]
    #[doc = "         this algorithm; or one of the inputs was a key whose policy didn't"]
    #[doc = "         allow #PSA_KEY_USAGE_VERIFY_DERIVATION."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "                          The operation's capacity was less than"]
    #[doc = "                          the length of the expected value. In this case,"]
    #[doc = "                          the operation's capacity is set to 0, thus"]
    #[doc = "                          subsequent calls to this function will not"]
    #[doc = "                          succeed, even with a smaller expected output."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps), or the library has not been previously"]
    #[doc = "         initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_verify_key(
        operation: *mut psa_key_derivation_operation_t,
        expected: psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a key derivation operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the \\c"]
    #[doc = " operation structure itself. Once aborted, the operation object can be reused"]
    #[doc = " for another operation by calling psa_key_derivation_setup() again."]
    #[doc = ""]
    #[doc = " This function may be called at any time after the operation"]
    #[doc = " object has been initialized as described in #psa_key_derivation_operation_t."]
    #[doc = ""]
    #[doc = " In particular, it is valid to call psa_key_derivation_abort() twice, or to"]
    #[doc = " call psa_key_derivation_abort() on an operation that has not been set up."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation    The operation to abort."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_abort(operation: *mut psa_key_derivation_operation_t)
        -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and return the raw shared secret."]
    #[doc = ""]
    #[doc = " \\warning The raw result of a key agreement algorithm such as finite-field"]
    #[doc = " Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should"]
    #[doc = " not be used directly as key material. It should instead be passed as"]
    #[doc = " input to a key derivation algorithm. To chain a key agreement with"]
    #[doc = " a key derivation, use psa_key_derivation_key_agreement() and other"]
    #[doc = " functions from the key derivation interface."]
    #[doc = ""]
    #[doc = " \\param alg                     The key agreement algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\p alg)"]
    #[doc = "                                is true)."]
    #[doc = " \\param private_key             Identifier of the private key to use. It must"]
    #[doc = "                                allow the usage #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\param[in] peer_key            Public key of the peer. It must be"]
    #[doc = "                                in the same format that psa_import_key()"]
    #[doc = "                                accepts. The standard formats for public"]
    #[doc = "                                keys are documented in the documentation"]
    #[doc = "                                of psa_export_public_key()."]
    #[doc = " \\param peer_key_length         Size of \\p peer_key in bytes."]
    #[doc = " \\param[out] output             Buffer where the decrypted message is to"]
    #[doc = "                                be written."]
    #[doc = " \\param output_size             Size of the \\c output buffer in bytes."]
    #[doc = " \\param[out] output_length      On success, the number of bytes"]
    #[doc = "                                that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p alg is not a key agreement algorithm, or"]
    #[doc = "         \\p private_key is not compatible with \\p alg,"]
    #[doc = "         or \\p peer_key is not valid for \\p alg or not compatible with"]
    #[doc = "         \\p private_key."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p output_size is too small"]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not a supported key agreement algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_raw_key_agreement(
        alg: psa_algorithm_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate random bytes."]
    #[doc = ""]
    #[doc = " \\warning This function **can** fail! Callers MUST check the return status"]
    #[doc = "          and MUST NOT use the content of the output buffer if the return"]
    #[doc = "          status is not #PSA_SUCCESS."]
    #[doc = ""]
    #[doc = " \\note    To generate a key, use psa_generate_key() instead."]
    #[doc = ""]
    #[doc = " \\param[out] output       Output buffer for the generated data."]
    #[doc = " \\param output_size       Number of bytes to generate and output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_generate_random(output: *mut u8, output_size: size_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate a key or key pair."]
    #[doc = ""]
    #[doc = " The key is generated randomly."]
    #[doc = " Its location, usage policy, type and size are taken from \\p attributes."]
    #[doc = ""]
    #[doc = " Implementations must reject an attempt to generate a key of size 0."]
    #[doc = ""]
    #[doc = " The following type-specific considerations apply:"]
    #[doc = " - For RSA keys (#PSA_KEY_TYPE_RSA_KEY_PAIR),"]
    #[doc = "   the public exponent is 65537."]
    #[doc = "   The modulus is a product of two probabilistic primes"]
    #[doc = "   between 2^{n-1} and 2^n where n is the bit size specified in the"]
    #[doc = "   attributes."]
    #[doc = ""]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = " \\param[out] key          On success, an identifier for the newly created"]
    #[doc = "                          key. For persistent keys, this is the key"]
    #[doc = "                          identifier defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = "         If the key is persistent, the key material and the key's metadata"]
    #[doc = "         have been saved to persistent storage."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_generate_key(
        attributes: *const psa_key_attributes_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
#[doc = " \\brief The context for PSA interruptible hash signing."]
pub type psa_sign_hash_interruptible_operation_t = psa_sign_hash_interruptible_operation_s;
#[doc = " \\brief The context for PSA interruptible hash verification."]
pub type psa_verify_hash_interruptible_operation_t = psa_verify_hash_interruptible_operation_s;
extern "C" {
    #[doc = " \\brief                       Set the maximum number of ops allowed to be"]
    #[doc = "                              executed by an interruptible function in a"]
    #[doc = "                              single call."]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = " \\note                        The time taken to execute a single op is"]
    #[doc = "                              implementation specific and depends on"]
    #[doc = "                              software, hardware, the algorithm, key type and"]
    #[doc = "                              curve chosen. Even within a single operation,"]
    #[doc = "                              successive ops can take differing amounts of"]
    #[doc = "                              time. The only guarantee is that lower values"]
    #[doc = "                              for \\p max_ops means functions will block for a"]
    #[doc = "                              lesser maximum amount of time. The functions"]
    #[doc = "                              \\c psa_sign_interruptible_get_num_ops() and"]
    #[doc = "                              \\c psa_verify_interruptible_get_num_ops() are"]
    #[doc = "                              provided to help with tuning this value."]
    #[doc = ""]
    #[doc = " \\note                        This value defaults to"]
    #[doc = "                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, which"]
    #[doc = "                              means the whole operation will be done in one"]
    #[doc = "                              go, regardless of the number of ops required."]
    #[doc = ""]
    #[doc = " \\note                        If more ops are needed to complete a"]
    #[doc = "                              computation, #PSA_OPERATION_INCOMPLETE will be"]
    #[doc = "                              returned by the function performing the"]
    #[doc = "                              computation. It is then the caller's"]
    #[doc = "                              responsibility to either call again with the"]
    #[doc = "                              same operation context until it returns 0 or an"]
    #[doc = "                              error code; or to call the relevant abort"]
    #[doc = "                              function if the answer is no longer required."]
    #[doc = ""]
    #[doc = " \\note                        The interpretation of \\p max_ops is also"]
    #[doc = "                              implementation defined. On a hard real time"]
    #[doc = "                              system, this can indicate a hard deadline, as a"]
    #[doc = "                              real-time system needs a guarantee of not"]
    #[doc = "                              spending more than X time, however care must be"]
    #[doc = "                              taken in such an implementation to avoid the"]
    #[doc = "                              situation whereby calls just return, not being"]
    #[doc = "                              able to do any actual work within the allotted"]
    #[doc = "                              time.  On a non-real-time system, the"]
    #[doc = "                              implementation can be more relaxed, but again"]
    #[doc = "                              whether this number should be interpreted as as"]
    #[doc = "                              hard or soft limit or even whether a less than"]
    #[doc = "                              or equals as regards to ops executed in a"]
    #[doc = "                              single call is implementation defined."]
    #[doc = ""]
    #[doc = " \\note                        For keys in local storage when no accelerator"]
    #[doc = "                              driver applies, please see also the"]
    #[doc = "                              documentation for \\c mbedtls_ecp_set_max_ops(),"]
    #[doc = "                              which is the internal implementation in these"]
    #[doc = "                              cases."]
    #[doc = ""]
    #[doc = " \\warning                     With implementations that interpret this number"]
    #[doc = "                              as a hard limit, setting this number too small"]
    #[doc = "                              may result in an infinite loop, whereby each"]
    #[doc = "                              call results in immediate return with no ops"]
    #[doc = "                              done (as there is not enough time to execute"]
    #[doc = "                              any), and thus no result will ever be achieved."]
    #[doc = ""]
    #[doc = " \\note                        This only applies to functions whose"]
    #[doc = "                              documentation mentions they may return"]
    #[doc = "                              #PSA_OPERATION_INCOMPLETE."]
    #[doc = ""]
    #[doc = " \\param max_ops               The maximum number of ops to be executed in a"]
    #[doc = "                              single call. This can be a number from 0 to"]
    #[doc = "                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, where 0"]
    #[doc = "                              is the least amount of work done per call."]
    pub fn psa_interruptible_set_max_ops(max_ops: u32);
}
extern "C" {
    #[doc = " \\brief                       Get the maximum number of ops allowed to be"]
    #[doc = "                              executed by an interruptible function in a"]
    #[doc = "                              single call. This will return the last"]
    #[doc = "                              value set by"]
    #[doc = "                              \\c psa_interruptible_set_max_ops() or"]
    #[doc = "                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED if"]
    #[doc = "                              that function has never been called."]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = " \\return                      Maximum number of ops allowed to be"]
    #[doc = "                              executed by an interruptible function in a"]
    #[doc = "                              single call."]
    pub fn psa_interruptible_get_max_ops() -> u32;
}
extern "C" {
    #[doc = " \\brief                       Get the number of ops that a hash signing"]
    #[doc = "                              operation has taken so far. If the operation"]
    #[doc = "                              has completed, then this will represent the"]
    #[doc = "                              number of ops required for the entire"]
    #[doc = "                              operation. After initialization or calling"]
    #[doc = "                              \\c psa_sign_hash_interruptible_abort() on"]
    #[doc = "                              the operation, a value of 0 will be returned."]
    #[doc = ""]
    #[doc = " \\note                        This interface is guaranteed re-entrant and"]
    #[doc = "                              thus may be called from driver code."]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = "                              This is a helper provided to help you tune the"]
    #[doc = "                              value passed to \\c"]
    #[doc = "                              psa_interruptible_set_max_ops()."]
    #[doc = ""]
    #[doc = " \\param operation             The \\c psa_sign_hash_interruptible_operation_t"]
    #[doc = "                              to use. This must be initialized first."]
    #[doc = ""]
    #[doc = " \\return                      Number of ops that the operation has taken so"]
    #[doc = "                              far."]
    pub fn psa_sign_hash_get_num_ops(
        operation: *const psa_sign_hash_interruptible_operation_t,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief                       Get the number of ops that a hash verification"]
    #[doc = "                              operation has taken so far. If the operation"]
    #[doc = "                              has completed, then this will represent the"]
    #[doc = "                              number of ops required for the entire"]
    #[doc = "                              operation. After initialization or calling \\c"]
    #[doc = "                              psa_verify_hash_interruptible_abort() on the"]
    #[doc = "                              operation, a value of 0 will be returned."]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = "                              This is a helper provided to help you tune the"]
    #[doc = "                              value passed to \\c"]
    #[doc = "                              psa_interruptible_set_max_ops()."]
    #[doc = ""]
    #[doc = " \\param operation             The \\c"]
    #[doc = "                              psa_verify_hash_interruptible_operation_t to"]
    #[doc = "                              use. This must be initialized first."]
    #[doc = ""]
    #[doc = " \\return                      Number of ops that the operation has taken so"]
    #[doc = "                              far."]
    pub fn psa_verify_hash_get_num_ops(
        operation: *const psa_verify_hash_interruptible_operation_t,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief                       Start signing a hash or short message with a"]
    #[doc = "                              private key, in an interruptible manner."]
    #[doc = ""]
    #[doc = " \\see                         \\c psa_sign_hash_complete()"]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = " \\note                        This function combined with \\c"]
    #[doc = "                              psa_sign_hash_complete() is equivalent to"]
    #[doc = "                              \\c psa_sign_hash() but"]
    #[doc = "                              \\c psa_sign_hash_complete() can return early and"]
    #[doc = "                              resume according to the limit set with \\c"]
    #[doc = "                              psa_interruptible_set_max_ops() to reduce the"]
    #[doc = "                              maximum time spent in a function call."]
    #[doc = ""]
    #[doc = " \\note                        Users should call \\c psa_sign_hash_complete()"]
    #[doc = "                              repeatedly on the same context after a"]
    #[doc = "                              successful call to this function until \\c"]
    #[doc = "                              psa_sign_hash_complete() either returns 0 or an"]
    #[doc = "                              error. \\c psa_sign_hash_complete() will return"]
    #[doc = "                              #PSA_OPERATION_INCOMPLETE if there is more work"]
    #[doc = "                              to do. Alternatively users can call"]
    #[doc = "                              \\c psa_sign_hash_abort() at any point if they no"]
    #[doc = "                              longer want the result."]
    #[doc = ""]
    #[doc = " \\note                        If this function returns an error status, the"]
    #[doc = "                              operation enters an error state and must be"]
    #[doc = "                              aborted by calling \\c psa_sign_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in, out] operation    The \\c psa_sign_hash_interruptible_operation_t"]
    #[doc = "                              to use. This must be initialized first."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must be an asymmetric key pair. The key must"]
    #[doc = "                              allow the usage #PSA_KEY_USAGE_SIGN_HASH."]
    #[doc = " \\param alg                   A signature algorithm (\\c PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)"]
    #[doc = "                              is true), that is compatible with"]
    #[doc = "                              the type of \\p key."]
    #[doc = " \\param[in] hash              The hash or message to sign."]
    #[doc = " \\param hash_length           Size of the \\p hash buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The operation started successfully - call \\c psa_sign_hash_complete()"]
    #[doc = "         with the same context to complete the operation"]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_SIGN_HASH flag, or it does"]
    #[doc = "         not permit the requested algorithm."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         An operation has previously been started on this context, and is"]
    #[doc = "         still in progress."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_sign_hash_start(
        operation: *mut psa_sign_hash_interruptible_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Continue and eventually complete the action of"]
    #[doc = "                              signing a hash or short message with a private"]
    #[doc = "                              key, in an interruptible manner."]
    #[doc = ""]
    #[doc = " \\see                         \\c psa_sign_hash_start()"]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = " \\note                        This function combined with \\c"]
    #[doc = "                              psa_sign_hash_start() is equivalent to"]
    #[doc = "                              \\c psa_sign_hash() but this function can return"]
    #[doc = "                              early and resume according to the limit set with"]
    #[doc = "                              \\c psa_interruptible_set_max_ops() to reduce the"]
    #[doc = "                              maximum time spent in a function call."]
    #[doc = ""]
    #[doc = " \\note                        Users should call this function on the same"]
    #[doc = "                              operation object repeatedly until it either"]
    #[doc = "                              returns 0 or an error. This function will return"]
    #[doc = "                              #PSA_OPERATION_INCOMPLETE if there is more work"]
    #[doc = "                              to do. Alternatively users can call"]
    #[doc = "                              \\c psa_sign_hash_abort() at any point if they no"]
    #[doc = "                              longer want the result."]
    #[doc = ""]
    #[doc = " \\note                        When this function returns successfully, the"]
    #[doc = "                              operation becomes inactive. If this function"]
    #[doc = "                              returns an error status, the operation enters an"]
    #[doc = "                              error state and must be aborted by calling"]
    #[doc = "                              \\c psa_sign_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in, out] operation    The \\c psa_sign_hash_interruptible_operation_t"]
    #[doc = "                              to use. This must be initialized first, and have"]
    #[doc = "                              had \\c psa_sign_hash_start() called with it"]
    #[doc = "                              first."]
    #[doc = ""]
    #[doc = " \\param[out] signature        Buffer where the signature is to be written."]
    #[doc = " \\param signature_size        Size of the \\p signature buffer in bytes. This"]
    #[doc = "                              must be appropriate for the selected"]
    #[doc = "                              algorithm and key:"]
    #[doc = "                              - The required signature size is"]
    #[doc = "                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c"]
    #[doc = "                                key_bits, \\c alg) where \\c key_type and \\c"]
    #[doc = "                                key_bits are the type and bit-size"]
    #[doc = "                                respectively of key."]
    #[doc = "                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the"]
    #[doc = "                                maximum signature size of any supported"]
    #[doc = "                                signature algorithm."]
    #[doc = " \\param[out] signature_length On success, the number of bytes that make up"]
    #[doc = "                              the returned signature value."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Operation completed successfully"]
    #[doc = ""]
    #[doc = " \\retval #PSA_OPERATION_INCOMPLETE"]
    #[doc = "         Operation was interrupted due to the setting of \\c"]
    #[doc = "         psa_interruptible_set_max_ops(). There is still work to be done."]
    #[doc = "         Call this function again with the same operation object."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p signature buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         An operation was not previously started on this context via"]
    #[doc = "         \\c psa_sign_hash_start()."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has either not been previously initialized by"]
    #[doc = "         psa_crypto_init() or you did not previously call"]
    #[doc = "         psa_sign_hash_start() with this operation object. It is"]
    #[doc = "         implementation-dependent whether a failure to initialize results in"]
    #[doc = "         this error code."]
    pub fn psa_sign_hash_complete(
        operation: *mut psa_sign_hash_interruptible_operation_t,
        signature: *mut u8,
        signature_size: size_t,
        signature_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Abort a sign hash operation."]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = " \\note                        This function is the only function that clears"]
    #[doc = "                              the number of ops completed as part of the"]
    #[doc = "                              operation. Please ensure you copy this value via"]
    #[doc = "                              \\c psa_sign_hash_get_num_ops() if required"]
    #[doc = "                              before calling."]
    #[doc = ""]
    #[doc = " \\note                        Aborting an operation frees all associated"]
    #[doc = "                              resources except for the \\p operation structure"]
    #[doc = "                              itself. Once aborted, the operation object can"]
    #[doc = "                              be reused for another operation by calling \\c"]
    #[doc = "                              psa_sign_hash_start() again."]
    #[doc = ""]
    #[doc = " \\note                        You may call this function any time after the"]
    #[doc = "                              operation object has been initialized. In"]
    #[doc = "                              particular, calling \\c psa_sign_hash_abort()"]
    #[doc = "                              after the operation has already been terminated"]
    #[doc = "                              by a call to \\c psa_sign_hash_abort() or"]
    #[doc = "                              psa_sign_hash_complete() is safe."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Initialized sign hash operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The operation was aborted successfully."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_sign_hash_abort(
        operation: *mut psa_sign_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Start reading and verifying a hash or short"]
    #[doc = "                              message, in an interruptible manner."]
    #[doc = ""]
    #[doc = " \\see                         \\c psa_verify_hash_complete()"]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = " \\note                        This function combined with \\c"]
    #[doc = "                              psa_verify_hash_complete() is equivalent to"]
    #[doc = "                              \\c psa_verify_hash() but \\c"]
    #[doc = "                              psa_verify_hash_complete() can return early and"]
    #[doc = "                              resume according to the limit set with \\c"]
    #[doc = "                              psa_interruptible_set_max_ops() to reduce the"]
    #[doc = "                              maximum time spent in a function."]
    #[doc = ""]
    #[doc = " \\note                        Users should call \\c psa_verify_hash_complete()"]
    #[doc = "                              repeatedly on the same operation object after a"]
    #[doc = "                              successful call to this function until \\c"]
    #[doc = "                              psa_verify_hash_complete() either returns 0 or"]
    #[doc = "                              an error. \\c psa_verify_hash_complete() will"]
    #[doc = "                              return #PSA_OPERATION_INCOMPLETE if there is"]
    #[doc = "                              more work to do. Alternatively users can call"]
    #[doc = "                              \\c psa_verify_hash_abort() at any point if they"]
    #[doc = "                              no longer want the result."]
    #[doc = ""]
    #[doc = " \\note                        If this function returns an error status, the"]
    #[doc = "                              operation enters an error state and must be"]
    #[doc = "                              aborted by calling \\c psa_verify_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in, out] operation    The \\c psa_verify_hash_interruptible_operation_t"]
    #[doc = "                              to use. This must be initialized first."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              The key must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_VERIFY_HASH."]
    #[doc = " \\param alg                   A signature algorithm (\\c PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)"]
    #[doc = "                              is true), that is compatible with"]
    #[doc = "                              the type of \\p key."]
    #[doc = " \\param[in] hash              The hash whose signature is to be verified."]
    #[doc = " \\param hash_length           Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[in] signature         Buffer containing the signature to verify."]
    #[doc = " \\param signature_length      Size of the \\p signature buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The operation started successfully - please call \\c"]
    #[doc = "         psa_verify_hash_complete() with the same context to complete the"]
    #[doc = "         operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Another operation has already been started on this context, and is"]
    #[doc = "         still in progress."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_VERIFY_HASH flag, or it does"]
    #[doc = "         not permit the requested algorithm."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_verify_hash_start(
        operation: *mut psa_verify_hash_interruptible_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: size_t,
        signature: *const u8,
        signature_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Continue and eventually complete the action of"]
    #[doc = "                              reading and verifying a hash or short message"]
    #[doc = "                              signed with a private key, in an interruptible"]
    #[doc = "                              manner."]
    #[doc = ""]
    #[doc = " \\see                         \\c psa_verify_hash_start()"]
    #[doc = ""]
    #[doc = " \\warning                     This is a beta API, and thus subject to change"]
    #[doc = "                              at any point. It is not bound by the usual"]
    #[doc = "                              interface stability promises."]
    #[doc = ""]
    #[doc = " \\note                        This function combined with \\c"]
    #[doc = "                              psa_verify_hash_start() is equivalent to"]
    #[doc = "                              \\c psa_verify_hash() but this function can"]
    #[doc = "                              return early and resume according to the limit"]
    #[doc = "                              set with \\c psa_interruptible_set_max_ops() to"]
    #[doc = "                              reduce the maximum time spent in a function"]
    #[doc = "                              call."]
    #[doc = ""]
    #[doc = " \\note                        Users should call this function on the same"]
    #[doc = "                              operation object repeatedly until it either"]
    #[doc = "                              returns 0 or an error. This function will return"]
    #[doc = "                              #PSA_OPERATION_INCOMPLETE if there is more work"]
    #[doc = "                              to do. Alternatively users can call"]
    #[doc = "                              \\c psa_verify_hash_abort() at any point if they"]
    #[doc = "                              no longer want the result."]
    #[doc = ""]
    #[doc = " \\note                        When this function returns successfully, the"]
    #[doc = "                              operation becomes inactive. If this function"]
    #[doc = "                              returns an error status, the operation enters an"]
    #[doc = "                              error state and must be aborted by calling"]
    #[doc = "                              \\c psa_verify_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in, out] operation    The \\c psa_verify_hash_interruptible_operation_t"]
    #[doc = "                              to use. This must be initialized first, and have"]
    #[doc = "                              had \\c psa_verify_hash_start() called with it"]
    #[doc = "                              first."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Operation completed successfully, and the passed signature is valid."]
    #[doc = ""]
    #[doc = " \\retval #PSA_OPERATION_INCOMPLETE"]
    #[doc = "         Operation was interrupted due to the setting of \\c"]
    #[doc = "         psa_interruptible_set_max_ops(). There is still work to be done."]
    #[doc = "         Call this function again with the same operation object."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The calculation was performed successfully, but the passed"]
    #[doc = "         signature is not a valid signature."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         An operation was not previously started on this context via"]
    #[doc = "         \\c psa_verify_hash_start()."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has either not been previously initialized by"]
    #[doc = "         psa_crypto_init() or you did not previously call"]
    #[doc = "         psa_verify_hash_start() on this object. It is"]
    #[doc = "         implementation-dependent whether a failure to initialize results in"]
    #[doc = "         this error code."]
    pub fn psa_verify_hash_complete(
        operation: *mut psa_verify_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                     Abort a verify hash operation."]
    #[doc = ""]
    #[doc = " \\warning                   This is a beta API, and thus subject to change at"]
    #[doc = "                            any point. It is not bound by the usual interface"]
    #[doc = "                            stability promises."]
    #[doc = ""]
    #[doc = " \\note                      This function is the only function that clears the"]
    #[doc = "                            number of ops completed as part of the operation."]
    #[doc = "                            Please ensure you copy this value via"]
    #[doc = "                            \\c psa_verify_hash_get_num_ops() if required"]
    #[doc = "                            before calling."]
    #[doc = ""]
    #[doc = " \\note                      Aborting an operation frees all associated"]
    #[doc = "                            resources except for the operation structure"]
    #[doc = "                            itself. Once aborted, the operation object can be"]
    #[doc = "                            reused for another operation by calling \\c"]
    #[doc = "                            psa_verify_hash_start() again."]
    #[doc = ""]
    #[doc = " \\note                      You may call this function any time after the"]
    #[doc = "                            operation object has been initialized."]
    #[doc = "                            In particular, calling \\c psa_verify_hash_abort()"]
    #[doc = "                            after the operation has already been terminated by"]
    #[doc = "                            a call to \\c psa_verify_hash_abort() or"]
    #[doc = "                            psa_verify_hash_complete() is safe."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation   Initialized verify hash operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The operation was aborted successfully."]
    #[doc = ""]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_verify_hash_abort(
        operation: *mut psa_verify_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
#[doc = " The CMAC context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cmac_context_t {
    pub private_state: [crate::c_types::c_uchar; 16usize],
    pub private_unprocessed_block: [crate::c_types::c_uchar; 16usize],
    pub private_unprocessed_len: size_t,
}
extern "C" {
    #[doc = " \\brief               This function starts a new CMAC computation"]
    #[doc = "                      by setting the CMAC key, and preparing to authenticate"]
    #[doc = "                      the input data."]
    #[doc = "                      It must be called with an initialized cipher context."]
    #[doc = ""]
    #[doc = "                      Once this function has completed, data can be supplied"]
    #[doc = "                      to the CMAC computation by calling"]
    #[doc = "                      mbedtls_cipher_cmac_update()."]
    #[doc = ""]
    #[doc = "                      To start a CMAC computation using the same key as a previous"]
    #[doc = "                      CMAC computation, use mbedtls_cipher_cmac_finish()."]
    #[doc = ""]
    #[doc = " \\note                When the CMAC implementation is supplied by an alternate"]
    #[doc = "                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers"]
    #[doc = "                      may not be supported by that implementation, and thus"]
    #[doc = "                      return an error. Alternate implementations must support"]
    #[doc = "                      AES-128 and AES-256, and may support AES-192 and 3DES."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation, initialized"]
    #[doc = "                      as one of the following types: MBEDTLS_CIPHER_AES_128_ECB,"]
    #[doc = "                      MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_CIPHER_AES_256_ECB,"]
    #[doc = "                      or MBEDTLS_CIPHER_DES_EDE3_ECB."]
    #[doc = " \\param key           The CMAC key."]
    #[doc = " \\param keybits       The length of the CMAC key in bits."]
    #[doc = "                      Must be supported by the cipher."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_cmac_starts(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const crate::c_types::c_uchar,
        keybits: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function feeds an input buffer into an ongoing CMAC"]
    #[doc = "                      computation."]
    #[doc = ""]
    #[doc = "                      The CMAC computation must have previously been started"]
    #[doc = "                      by calling mbedtls_cipher_cmac_starts() or"]
    #[doc = "                      mbedtls_cipher_cmac_reset()."]
    #[doc = ""]
    #[doc = "                      Call this function as many times as needed to input the"]
    #[doc = "                      data to be authenticated."]
    #[doc = "                      Once all of the required data has been input,"]
    #[doc = "                      call mbedtls_cipher_cmac_finish() to obtain the result"]
    #[doc = "                      of the CMAC operation."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = ""]
    #[doc = " \\return             \\c 0 on success."]
    #[doc = " \\return             #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                     if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function finishes an ongoing CMAC operation, and"]
    #[doc = "                      writes the result to the output buffer."]
    #[doc = ""]
    #[doc = "                      It should be followed either by"]
    #[doc = "                      mbedtls_cipher_cmac_reset(), which starts another CMAC"]
    #[doc = "                      operation with the same key, or mbedtls_cipher_free(),"]
    #[doc = "                      which clears the cipher context."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation."]
    #[doc = " \\param output        The output buffer for the CMAC checksum result."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function starts a new CMAC operation with the same"]
    #[doc = "                      key as the previous one."]
    #[doc = ""]
    #[doc = "                      It should be called after finishing the previous CMAC"]
    #[doc = "                      operation with mbedtls_cipher_cmac_finish()."]
    #[doc = "                      After calling this function,"]
    #[doc = "                      call mbedtls_cipher_cmac_update() to supply the new"]
    #[doc = "                      CMAC operation with data."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_reset(ctx: *mut mbedtls_cipher_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function calculates the full generic CMAC"]
    #[doc = "                      on the input buffer with the provided key."]
    #[doc = ""]
    #[doc = "                      The function allocates the context, performs the"]
    #[doc = "                      calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                      The CMAC result is calculated as"]
    #[doc = "                      output = generic CMAC(cmac key, input buffer)."]
    #[doc = ""]
    #[doc = " \\note                When the CMAC implementation is supplied by an alternate"]
    #[doc = "                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers"]
    #[doc = "                      may not be supported by that implementation, and thus"]
    #[doc = "                      return an error. Alternate implementations must support"]
    #[doc = "                      AES-128 and AES-256, and may support AES-192 and 3DES."]
    #[doc = ""]
    #[doc = " \\param cipher_info   The cipher information."]
    #[doc = " \\param key           The CMAC key."]
    #[doc = " \\param keylen        The length of the CMAC key in bits."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the generic CMAC result."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac(
        cipher_info: *const mbedtls_cipher_info_t,
        key: *const crate::c_types::c_uchar,
        keylen: size_t,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function implements the AES-CMAC-PRF-128 pseudorandom"]
    #[doc = "                  function, as defined in"]
    #[doc = "                  <em>RFC-4615: The Advanced Encryption Standard-Cipher-based"]
    #[doc = "                  Message Authentication Code-Pseudo-Random Function-128"]
    #[doc = "                  (AES-CMAC-PRF-128) Algorithm for the Internet Key"]
    #[doc = "                  Exchange Protocol (IKE).</em>"]
    #[doc = ""]
    #[doc = " \\param key       The key to use."]
    #[doc = " \\param key_len   The key length in Bytes."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param in_len    The length of the input data in Bytes."]
    #[doc = " \\param output    The buffer holding the generated 16 Bytes of"]
    #[doc = "                  pseudorandom output."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_aes_cmac_prf_128(
        key: *const crate::c_types::c_uchar,
        key_len: size_t,
        input: *const crate::c_types::c_uchar,
        in_len: size_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The CMAC checkup routine."]
    #[doc = ""]
    #[doc = " \\note           In case the CMAC routines are provided by an alternative"]
    #[doc = "                 implementation (i.e. #MBEDTLS_CMAC_ALT is defined), the"]
    #[doc = "                 checkup routine will succeed even if the implementation does"]
    #[doc = "                 not support the less widely used AES-192 or 3DES primitives."]
    #[doc = "                 The self-test requires at least AES-128 and AES-256 to be"]
    #[doc = "                 supported by the underlying implementation."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_cmac_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The GCM context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_gcm_context {
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    pub private_HL: [u64; 16usize],
    pub private_HH: [u64; 16usize],
    pub private_len: u64,
    pub private_add_len: u64,
    pub private_base_ectr: [crate::c_types::c_uchar; 16usize],
    pub private_y: [crate::c_types::c_uchar; 16usize],
    pub private_buf: [crate::c_types::c_uchar; 16usize],
    pub private_mode: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified GCM context,"]
    #[doc = "                  to make references valid, and prepares the context"]
    #[doc = "                  for mbedtls_gcm_setkey() or mbedtls_gcm_free()."]
    #[doc = ""]
    #[doc = "                  The function does not bind the GCM context to a particular"]
    #[doc = "                  cipher, nor set the key. For this purpose, use"]
    #[doc = "                  mbedtls_gcm_setkey()."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_gcm_init(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
    #[doc = " \\brief           This function associates a GCM context with a"]
    #[doc = "                  cipher algorithm and a key."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param cipher    The 128-bit block cipher to use."]
    #[doc = " \\param key       The encryption key. This must be a readable buffer of at"]
    #[doc = "                  least \\p keybits bits."]
    #[doc = " \\param keybits   The key size in bits. Valid options are:"]
    #[doc = "                  <ul><li>128 bits</li>"]
    #[doc = "                  <li>192 bits</li>"]
    #[doc = "                  <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A cipher-specific error code on failure."]
    pub fn mbedtls_gcm_setkey(
        ctx: *mut mbedtls_gcm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs GCM encryption or decryption of a buffer."]
    #[doc = ""]
    #[doc = " \\note            For encryption, the output buffer can be the same as the"]
    #[doc = "                  input buffer. For decryption, the output buffer cannot be"]
    #[doc = "                  the same as input buffer. If the buffers overlap, the output"]
    #[doc = "                  buffer must trail at least 8 Bytes behind the input buffer."]
    #[doc = ""]
    #[doc = " \\warning         When this function performs a decryption, it outputs the"]
    #[doc = "                  authentication tag and does not verify that the data is"]
    #[doc = "                  authentic. You should use this function to perform encryption"]
    #[doc = "                  only. For decryption, use mbedtls_gcm_auth_decrypt() instead."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context to use for encryption or decryption. This"]
    #[doc = "                  must be initialized."]
    #[doc = " \\param mode      The operation to perform:"]
    #[doc = "                  - #MBEDTLS_GCM_ENCRYPT to perform authenticated encryption."]
    #[doc = "                    The ciphertext is written to \\p output and the"]
    #[doc = "                    authentication tag is written to \\p tag."]
    #[doc = "                  - #MBEDTLS_GCM_DECRYPT to perform decryption."]
    #[doc = "                    The plaintext is written to \\p output and the"]
    #[doc = "                    authentication tag is written to \\p tag."]
    #[doc = "                    Note that this mode is not recommended, because it does"]
    #[doc = "                    not verify the authenticity of the data. For this reason,"]
    #[doc = "                    you should use mbedtls_gcm_auth_decrypt() instead of"]
    #[doc = "                    calling this function in decryption mode."]
    #[doc = " \\param length    The length of the input data, which is equal to the length"]
    #[doc = "                  of the output data."]
    #[doc = " \\param iv        The initialization vector. This must be a readable buffer of"]
    #[doc = "                  at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the IV."]
    #[doc = " \\param add       The buffer holding the additional data. This must be of at"]
    #[doc = "                  least that size in Bytes."]
    #[doc = " \\param add_len   The length of the additional data."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, this must be a readable buffer of at least that"]
    #[doc = "                  size in Bytes."]
    #[doc = " \\param output    The buffer for holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, this must be a writable buffer of at least that"]
    #[doc = "                  size in Bytes."]
    #[doc = " \\param tag_len   The length of the tag to generate."]
    #[doc = " \\param tag       The buffer for holding the tag. This must be a writable"]
    #[doc = "                  buffer of at least \\p tag_len Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the encryption or decryption was performed"]
    #[doc = "                  successfully. Note that in #MBEDTLS_GCM_DECRYPT mode,"]
    #[doc = "                  this does not indicate that the data is authentic."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are"]
    #[doc = "                  not valid or a cipher-specific error code if the encryption"]
    #[doc = "                  or decryption failed."]
    pub fn mbedtls_gcm_crypt_and_tag(
        ctx: *mut mbedtls_gcm_context,
        mode: crate::c_types::c_int,
        length: size_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        add: *const crate::c_types::c_uchar,
        add_len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag_len: size_t,
        tag: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a GCM authenticated decryption of a"]
    #[doc = "                  buffer."]
    #[doc = ""]
    #[doc = " \\note            For decryption, the output buffer cannot be the same as"]
    #[doc = "                  input buffer. If the buffers overlap, the output buffer"]
    #[doc = "                  must trail at least 8 Bytes behind the input buffer."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param length    The length of the ciphertext to decrypt, which is also"]
    #[doc = "                  the length of the decrypted plaintext."]
    #[doc = " \\param iv        The initialization vector. This must be a readable buffer"]
    #[doc = "                  of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the IV."]
    #[doc = " \\param add       The buffer holding the additional data. This must be of at"]
    #[doc = "                  least that size in Bytes."]
    #[doc = " \\param add_len   The length of the additional data."]
    #[doc = " \\param tag       The buffer holding the tag to verify. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the tag to verify."]
    #[doc = " \\param input     The buffer holding the ciphertext. If \\p length is greater"]
    #[doc = "                  than zero, this must be a readable buffer of at least that"]
    #[doc = "                  size."]
    #[doc = " \\param output    The buffer for holding the decrypted plaintext. If \\p length"]
    #[doc = "                  is greater than zero, this must be a writable buffer of at"]
    #[doc = "                  least that size."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful and authenticated."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_AUTH_FAILED if the tag does not match."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are"]
    #[doc = "                  not valid or a cipher-specific error code if the decryption"]
    #[doc = "                  failed."]
    pub fn mbedtls_gcm_auth_decrypt(
        ctx: *mut mbedtls_gcm_context,
        length: size_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        add: *const crate::c_types::c_uchar,
        add_len: size_t,
        tag: *const crate::c_types::c_uchar,
        tag_len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a GCM encryption or decryption"]
    #[doc = "                  operation."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or"]
    #[doc = "                  #MBEDTLS_GCM_DECRYPT."]
    #[doc = " \\param iv        The initialization vector. This must be a readable buffer of"]
    #[doc = "                  at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the IV."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_gcm_starts(
        ctx: *mut mbedtls_gcm_context,
        mode: crate::c_types::c_int,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer as associated data"]
    #[doc = "                  (authenticated but not encrypted data) in a GCM"]
    #[doc = "                  encryption or decryption operation."]
    #[doc = ""]
    #[doc = "                  Call this function after mbedtls_gcm_starts() to pass"]
    #[doc = "                  the associated data. If the associated data is empty,"]
    #[doc = "                  you do not need to call this function. You may not"]
    #[doc = "                  call this function after calling mbedtls_cipher_update()."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must have been started with"]
    #[doc = "                  mbedtls_gcm_starts() and must not have yet received"]
    #[doc = "                  any input with mbedtls_gcm_update()."]
    #[doc = " \\param add       The buffer holding the additional data, or \\c NULL"]
    #[doc = "                  if \\p add_len is \\c 0."]
    #[doc = " \\param add_len   The length of the additional data. If \\c 0,"]
    #[doc = "                  \\p add may be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_gcm_update_ad(
        ctx: *mut mbedtls_gcm_context,
        add: *const crate::c_types::c_uchar,
        add_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing GCM"]
    #[doc = "                  encryption or decryption operation."]
    #[doc = ""]
    #[doc = "                  You may call this function zero, one or more times"]
    #[doc = "                  to pass successive parts of the input: the plaintext to"]
    #[doc = "                  encrypt, or the ciphertext (not including the tag) to"]
    #[doc = "                  decrypt. After the last part of the input, call"]
    #[doc = "                  mbedtls_gcm_finish()."]
    #[doc = ""]
    #[doc = "                  This function may produce output in one of the following"]
    #[doc = "                  ways:"]
    #[doc = "                  - Immediate output: the output length is always equal"]
    #[doc = "                    to the input length."]
    #[doc = "                  - Buffered output: the output consists of a whole number"]
    #[doc = "                    of 16-byte blocks. If the total input length so far"]
    #[doc = "                    (not including associated data) is 16 \\* *B* + *A*"]
    #[doc = "                    with *A* < 16 then the total output length is 16 \\* *B*."]
    #[doc = ""]
    #[doc = "                  In particular:"]
    #[doc = "                  - It is always correct to call this function with"]
    #[doc = "                    \\p output_size >= \\p input_length + 15."]
    #[doc = "                  - If \\p input_length is a multiple of 16 for all the calls"]
    #[doc = "                    to this function during an operation, then it is"]
    #[doc = "                    correct to use \\p output_size = \\p input_length."]
    #[doc = ""]
    #[doc = " \\note            For decryption, the output buffer cannot be the same as"]
    #[doc = "                  input buffer. If the buffers overlap, the output buffer"]
    #[doc = "                  must trail at least 8 Bytes behind the input buffer."]
    #[doc = ""]
    #[doc = " \\param ctx           The GCM context. This must be initialized."]
    #[doc = " \\param input         The buffer holding the input data. If \\p input_length"]
    #[doc = "                      is greater than zero, this must be a readable buffer"]
    #[doc = "                      of at least \\p input_length bytes."]
    #[doc = " \\param input_length  The length of the input data in bytes."]
    #[doc = " \\param output        The buffer for the output data. If \\p output_size"]
    #[doc = "                      is greater than zero, this must be a writable buffer of"]
    #[doc = "                      of at least \\p output_size bytes."]
    #[doc = " \\param output_size   The size of the output buffer in bytes."]
    #[doc = "                      See the function description regarding the output size."]
    #[doc = " \\param output_length On success, \\p *output_length contains the actual"]
    #[doc = "                      length of the output written in \\p output."]
    #[doc = "                      On failure, the content of \\p *output_length is"]
    #[doc = "                      unspecified."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_GCM_BAD_INPUT on failure:"]
    #[doc = "                 total input length too long,"]
    #[doc = "                 unsupported input/output buffer overlap detected,"]
    #[doc = "                 or \\p output_size too small."]
    pub fn mbedtls_gcm_update(
        ctx: *mut mbedtls_gcm_context,
        input: *const crate::c_types::c_uchar,
        input_length: size_t,
        output: *mut crate::c_types::c_uchar,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the GCM operation and generates"]
    #[doc = "                  the authentication tag."]
    #[doc = ""]
    #[doc = "                  It wraps up the GCM stream, and generates the"]
    #[doc = "                  tag. The tag can have a maximum length of 16 Bytes."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param tag       The buffer for holding the tag. This must be a writable"]
    #[doc = "                  buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the tag to generate. This must be at least"]
    #[doc = "                  four."]
    #[doc = " \\param output    The buffer for the final output."]
    #[doc = "                  If \\p output_size is nonzero, this must be a writable"]
    #[doc = "                  buffer of at least \\p output_size bytes."]
    #[doc = " \\param output_size  The size of the \\p output buffer in bytes."]
    #[doc = "                  This must be large enough for the output that"]
    #[doc = "                  mbedtls_gcm_update() has not produced. In particular:"]
    #[doc = "                  - If mbedtls_gcm_update() produces immediate output,"]
    #[doc = "                    or if the total input size is a multiple of \\c 16,"]
    #[doc = "                    then mbedtls_gcm_finish() never produces any output,"]
    #[doc = "                    so \\p output_size can be \\c 0."]
    #[doc = "                  - \\p output_size never needs to be more than \\c 15."]
    #[doc = " \\param output_length On success, \\p *output_length contains the actual"]
    #[doc = "                      length of the output written in \\p output."]
    #[doc = "                      On failure, the content of \\p *output_length is"]
    #[doc = "                      unspecified."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_BAD_INPUT on failure:"]
    #[doc = "                  invalid value of \\p tag_len,"]
    #[doc = "                  or \\p output_size too small."]
    pub fn mbedtls_gcm_finish(
        ctx: *mut mbedtls_gcm_context,
        output: *mut crate::c_types::c_uchar,
        output_size: size_t,
        output_length: *mut size_t,
        tag: *mut crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clears a GCM context and the underlying"]
    #[doc = "                  cipher sub-context."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context to clear. If this is \\c NULL, the call has"]
    #[doc = "                  no effect. Otherwise, this must be initialized."]
    pub fn mbedtls_gcm_free(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
    #[doc = " \\brief          The GCM checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_gcm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief    The CCM context-type definition. The CCM context is passed"]
#[doc = "           to the APIs called."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ccm_context {
    pub private_y: [crate::c_types::c_uchar; 16usize],
    pub private_ctr: [crate::c_types::c_uchar; 16usize],
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    pub private_plaintext_len: size_t,
    pub private_add_len: size_t,
    pub private_tag_len: size_t,
    pub private_processed: size_t,
    pub private_q: crate::c_types::c_uchar,
    pub private_mode: crate::c_types::c_uchar,
    pub private_state: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified CCM context,"]
    #[doc = "                  to make references valid, and prepare the context"]
    #[doc = "                  for mbedtls_ccm_setkey() or mbedtls_ccm_free()."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_ccm_init(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function initializes the CCM context set in the"]
    #[doc = "                  \\p ctx parameter and sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to initialize. This must be an initialized"]
    #[doc = "                  context."]
    #[doc = " \\param cipher    The 128-bit block cipher to use."]
    #[doc = " \\param key       The encryption key. This must not be \\c NULL."]
    #[doc = " \\param keybits   The key size in bits. This must be acceptable by the cipher."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_setkey(
        ctx: *mut mbedtls_ccm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function releases and clears the specified CCM context"]
    #[doc = "          and underlying cipher sub-context."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to clear. If this is \\c NULL, the function"]
    #[doc = "                  has no effect. Otherwise, this must be initialized."]
    pub fn mbedtls_ccm_free(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM."]
    #[doc = ""]
    #[doc = " \\note            The tag is written to a separate buffer. To concatenate"]
    #[doc = "                  the \\p tag with the \\p output, as done in <em>RFC-3610:"]
    #[doc = "                  Counter with CBC-MAC (CCM)</em>, use"]
    #[doc = "                  \\p tag = \\p output + \\p length, and make sure that the"]
    #[doc = "                  output buffer is at least \\p length + \\p tag_len wide."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for encryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param ad        The additional data field. If \\p ad_len is greater than"]
    #[doc = "                  zero, \\p ad must be a readable buffer of at least that"]
    #[doc = "                  length."]
    #[doc = " \\param ad_len    The length of additional data in Bytes."]
    #[doc = "                  This must be less than `2^16 - 2^8`."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  writable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field to generate in Bytes:"]
    #[doc = "                  4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: size_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM*."]
    #[doc = ""]
    #[doc = " \\note            The tag is written to a separate buffer. To concatenate"]
    #[doc = "                  the \\p tag with the \\p output, as done in <em>RFC-3610:"]
    #[doc = "                  Counter with CBC-MAC (CCM)</em>, use"]
    #[doc = "                  \\p tag = \\p output + \\p length, and make sure that the"]
    #[doc = "                  output buffer is at least \\p length + \\p tag_len wide."]
    #[doc = ""]
    #[doc = " \\note            When using this function in a variable tag length context,"]
    #[doc = "                  the tag length has to be encoded into the \\p iv passed to"]
    #[doc = "                  this function."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for encryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = "                  For tag length = 0, input length is ignored."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param ad        The additional data field. This must be a readable buffer of"]
    #[doc = "                  at least \\p ad_len Bytes."]
    #[doc = " \\param ad_len    The length of additional data in Bytes."]
    #[doc = "                  This must be less than 2^16 - 2^8."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  writable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field to generate in Bytes:"]
    #[doc = "                  0, 4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\warning         Passing \\c 0 as \\p tag_len means that the message is no"]
    #[doc = "                  longer authenticated."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_star_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: size_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM authenticated decryption of a"]
    #[doc = "                  buffer."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for decryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param ad        The additional data field. This must be a readable buffer"]
    #[doc = "                  of at least that \\p ad_len Bytes.."]
    #[doc = " \\param ad_len    The length of additional data in Bytes."]
    #[doc = "                  This must be less than 2^16 - 2^8."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field to generate in Bytes:"]
    #[doc = "                  4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success. This indicates that the message is authentic."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match."]
    #[doc = " \\return          A cipher-specific error code on calculation failure."]
    pub fn mbedtls_ccm_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: size_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *const crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM* authenticated decryption of a"]
    #[doc = "                  buffer."]
    #[doc = ""]
    #[doc = " \\note            When using this function in a variable tag length context,"]
    #[doc = "                  the tag length has to be decoded from \\p iv and passed to"]
    #[doc = "                  this function as \\p tag_len. (\\p tag needs to be adjusted"]
    #[doc = "                  accordingly.)"]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for decryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = "                  For tag length = 0, input length is ignored."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param ad        The additional data field. This must be a readable buffer of"]
    #[doc = "                  at least that \\p ad_len Bytes."]
    #[doc = " \\param ad_len    The length of additional data in Bytes."]
    #[doc = "                  This must be less than 2^16 - 2^8."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field in Bytes."]
    #[doc = "                  0, 4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\warning         Passing \\c 0 as \\p tag_len means that the message is nos"]
    #[doc = "                  longer authenticated."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match."]
    #[doc = " \\return          A cipher-specific error code on calculation failure."]
    pub fn mbedtls_ccm_star_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: size_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *const crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a CCM encryption or decryption"]
    #[doc = "                  operation."]
    #[doc = ""]
    #[doc = "                  This function and mbedtls_ccm_set_lengths() must be called"]
    #[doc = "                  before calling mbedtls_ccm_update_ad() or"]
    #[doc = "                  mbedtls_ccm_update(). This function can be called before"]
    #[doc = "                  or after mbedtls_ccm_set_lengths()."]
    #[doc = ""]
    #[doc = " \\note            This function is not implemented in Mbed TLS yet."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context. This must be initialized."]
    #[doc = " \\param mode      The operation to perform: #MBEDTLS_CCM_ENCRYPT or"]
    #[doc = "                  #MBEDTLS_CCM_DECRYPT or #MBEDTLS_CCM_STAR_ENCRYPT or"]
    #[doc = "                  #MBEDTLS_CCM_STAR_DECRYPT."]
    #[doc = " \\param iv        The initialization vector. This must be a readable buffer"]
    #[doc = "                  of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:"]
    #[doc = "                  \\p ctx is in an invalid state,"]
    #[doc = "                  \\p mode is invalid,"]
    #[doc = "                  \\p iv_len is invalid (lower than \\c 7 or greater than"]
    #[doc = "                  \\c 13)."]
    pub fn mbedtls_ccm_starts(
        ctx: *mut mbedtls_ccm_context,
        mode: crate::c_types::c_int,
        iv: *const crate::c_types::c_uchar,
        iv_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function declares the lengths of the message"]
    #[doc = "                  and additional data for a CCM encryption or decryption"]
    #[doc = "                  operation."]
    #[doc = ""]
    #[doc = "                  This function and mbedtls_ccm_starts() must be called"]
    #[doc = "                  before calling mbedtls_ccm_update_ad() or"]
    #[doc = "                  mbedtls_ccm_update(). This function can be called before"]
    #[doc = "                  or after mbedtls_ccm_starts()."]
    #[doc = ""]
    #[doc = " \\note            This function is not implemented in Mbed TLS yet."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context. This must be initialized."]
    #[doc = " \\param total_ad_len   The total length of additional data in bytes."]
    #[doc = "                       This must be less than `2^16 - 2^8`."]
    #[doc = " \\param plaintext_len  The length in bytes of the plaintext to encrypt or"]
    #[doc = "                       result of the decryption (thus not encompassing the"]
    #[doc = "                       additional data that are not encrypted)."]
    #[doc = " \\param tag_len   The length of the tag to generate in Bytes:"]
    #[doc = "                  4, 6, 8, 10, 12, 14 or 16."]
    #[doc = "                  For CCM*, zero is also valid."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:"]
    #[doc = "                  \\p ctx is in an invalid state,"]
    #[doc = "                  \\p total_ad_len is greater than \\c 0xFF00."]
    pub fn mbedtls_ccm_set_lengths(
        ctx: *mut mbedtls_ccm_context,
        total_ad_len: size_t,
        plaintext_len: size_t,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer as associated data"]
    #[doc = "                  (authenticated but not encrypted data) in a CCM"]
    #[doc = "                  encryption or decryption operation."]
    #[doc = ""]
    #[doc = "                  You may call this function zero, one or more times"]
    #[doc = "                  to pass successive parts of the additional data. The"]
    #[doc = "                  lengths \\p ad_len of the data parts should eventually add"]
    #[doc = "                  up exactly to the total length of additional data"]
    #[doc = "                  \\c total_ad_len passed to mbedtls_ccm_set_lengths(). You"]
    #[doc = "                  may not call this function after calling"]
    #[doc = "                  mbedtls_ccm_update()."]
    #[doc = ""]
    #[doc = " \\note            This function is not implemented in Mbed TLS yet."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context. This must have been started with"]
    #[doc = "                  mbedtls_ccm_starts(), the lengths of the message and"]
    #[doc = "                  additional data must have been declared with"]
    #[doc = "                  mbedtls_ccm_set_lengths() and this must not have yet"]
    #[doc = "                  received any input with mbedtls_ccm_update()."]
    #[doc = " \\param ad        The buffer holding the additional data, or \\c NULL"]
    #[doc = "                  if \\p ad_len is \\c 0."]
    #[doc = " \\param ad_len    The length of the additional data. If \\c 0,"]
    #[doc = "                  \\p ad may be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:"]
    #[doc = "                  \\p ctx is in an invalid state,"]
    #[doc = "                  total input length too long."]
    pub fn mbedtls_ccm_update_ad(
        ctx: *mut mbedtls_ccm_context,
        ad: *const crate::c_types::c_uchar,
        ad_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing CCM"]
    #[doc = "                  encryption or decryption operation."]
    #[doc = ""]
    #[doc = "                  You may call this function zero, one or more times"]
    #[doc = "                  to pass successive parts of the input: the plaintext to"]
    #[doc = "                  encrypt, or the ciphertext (not including the tag) to"]
    #[doc = "                  decrypt. After the last part of the input, call"]
    #[doc = "                  mbedtls_ccm_finish(). The lengths \\p input_len of the"]
    #[doc = "                  data parts should eventually add up exactly to the"]
    #[doc = "                  plaintext length \\c plaintext_len passed to"]
    #[doc = "                  mbedtls_ccm_set_lengths()."]
    #[doc = ""]
    #[doc = "                  This function may produce output in one of the following"]
    #[doc = "                  ways:"]
    #[doc = "                  - Immediate output: the output length is always equal"]
    #[doc = "                    to the input length."]
    #[doc = "                  - Buffered output: except for the last part of input data,"]
    #[doc = "                    the output consists of a whole number of 16-byte blocks."]
    #[doc = "                    If the total input length so far (not including"]
    #[doc = "                    associated data) is 16 \\* *B* + *A* with *A* < 16 then"]
    #[doc = "                    the total output length is 16 \\* *B*."]
    #[doc = "                    For the last part of input data, the output length is"]
    #[doc = "                    equal to the input length plus the number of bytes (*A*)"]
    #[doc = "                    buffered in the previous call to the function (if any)."]
    #[doc = "                    The function uses the plaintext length"]
    #[doc = "                    \\c plaintext_len passed to mbedtls_ccm_set_lengths()"]
    #[doc = "                    to detect the last part of input data."]
    #[doc = ""]
    #[doc = "                  In particular:"]
    #[doc = "                  - It is always correct to call this function with"]
    #[doc = "                    \\p output_size >= \\p input_len + 15."]
    #[doc = "                  - If \\p input_len is a multiple of 16 for all the calls"]
    #[doc = "                    to this function during an operation (not necessary for"]
    #[doc = "                    the last one) then it is correct to use \\p output_size"]
    #[doc = "                    =\\p input_len."]
    #[doc = ""]
    #[doc = " \\note            This function is not implemented in Mbed TLS yet."]
    #[doc = ""]
    #[doc = " \\param ctx           The CCM context. This must have been started with"]
    #[doc = "                      mbedtls_ccm_starts() and the lengths of the message and"]
    #[doc = "                      additional data must have been declared with"]
    #[doc = "                      mbedtls_ccm_set_lengths()."]
    #[doc = " \\param input         The buffer holding the input data. If \\p input_len"]
    #[doc = "                      is greater than zero, this must be a readable buffer"]
    #[doc = "                      of at least \\p input_len bytes."]
    #[doc = " \\param input_len     The length of the input data in bytes."]
    #[doc = " \\param output        The buffer for the output data. If \\p output_size"]
    #[doc = "                      is greater than zero, this must be a writable buffer of"]
    #[doc = "                      at least \\p output_size bytes."]
    #[doc = " \\param output_size   The size of the output buffer in bytes."]
    #[doc = "                      See the function description regarding the output size."]
    #[doc = " \\param output_len    On success, \\p *output_len contains the actual"]
    #[doc = "                      length of the output written in \\p output."]
    #[doc = "                      On failure, the content of \\p *output_len is"]
    #[doc = "                      unspecified."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_CCM_BAD_INPUT on failure:"]
    #[doc = "                 \\p ctx is in an invalid state,"]
    #[doc = "                 total input length too long,"]
    #[doc = "                 or \\p output_size too small."]
    pub fn mbedtls_ccm_update(
        ctx: *mut mbedtls_ccm_context,
        input: *const crate::c_types::c_uchar,
        input_len: size_t,
        output: *mut crate::c_types::c_uchar,
        output_size: size_t,
        output_len: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the CCM operation and generates"]
    #[doc = "                  the authentication tag."]
    #[doc = ""]
    #[doc = "                  It wraps up the CCM stream, and generates the"]
    #[doc = "                  tag. The tag can have a maximum length of 16 Bytes."]
    #[doc = ""]
    #[doc = " \\note            This function is not implemented in Mbed TLS yet."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context. This must have been started with"]
    #[doc = "                  mbedtls_ccm_starts() and the lengths of the message and"]
    #[doc = "                  additional data must have been declared with"]
    #[doc = "                  mbedtls_ccm_set_lengths()."]
    #[doc = " \\param tag       The buffer for holding the tag. If \\p tag_len is greater"]
    #[doc = "                  than zero, this must be a writable buffer of at least \\p"]
    #[doc = "                  tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the tag. Must match the tag length passed to"]
    #[doc = "                  mbedtls_ccm_set_lengths() function."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:"]
    #[doc = "                  \\p ctx is in an invalid state,"]
    #[doc = "                  invalid value of \\p tag_len,"]
    #[doc = "                  the total amount of additional data passed to"]
    #[doc = "                  mbedtls_ccm_update_ad() was lower than the total length of"]
    #[doc = "                  additional data \\c total_ad_len passed to"]
    #[doc = "                  mbedtls_ccm_set_lengths(),"]
    #[doc = "                  the total amount of input data passed to"]
    #[doc = "                  mbedtls_ccm_update() was lower than the plaintext length"]
    #[doc = "                  \\c plaintext_len passed to mbedtls_ccm_set_lengths()."]
    pub fn mbedtls_ccm_finish(
        ctx: *mut mbedtls_ccm_context,
        tag: *mut crate::c_types::c_uchar,
        tag_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The CCM checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_ccm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_poly1305_context {
    pub private_r: [u32; 4usize],
    pub private_s: [u32; 4usize],
    pub private_acc: [u32; 5usize],
    pub private_queue: [u8; 16usize],
    pub private_queue_len: size_t,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified Poly1305 context."]
    #[doc = ""]
    #[doc = "                  It must be the first API called before using"]
    #[doc = "                  the context."]
    #[doc = ""]
    #[doc = "                  It is usually followed by a call to"]
    #[doc = "                  \\c mbedtls_poly1305_starts(), then one or more calls to"]
    #[doc = "                  \\c mbedtls_poly1305_update(), then one call to"]
    #[doc = "                  \\c mbedtls_poly1305_finish(), then finally"]
    #[doc = "                  \\c mbedtls_poly1305_free()."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to initialize. This must"]
    #[doc = "                  not be \\c NULL."]
    pub fn mbedtls_poly1305_init(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified"]
    #[doc = "                  Poly1305 context."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to clear. This may be \\c NULL, in which"]
    #[doc = "                  case this function is a no-op. If it is not \\c NULL, it must"]
    #[doc = "                  point to an initialized Poly1305 context."]
    pub fn mbedtls_poly1305_free(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the one-time authentication key."]
    #[doc = ""]
    #[doc = " \\warning         The key must be unique and unpredictable for each"]
    #[doc = "                  invocation of Poly1305."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to which the key should be bound."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_starts(
        ctx: *mut mbedtls_poly1305_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This functions feeds an input buffer into an ongoing"]
    #[doc = "                  Poly1305 computation."]
    #[doc = ""]
    #[doc = "                  It is called between \\c mbedtls_cipher_poly1305_starts() and"]
    #[doc = "                  \\c mbedtls_cipher_poly1305_finish()."]
    #[doc = "                  It can be called repeatedly to process a stream of data."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to use for the Poly1305 operation."]
    #[doc = "                  This must be initialized and bound to a key."]
    #[doc = " \\param ilen      The length of the input data in Bytes."]
    #[doc = "                  Any value is accepted."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_update(
        ctx: *mut mbedtls_poly1305_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates the Poly1305 Message"]
    #[doc = "                  Authentication Code (MAC)."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to use for the Poly1305 operation."]
    #[doc = "                  This must be initialized and bound to a key."]
    #[doc = " \\param mac       The buffer to where the MAC is written. This must"]
    #[doc = "                  be a writable buffer of length \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_finish(
        ctx: *mut mbedtls_poly1305_context,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function calculates the Poly1305 MAC of the input"]
    #[doc = "                  buffer with the provided key."]
    #[doc = ""]
    #[doc = " \\warning         The key must be unique and unpredictable for each"]
    #[doc = "                  invocation of Poly1305."]
    #[doc = ""]
    #[doc = " \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key."]
    #[doc = " \\param ilen      The length of the input data in Bytes."]
    #[doc = "                  Any value is accepted."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param mac       The buffer to where the MAC is written. This must be"]
    #[doc = "                  a writable buffer of length \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_mac(
        key: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           The Poly1305 checkup routine."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c 1 on failure."]
    pub fn mbedtls_poly1305_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< The mode value for performing encryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_ENCRYPT: mbedtls_chachapoly_mode_t = 0;
#[doc = "< The mode value for performing decryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_DECRYPT: mbedtls_chachapoly_mode_t = 1;
pub type mbedtls_chachapoly_mode_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_chacha20_context {
    pub private_state: [u32; 16usize],
    pub private_keystream8: [u8; 64usize],
    pub private_keystream_bytes_used: size_t,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20 context."]
    #[doc = ""]
    #[doc = "                  It must be the first API called before using"]
    #[doc = "                  the context."]
    #[doc = ""]
    #[doc = "                  It is usually followed by calls to"]
    #[doc = "                  \\c mbedtls_chacha20_setkey() and"]
    #[doc = "                  \\c mbedtls_chacha20_starts(), then one or more calls to"]
    #[doc = "                  to \\c mbedtls_chacha20_update(), and finally to"]
    #[doc = "                  \\c mbedtls_chacha20_free()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    pub fn mbedtls_chacha20_init(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified"]
    #[doc = "                  ChaCha20 context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to clear. This may be \\c NULL,"]
    #[doc = "                  in which case this function is a no-op. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized context."]
    #[doc = ""]
    pub fn mbedtls_chacha20_free(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the encryption/decryption key."]
    #[doc = ""]
    #[doc = " \\note            After using this function, you must also call"]
    #[doc = "                  \\c mbedtls_chacha20_starts() to set a nonce before you"]
    #[doc = "                  start encrypting/decrypting data with"]
    #[doc = "                  \\c mbedtls_chacha_update()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to which the key should be bound."]
    #[doc = "                  It must be initialized."]
    #[doc = " \\param key       The encryption/decryption key. This must be \\c 32 Bytes"]
    #[doc = "                  in length."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or key is NULL."]
    pub fn mbedtls_chacha20_setkey(
        ctx: *mut mbedtls_chacha20_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the nonce and initial counter value."]
    #[doc = ""]
    #[doc = " \\note            A ChaCha20 context can be re-used with the same key by"]
    #[doc = "                  calling this function to change the nonce."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same nonce twice with the same key."]
    #[doc = "                  This would void any confidentiality guarantees for the"]
    #[doc = "                  messages encrypted with the same nonce and key."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to which the nonce should be bound."]
    #[doc = "                  It must be initialized and bound to a key."]
    #[doc = " \\param nonce     The nonce. This must be \\c 12 Bytes in size."]
    #[doc = " \\param counter   The initial counter value. This is usually \\c 0."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or nonce is"]
    #[doc = "                  NULL."]
    pub fn mbedtls_chacha20_starts(
        ctx: *mut mbedtls_chacha20_context,
        nonce: *const crate::c_types::c_uchar,
        counter: u32,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data."]
    #[doc = ""]
    #[doc = "                  Since ChaCha20 is a stream cipher, the same operation is"]
    #[doc = "                  used for encrypting and decrypting data."]
    #[doc = ""]
    #[doc = " \\note            The \\p input and \\p output pointers must either be equal or"]
    #[doc = "                  point to non-overlapping buffers."]
    #[doc = ""]
    #[doc = " \\note            \\c mbedtls_chacha20_setkey() and"]
    #[doc = "                  \\c mbedtls_chacha20_starts() must be called at least once"]
    #[doc = "                  to setup the context before this function can be called."]
    #[doc = ""]
    #[doc = " \\note            This function can be called multiple times in a row in"]
    #[doc = "                  order to encrypt of decrypt data piecewise with the same"]
    #[doc = "                  key and nonce."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to use for encryption or decryption."]
    #[doc = "                  It must be initialized and bound to a key and nonce."]
    #[doc = " \\param size      The length of the input data in Bytes."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = " \\param output    The buffer holding the output data."]
    #[doc = "                  This must be able to hold \\p size Bytes."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_chacha20_update(
        ctx: *mut mbedtls_chacha20_context,
        size: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data with ChaCha20 and"]
    #[doc = "                  the given key and nonce."]
    #[doc = ""]
    #[doc = "                  Since ChaCha20 is a stream cipher, the same operation is"]
    #[doc = "                  used for encrypting and decrypting data."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same (key, nonce) pair more than"]
    #[doc = "                  once. This would void any confidentiality guarantees for"]
    #[doc = "                  the messages encrypted with the same nonce and key."]
    #[doc = ""]
    #[doc = " \\note            The \\p input and \\p output pointers must either be equal or"]
    #[doc = "                  point to non-overlapping buffers."]
    #[doc = ""]
    #[doc = " \\param key       The encryption/decryption key."]
    #[doc = "                  This must be \\c 32 Bytes in length."]
    #[doc = " \\param nonce     The nonce. This must be \\c 12 Bytes in size."]
    #[doc = " \\param counter   The initial counter value. This is usually \\c 0."]
    #[doc = " \\param size      The length of the input data in Bytes."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = " \\param output    The buffer holding the output data."]
    #[doc = "                  This must be able to hold \\p size Bytes."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_chacha20_crypt(
        key: *const crate::c_types::c_uchar,
        nonce: *const crate::c_types::c_uchar,
        counter: u32,
        size: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20 checkup routine."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c 1 on failure."]
    pub fn mbedtls_chacha20_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_chachapoly_context {
    pub private_chacha20_ctx: mbedtls_chacha20_context,
    pub private_poly1305_ctx: mbedtls_poly1305_context,
    pub private_aad_len: u64,
    pub private_ciphertext_len: u64,
    pub private_state: crate::c_types::c_int,
    pub private_mode: mbedtls_chachapoly_mode_t,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20-Poly1305 context."]
    #[doc = ""]
    #[doc = "                  It must be the first API called before using"]
    #[doc = "                  the context. It must be followed by a call to"]
    #[doc = "                  \\c mbedtls_chachapoly_setkey() before any operation can be"]
    #[doc = "                  done, and to \\c mbedtls_chachapoly_free() once all"]
    #[doc = "                  operations with that context have been finished."]
    #[doc = ""]
    #[doc = "                  In order to encrypt or decrypt full messages at once, for"]
    #[doc = "                  each message you should make a single call to"]
    #[doc = "                  \\c mbedtls_chachapoly_crypt_and_tag() or"]
    #[doc = "                  \\c mbedtls_chachapoly_auth_decrypt()."]
    #[doc = ""]
    #[doc = "                  In order to encrypt messages piecewise, for each"]
    #[doc = "                  message you should make a call to"]
    #[doc = "                  \\c mbedtls_chachapoly_starts(), then 0 or more calls to"]
    #[doc = "                  \\c mbedtls_chachapoly_update_aad(), then 0 or more calls to"]
    #[doc = "                  \\c mbedtls_chachapoly_update(), then one call to"]
    #[doc = "                  \\c mbedtls_chachapoly_finish()."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged! Always"]
    #[doc = "                  use \\c mbedtls_chachapoly_auth_decrypt() when possible!"]
    #[doc = ""]
    #[doc = "                  If however this is not possible because the data is too"]
    #[doc = "                  large to fit in memory, you need to:"]
    #[doc = ""]
    #[doc = "                  - call \\c mbedtls_chachapoly_starts() and (if needed)"]
    #[doc = "                  \\c mbedtls_chachapoly_update_aad() as above,"]
    #[doc = "                  - call \\c mbedtls_chachapoly_update() multiple times and"]
    #[doc = "                  ensure its output (the plaintext) is NOT used in any other"]
    #[doc = "                  way than placing it in temporary storage at this point,"]
    #[doc = "                  - call \\c mbedtls_chachapoly_finish() to compute the"]
    #[doc = "                  authentication tag and compared it in constant time to the"]
    #[doc = "                  tag received with the ciphertext."]
    #[doc = ""]
    #[doc = "                  If the tags are not equal, you must immediately discard"]
    #[doc = "                  all previous outputs of \\c mbedtls_chachapoly_update(),"]
    #[doc = "                  otherwise you can now safely use the plaintext."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChachaPoly context to initialize. Must not be \\c NULL."]
    pub fn mbedtls_chachapoly_init(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified"]
    #[doc = "                  ChaCha20-Poly1305 context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChachaPoly context to clear. This may be \\c NULL, in which"]
    #[doc = "                  case this function is a no-op."]
    pub fn mbedtls_chachapoly_free(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the ChaCha20-Poly1305"]
    #[doc = "                  symmetric encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to which the key should be"]
    #[doc = "                  bound. This must be initialized."]
    #[doc = " \\param key       The \\c 256 Bit (\\c 32 Bytes) key."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_setkey(
        ctx: *mut mbedtls_chachapoly_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a ChaCha20-Poly1305 encryption or"]
    #[doc = "                  decryption operation."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same nonce twice with the same key."]
    #[doc = "                  This would void any confidentiality and authenticity"]
    #[doc = "                  guarantees for the messages encrypted with the same nonce"]
    #[doc = "                  and key."]
    #[doc = ""]
    #[doc = " \\note            If the context is being used for AAD only (no data to"]
    #[doc = "                  encrypt or decrypt) then \\p mode can be set to any value."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context. This must be initialized"]
    #[doc = "                  and bound to a key."]
    #[doc = " \\param nonce     The nonce/IV to use for the message."]
    #[doc = "                  This must be a readable buffer of length \\c 12 Bytes."]
    #[doc = " \\param mode      The operation to perform: #MBEDTLS_CHACHAPOLY_ENCRYPT or"]
    #[doc = "                  #MBEDTLS_CHACHAPOLY_DECRYPT (discouraged, see warning)."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_starts(
        ctx: *mut mbedtls_chachapoly_context,
        nonce: *const crate::c_types::c_uchar,
        mode: mbedtls_chachapoly_mode_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds additional data to be authenticated"]
    #[doc = "                  into an ongoing ChaCha20-Poly1305 operation."]
    #[doc = ""]
    #[doc = "                  The Additional Authenticated Data (AAD), also called"]
    #[doc = "                  Associated Data (AD) is only authenticated but not"]
    #[doc = "                  encrypted nor included in the encrypted output. It is"]
    #[doc = "                  usually transmitted separately from the ciphertext or"]
    #[doc = "                  computed locally by each party."]
    #[doc = ""]
    #[doc = " \\note            This function is called before data is encrypted/decrypted."]
    #[doc = "                  I.e. call this function to process the AAD before calling"]
    #[doc = "                  \\c mbedtls_chachapoly_update()."]
    #[doc = ""]
    #[doc = "                  You may call this function multiple times to process"]
    #[doc = "                  an arbitrary amount of AAD. It is permitted to call"]
    #[doc = "                  this function 0 times, if no AAD is used."]
    #[doc = ""]
    #[doc = "                  This function cannot be called any more if data has"]
    #[doc = "                  been processed by \\c mbedtls_chachapoly_update(),"]
    #[doc = "                  or if the context has been finished."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context. This must be initialized"]
    #[doc = "                  and bound to a key."]
    #[doc = " \\param aad_len   The length in Bytes of the AAD. The length has no"]
    #[doc = "                  restrictions."]
    #[doc = " \\param aad       Buffer containing the AAD."]
    #[doc = "                  This pointer can be \\c NULL if `aad_len == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA"]
    #[doc = "                  if \\p ctx or \\p aad are NULL."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE"]
    #[doc = "                  if the operations has not been started or has been"]
    #[doc = "                  finished, or if the AAD has been finished."]
    pub fn mbedtls_chachapoly_update_aad(
        ctx: *mut mbedtls_chachapoly_context,
        aad: *const crate::c_types::c_uchar,
        aad_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Thus function feeds data to be encrypted or decrypted"]
    #[doc = "                  into an on-going ChaCha20-Poly1305"]
    #[doc = "                  operation."]
    #[doc = ""]
    #[doc = "                  The direction (encryption or decryption) depends on the"]
    #[doc = "                  mode that was given when calling"]
    #[doc = "                  \\c mbedtls_chachapoly_starts()."]
    #[doc = ""]
    #[doc = "                  You may call this function multiple times to process"]
    #[doc = "                  an arbitrary amount of data. It is permitted to call"]
    #[doc = "                  this function 0 times, if no data is to be encrypted"]
    #[doc = "                  or decrypted."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized."]
    #[doc = " \\param len       The length (in bytes) of the data to encrypt or decrypt."]
    #[doc = " \\param input     The buffer containing the data to encrypt or decrypt."]
    #[doc = "                  This pointer can be \\c NULL if `len == 0`."]
    #[doc = " \\param output    The buffer to where the encrypted or decrypted data is"]
    #[doc = "                  written. This must be able to hold \\p len bytes."]
    #[doc = "                  This pointer can be \\c NULL if `len == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE"]
    #[doc = "                  if the operation has not been started or has been"]
    #[doc = "                  finished."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_update(
        ctx: *mut mbedtls_chachapoly_context,
        len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finished the ChaCha20-Poly1305 operation and"]
    #[doc = "                  generates the MAC (authentication tag)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized."]
    #[doc = " \\param mac       The buffer to where the 128-bit (16 bytes) MAC is written."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE"]
    #[doc = "                  if the operation has not been started or has been"]
    #[doc = "                  finished."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_finish(
        ctx: *mut mbedtls_chachapoly_context,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305"]
    #[doc = "                  authenticated encryption with the previously-set key."]
    #[doc = ""]
    #[doc = " \\note            Before using this function, you must set the key with"]
    #[doc = "                  \\c mbedtls_chachapoly_setkey()."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same nonce twice with the same key."]
    #[doc = "                  This would void any confidentiality and authenticity"]
    #[doc = "                  guarantees for the messages encrypted with the same nonce"]
    #[doc = "                  and key."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use (holds the key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param length    The length (in bytes) of the data to encrypt or decrypt."]
    #[doc = " \\param nonce     The 96-bit (12 bytes) nonce/IV to use."]
    #[doc = " \\param aad       The buffer containing the additional authenticated"]
    #[doc = "                  data (AAD). This pointer can be \\c NULL if `aad_len == 0`."]
    #[doc = " \\param aad_len   The length (in bytes) of the AAD data to process."]
    #[doc = " \\param input     The buffer containing the data to encrypt or decrypt."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param output    The buffer to where the encrypted or decrypted data"]
    #[doc = "                  is written. This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param tag       The buffer to where the computed 128-bit (16 bytes) MAC"]
    #[doc = "                  is written. This must not be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_encrypt_and_tag(
        ctx: *mut mbedtls_chachapoly_context,
        length: size_t,
        nonce: *const crate::c_types::c_uchar,
        aad: *const crate::c_types::c_uchar,
        aad_len: size_t,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305"]
    #[doc = "                  authenticated decryption with the previously-set key."]
    #[doc = ""]
    #[doc = " \\note            Before using this function, you must set the key with"]
    #[doc = "                  \\c mbedtls_chachapoly_setkey()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use (holds the key)."]
    #[doc = " \\param length    The length (in Bytes) of the data to decrypt."]
    #[doc = " \\param nonce     The \\c 96 Bit (\\c 12 bytes) nonce/IV to use."]
    #[doc = " \\param aad       The buffer containing the additional authenticated data (AAD)."]
    #[doc = "                  This pointer can be \\c NULL if `aad_len == 0`."]
    #[doc = " \\param aad_len   The length (in bytes) of the AAD data to process."]
    #[doc = " \\param tag       The buffer holding the authentication tag."]
    #[doc = "                  This must be a readable buffer of length \\c 16 Bytes."]
    #[doc = " \\param input     The buffer containing the data to decrypt."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param output    The buffer to where the decrypted data is written."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED"]
    #[doc = "                  if the data was not authentic."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_auth_decrypt(
        ctx: *mut mbedtls_chachapoly_context,
        length: size_t,
        nonce: *const crate::c_types::c_uchar,
        aad: *const crate::c_types::c_uchar,
        aad_len: size_t,
        tag: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20-Poly1305 checkup routine."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c 1 on failure."]
    pub fn mbedtls_chachapoly_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_DECRYPT: psa_encrypt_or_decrypt_t = 0;
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_ENCRYPT: psa_encrypt_or_decrypt_t = 1;
#[doc = " For encrypt-decrypt functions, whether the operation is an encryption"]
#[doc = " or a decryption."]
pub type psa_encrypt_or_decrypt_t = crate::c_types::c_uint;
#[doc = " \\brief          MD5 context structure"]
#[doc = ""]
#[doc = " \\warning        MD5 is considered a weak message digest and its use"]
#[doc = "                 constitutes a security risk. We recommend considering"]
#[doc = "                 stronger message digests instead."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md5_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 4usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    #[doc = " \\brief          Initialize MD5 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5_init(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          Clear MD5 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context to be cleared"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5_free(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) an MD5 context"]
    #[doc = ""]
    #[doc = " \\param dst      The destination context"]
    #[doc = " \\param src      The context to be cloned"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5_clone(dst: *mut mbedtls_md5_context, src: *const mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          MD5 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5_starts(ctx: *mut mbedtls_md5_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5_update(
        ctx: *mut mbedtls_md5_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 final digest"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param output   MD5 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5_finish(
        ctx: *mut mbedtls_md5_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_internal_md5_process(
        ctx: *mut mbedtls_md5_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = MD5( input buffer )"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD5 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5(
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    pub fn mbedtls_md5_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          RIPEMD-160 context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ripemd160_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 5usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    #[doc = " \\brief          Initialize RIPEMD-160 context"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context to be initialized"]
    pub fn mbedtls_ripemd160_init(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clear RIPEMD-160 context"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context to be cleared"]
    pub fn mbedtls_ripemd160_free(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) a RIPEMD-160 context"]
    #[doc = ""]
    #[doc = " \\param dst      The destination context"]
    #[doc = " \\param src      The context to be cloned"]
    pub fn mbedtls_ripemd160_clone(
        dst: *mut mbedtls_ripemd160_context,
        src: *const mbedtls_ripemd160_context,
    );
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ripemd160_starts(ctx: *mut mbedtls_ripemd160_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ripemd160_update(
        ctx: *mut mbedtls_ripemd160_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 final digest"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param output   RIPEMD-160 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ripemd160_finish(
        ctx: *mut mbedtls_ripemd160_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_internal_ripemd160_process(
        ctx: *mut mbedtls_ripemd160_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = RIPEMD-160( input buffer )"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   RIPEMD-160 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ripemd160(
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_ripemd160_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The SHA-1 context structure."]
#[doc = ""]
#[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
#[doc = "                 constitutes a security risk. We recommend considering"]
#[doc = "                 stronger message digests instead."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha1_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 5usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-1 context."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to initialize."]
    #[doc = "                 This must not be \\c NULL."]
    #[doc = ""]
    pub fn mbedtls_sha1_init(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-1 context."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to clear. This may be \\c NULL,"]
    #[doc = "                 in which case this function does nothing. If it is"]
    #[doc = "                 not \\c NULL, it must point to an initialized"]
    #[doc = "                 SHA-1 context."]
    #[doc = ""]
    pub fn mbedtls_sha1_free(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-1 context."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param dst      The SHA-1 context to clone to. This must be initialized."]
    #[doc = " \\param src      The SHA-1 context to clone from. This must be initialized."]
    #[doc = ""]
    pub fn mbedtls_sha1_clone(dst: *mut mbedtls_sha1_context, src: *const mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-1 checksum calculation."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to initialize. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[doc = ""]
    pub fn mbedtls_sha1_starts(ctx: *mut mbedtls_sha1_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing SHA-1"]
    #[doc = "                 checksum calculation."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 This must be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data \\p input in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha1_update(
        ctx: *mut mbedtls_sha1_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-1 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to use. This must be initialized and"]
    #[doc = "                 have a hash operation started."]
    #[doc = " \\param output   The SHA-1 checksum result. This must be a writable"]
    #[doc = "                 buffer of length \\c 20 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha1_finish(
        ctx: *mut mbedtls_sha1_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          SHA-1 process data block (internal use only)."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to use. This must be initialized."]
    #[doc = " \\param data     The data block being processed. This must be a"]
    #[doc = "                 readable buffer of length \\c 64 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[doc = ""]
    pub fn mbedtls_internal_sha1_process(
        ctx: *mut mbedtls_sha1_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-1 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-1 result is calculated as"]
    #[doc = "                 output = SHA-1(input buffer)."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 This must be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data \\p input in Bytes."]
    #[doc = " \\param output   The SHA-1 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 20 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[doc = ""]
    pub fn mbedtls_sha1(
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-1 checkup routine."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[doc = ""]
    pub fn mbedtls_sha1_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The SHA-256 context structure."]
#[doc = ""]
#[doc = "                 The structure is used both for SHA-256 and for SHA-224"]
#[doc = "                 checksum calculations. The choice between these two is"]
#[doc = "                 made in the call to mbedtls_sha256_starts()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha256_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 8usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
    pub private_is224: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-256 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_sha256_init(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-256 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context to clear. This may be \\c NULL, in which"]
    #[doc = "                 case this function returns immediately. If it is not \\c NULL,"]
    #[doc = "                 it must point to an initialized SHA-256 context."]
    pub fn mbedtls_sha256_free(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-256 context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context. This must be initialized."]
    #[doc = " \\param src      The context to clone. This must be initialized."]
    pub fn mbedtls_sha256_clone(
        dst: *mut mbedtls_sha256_context,
        src: *const mbedtls_sha256_context,
    );
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-224 or SHA-256 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The context to use. This must be initialized."]
    #[doc = " \\param is224    This determines which function to use. This must be"]
    #[doc = "                 either \\c 0 for SHA-256, or \\c 1 for SHA-224."]
    #[doc = ""]
    #[doc = " \\note           is224 must be defined accordingly to the enabled"]
    #[doc = "                 MBEDTLS_SHA224_C/MBEDTLS_SHA256_C symbols otherwise the"]
    #[doc = "                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_starts(
        ctx: *mut mbedtls_sha256_context,
        is224: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-256 checksum calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the data. This must be a readable"]
    #[doc = "                 buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_update(
        ctx: *mut mbedtls_sha256_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-256 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param output   The SHA-224 or SHA-256 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 32 bytes"]
    #[doc = "                 for SHA-256, \\c 28 bytes for SHA-224."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_finish(
        ctx: *mut mbedtls_sha256_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-256 computation. This function is for"]
    #[doc = "                 internal use only."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized."]
    #[doc = " \\param data     The buffer holding one block of data. This must"]
    #[doc = "                 be a readable buffer of length \\c 64 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_internal_sha256_process(
        ctx: *mut mbedtls_sha256_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-224 or SHA-256"]
    #[doc = "                 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-256 result is calculated as"]
    #[doc = "                 output = SHA-256(input buffer)."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the data. This must be a readable"]
    #[doc = "                 buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = " \\param output   The SHA-224 or SHA-256 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 32 bytes"]
    #[doc = "                 for SHA-256, \\c 28 bytes for SHA-224."]
    #[doc = " \\param is224    Determines which function to use. This must be"]
    #[doc = "                 either \\c 0 for SHA-256, or \\c 1 for SHA-224."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha256(
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        is224: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-224 checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_sha224_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-256 checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_sha256_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The SHA-512 context structure."]
#[doc = ""]
#[doc = "                 The structure is used both for SHA-384 and for SHA-512"]
#[doc = "                 checksum calculations. The choice between these two is"]
#[doc = "                 made in the call to mbedtls_sha512_starts()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha512_context {
    pub private_total: [u64; 2usize],
    pub private_state: [u64; 8usize],
    pub private_buffer: [crate::c_types::c_uchar; 128usize],
    pub private_is384: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to initialize. This must"]
    #[doc = "                 not be \\c NULL."]
    pub fn mbedtls_sha512_init(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to clear. This may be \\c NULL,"]
    #[doc = "                 in which case this function does nothing. If it"]
    #[doc = "                 is not \\c NULL, it must point to an initialized"]
    #[doc = "                 SHA-512 context."]
    pub fn mbedtls_sha512_free(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context. This must be initialized."]
    #[doc = " \\param src      The context to clone. This must be initialized."]
    pub fn mbedtls_sha512_clone(
        dst: *mut mbedtls_sha512_context,
        src: *const mbedtls_sha512_context,
    );
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to use. This must be initialized."]
    #[doc = " \\param is384    Determines which function to use. This must be"]
    #[doc = "                 either \\c 0 for SHA-512, or \\c 1 for SHA-384."]
    #[doc = ""]
    #[doc = " \\note           is384 must be defined accordingly to the enabled"]
    #[doc = "                 MBEDTLS_SHA384_C/MBEDTLS_SHA512_C symbols otherwise the"]
    #[doc = "                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_starts(
        ctx: *mut mbedtls_sha512_context,
        is384: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-512 checksum calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the input data. This must"]
    #[doc = "                 be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_update(
        ctx: *mut mbedtls_sha512_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-512 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 64 bytes"]
    #[doc = "                 for SHA-512, \\c 48 bytes for SHA-384."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_finish(
        ctx: *mut mbedtls_sha512_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-512 computation."]
    #[doc = "                 This function is for internal use only."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized."]
    #[doc = " \\param data     The buffer holding one block of data. This"]
    #[doc = "                 must be a readable buffer of length \\c 128 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_internal_sha512_process(
        ctx: *mut mbedtls_sha512_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-512 or SHA-384"]
    #[doc = "                 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-512 result is calculated as"]
    #[doc = "                 output = SHA-512(input buffer)."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the input data. This must be"]
    #[doc = "                 a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 64 bytes"]
    #[doc = "                 for SHA-512, \\c 48 bytes for SHA-384."]
    #[doc = " \\param is384    Determines which function to use. This must be either"]
    #[doc = "                 \\c 0 for SHA-512, or \\c 1 for SHA-384."]
    #[doc = ""]
    #[doc = " \\note           is384 must be defined accordingly with the supported"]
    #[doc = "                 symbols in the config file. If:"]
    #[doc = "                 - is384 is 0, but \\c MBEDTLS_SHA384_C is not defined, or"]
    #[doc = "                 - is384 is 1, but \\c MBEDTLS_SHA512_C is not defined"]
    #[doc = "                 then the function will return"]
    #[doc = "                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_sha512(
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
        output: *mut crate::c_types::c_uchar,
        is384: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-384 checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_sha384_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-512 checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_sha512_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hash_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_hash_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_hash_operation_t__bindgen_ty_1 {
    pub dummy: crate::c_types::c_uint,
    pub md5: mbedtls_md5_context,
    pub ripemd160: mbedtls_ripemd160_context,
    pub sha1: mbedtls_sha1_context,
    pub sha256: mbedtls_sha256_context,
    pub sha512: mbedtls_sha512_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_cipher_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_iv_length: u8,
    pub private_block_length: u8,
    pub private_ctx: mbedtls_psa_cipher_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_cipher_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_cipher: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_hash_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_hash_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_cipher_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_cipher_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hash_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_hash_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_cipher_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_default_iv_length: u8,
    pub private_ctx: psa_driver_cipher_context_t,
}
impl psa_cipher_operation_s {
    #[inline]
    pub fn private_iv_required(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_required(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_iv_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_iv_required: crate::c_types::c_uint,
        private_iv_set: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_iv_required: u32 = unsafe { ::core::mem::transmute(private_iv_required) };
            private_iv_required as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_iv_set: u32 = unsafe { ::core::mem::transmute(private_iv_set) };
            private_iv_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hmac_operation_t {
    pub private_alg: psa_algorithm_t,
    #[doc = " The hash context."]
    pub hash_ctx: psa_hash_operation_s,
    pub private_opad: [u8; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_mac_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_mac_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_mac_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_hmac: mbedtls_psa_hmac_operation_t,
    pub private_cmac: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_aead_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_tag_length: u8,
    pub ctx: mbedtls_psa_aead_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_aead_operation_t__bindgen_ty_1 {
    pub dummy: crate::c_types::c_uint,
    pub private_ccm: mbedtls_ccm_context,
    pub private_gcm: mbedtls_gcm_context,
    pub private_chachapoly: mbedtls_chachapoly_context,
}
impl mbedtls_psa_aead_operation_t {
    #[inline]
    pub fn private_is_encrypt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_encrypt: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_sign_hash_interruptible_operation_t {
    pub private_dummy: crate::c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_verify_hash_interruptible_operation_t {
    pub private_dummy: crate::c_types::c_uint,
}
#[doc = "< Client"]
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_CLIENT: mbedtls_ecjpake_role = 0;
#[doc = "< Server"]
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_SERVER: mbedtls_ecjpake_role = 1;
#[doc = " Roles in the EC J-PAKE exchange"]
pub type mbedtls_ecjpake_role = crate::c_types::c_uint;
#[doc = " EC J-PAKE context structure."]
#[doc = ""]
#[doc = " J-PAKE is a symmetric protocol, except for the identifiers used in"]
#[doc = " Zero-Knowledge Proofs, and the serialization of the second message"]
#[doc = " (KeyExchange) as defined by the Thread spec."]
#[doc = ""]
#[doc = " In order to benefit from this symmetry, we choose a different naming"]
#[doc = " convention from the Thread v1.0 spec. Correspondence is indicated in the"]
#[doc = " description as a pair C: client name, S: server name"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecjpake_context {
    pub private_md_type: mbedtls_md_type_t,
    pub private_grp: mbedtls_ecp_group,
    pub private_role: mbedtls_ecjpake_role,
    pub private_point_format: crate::c_types::c_int,
    pub private_Xm1: mbedtls_ecp_point,
    pub private_Xm2: mbedtls_ecp_point,
    pub private_Xp1: mbedtls_ecp_point,
    pub private_Xp2: mbedtls_ecp_point,
    pub private_Xp: mbedtls_ecp_point,
    pub private_xm1: mbedtls_mpi,
    pub private_xm2: mbedtls_mpi,
    pub private_s: mbedtls_mpi,
}
extern "C" {
    #[doc = " \\brief           Initialize an ECJPAKE context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    pub fn mbedtls_ecjpake_init(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
    #[doc = " \\brief           Set up an ECJPAKE context for use."]
    #[doc = ""]
    #[doc = " \\note            Currently the only values for hash/curve allowed by the"]
    #[doc = "                  standard are #MBEDTLS_MD_SHA256/#MBEDTLS_ECP_DP_SECP256R1."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to set up. This must be initialized."]
    #[doc = " \\param role      The role of the caller. This must be either"]
    #[doc = "                  #MBEDTLS_ECJPAKE_CLIENT or #MBEDTLS_ECJPAKE_SERVER."]
    #[doc = " \\param hash      The identifier of the hash function to use,"]
    #[doc = "                  for example #MBEDTLS_MD_SHA256."]
    #[doc = " \\param curve     The identifier of the elliptic curve to use,"]
    #[doc = "                  for example #MBEDTLS_ECP_DP_SECP256R1."]
    #[doc = " \\param secret    The pre-shared secret (passphrase). This must be"]
    #[doc = "                  a readable not empty buffer of length \\p len Bytes. It need"]
    #[doc = "                  only be valid for the duration of this call."]
    #[doc = " \\param len       The length of the pre-shared secret \\p secret."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_setup(
        ctx: *mut mbedtls_ecjpake_context,
        role: mbedtls_ecjpake_role,
        hash: mbedtls_md_type_t,
        curve: mbedtls_ecp_group_id,
        secret: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               Set the point format for future reads and writes."]
    #[doc = ""]
    #[doc = " \\param ctx           The ECJPAKE context to configure."]
    #[doc = " \\param point_format  The point format to use:"]
    #[doc = "                      #MBEDTLS_ECP_PF_UNCOMPRESSED (default)"]
    #[doc = "                      or #MBEDTLS_ECP_PF_COMPRESSED."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if \\p point_format"]
    #[doc = "                      is invalid."]
    pub fn mbedtls_ecjpake_set_point_format(
        ctx: *mut mbedtls_ecjpake_context,
        point_format: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if an ECJPAKE context is ready for use."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to check. This must be"]
    #[doc = "                  initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the context is ready for use."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA otherwise."]
    pub fn mbedtls_ecjpake_check(ctx: *const mbedtls_ecjpake_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Generate and write the first round message"]
    #[doc = "                  (TLS: contents of the Client/ServerHello extension,"]
    #[doc = "                  excluding extension type and length bytes)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be"]
    #[doc = "                  initialized and set up."]
    #[doc = " \\param buf       The buffer to write the contents to. This must be a"]
    #[doc = "                  writable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length of \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total number"]
    #[doc = "                  of Bytes written to \\p buf. This must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This"]
    #[doc = "                  may be \\c NULL if \\p f_rng doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_write_round_one(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Read and process the first round message"]
    #[doc = "                  (TLS: contents of the Client/ServerHello extension,"]
    #[doc = "                  excluding extension type and length bytes)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized"]
    #[doc = "                  and set up."]
    #[doc = " \\param buf       The buffer holding the first round message. This must"]
    #[doc = "                  be a readable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_read_round_one(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Generate and write the second round message"]
    #[doc = "                  (TLS: contents of the Client/ServerKeyExchange)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized,"]
    #[doc = "                  set up, and already have performed round one."]
    #[doc = " \\param buf       The buffer to write the round two contents to."]
    #[doc = "                  This must be a writable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The size of \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total number of Bytes"]
    #[doc = "                  written to \\p buf. This must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This"]
    #[doc = "                  may be \\c NULL if \\p f_rng doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_write_round_two(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Read and process the second round message"]
    #[doc = "                  (TLS: contents of the Client/ServerKeyExchange)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized"]
    #[doc = "                  and set up and already have performed round one."]
    #[doc = " \\param buf       The buffer holding the second round message. This must"]
    #[doc = "                  be a readable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_read_round_two(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Derive the shared secret"]
    #[doc = "                  (TLS: Pre-Master Secret)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized,"]
    #[doc = "                  set up and have performed both round one and two."]
    #[doc = " \\param buf       The buffer to write the derived secret to. This must"]
    #[doc = "                  be a writable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length of \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total number of Bytes"]
    #[doc = "                  written to \\p buf. This must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This"]
    #[doc = "                  may be \\c NULL if \\p f_rng doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_derive_secret(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write the shared key material to be passed to a Key"]
    #[doc = "                  Derivation Function as described in RFC8236."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized,"]
    #[doc = "                  set up and have performed both round one and two."]
    #[doc = " \\param buf       The buffer to write the derived secret to. This must"]
    #[doc = "                  be a writable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length of \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total number of bytes"]
    #[doc = "                  written to \\p buf. This must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This"]
    #[doc = "                  may be \\c NULL if \\p f_rng doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_write_shared_key(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This clears an ECJPAKE context and frees any"]
    #[doc = "                  embedded data structure."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to free. This may be \\c NULL,"]
    #[doc = "                  in which case this function does nothing. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized ECJPAKE context."]
    pub fn mbedtls_ecjpake_free(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if a test failed"]
    pub fn mbedtls_ecjpake_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_pake_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_password: *mut u8,
    pub private_password_len: size_t,
    pub private_role: u8,
    pub private_buffer: [u8; 336usize],
    pub private_buffer_length: size_t,
    pub private_buffer_offset: size_t,
    pub private_ctx: mbedtls_psa_pake_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_pake_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_jpake: mbedtls_ecjpake_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_mac_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_mac_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_aead_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_aead_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_sign_hash_interruptible_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_sign_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_verify_hash_interruptible_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_verify_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_pake_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_pake_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_mac_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_mac_size: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_mac_context_t,
}
impl psa_mac_operation_s {
    #[inline]
    pub fn private_is_sign(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_sign(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_sign: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_sign: u32 = unsafe { ::core::mem::transmute(private_is_sign) };
            private_is_sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_aead_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub private_ad_remaining: size_t,
    pub private_body_remaining: size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_aead_context_t,
}
impl psa_aead_operation_s {
    #[inline]
    pub fn private_nonce_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_nonce_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_lengths_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_lengths_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_ad_started(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_ad_started(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_body_started(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_body_started(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_is_encrypt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_nonce_set: crate::c_types::c_uint,
        private_lengths_set: crate::c_types::c_uint,
        private_ad_started: crate::c_types::c_uint,
        private_body_started: crate::c_types::c_uint,
        private_is_encrypt: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_nonce_set: u32 = unsafe { ::core::mem::transmute(private_nonce_set) };
            private_nonce_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_lengths_set: u32 = unsafe { ::core::mem::transmute(private_lengths_set) };
            private_lengths_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_ad_started: u32 = unsafe { ::core::mem::transmute(private_ad_started) };
            private_ad_started as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let private_body_started: u32 = unsafe { ::core::mem::transmute(private_body_started) };
            private_body_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hkdf_key_derivation_t {
    pub private_info: *mut u8,
    pub private_info_length: size_t,
    pub private_offset_in_block: u8,
    pub private_block_number: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_output_block: [u8; 64usize],
    pub private_prk: [u8; 64usize],
    pub private_hmac: psa_mac_operation_s,
}
impl psa_hkdf_key_derivation_t {
    #[inline]
    pub fn private_state(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_private_state(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn private_info_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_info_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_state: crate::c_types::c_uint,
        private_info_set: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let private_state: u32 = unsafe { ::core::mem::transmute(private_state) };
            private_state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_info_set: u32 = unsafe { ::core::mem::transmute(private_info_set) };
            private_info_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_tls12_ecjpake_to_pms_t {
    pub private_data: [u8; 32usize],
}
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_INIT:
    psa_tls12_prf_key_derivation_state_t = 0;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_SEED_SET:
    psa_tls12_prf_key_derivation_state_t = 1;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OTHER_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 2;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 3;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_LABEL_SET:
    psa_tls12_prf_key_derivation_state_t = 4;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OUTPUT:
    psa_tls12_prf_key_derivation_state_t = 5;
pub type psa_tls12_prf_key_derivation_state_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_tls12_prf_key_derivation_s {
    pub private_left_in_block: u8,
    pub private_block_number: u8,
    pub private_state: psa_tls12_prf_key_derivation_state_t,
    pub private_secret: *mut u8,
    pub private_secret_length: size_t,
    pub private_seed: *mut u8,
    pub private_seed_length: size_t,
    pub private_label: *mut u8,
    pub private_label_length: size_t,
    pub private_other_secret: *mut u8,
    pub private_other_secret_length: size_t,
    pub private_Ai: [u8; 64usize],
    pub private_output_block: [u8; 64usize],
}
pub type psa_tls12_prf_key_derivation_t = psa_tls12_prf_key_derivation_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_derivation_s {
    pub private_alg: psa_algorithm_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_capacity: size_t,
    pub private_ctx: psa_key_derivation_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_key_derivation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_hkdf: psa_hkdf_key_derivation_t,
    pub private_tls12_prf: psa_tls12_prf_key_derivation_t,
    pub private_tls12_ecjpake_to_pms: psa_tls12_ecjpake_to_pms_t,
}
impl psa_key_derivation_s {
    #[inline]
    pub fn private_can_output_key(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_can_output_key(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_can_output_key: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_can_output_key: u32 =
                unsafe { ::core::mem::transmute(private_can_output_key) };
            private_can_output_key as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_policy_s {
    pub private_usage: psa_key_usage_t,
    pub private_alg: psa_algorithm_t,
    pub private_alg2: psa_algorithm_t,
}
pub type psa_key_policy_t = psa_key_policy_s;
pub type psa_key_bits_t = u16;
#[doc = " A mask of flags that can be stored in key attributes."]
#[doc = ""]
#[doc = " This type is also used internally to store flags in slots. Internal"]
#[doc = " flags are defined in library/psa_crypto_core.h. Internal flags may have"]
#[doc = " the same value as external flags if they are properly handled during"]
#[doc = " key creation and in psa_get_key_attributes."]
pub type psa_key_attributes_flag_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_core_key_attributes_t {
    pub private_type: psa_key_type_t,
    pub private_bits: psa_key_bits_t,
    pub private_lifetime: psa_key_lifetime_t,
    pub private_id: mbedtls_svc_key_id_t,
    pub private_policy: psa_key_policy_t,
    pub private_flags: psa_key_attributes_flag_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_attributes_s {
    pub private_core: psa_core_key_attributes_t,
    pub private_domain_parameters: *mut crate::c_types::c_void,
    pub private_domain_parameters_size: size_t,
}
extern "C" {
    #[doc = " \\brief Set domain parameters for a key."]
    #[doc = ""]
    #[doc = " Some key types require additional domain parameters in addition to"]
    #[doc = " the key type identifier and the key size. Use this function instead"]
    #[doc = " of psa_set_key_type() when you need to specify domain parameters."]
    #[doc = ""]
    #[doc = " The format for the required domain parameters varies based on the key type."]
    #[doc = ""]
    #[doc = " - For RSA keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY or #PSA_KEY_TYPE_RSA_KEY_PAIR),"]
    #[doc = "   the domain parameter data consists of the public exponent,"]
    #[doc = "   represented as a big-endian integer with no leading zeros."]
    #[doc = "   This information is used when generating an RSA key pair."]
    #[doc = "   When importing a key, the public exponent is read from the imported"]
    #[doc = "   key data and the exponent recorded in the attribute structure is ignored."]
    #[doc = "   As an exception, the public exponent 65537 is represented by an empty"]
    #[doc = "   byte string."]
    #[doc = " - For DSA keys (#PSA_KEY_TYPE_DSA_PUBLIC_KEY or #PSA_KEY_TYPE_DSA_KEY_PAIR),"]
    #[doc = "   the `Dss-Params` format as defined by RFC 3279 &sect;2.3.2."]
    #[doc = "   ```"]
    #[doc = "   Dss-Params ::= SEQUENCE  {"]
    #[doc = "      p       INTEGER,"]
    #[doc = "      q       INTEGER,"]
    #[doc = "      g       INTEGER"]
    #[doc = "   }"]
    #[doc = "   ```"]
    #[doc = " - For Diffie-Hellman key exchange keys"]
    #[doc = "   (#PSA_KEY_TYPE_DH_PUBLIC_KEY(#PSA_DH_FAMILY_CUSTOM) or"]
    #[doc = "   #PSA_KEY_TYPE_DH_KEY_PAIR(#PSA_DH_FAMILY_CUSTOM)), the"]
    #[doc = "   `DomainParameters` format as defined by RFC 3279 &sect;2.3.3."]
    #[doc = "   ```"]
    #[doc = "   DomainParameters ::= SEQUENCE {"]
    #[doc = "      p               INTEGER,                    -- odd prime, p=jq +1"]
    #[doc = "      g               INTEGER,                    -- generator, g"]
    #[doc = "      q               INTEGER,                    -- factor of p-1"]
    #[doc = "      j               INTEGER OPTIONAL,           -- subgroup factor"]
    #[doc = "      validationParams ValidationParams OPTIONAL"]
    #[doc = "   }"]
    #[doc = "   ValidationParams ::= SEQUENCE {"]
    #[doc = "      seed            BIT STRING,"]
    #[doc = "      pgenCounter     INTEGER"]
    #[doc = "   }"]
    #[doc = "   ```"]
    #[doc = ""]
    #[doc = " \\note This function may allocate memory or other resources."]
    #[doc = "       Once you have called this function on an attribute structure,"]
    #[doc = "       you must call psa_reset_key_attributes() to free these resources."]
    #[doc = ""]
    #[doc = " \\note This is an experimental extension to the interface. It may change"]
    #[doc = "       in future versions of the library."]
    #[doc = ""]
    #[doc = " \\param[in,out] attributes    Attribute structure where the specified domain"]
    #[doc = "                              parameters will be stored."]
    #[doc = "                              If this function fails, the content of"]
    #[doc = "                              \\p attributes is not modified."]
    #[doc = " \\param type                  Key type (a \\c PSA_KEY_TYPE_XXX value)."]
    #[doc = " \\param[in] data              Buffer containing the key domain parameters."]
    #[doc = "                              The content of this buffer is interpreted"]
    #[doc = "                              according to \\p type as described above."]
    #[doc = " \\param data_length           Size of the \\p data buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    pub fn psa_set_key_domain_parameters(
        attributes: *mut psa_key_attributes_t,
        type_: psa_key_type_t,
        data: *const u8,
        data_length: size_t,
    ) -> psa_status_t;
}
#[doc = " \\brief The context for PSA interruptible hash signing."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_sign_hash_interruptible_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_sign_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_sign_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\brief The context for PSA interruptible hash verification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_verify_hash_interruptible_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_verify_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_verify_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type psa_key_handle_t = mbedtls_svc_key_id_t;
extern "C" {
    #[doc = " Open a handle to an existing persistent key."]
    #[doc = ""]
    #[doc = " Open a handle to a persistent key. A key is persistent if it was created"]
    #[doc = " with a lifetime other than #PSA_KEY_LIFETIME_VOLATILE. A persistent key"]
    #[doc = " always has a nonzero key identifier, set with psa_set_key_id() when"]
    #[doc = " creating the key. Implementations may provide additional pre-provisioned"]
    #[doc = " keys that can be opened with psa_open_key(). Such keys have an application"]
    #[doc = " key identifier in the vendor range, as documented in the description of"]
    #[doc = " #psa_key_id_t."]
    #[doc = ""]
    #[doc = " The application must eventually close the handle with psa_close_key() or"]
    #[doc = " psa_destroy_key() to release associated resources. If the application dies"]
    #[doc = " without calling one of these functions, the implementation should perform"]
    #[doc = " the equivalent of a call to psa_close_key()."]
    #[doc = ""]
    #[doc = " Some implementations permit an application to open the same key multiple"]
    #[doc = " times. If this is successful, each call to psa_open_key() will return a"]
    #[doc = " different key handle."]
    #[doc = ""]
    #[doc = " \\note This API is not part of the PSA Cryptography API Release 1.0.0"]
    #[doc = " specification. It was defined in the 1.0 Beta 3 version of the"]
    #[doc = " specification but was removed in the 1.0.0 released version. This API is"]
    #[doc = " kept for the time being to not break applications relying on it. It is not"]
    #[doc = " deprecated yet but will be in the near future."]
    #[doc = ""]
    #[doc = " \\note Applications that rely on opening a key multiple times will not be"]
    #[doc = " portable to implementations that only permit a single key handle to be"]
    #[doc = " opened. See also :ref:\\`key-handles\\`."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param key           The persistent identifier of the key."]
    #[doc = " \\param[out] handle   On success, a handle to the key."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success. The application can now use the value of `*handle`"]
    #[doc = "         to access the key."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = "         The implementation does not have sufficient resources to open the"]
    #[doc = "         key. This can be due to reaching an implementation limit on the"]
    #[doc = "         number of open keys, the number of open key handles, or available"]
    #[doc = "         memory."]
    #[doc = " \\retval #PSA_ERROR_DOES_NOT_EXIST"]
    #[doc = "         There is no persistent key with key identifier \\p key."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not a valid persistent key identifier."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The specified key exists, but the application does not have the"]
    #[doc = "         permission to access it. Note that this specification does not"]
    #[doc = "         define any way to create such a key, but it may be possible"]
    #[doc = "         through implementation-specific means."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_open_key(key: mbedtls_svc_key_id_t, handle: *mut psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Close a key handle."]
    #[doc = ""]
    #[doc = " If the handle designates a volatile key, this will destroy the key material"]
    #[doc = " and free all associated resources, just like psa_destroy_key()."]
    #[doc = ""]
    #[doc = " If this is the last open handle to a persistent key, then closing the handle"]
    #[doc = " will free all resources associated with the key in volatile memory. The key"]
    #[doc = " data in persistent storage is not affected and can be opened again later"]
    #[doc = " with a call to psa_open_key()."]
    #[doc = ""]
    #[doc = " Closing the key handle makes the handle invalid, and the key handle"]
    #[doc = " must not be used again by the application."]
    #[doc = ""]
    #[doc = " \\note This API is not part of the PSA Cryptography API Release 1.0.0"]
    #[doc = " specification. It was defined in the 1.0 Beta 3 version of the"]
    #[doc = " specification but was removed in the 1.0.0 released version. This API is"]
    #[doc = " kept for the time being to not break applications relying on it. It is not"]
    #[doc = " deprecated yet but will be in the near future."]
    #[doc = ""]
    #[doc = " \\note If the key handle was used to set up an active"]
    #[doc = " :ref:\\`multipart operation <multipart-operations>\\`, then closing the"]
    #[doc = " key handle can cause the multipart operation to fail. Applications should"]
    #[doc = " maintain the key handle until after the multipart operation has finished."]
    #[doc = ""]
    #[doc = " \\param handle        The key handle to close."]
    #[doc = "                      If this is \\c 0, do nothing and return \\c PSA_SUCCESS."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         \\p handle was a valid handle or \\c 0. It is now closed."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         \\p handle is not a valid handle nor \\c 0."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_close_key(handle: psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Library deinitialization."]
    #[doc = ""]
    #[doc = " This function clears all data associated with the PSA layer,"]
    #[doc = " including the whole key store."]
    #[doc = ""]
    #[doc = " This is an Mbed TLS extension."]
    pub fn mbedtls_psa_crypto_free();
}
#[doc = " \\brief Statistics about"]
#[doc = " resource consumption related to the PSA keystore."]
#[doc = ""]
#[doc = " \\note The content of this structure is not part of the stable API and ABI"]
#[doc = "       of Mbed Crypto and may change arbitrarily from version to version."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_stats_s {
    pub private_volatile_slots: size_t,
    pub private_persistent_slots: size_t,
    pub private_external_slots: size_t,
    pub private_half_filled_slots: size_t,
    pub private_cache_slots: size_t,
    pub private_empty_slots: size_t,
    pub private_locked_slots: size_t,
    pub private_max_open_internal_key_id: psa_key_id_t,
    pub private_max_open_external_key_id: psa_key_id_t,
}
#[doc = " \\brief Statistics about"]
#[doc = " resource consumption related to the PSA keystore."]
#[doc = ""]
#[doc = " \\note The content of this structure is not part of the stable API and ABI"]
#[doc = "       of Mbed Crypto and may change arbitrarily from version to version."]
pub type mbedtls_psa_stats_t = mbedtls_psa_stats_s;
extern "C" {
    #[doc = " \\brief Get statistics about"]
    #[doc = " resource consumption related to the PSA keystore."]
    #[doc = ""]
    #[doc = " \\note When Mbed Crypto is built as part of a service, with isolation"]
    #[doc = "       between the application and the keystore, the service may or"]
    #[doc = "       may not expose this function."]
    pub fn mbedtls_psa_get_stats(stats: *mut mbedtls_psa_stats_t);
}
extern "C" {
    #[doc = " \\brief Inject an initial entropy seed for the random generator into"]
    #[doc = "        secure storage."]
    #[doc = ""]
    #[doc = " This function injects data to be used as a seed for the random generator"]
    #[doc = " used by the PSA Crypto implementation. On devices that lack a trusted"]
    #[doc = " entropy source (preferably a hardware random number generator),"]
    #[doc = " the Mbed PSA Crypto implementation uses this value to seed its"]
    #[doc = " random generator."]
    #[doc = ""]
    #[doc = " On devices without a trusted entropy source, this function must be"]
    #[doc = " called exactly once in the lifetime of the device. On devices with"]
    #[doc = " a trusted entropy source, calling this function is optional."]
    #[doc = " In all cases, this function may only be called before calling any"]
    #[doc = " other function in the PSA Crypto API, including psa_crypto_init()."]
    #[doc = ""]
    #[doc = " When this function returns successfully, it populates a file in"]
    #[doc = " persistent storage. Once the file has been created, this function"]
    #[doc = " can no longer succeed."]
    #[doc = ""]
    #[doc = " If any error occurs, this function does not change the system state."]
    #[doc = " You can call this function again after correcting the reason for the"]
    #[doc = " error if possible."]
    #[doc = ""]
    #[doc = " \\warning This function **can** fail! Callers MUST check the return status."]
    #[doc = ""]
    #[doc = " \\warning If you use this function, you should use it as part of a"]
    #[doc = "          factory provisioning process. The value of the injected seed"]
    #[doc = "          is critical to the security of the device. It must be"]
    #[doc = "          *secret*, *unpredictable* and (statistically) *unique per device*."]
    #[doc = "          You should be generate it randomly using a cryptographically"]
    #[doc = "          secure random generator seeded from trusted entropy sources."]
    #[doc = "          You should transmit it securely to the device and ensure"]
    #[doc = "          that its value is not leaked or stored anywhere beyond the"]
    #[doc = "          needs of transmitting it from the point of generation to"]
    #[doc = "          the call of this function, and erase all copies of the value"]
    #[doc = "          once this function returns."]
    #[doc = ""]
    #[doc = " This is an Mbed TLS extension."]
    #[doc = ""]
    #[doc = " \\note This function is only available on the following platforms:"]
    #[doc = " * If the compile-time option MBEDTLS_PSA_INJECT_ENTROPY is enabled."]
    #[doc = "   Note that you must provide compatible implementations of"]
    #[doc = "   mbedtls_nv_seed_read and mbedtls_nv_seed_write."]
    #[doc = " * In a client-server integration of PSA Cryptography, on the client side,"]
    #[doc = "   if the server supports this feature."]
    #[doc = " \\param[in] seed          Buffer containing the seed value to inject."]
    #[doc = " \\param[in] seed_size     Size of the \\p seed buffer."]
    #[doc = "                          The size of the seed in bytes must be greater"]
    #[doc = "                          or equal to both #MBEDTLS_ENTROPY_BLOCK_SIZE"]
    #[doc = "                          and the value of \\c MBEDTLS_ENTROPY_MIN_PLATFORM"]
    #[doc = "                          in `library/entropy_poll.h` in the Mbed TLS source"]
    #[doc = "                          code."]
    #[doc = "                          It must be less or equal to"]
    #[doc = "                          #MBEDTLS_ENTROPY_MAX_SEED_SIZE."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The seed value was injected successfully. The random generator"]
    #[doc = "         of the PSA Crypto implementation is now ready for use."]
    #[doc = "         You may now call psa_crypto_init() and use the PSA Crypto"]
    #[doc = "         implementation."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p seed_size is out of range."]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         There was a failure reading or writing from storage."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The library has already been initialized. It is no longer"]
    #[doc = "         possible to call this function."]
    pub fn mbedtls_psa_inject_entropy(seed: *const u8, seed_size: size_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Get domain parameters for a key."]
    #[doc = ""]
    #[doc = " Get the domain parameters for a key with this function, if any. The format"]
    #[doc = " of the domain parameters written to \\p data is specified in the"]
    #[doc = " documentation for psa_set_key_domain_parameters()."]
    #[doc = ""]
    #[doc = " \\note This is an experimental extension to the interface. It may change"]
    #[doc = "       in future versions of the library."]
    #[doc = ""]
    #[doc = " \\param[in] attributes        The key attribute structure to query."]
    #[doc = " \\param[out] data             On success, the key domain parameters."]
    #[doc = " \\param data_size             Size of the \\p data buffer in bytes."]
    #[doc = "                              The buffer is guaranteed to be large"]
    #[doc = "                              enough if its size in bytes is at least"]
    #[doc = "                              the value given by"]
    #[doc = "                              PSA_KEY_DOMAIN_PARAMETERS_SIZE()."]
    #[doc = " \\param[out] data_length      On success, the number of bytes"]
    #[doc = "                              that make up the key domain parameters data."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription"]
    pub fn psa_get_key_domain_parameters(
        attributes: *const psa_key_attributes_t,
        data: *mut u8,
        data_size: size_t,
        data_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Convert an ECC curve identifier from the PSA encoding to Mbed TLS."]
    #[doc = ""]
    #[doc = " \\note This function is provided solely for the convenience of"]
    #[doc = "       Mbed TLS and may be removed at any time without notice."]
    #[doc = ""]
    #[doc = " \\param curve         A PSA elliptic curve identifier"]
    #[doc = "                      (`PSA_ECC_FAMILY_xxx`)."]
    #[doc = " \\param bits          The bit-length of a private key on \\p curve."]
    #[doc = " \\param bits_is_sloppy If true, \\p bits may be the bit-length rounded up"]
    #[doc = "                      to the nearest multiple of 8. This allows the caller"]
    #[doc = "                      to infer the exact curve from the length of a key"]
    #[doc = "                      which is supplied as a byte string."]
    #[doc = ""]
    #[doc = " \\return              The corresponding Mbed TLS elliptic curve identifier"]
    #[doc = "                      (`MBEDTLS_ECP_DP_xxx`)."]
    #[doc = " \\return              #MBEDTLS_ECP_DP_NONE if \\c curve is not recognized."]
    #[doc = " \\return              #MBEDTLS_ECP_DP_NONE if \\p bits is not"]
    #[doc = "                      correct for \\p curve."]
    pub fn mbedtls_ecc_group_of_psa(
        curve: psa_ecc_family_t,
        bits: size_t,
        bits_is_sloppy: crate::c_types::c_int,
    ) -> mbedtls_ecp_group_id;
}
extern "C" {
    #[doc = " External random generator function, implemented by the platform."]
    #[doc = ""]
    #[doc = " When the compile-time option #MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG is enabled,"]
    #[doc = " this function replaces Mbed TLS's entropy and DRBG modules for all"]
    #[doc = " random generation triggered via PSA crypto interfaces."]
    #[doc = ""]
    #[doc = " \\note This random generator must deliver random numbers with cryptographic"]
    #[doc = "       quality and high performance. It must supply unpredictable numbers"]
    #[doc = "       with a uniform distribution. The implementation of this function"]
    #[doc = "       is responsible for ensuring that the random generator is seeded"]
    #[doc = "       with sufficient entropy. If you have a hardware TRNG which is slow"]
    #[doc = "       or delivers non-uniform output, declare it as an entropy source"]
    #[doc = "       with mbedtls_entropy_add_source() instead of enabling this option."]
    #[doc = ""]
    #[doc = " \\param[in,out] context       Pointer to the random generator context."]
    #[doc = "                              This is all-bits-zero on the first call"]
    #[doc = "                              and preserved between successive calls."]
    #[doc = " \\param[out] output           Output buffer. On success, this buffer"]
    #[doc = "                              contains random data with a uniform"]
    #[doc = "                              distribution."]
    #[doc = " \\param output_size           The size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, set this value to \\p output_size."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success. The output buffer contains \\p output_size bytes of"]
    #[doc = "         cryptographic-quality random data, and \\c *output_length is"]
    #[doc = "         set to \\p output_size."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = "         The random generator requires extra entropy and there is no"]
    #[doc = "         way to obtain entropy under current environment conditions."]
    #[doc = "         This error should not happen under normal circumstances since"]
    #[doc = "         this function is responsible for obtaining as much entropy as"]
    #[doc = "         it needs. However implementations of this function may return"]
    #[doc = "         #PSA_ERROR_INSUFFICIENT_ENTROPY if there is no way to obtain"]
    #[doc = "         entropy without blocking indefinitely."]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = "         A failure of the random generator hardware that isn't covered"]
    #[doc = "         by #PSA_ERROR_INSUFFICIENT_ENTROPY."]
    pub fn mbedtls_psa_external_get_random(
        context: *mut mbedtls_psa_external_random_context_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
#[doc = " A slot number identifying a key in a driver."]
#[doc = ""]
#[doc = " Values of this type are used to identify built-in keys."]
pub type psa_drv_slot_number_t = u64;
#[doc = " \\brief Encoding of the application role of PAKE"]
#[doc = ""]
#[doc = " Encodes the application's role in the algorithm is being executed. For more"]
#[doc = " information see the documentation of individual \\c PSA_PAKE_ROLE_XXX"]
#[doc = " constants."]
pub type psa_pake_role_t = u8;
#[doc = " Encoding of input and output indicators for PAKE."]
#[doc = ""]
#[doc = " Some PAKE algorithms need to exchange more data than just a single key share."]
#[doc = " This type is for encoding additional input and output data for such"]
#[doc = " algorithms."]
pub type psa_pake_step_t = u8;
#[doc = " Encoding of the type of the PAKE's primitive."]
#[doc = ""]
#[doc = " Values defined by this standard will never be in the range 0x80-0xff."]
#[doc = " Vendors who define additional types must use an encoding in this range."]
#[doc = ""]
#[doc = " For more information see the documentation of individual"]
#[doc = " \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_primitive_type_t = u8;
#[doc = " \\brief Encoding of the family of the primitive associated with the PAKE."]
#[doc = ""]
#[doc = " For more information see the documentation of individual"]
#[doc = " \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_family_t = u8;
#[doc = " \\brief Encoding of the primitive associated with the PAKE."]
#[doc = ""]
#[doc = " For more information see the documentation of the #PSA_PAKE_PRIMITIVE macro."]
pub type psa_pake_primitive_t = u32;
#[doc = " The type of the data structure for PAKE cipher suites."]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_pake_cipher_suite_t = psa_pake_cipher_suite_s;
#[doc = " The type of the state data structure for PAKE operations."]
#[doc = ""]
#[doc = " Before calling any function on a PAKE operation object, the application"]
#[doc = " must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_pake_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_pake_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_PAKE_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_pake_operation_t operation = PSA_PAKE_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_pake_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_pake_operation_t operation;"]
#[doc = "   operation = psa_pake_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_pake_operation_t = psa_pake_operation_s;
#[doc = " The type of input values for PAKE operations."]
pub type psa_crypto_driver_pake_inputs_t = psa_crypto_driver_pake_inputs_s;
#[doc = " The type of computation stage for J-PAKE operations."]
pub type psa_jpake_computation_stage_t = psa_jpake_computation_stage_s;
extern "C" {
    #[doc = " Get the length of the password in bytes from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] password_len     Password length."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Password hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_password_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        password_len: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the password from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] buffer           Return buffer for password."]
    #[doc = " \\param      buffer_size      Size of the return buffer in bytes."]
    #[doc = " \\param[out] buffer_length    Actual size of the password in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Password hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_password(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        buffer: *mut u8,
        buffer_size: size_t,
        buffer_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the role from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] role             Return buffer for role."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Role hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_role(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        role: *mut psa_pake_role_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the length of the user id in bytes from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] user_len         User id length."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         User id hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_user_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        user_len: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the length of the peer id in bytes from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] peer_len         Peer id length."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Peer id hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_peer_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        peer_len: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the user id from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] user_id          User id."]
    #[doc = " \\param      user_id_size     Size of \\p user_id in bytes."]
    #[doc = " \\param[out] user_id_len      Size of the user id in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         User id hasn't been set yet."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p user_id is too small."]
    pub fn psa_crypto_driver_pake_get_user(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        user_id: *mut u8,
        user_id_size: size_t,
        user_id_len: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the peer id from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] peer_id          Peer id."]
    #[doc = " \\param      peer_id_size     Size of \\p peer_id in bytes."]
    #[doc = " \\param[out] peer_id_length   Size of the peer id in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Peer id hasn't been set yet."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p peer_id is too small."]
    pub fn psa_crypto_driver_pake_get_peer(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        peer_id: *mut u8,
        peer_id_size: size_t,
        peer_id_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the cipher suite from given inputs."]
    #[doc = ""]
    #[doc = " \\param[in]  inputs           Operation inputs."]
    #[doc = " \\param[out] cipher_suite     Return buffer for role."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Cipher_suite hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_cipher_suite(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        cipher_suite: *mut psa_pake_cipher_suite_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the session information for a password-authenticated key exchange."]
    #[doc = ""]
    #[doc = " The sequence of operations to set up a password-authenticated key exchange"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_pake_operation_t, e.g."]
    #[doc = "    #PSA_PAKE_OPERATION_INIT."]
    #[doc = " -# Call psa_pake_setup() to specify the cipher suite."]
    #[doc = " -# Call \\c psa_pake_set_xxx() functions on the operation to complete the"]
    #[doc = "    setup. The exact sequence of \\c psa_pake_set_xxx() functions that needs"]
    #[doc = "    to be called depends on the algorithm in use."]
    #[doc = ""]
    #[doc = " Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`"]
    #[doc = " values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " A typical sequence of calls to perform a password-authenticated key"]
    #[doc = " exchange:"]
    #[doc = " -# Call psa_pake_output(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to get the"]
    #[doc = "    key share that needs to be sent to the peer."]
    #[doc = " -# Call psa_pake_input(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to provide"]
    #[doc = "    the key share that was received from the peer."]
    #[doc = " -# Depending on the algorithm additional calls to psa_pake_output() and"]
    #[doc = "    psa_pake_input() might be necessary."]
    #[doc = " -# Call psa_pake_get_implicit_key() for accessing the shared secret."]
    #[doc = ""]
    #[doc = " Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`"]
    #[doc = " values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_pake_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_pake_abort(). The"]
    #[doc = " application may call psa_pake_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_pake_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A call to psa_pake_abort()."]
    #[doc = " - A successful call to psa_pake_get_implicit_key()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized but not set up yet."]
    #[doc = " \\param[in] cipher_suite      The cipher suite to use. (A cipher suite fully"]
    #[doc = "                              characterizes a PAKE algorithm and determines"]
    #[doc = "                              the algorithm as well.)"]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The algorithm in \\p cipher_suite is not a PAKE algorithm, or the"]
    #[doc = "         PAKE primitive in \\p cipher_suite is not compatible with the"]
    #[doc = "         PAKE algorithm, or the hash algorithm in \\p cipher_suite is invalid"]
    #[doc = "         or not compatible with the PAKE algorithm and primitive."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The algorithm in \\p cipher_suite is not a supported PAKE algorithm,"]
    #[doc = "         or the PAKE primitive in \\p cipher_suite is not supported or not"]
    #[doc = "         compatible with the PAKE algorithm, or the hash algorithm in"]
    #[doc = "         \\p cipher_suite is not supported or not compatible with the PAKE"]
    #[doc = "         algorithm and primitive."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid, or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_setup(
        operation: *mut psa_pake_operation_t,
        cipher_suite: *const psa_pake_cipher_suite_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the password for a password-authenticated key exchange from key ID."]
    #[doc = ""]
    #[doc = " Call this function when the password, or a value derived from the password,"]
    #[doc = " is already present in the key store."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set the password for. It"]
    #[doc = "                              must have been set up by psa_pake_setup() and"]
    #[doc = "                              not yet in use (neither psa_pake_output() nor"]
    #[doc = "                              psa_pake_input() has been called yet). It must"]
    #[doc = "                              be on operation for which the password hasn't"]
    #[doc = "                              been set yet (psa_pake_set_password_key()"]
    #[doc = "                              hasn't been called yet)."]
    #[doc = " \\param password              Identifier of the key holding the password or a"]
    #[doc = "                              value derived from the password (eg. by a"]
    #[doc = "                              memory-hard function).  It must remain valid"]
    #[doc = "                              until the operation terminates. It must be of"]
    #[doc = "                              type #PSA_KEY_TYPE_PASSWORD or"]
    #[doc = "                              #PSA_KEY_TYPE_PASSWORD_HASH. It has to allow"]
    #[doc = "                              the usage #PSA_KEY_USAGE_DERIVE."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         \\p password is not a valid key identifier."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_DERIVE flag, or it does not"]
    #[doc = "         permit the \\p operation's algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key type for \\p password is not #PSA_KEY_TYPE_PASSWORD or"]
    #[doc = "         #PSA_KEY_TYPE_PASSWORD_HASH, or \\p password is not compatible with"]
    #[doc = "         the \\p operation's cipher suite."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The key type or key size of \\p password is not supported with the"]
    #[doc = "         \\p operation's cipher suite."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must have been set up.), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_set_password_key(
        operation: *mut psa_pake_operation_t,
        password: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the user ID for a password-authenticated key exchange."]
    #[doc = ""]
    #[doc = " Call this function to set the user ID. For PAKE algorithms that associate a"]
    #[doc = " user identifier with each side of the session you need to call"]
    #[doc = " psa_pake_set_peer() as well. For PAKE algorithms that associate a single"]
    #[doc = " user identifier with the session, call psa_pake_set_user() only."]
    #[doc = ""]
    #[doc = " Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`"]
    #[doc = " values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set the user ID for. It"]
    #[doc = "                              must have been set up by psa_pake_setup() and"]
    #[doc = "                              not yet in use (neither psa_pake_output() nor"]
    #[doc = "                              psa_pake_input() has been called yet). It must"]
    #[doc = "                              be on operation for which the user ID hasn't"]
    #[doc = "                              been set (psa_pake_set_user() hasn't been"]
    #[doc = "                              called yet)."]
    #[doc = " \\param[in] user_id           The user ID to authenticate with."]
    #[doc = "                              (temporary limitation: \"client\" or \"server\" only)"]
    #[doc = " \\param user_id_len           Size of the \\p user_id buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p user_id is not valid for the \\p operation's algorithm and cipher"]
    #[doc = "         suite."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The value of \\p user_id is not supported by the implementation."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid, or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_set_user(
        operation: *mut psa_pake_operation_t,
        user_id: *const u8,
        user_id_len: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the peer ID for a password-authenticated key exchange."]
    #[doc = ""]
    #[doc = " Call this function in addition to psa_pake_set_user() for PAKE algorithms"]
    #[doc = " that associate a user identifier with each side of the session. For PAKE"]
    #[doc = " algorithms that associate a single user identifier with the session, call"]
    #[doc = " psa_pake_set_user() only."]
    #[doc = ""]
    #[doc = " Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`"]
    #[doc = " values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set the peer ID for. It"]
    #[doc = "                              must have been set up by psa_pake_setup() and"]
    #[doc = "                              not yet in use (neither psa_pake_output() nor"]
    #[doc = "                              psa_pake_input() has been called yet). It must"]
    #[doc = "                              be on operation for which the peer ID hasn't"]
    #[doc = "                              been set (psa_pake_set_peer() hasn't been"]
    #[doc = "                              called yet)."]
    #[doc = " \\param[in] peer_id           The peer's ID to authenticate."]
    #[doc = "                              (temporary limitation: \"client\" or \"server\" only)"]
    #[doc = " \\param peer_id_len           Size of the \\p peer_id buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p user_id is not valid for the \\p operation's algorithm and cipher"]
    #[doc = "         suite."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The algorithm doesn't associate a second identity with the session."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         Calling psa_pake_set_peer() is invalid with the \\p operation's"]
    #[doc = "         algorithm, the operation state is not valid, or the library has not"]
    #[doc = "         been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_set_peer(
        operation: *mut psa_pake_operation_t,
        peer_id: *const u8,
        peer_id_len: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the application role for a password-authenticated key exchange."]
    #[doc = ""]
    #[doc = " Not all PAKE algorithms need to differentiate the communicating entities."]
    #[doc = " It is optional to call this function for PAKEs that don't require a role"]
    #[doc = " to be specified. For such PAKEs the application role parameter is ignored,"]
    #[doc = " or #PSA_PAKE_ROLE_NONE can be passed as \\c role."]
    #[doc = ""]
    #[doc = " Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`"]
    #[doc = " values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to specify the"]
    #[doc = "                              application's role for. It must have been set up"]
    #[doc = "                              by psa_pake_setup() and not yet in use (neither"]
    #[doc = "                              psa_pake_output() nor psa_pake_input() has been"]
    #[doc = "                              called yet). It must be on operation for which"]
    #[doc = "                              the application's role hasn't been specified"]
    #[doc = "                              (psa_pake_set_role() hasn't been called yet)."]
    #[doc = " \\param role                  A value of type ::psa_pake_role_t indicating the"]
    #[doc = "                              application's role in the PAKE the algorithm"]
    #[doc = "                              that is being set up. For more information see"]
    #[doc = "                              the documentation of \\c PSA_PAKE_ROLE_XXX"]
    #[doc = "                              constants."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The \\p role is not a valid PAKE role in the \\p operations algorithm."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The \\p role for this algorithm is not supported or is not valid."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid, or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_set_role(
        operation: *mut psa_pake_operation_t,
        role: psa_pake_role_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get output for a step of a password-authenticated key exchange."]
    #[doc = ""]
    #[doc = " Depending on the algorithm being executed, you might need to call this"]
    #[doc = " function several times or you might not need to call this at all."]
    #[doc = ""]
    #[doc = " The exact sequence of calls to perform a password-authenticated key"]
    #[doc = " exchange depends on the algorithm in use.  Refer to the documentation of"]
    #[doc = " individual PAKE algorithm types (`PSA_ALG_XXX` values of type"]
    #[doc = " ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more"]
    #[doc = " information."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_pake_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation    Active PAKE operation."]
    #[doc = " \\param step                 The step of the algorithm for which the output is"]
    #[doc = "                             requested."]
    #[doc = " \\param[out] output          Buffer where the output is to be written in the"]
    #[doc = "                             format appropriate for this \\p step. Refer to"]
    #[doc = "                             the documentation of the individual"]
    #[doc = "                             \\c PSA_PAKE_STEP_XXX constants for more"]
    #[doc = "                             information."]
    #[doc = " \\param output_size          Size of the \\p output buffer in bytes. This must"]
    #[doc = "                             be at least #PSA_PAKE_OUTPUT_SIZE(\\p alg, \\p"]
    #[doc = "                             primitive, \\p step) where \\p alg and"]
    #[doc = "                             \\p primitive are the PAKE algorithm and primitive"]
    #[doc = "                             in the operation's cipher suite, and \\p step is"]
    #[doc = "                             the output step."]
    #[doc = ""]
    #[doc = " \\param[out] output_length   On success, the number of bytes of the returned"]
    #[doc = "                             output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p step is not compatible with the operation's algorithm."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p step is not supported with the operation's algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, and fully set"]
    #[doc = "         up, and this call must conform to the algorithm's requirements"]
    #[doc = "         for ordering of input and output steps), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_output(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide input for a step of a password-authenticated key exchange."]
    #[doc = ""]
    #[doc = " Depending on the algorithm being executed, you might need to call this"]
    #[doc = " function several times or you might not need to call this at all."]
    #[doc = ""]
    #[doc = " The exact sequence of calls to perform a password-authenticated key"]
    #[doc = " exchange depends on the algorithm in use.  Refer to the documentation of"]
    #[doc = " individual PAKE algorithm types (`PSA_ALG_XXX` values of type"]
    #[doc = " ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more"]
    #[doc = " information."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_pake_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation    Active PAKE operation."]
    #[doc = " \\param step                 The step for which the input is provided."]
    #[doc = " \\param[in] input            Buffer containing the input in the format"]
    #[doc = "                             appropriate for this \\p step. Refer to the"]
    #[doc = "                             documentation of the individual"]
    #[doc = "                             \\c PSA_PAKE_STEP_XXX constants for more"]
    #[doc = "                             information."]
    #[doc = " \\param input_length         Size of the \\p input buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The verification fails for a #PSA_PAKE_STEP_ZK_PROOF input step."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p is not compatible with the \\p operations algorithm, or the"]
    #[doc = "         \\p input is not valid for the \\p operation's algorithm, cipher suite"]
    #[doc = "         or \\p step."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p step p is not supported with the \\p operation's algorithm, or the"]
    #[doc = "         \\p input is not supported for the \\p operation's algorithm, cipher"]
    #[doc = "         suite or \\p step."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, and fully set"]
    #[doc = "         up, and this call must conform to the algorithm's requirements"]
    #[doc = "         for ordering of input and output steps), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_input(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        input: *const u8,
        input_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get implicitly confirmed shared secret from a PAKE."]
    #[doc = ""]
    #[doc = " At this point there is a cryptographic guarantee that only the authenticated"]
    #[doc = " party who used the same password is able to compute the key. But there is no"]
    #[doc = " guarantee that the peer is the party it claims to be and was able to do so."]
    #[doc = ""]
    #[doc = " That is, the authentication is only implicit. Since the peer is not"]
    #[doc = " authenticated yet, no action should be taken yet that assumes that the peer"]
    #[doc = " is who it claims to be. For example, do not access restricted files on the"]
    #[doc = " peer's behalf until an explicit authentication has succeeded."]
    #[doc = ""]
    #[doc = " This function can be called after the key exchange phase of the operation"]
    #[doc = " has completed. It imports the shared secret output of the PAKE into the"]
    #[doc = " provided derivation operation. The input step"]
    #[doc = " #PSA_KEY_DERIVATION_INPUT_SECRET is used when placing the shared key"]
    #[doc = " material in the key derivation operation."]
    #[doc = ""]
    #[doc = " The exact sequence of calls to perform a password-authenticated key"]
    #[doc = " exchange depends on the algorithm in use.  Refer to the documentation of"]
    #[doc = " individual PAKE algorithm types (`PSA_ALG_XXX` values of type"]
    #[doc = " ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more"]
    #[doc = " information."]
    #[doc = ""]
    #[doc = " When this function returns successfully, \\p operation becomes inactive."]
    #[doc = " If this function returns an error status, both \\p operation"]
    #[doc = " and \\p key_derivation operations enter an error state and must be aborted by"]
    #[doc = " calling psa_pake_abort() and psa_key_derivation_abort() respectively."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation    Active PAKE operation."]
    #[doc = " \\param[out] output          A key derivation operation that is ready"]
    #[doc = "                             for an input step of type"]
    #[doc = "                             #PSA_KEY_DERIVATION_INPUT_SECRET."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         #PSA_KEY_DERIVATION_INPUT_SECRET is not compatible with the"]
    #[doc = "         algorithm in the \\p output key derivation operation."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         Input from a PAKE is not supported by the algorithm in the \\p output"]
    #[doc = "         key derivation operation."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The PAKE operation state is not valid (it must be active, but beyond"]
    #[doc = "         that validity is specific to the algorithm), or"]
    #[doc = "         the library has not been previously initialized by psa_crypto_init(),"]
    #[doc = "         or the state of \\p output is not valid for"]
    #[doc = "         the #PSA_KEY_DERIVATION_INPUT_SECRET step. This can happen if the"]
    #[doc = "         step is out of order or the application has done this step already"]
    #[doc = "         and it may not be repeated."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_get_implicit_key(
        operation: *mut psa_pake_operation_t,
        output: *mut psa_key_derivation_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a PAKE operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the \\c"]
    #[doc = " operation structure itself. Once aborted, the operation object can be reused"]
    #[doc = " for another operation by calling psa_pake_setup() again."]
    #[doc = ""]
    #[doc = " This function may be called at any time after the operation"]
    #[doc = " object has been initialized as described in #psa_pake_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_pake_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_pake_abort() or psa_pake_get_implicit_key()"]
    #[doc = " is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation    The operation to abort."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_pake_abort(operation: *mut psa_pake_operation_t) -> psa_status_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_cipher_suite_s {
    pub algorithm: psa_algorithm_t,
    pub type_: psa_pake_primitive_type_t,
    pub family: psa_pake_family_t,
    pub bits: u16,
    pub hash: psa_algorithm_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_crypto_driver_pake_inputs_s {
    pub private_password: *mut u8,
    pub private_password_len: size_t,
    pub private_role: psa_pake_role_t,
    pub private_user: *mut u8,
    pub private_user_len: size_t,
    pub private_peer: *mut u8,
    pub private_peer_len: size_t,
    pub private_attributes: psa_key_attributes_t,
    pub private_cipher_suite: psa_pake_cipher_suite_t,
}
pub const psa_jpake_step_PSA_PAKE_STEP_INVALID: psa_jpake_step = 0;
pub const psa_jpake_step_PSA_PAKE_STEP_X1_X2: psa_jpake_step = 1;
pub const psa_jpake_step_PSA_PAKE_STEP_X2S: psa_jpake_step = 2;
pub const psa_jpake_step_PSA_PAKE_STEP_DERIVE: psa_jpake_step = 3;
pub type psa_jpake_step = crate::c_types::c_uint;
pub use self::psa_jpake_step as psa_jpake_step_t;
pub const psa_jpake_state_PSA_PAKE_STATE_INVALID: psa_jpake_state = 0;
pub const psa_jpake_state_PSA_PAKE_STATE_SETUP: psa_jpake_state = 1;
pub const psa_jpake_state_PSA_PAKE_STATE_READY: psa_jpake_state = 2;
pub const psa_jpake_state_PSA_PAKE_OUTPUT_X1_X2: psa_jpake_state = 3;
pub const psa_jpake_state_PSA_PAKE_OUTPUT_X2S: psa_jpake_state = 4;
pub const psa_jpake_state_PSA_PAKE_INPUT_X1_X2: psa_jpake_state = 5;
pub const psa_jpake_state_PSA_PAKE_INPUT_X4S: psa_jpake_state = 6;
pub type psa_jpake_state = crate::c_types::c_uint;
pub use self::psa_jpake_state as psa_jpake_state_t;
pub const psa_jpake_sequence_PSA_PAKE_SEQ_INVALID: psa_jpake_sequence = 0;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_KEY_SHARE: psa_jpake_sequence = 1;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_ZK_PUBLIC: psa_jpake_sequence = 2;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_ZK_PROOF: psa_jpake_sequence = 3;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_KEY_SHARE: psa_jpake_sequence = 4;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_ZK_PUBLIC: psa_jpake_sequence = 5;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_ZK_PROOF: psa_jpake_sequence = 6;
pub const psa_jpake_sequence_PSA_PAKE_SEQ_END: psa_jpake_sequence = 7;
pub type psa_jpake_sequence = crate::c_types::c_uint;
pub use self::psa_jpake_sequence as psa_jpake_sequence_t;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_STEP_INVALID: psa_crypto_driver_pake_step = 0;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 1;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 2;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 3;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 4;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 5;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 6;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 7;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 8;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 9;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_KEY_SHARE: psa_crypto_driver_pake_step =
    10;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step =
    11;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 12;
pub type psa_crypto_driver_pake_step = crate::c_types::c_uint;
pub use self::psa_crypto_driver_pake_step as psa_crypto_driver_pake_step_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_jpake_computation_stage_s {
    pub private_state: psa_jpake_state_t,
    pub private_sequence: psa_jpake_sequence_t,
    pub private_input_step: psa_jpake_step_t,
    pub private_output_step: psa_jpake_step_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_stage: u8,
    pub private_computation_stage: psa_pake_operation_s__bindgen_ty_1,
    pub private_data: psa_pake_operation_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_jpake: psa_jpake_computation_stage_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_2 {
    pub private_ctx: psa_driver_pake_context_t,
    pub private_inputs: psa_crypto_driver_pake_inputs_t,
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_buf {
    #[doc = "< ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING."]
    pub tag: crate::c_types::c_int,
    #[doc = "< ASN1 length, in octets."]
    pub len: size_t,
    #[doc = "< ASN1 data, e.g. in ASCII."]
    pub p: *mut crate::c_types::c_uchar,
}
#[doc = " Container for ASN1 bit strings."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_bitstring {
    #[doc = "< ASN1 length, in octets."]
    pub len: size_t,
    #[doc = "< Number of unused bits at the end of the string"]
    pub unused_bits: crate::c_types::c_uchar,
    #[doc = "< Raw ASN1 data for the bit string"]
    pub p: *mut crate::c_types::c_uchar,
}
#[doc = " Container for a sequence of ASN.1 items"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_sequence {
    #[doc = "< Buffer containing the given ASN.1 item."]
    pub buf: mbedtls_asn1_buf,
    #[doc = " The next entry in the sequence."]
    #[doc = ""]
    #[doc = " The details of memory management for sequences are not documented and"]
    #[doc = " may change in future versions. Set this field to \\p NULL when"]
    #[doc = " initializing a structure, and do not modify it except via Mbed TLS"]
    #[doc = " library functions."]
    pub next: *mut mbedtls_asn1_sequence,
}
#[doc = " Container for a sequence or list of 'named' ASN.1 data items"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_named_data {
    #[doc = "< The object identifier."]
    pub oid: mbedtls_asn1_buf,
    #[doc = "< The named value."]
    pub val: mbedtls_asn1_buf,
    #[doc = " The next entry in the sequence."]
    #[doc = ""]
    #[doc = " The details of memory management for named data sequences are not"]
    #[doc = " documented and may change in future versions. Set this field to \\p NULL"]
    #[doc = " when initializing a structure, and do not modify it except via Mbed TLS"]
    #[doc = " library functions."]
    pub next: *mut mbedtls_asn1_named_data,
    pub private_next_merged: crate::c_types::c_uchar,
}
extern "C" {
    #[doc = " \\brief       Get the length of an ASN.1 element."]
    #[doc = "              Updates the pointer to immediately behind the length."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the first byte of the length,"]
    #[doc = "              i.e. immediately after the tag."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              after the length, i.e. the first byte of the content."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param len   On successful completion, \\c *len contains the length"]
    #[doc = "              read from the ASN.1 input."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element"]
    #[doc = "              would end beyond \\p end."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable."]
    pub fn mbedtls_asn1_get_len(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Get the tag and length of the element."]
    #[doc = "              Check for the requested tag."]
    #[doc = "              Updates the pointer to immediately behind the tag and length."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              after the length, i.e. the first byte of the content."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param len   On successful completion, \\c *len contains the length"]
    #[doc = "              read from the ASN.1 input."]
    #[doc = " \\param tag   The expected tag."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the data does not start"]
    #[doc = "              with the requested tag."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element"]
    #[doc = "              would end beyond \\p end."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable."]
    pub fn mbedtls_asn1_get_tag(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut size_t,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a boolean ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param val   On success, the parsed value (\\c 0 or \\c 1)."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 BOOLEAN."]
    pub fn mbedtls_asn1_get_bool(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param val   On success, the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 INTEGER."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does"]
    #[doc = "              not fit in an \\c int."]
    pub fn mbedtls_asn1_get_int(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an enumerated ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param val   On success, the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 ENUMERATED."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does"]
    #[doc = "              not fit in an \\c int."]
    pub fn mbedtls_asn1_get_enum(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p is equal to \\p end."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param bs    On success, ::mbedtls_asn1_bitstring information about"]
    #[doc = "              the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains"]
    #[doc = "              extra data after a valid BIT STRING."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 BIT STRING."]
    pub fn mbedtls_asn1_get_bitstring(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        bs: *mut mbedtls_asn1_bitstring,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag without unused bits and its"]
    #[doc = "              value."]
    #[doc = "              Updates the pointer to the beginning of the bit/octet string."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              of the content of the BIT STRING."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param len   On success, \\c *len is the length of the content in bytes."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_DATA if the input starts with"]
    #[doc = "              a valid BIT STRING with a nonzero number of unused bits."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 BIT STRING."]
    pub fn mbedtls_asn1_get_bitstring_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Parses and splits an ASN.1 \"SEQUENCE OF <tag>\"."]
    #[doc = "              Updates the pointer to immediately behind the full sequence tag."]
    #[doc = ""]
    #[doc = " This function allocates memory for the sequence elements. You can free"]
    #[doc = " the allocated memory with mbedtls_asn1_sequence_free()."]
    #[doc = ""]
    #[doc = " \\note        On error, this function may return a partial list in \\p cur."]
    #[doc = "              You must set `cur->next = NULL` before calling this function!"]
    #[doc = "              Otherwise it is impossible to distinguish a previously non-null"]
    #[doc = "              pointer from a pointer to an object allocated by this function."]
    #[doc = ""]
    #[doc = " \\note        If the sequence is empty, this function does not modify"]
    #[doc = "              \\c *cur. If the sequence is valid and non-empty, this"]
    #[doc = "              function sets `cur->buf.tag` to \\p tag. This allows"]
    #[doc = "              callers to distinguish between an empty sequence and"]
    #[doc = "              a one-element sequence."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p is equal to \\p end."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param cur   A ::mbedtls_asn1_sequence which this function fills."]
    #[doc = "              When this function returns, \\c *cur is the head of a linked"]
    #[doc = "              list. Each node in this list is allocated with"]
    #[doc = "              mbedtls_calloc() apart from \\p cur itself, and should"]
    #[doc = "              therefore be freed with mbedtls_free()."]
    #[doc = "              The list describes the content of the sequence."]
    #[doc = "              The head of the list (i.e. \\c *cur itself) describes the"]
    #[doc = "              first element, `*cur->next` describes the second element, etc."]
    #[doc = "              For each element, `buf.tag == tag`, `buf.len` is the length"]
    #[doc = "              of the content of the content of the element, and `buf.p`"]
    #[doc = "              points to the first byte of the content (i.e. immediately"]
    #[doc = "              past the length of the element)."]
    #[doc = "              Note that list elements may be allocated even on error."]
    #[doc = " \\param tag   Each element of the sequence must have this tag."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains"]
    #[doc = "              extra data after a valid SEQUENCE OF \\p tag."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts with"]
    #[doc = "              an ASN.1 SEQUENCE in which an element has a tag that"]
    #[doc = "              is different from \\p tag."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 SEQUENCE."]
    pub fn mbedtls_asn1_get_sequence_of(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        cur: *mut mbedtls_asn1_sequence,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free a heap-allocated linked list presentation of"]
    #[doc = "                 an ASN.1 sequence, including the first element."]
    #[doc = ""]
    #[doc = " There are two common ways to manage the memory used for the representation"]
    #[doc = " of a parsed ASN.1 sequence:"]
    #[doc = " - Allocate a head node `mbedtls_asn1_sequence *head` with mbedtls_calloc()."]
    #[doc = "   Pass this node as the `cur` argument to mbedtls_asn1_get_sequence_of()."]
    #[doc = "   When you have finished processing the sequence,"]
    #[doc = "   call mbedtls_asn1_sequence_free() on `head`."]
    #[doc = " - Allocate a head node `mbedtls_asn1_sequence *head` in any manner,"]
    #[doc = "   for example on the stack. Make sure that `head->next == NULL`."]
    #[doc = "   Pass `head` as the `cur` argument to mbedtls_asn1_get_sequence_of()."]
    #[doc = "   When you have finished processing the sequence,"]
    #[doc = "   call mbedtls_asn1_sequence_free() on `head->cur`,"]
    #[doc = "   then free `head` itself in the appropriate manner."]
    #[doc = ""]
    #[doc = " \\param seq      The address of the first sequence component. This may"]
    #[doc = "                 be \\c NULL, in which case this functions returns"]
    #[doc = "                 immediately."]
    pub fn mbedtls_asn1_sequence_free(seq: *mut mbedtls_asn1_sequence);
}
extern "C" {
    #[doc = " \\brief                Traverse an ASN.1 SEQUENCE container and"]
    #[doc = "                       call a callback for each entry."]
    #[doc = ""]
    #[doc = " This function checks that the input is a SEQUENCE of elements that"]
    #[doc = " each have a \"must\" tag, and calls a callback function on the elements"]
    #[doc = " that have a \"may\" tag."]
    #[doc = ""]
    #[doc = " For example, to validate that the input is a SEQUENCE of `tag1` and call"]
    #[doc = " `cb` on each element, use"]
    #[doc = " ```"]
    #[doc = " mbedtls_asn1_traverse_sequence_of(&p, end, 0xff, tag1, 0, 0, cb, ctx);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " To validate that the input is a SEQUENCE of ANY and call `cb` on"]
    #[doc = " each element, use"]
    #[doc = " ```"]
    #[doc = " mbedtls_asn1_traverse_sequence_of(&p, end, 0, 0, 0, 0, cb, ctx);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING}"]
    #[doc = " and call `cb` on each element that is an OCTET STRING, use"]
    #[doc = " ```"]
    #[doc = " mbedtls_asn1_traverse_sequence_of(&p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " The callback is called on the elements with a \"may\" tag from left to"]
    #[doc = " right. If the input is not a valid SEQUENCE of elements with a \"must\" tag,"]
    #[doc = " the callback is called on the elements up to the leftmost point where"]
    #[doc = " the input is invalid."]
    #[doc = ""]
    #[doc = " \\warning              This function is still experimental and may change"]
    #[doc = "                       at any time."]
    #[doc = ""]
    #[doc = " \\param p              The address of the pointer to the beginning of"]
    #[doc = "                       the ASN.1 SEQUENCE header. This is updated to"]
    #[doc = "                       point to the end of the ASN.1 SEQUENCE container"]
    #[doc = "                       on a successful invocation."]
    #[doc = " \\param end            The end of the ASN.1 SEQUENCE container."]
    #[doc = " \\param tag_must_mask  A mask to be applied to the ASN.1 tags found within"]
    #[doc = "                       the SEQUENCE before comparing to \\p tag_must_value."]
    #[doc = " \\param tag_must_val   The required value of each ASN.1 tag found in the"]
    #[doc = "                       SEQUENCE, after masking with \\p tag_must_mask."]
    #[doc = "                       Mismatching tags lead to an error."]
    #[doc = "                       For example, a value of \\c 0 for both \\p tag_must_mask"]
    #[doc = "                       and \\p tag_must_val means that every tag is allowed,"]
    #[doc = "                       while a value of \\c 0xFF for \\p tag_must_mask means"]
    #[doc = "                       that \\p tag_must_val is the only allowed tag."]
    #[doc = " \\param tag_may_mask   A mask to be applied to the ASN.1 tags found within"]
    #[doc = "                       the SEQUENCE before comparing to \\p tag_may_value."]
    #[doc = " \\param tag_may_val    The desired value of each ASN.1 tag found in the"]
    #[doc = "                       SEQUENCE, after masking with \\p tag_may_mask."]
    #[doc = "                       Mismatching tags will be silently ignored."]
    #[doc = "                       For example, a value of \\c 0 for \\p tag_may_mask and"]
    #[doc = "                       \\p tag_may_val means that any tag will be considered,"]
    #[doc = "                       while a value of \\c 0xFF for \\p tag_may_mask means"]
    #[doc = "                       that all tags with value different from \\p tag_may_val"]
    #[doc = "                       will be ignored."]
    #[doc = " \\param cb             The callback to trigger for each component"]
    #[doc = "                       in the ASN.1 SEQUENCE that matches \\p tag_may_val."]
    #[doc = "                       The callback function is called with the following"]
    #[doc = "                       parameters:"]
    #[doc = "                       - \\p ctx."]
    #[doc = "                       - The tag of the current element."]
    #[doc = "                       - A pointer to the start of the current element's"]
    #[doc = "                         content inside the input."]
    #[doc = "                       - The length of the content of the current element."]
    #[doc = "                       If the callback returns a non-zero value,"]
    #[doc = "                       the function stops immediately,"]
    #[doc = "                       forwarding the callback's return value."]
    #[doc = " \\param ctx            The context to be passed to the callback \\p cb."]
    #[doc = ""]
    #[doc = " \\return               \\c 0 if successful the entire ASN.1 SEQUENCE"]
    #[doc = "                       was traversed without parsing or callback errors."]
    #[doc = " \\return               #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input"]
    #[doc = "                       contains extra data after a valid SEQUENCE"]
    #[doc = "                       of elements with an accepted tag."]
    #[doc = " \\return               #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts"]
    #[doc = "                       with an ASN.1 SEQUENCE in which an element has a tag"]
    #[doc = "                       that is not accepted."]
    #[doc = " \\return               An ASN.1 error code if the input does not start with"]
    #[doc = "                       a valid ASN.1 SEQUENCE."]
    #[doc = " \\return               A non-zero error code forwarded from the callback"]
    #[doc = "                       \\p cb in case the latter returns a non-zero value."]
    pub fn mbedtls_asn1_traverse_sequence_of(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        tag_must_mask: crate::c_types::c_uchar,
        tag_must_val: crate::c_types::c_uchar,
        tag_may_mask: crate::c_types::c_uchar,
        tag_may_val: crate::c_types::c_uchar,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut crate::c_types::c_void,
                tag: crate::c_types::c_int,
                start: *mut crate::c_types::c_uchar,
                len: size_t,
            ) -> crate::c_types::c_int,
        >,
        ctx: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param X     On success, the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 INTEGER."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does"]
    #[doc = "              not fit in an \\c int."]
    #[doc = " \\return      An MPI error code if the parsed value is too large."]
    pub fn mbedtls_asn1_get_mpi(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        X: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence."]
    #[doc = "              Updates the pointer to immediately behind the full"]
    #[doc = "              AlgorithmIdentifier."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the AlgorithmIdentifier element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param alg   The buffer to receive the OID."]
    #[doc = " \\param params The buffer to receive the parameters."]
    #[doc = "              This is zeroized if there are no parameters."]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_asn1_buf,
        params: *mut mbedtls_asn1_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no"]
    #[doc = "              params."]
    #[doc = "              Updates the pointer to immediately behind the full"]
    #[doc = "              AlgorithmIdentifier."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the AlgorithmIdentifier element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param alg   The buffer to receive the OID."]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_asn1_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Find a specific named_data entry in a sequence or list based on"]
    #[doc = "              the OID."]
    #[doc = ""]
    #[doc = " \\param list  The list to seek through"]
    #[doc = " \\param oid   The OID to look for"]
    #[doc = " \\param len   Size of the OID"]
    #[doc = ""]
    #[doc = " \\return      NULL if not found, or a pointer to the existing entry."]
    pub fn mbedtls_asn1_find_named_data(
        list: *const mbedtls_asn1_named_data,
        oid: *const crate::c_types::c_char,
        len: size_t,
    ) -> *const mbedtls_asn1_named_data;
}
extern "C" {
    #[doc = " \\brief       Free a mbedtls_asn1_named_data entry"]
    #[doc = ""]
    #[doc = " \\deprecated  This function is deprecated and will be removed in a"]
    #[doc = "              future version of the library."]
    #[doc = "              Please use mbedtls_asn1_free_named_data_list()"]
    #[doc = "              or mbedtls_asn1_free_named_data_list_shallow()."]
    #[doc = ""]
    #[doc = " \\param entry The named data entry to free."]
    #[doc = "              This function calls mbedtls_free() on"]
    #[doc = "              `entry->oid.p` and `entry->val.p`."]
    pub fn mbedtls_asn1_free_named_data(entry: *mut mbedtls_asn1_named_data);
}
extern "C" {
    #[doc = " \\brief       Free all entries in a mbedtls_asn1_named_data list."]
    #[doc = ""]
    #[doc = " \\param head  Pointer to the head of the list of named data entries to free."]
    #[doc = "              This function calls mbedtls_free() on"]
    #[doc = "              `entry->oid.p` and `entry->val.p` and then on `entry`"]
    #[doc = "              for each list entry, and sets \\c *head to \\c NULL."]
    pub fn mbedtls_asn1_free_named_data_list(head: *mut *mut mbedtls_asn1_named_data);
}
extern "C" {
    #[doc = " \\brief       Free all shallow entries in a mbedtls_asn1_named_data list,"]
    #[doc = "              but do not free internal pointer targets."]
    #[doc = ""]
    #[doc = " \\param name  Head of the list of named data entries to free."]
    #[doc = "              This function calls mbedtls_free() on each list element."]
    pub fn mbedtls_asn1_free_named_data_list_shallow(name: *mut mbedtls_asn1_named_data);
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
pub type mbedtls_x509_buf = mbedtls_asn1_buf;
#[doc = " Container for ASN1 bit strings."]
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
#[doc = " Container for a sequence or list of 'named' ASN.1 data items"]
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
#[doc = " Container for a sequence of ASN.1 items"]
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
#[doc = " Container for date and time (precision in seconds)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_time {
    #[doc = "< Date."]
    pub year: crate::c_types::c_int,
    #[doc = "< Date."]
    pub mon: crate::c_types::c_int,
    #[doc = "< Date."]
    pub day: crate::c_types::c_int,
    #[doc = "< Time."]
    pub hour: crate::c_types::c_int,
    #[doc = "< Time."]
    pub min: crate::c_types::c_int,
    #[doc = "< Time."]
    pub sec: crate::c_types::c_int,
}
#[doc = " From RFC 5280 section 4.2.1.6:"]
#[doc = " OtherName ::= SEQUENCE {"]
#[doc = "      type-id    OBJECT IDENTIFIER,"]
#[doc = "      value      [0] EXPLICIT ANY DEFINED BY type-id }"]
#[doc = ""]
#[doc = " Future versions of the library may add new fields to this structure or"]
#[doc = " to its embedded union and structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name {
    #[doc = "< The type id."]
    pub type_id: mbedtls_x509_buf,
    pub value: mbedtls_x509_san_other_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_san_other_name__bindgen_ty_1 {
    pub hardware_module_name: mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " From RFC 4108 section 5:"]
#[doc = " HardwareModuleName ::= SEQUENCE {"]
#[doc = "                         hwType OBJECT IDENTIFIER,"]
#[doc = "                         hwSerialNum OCTET STRING }"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The object identifier."]
    pub oid: mbedtls_x509_buf,
    #[doc = "< The named value."]
    pub val: mbedtls_x509_buf,
}
#[doc = " A structure for holding the parsed Subject Alternative Name,"]
#[doc = " according to type."]
#[doc = ""]
#[doc = " Future versions of the library may add new fields to this structure or"]
#[doc = " to its embedded union and structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_subject_alternative_name {
    #[doc = "< The SAN type, value of MBEDTLS_X509_SAN_XXX."]
    pub type_: crate::c_types::c_int,
    #[doc = "< A union of the supported SAN types"]
    pub san: mbedtls_x509_subject_alternative_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_subject_alternative_name__bindgen_ty_1 {
    #[doc = "< The otherName supported type."]
    pub other_name: mbedtls_x509_san_other_name,
    #[doc = "< The buffer for the unconstructed types. Only rfc822Name, dnsName and uniformResourceIdentifier are currently supported"]
    pub unstructured_name: mbedtls_x509_buf,
}
extern "C" {
    #[doc = " \\brief          Store the certificate DN in printable form into buf;"]
    #[doc = "                 no more than size characters will be written."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param dn       The X509 name to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_dn_gets(
        buf: *mut crate::c_types::c_char,
        size: size_t,
        dn: *const mbedtls_x509_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Store the certificate serial in printable form into buf;"]
    #[doc = "                 no more than size characters will be written."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param serial   The X509 serial to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_serial_gets(
        buf: *mut crate::c_types::c_char,
        size: size_t,
        serial: *const mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time"]
    #[doc = "                 and tell if it's in the past."]
    #[doc = ""]
    #[doc = " \\note           Intended usage is \"if( is_past( valid_to ) ) ERROR\"."]
    #[doc = "                 Hence the return value of 1 if on internal errors."]
    #[doc = ""]
    #[doc = " \\param to       mbedtls_x509_time to check"]
    #[doc = ""]
    #[doc = " \\return         1 if the given time is in the past or an error occurred,"]
    #[doc = "                 0 otherwise."]
    pub fn mbedtls_x509_time_is_past(to: *const mbedtls_x509_time) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time"]
    #[doc = "                 and tell if it's in the future."]
    #[doc = ""]
    #[doc = " \\note           Intended usage is \"if( is_future( valid_from ) ) ERROR\"."]
    #[doc = "                 Hence the return value of 1 if on internal errors."]
    #[doc = ""]
    #[doc = " \\param from     mbedtls_x509_time to check"]
    #[doc = ""]
    #[doc = " \\return         1 if the given time is in the future or an error occurred,"]
    #[doc = "                 0 otherwise."]
    pub fn mbedtls_x509_time_is_future(from: *const mbedtls_x509_time) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function parses an item in the SubjectAlternativeNames"]
    #[doc = "                 extension."]
    #[doc = ""]
    #[doc = " \\param san_buf  The buffer holding the raw data item of the subject"]
    #[doc = "                 alternative name."]
    #[doc = " \\param san      The target structure to populate with the parsed presentation"]
    #[doc = "                 of the subject alternative name encoded in \\p san_raw."]
    #[doc = ""]
    #[doc = " \\note           Supported GeneralName types, as defined in RFC 5280:"]
    #[doc = "                 \"rfc822Name\", \"dnsName\", \"uniformResourceIdentifier\" and \"hardware_module_name\""]
    #[doc = "                 of type \"otherName\", as defined in RFC 4108."]
    #[doc = ""]
    #[doc = " \\note           This function should be called on a single raw data of"]
    #[doc = "                 subject alternative name. For example, after successful"]
    #[doc = "                 certificate parsing, one must iterate on every item in the"]
    #[doc = "                 \\p crt->subject_alt_names sequence, and pass it to"]
    #[doc = "                 this function."]
    #[doc = ""]
    #[doc = " \\warning        The target structure contains pointers to the raw data of the"]
    #[doc = "                 parsed certificate, and its lifetime is restricted by the"]
    #[doc = "                 lifetime of the certificate."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success"]
    #[doc = " \\return         #MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE for an unsupported"]
    #[doc = "                 SAN type."]
    #[doc = " \\return         Another negative value for any other failure."]
    pub fn mbedtls_x509_parse_subject_alt_name(
        san_buf: *const mbedtls_x509_buf,
        san: *mut mbedtls_x509_subject_alternative_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\} addtogroup x509_module"]
    pub fn mbedtls_x509_get_name(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        cur: *mut mbedtls_x509_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_x509_buf,
        params: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_rsassa_pss_params(
        params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        mgf_md: *mut mbedtls_md_type_t,
        salt_len: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        sig: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig_alg(
        sig_oid: *const mbedtls_x509_buf,
        sig_params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        pk_alg: *mut mbedtls_pk_type_t,
        sig_opts: *mut *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_time(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        t: *mut mbedtls_x509_time,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_serial(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        serial: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ext(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        ext: *mut mbedtls_x509_buf,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_sig_alg_gets(
        buf: *mut crate::c_types::c_char,
        size: size_t,
        sig_oid: *const mbedtls_x509_buf,
        pk_alg: mbedtls_pk_type_t,
        md_alg: mbedtls_md_type_t,
        sig_opts: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_key_size_helper(
        buf: *mut crate::c_types::c_char,
        buf_size: size_t,
        name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_string_to_names(
        head: *mut *mut mbedtls_asn1_named_data,
        name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_set_extension(
        head: *mut *mut mbedtls_asn1_named_data,
        oid: *const crate::c_types::c_char,
        oid_len: size_t,
        critical: crate::c_types::c_int,
        val: *const crate::c_types::c_uchar,
        val_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_extensions(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_names(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_sig(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        oid: *const crate::c_types::c_char,
        oid_len: size_t,
        sig: *mut crate::c_types::c_uchar,
        size: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ns_cert_type(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        ns_cert_type: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_key_usage(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        key_usage: *mut crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_subject_alt_name(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        subject_alt_name: *mut mbedtls_x509_sequence,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_subject_alt_name(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut size_t,
        subject_alt_name: *const mbedtls_x509_sequence,
        prefix: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_cert_type(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut size_t,
        ns_cert_type: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_key_usage(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut size_t,
        key_usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
#[doc = " Certificate revocation list entry."]
#[doc = " Contains the CA-specific serial numbers and revocation dates."]
#[doc = ""]
#[doc = " Some fields of this structure are publicly readable. Do not modify"]
#[doc = " them except via Mbed TLS library functions: the effect of modifying"]
#[doc = " those fields or the data that those fields points to is unspecified."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crl_entry {
    #[doc = " Direct access to the whole entry inside the containing buffer."]
    pub raw: mbedtls_x509_buf,
    #[doc = " The serial number of the revoked certificate."]
    pub serial: mbedtls_x509_buf,
    #[doc = " The revocation date of this entry."]
    pub revocation_date: mbedtls_x509_time,
    #[doc = " Direct access to the list of CRL entry extensions"]
    #[doc = " (an ASN.1 constructed sequence)."]
    #[doc = ""]
    #[doc = " If there are no extensions, `entry_ext.len == 0` and"]
    #[doc = " `entry_ext.p == NULL`."]
    pub entry_ext: mbedtls_x509_buf,
    #[doc = " Next element in the linked list of entries."]
    #[doc = " \\p NULL indicates the end of the list."]
    #[doc = " Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crl_entry,
}
#[doc = " Certificate revocation list structure."]
#[doc = " Every CRL may have multiple entries."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crl {
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< CRL version (1=v1, 2=v2)"]
    pub version: crate::c_types::c_int,
    #[doc = "< CRL signature type identifier"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER)."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    pub this_update: mbedtls_x509_time,
    pub next_update: mbedtls_x509_time,
    #[doc = "< The CRL entries containing the certificate revocation times for this CA."]
    pub entry: mbedtls_x509_crl_entry,
    pub crl_ext: mbedtls_x509_buf,
    pub private_sig_oid2: mbedtls_x509_buf,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut crate::c_types::c_void,
    #[doc = " Next element in the linked list of CRL."]
    #[doc = " \\p NULL indicates the end of the list."]
    #[doc = " Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crl,
}
extern "C" {
    #[doc = " \\brief          Parse a DER-encoded CRL and append it to the chained list"]
    #[doc = ""]
    #[doc = " \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                 subsystem must have been initialized by calling"]
    #[doc = "                 psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the CRL data in DER format"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse_der(
        chain: *mut mbedtls_x509_crl,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one or more CRLs and append them to the chained list"]
    #[doc = ""]
    #[doc = " \\note           Multiple CRLs are accepted only if using PEM format"]
    #[doc = ""]
    #[doc = " \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                 subsystem must have been initialized by calling"]
    #[doc = "                 psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the CRL data in PEM or DER format"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse(
        chain: *mut mbedtls_x509_crl,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the CRL."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param crl      The X509 CRL to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crl_info(
        buf: *mut crate::c_types::c_char,
        size: size_t,
        prefix: *const crate::c_types::c_char,
        crl: *const mbedtls_x509_crl,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a CRL (chain)"]
    #[doc = ""]
    #[doc = " \\param crl      CRL chain to initialize"]
    pub fn mbedtls_x509_crl_init(crl: *mut mbedtls_x509_crl);
}
extern "C" {
    #[doc = " \\brief          Unallocate all CRL data"]
    #[doc = ""]
    #[doc = " \\param crl      CRL chain to free"]
    pub fn mbedtls_x509_crl_free(crl: *mut mbedtls_x509_crl);
}
#[doc = " Container for an X.509 certificate. The certificate may be chained."]
#[doc = ""]
#[doc = " Some fields of this structure are publicly readable. Do not modify"]
#[doc = " them except via Mbed TLS library functions: the effect of modifying"]
#[doc = " those fields or the data that those fields points to is unspecified."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt {
    pub private_own_buffer: crate::c_types::c_int,
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< The X.509 version. (1=v1, 2=v2, 3=v3)"]
    pub version: crate::c_types::c_int,
    #[doc = "< Unique id for certificate issued by a specific CA."]
    pub serial: mbedtls_x509_buf,
    #[doc = "< Signature algorithm, e.g. sha1RSA"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER). Used for quick comparison."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The raw subject data (DER). Used for quick comparison."]
    pub subject_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    #[doc = "< The parsed subject data (named information object)."]
    pub subject: mbedtls_x509_name,
    #[doc = "< Start time of certificate validity."]
    pub valid_from: mbedtls_x509_time,
    #[doc = "< End time of certificate validity."]
    pub valid_to: mbedtls_x509_time,
    pub pk_raw: mbedtls_x509_buf,
    #[doc = "< Container for the public key context."]
    pub pk: mbedtls_pk_context,
    #[doc = "< Optional X.509 v2/v3 issuer unique identifier."]
    pub issuer_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v2/v3 subject unique identifier."]
    pub subject_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v3 extensions."]
    pub v3_ext: mbedtls_x509_buf,
    #[doc = "< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName, uniformResourceIdentifier and OtherName are listed)."]
    pub subject_alt_names: mbedtls_x509_sequence,
    #[doc = "< Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed)."]
    pub certificate_policies: mbedtls_x509_sequence,
    pub private_ext_types: crate::c_types::c_int,
    pub private_ca_istrue: crate::c_types::c_int,
    pub private_max_pathlen: crate::c_types::c_int,
    pub private_key_usage: crate::c_types::c_uint,
    #[doc = "< Optional list of extended key usage OIDs."]
    pub ext_key_usage: mbedtls_x509_sequence,
    pub private_ns_cert_type: crate::c_types::c_uchar,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut crate::c_types::c_void,
    #[doc = " Next certificate in the linked list that constitutes the CA chain."]
    #[doc = " \\p NULL indicates the end of the list."]
    #[doc = " Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crt,
}
#[doc = " Security profile for certificate verification."]
#[doc = ""]
#[doc = " All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG()."]
#[doc = ""]
#[doc = " The fields of this structure are part of the public API and can be"]
#[doc = " manipulated directly by applications. Future versions of the library may"]
#[doc = " add extra fields or reorder existing fields."]
#[doc = ""]
#[doc = " You can create custom profiles by starting from a copy of"]
#[doc = " an existing profile, such as mbedtls_x509_crt_profile_default or"]
#[doc = " mbedtls_x509_ctr_profile_none and then tune it to your needs."]
#[doc = ""]
#[doc = " For example to allow SHA-224 in addition to the default:"]
#[doc = ""]
#[doc = "  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_default;"]
#[doc = "  my_profile.allowed_mds |= MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 );"]
#[doc = ""]
#[doc = " Or to allow only RSA-3072+ with SHA-256:"]
#[doc = ""]
#[doc = "  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_none;"]
#[doc = "  my_profile.allowed_mds = MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 );"]
#[doc = "  my_profile.allowed_pks = MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_RSA );"]
#[doc = "  my_profile.rsa_min_bitlen = 3072;"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_profile {
    #[doc = "< MDs for signatures"]
    pub allowed_mds: u32,
    #[doc = "< PK algs for public keys;"]
    #[doc = "   this applies to all certificates"]
    #[doc = "   in the provided chain."]
    pub allowed_pks: u32,
    #[doc = "< Elliptic curves for ECDSA"]
    pub allowed_curves: u32,
    #[doc = "< Minimum size for RSA keys"]
    pub rsa_min_bitlen: u32,
}
#[doc = " Container for writing a certificate (CRT)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509write_cert {
    pub private_version: crate::c_types::c_int,
    pub private_serial: [crate::c_types::c_uchar; 20usize],
    pub private_serial_len: size_t,
    pub private_subject_key: *mut mbedtls_pk_context,
    pub private_issuer_key: *mut mbedtls_pk_context,
    pub private_subject: *mut mbedtls_asn1_named_data,
    pub private_issuer: *mut mbedtls_asn1_named_data,
    pub private_md_alg: mbedtls_md_type_t,
    pub private_not_before: [crate::c_types::c_char; 16usize],
    pub private_not_after: [crate::c_types::c_char; 16usize],
    pub private_extensions: *mut mbedtls_asn1_named_data,
}
#[doc = " Item in a verification chain: cert and flags for it"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain_item {
    pub private_crt: *mut mbedtls_x509_crt,
    pub private_flags: u32,
}
#[doc = " Verification chain as built by \\c mbedtls_crt_verify_chain()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain {
    pub private_items: [mbedtls_x509_crt_verify_chain_item; 10usize],
    pub private_len: crate::c_types::c_uint,
}
pub type mbedtls_x509_crt_restart_ctx = crate::c_types::c_void;
extern "C" {
    #[doc = " Default security profile. Should provide a good balance between security"]
    #[doc = " and compatibility with current deployments."]
    #[doc = ""]
    #[doc = " This profile permits:"]
    #[doc = " - SHA2 hashes with at least 256 bits: SHA-256, SHA-384, SHA-512."]
    #[doc = " - Elliptic curves with 255 bits and above except secp256k1."]
    #[doc = " - RSA with 2048 bits and above."]
    #[doc = ""]
    #[doc = " New minor versions of Mbed TLS may extend this profile, for example if"]
    #[doc = " new algorithms are added to the library. New minor versions of Mbed TLS will"]
    #[doc = " not reduce this profile unless serious security concerns require it."]
    pub static mbedtls_x509_crt_profile_default: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " Expected next default profile. Recommended for new deployments."]
    #[doc = " Currently targets a 128-bit security level, except for allowing RSA-2048."]
    #[doc = " This profile may change at any time."]
    pub static mbedtls_x509_crt_profile_next: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " NSA Suite B profile."]
    pub static mbedtls_x509_crt_profile_suiteb: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " Empty profile that allows nothing. Useful as a basis for constructing"]
    #[doc = " custom profiles."]
    pub static mbedtls_x509_crt_profile_none: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it"]
    #[doc = "                 to the end of the provided chained list."]
    #[doc = ""]
    #[doc = " \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                 subsystem must have been initialized by calling"]
    #[doc = "                 psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param chain    The pointer to the start of the CRT chain to attach to."]
    #[doc = "                 When parsing the first CRT in a chain, this should point"]
    #[doc = "                 to an instance of ::mbedtls_x509_crt initialized through"]
    #[doc = "                 mbedtls_x509_crt_init()."]
    #[doc = " \\param buf      The buffer holding the DER encoded certificate."]
    #[doc = " \\param buflen   The size in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\note           This function makes an internal copy of the CRT buffer"]
    #[doc = "                 \\p buf. In particular, \\p buf may be destroyed or reused"]
    #[doc = "                 after this call returns. To avoid duplicating the CRT"]
    #[doc = "                 buffer (at the cost of stricter lifetime constraints),"]
    #[doc = "                 use mbedtls_x509_crt_parse_der_nocopy() instead."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief          The type of certificate extension callbacks."]
#[doc = ""]
#[doc = "                 Callbacks of this type are passed to and used by the"]
#[doc = "                 mbedtls_x509_crt_parse_der_with_ext_cb() routine when"]
#[doc = "                 it encounters either an unsupported extension or a"]
#[doc = "                 \"certificate policies\" extension containing any"]
#[doc = "                 unsupported certificate policies."]
#[doc = "                 Future versions of the library may invoke the callback"]
#[doc = "                 in other cases, if and when the need arises."]
#[doc = ""]
#[doc = " \\param p_ctx    An opaque context passed to the callback."]
#[doc = " \\param crt      The certificate being parsed."]
#[doc = " \\param oid      The OID of the extension."]
#[doc = " \\param critical Whether the extension is critical."]
#[doc = " \\param p        Pointer to the start of the extension value"]
#[doc = "                 (the content of the OCTET STRING)."]
#[doc = " \\param end      End of extension value."]
#[doc = ""]
#[doc = " \\note           The callback must fail and return a negative error code"]
#[doc = "                 if it can not parse or does not support the extension."]
#[doc = "                 When the callback fails to parse a critical extension"]
#[doc = "                 mbedtls_x509_crt_parse_der_with_ext_cb() also fails."]
#[doc = "                 When the callback fails to parse a non critical extension"]
#[doc = "                 mbedtls_x509_crt_parse_der_with_ext_cb() simply skips"]
#[doc = "                 the extension and continues parsing."]
#[doc = ""]
#[doc = " \\return         \\c 0 on success."]
#[doc = " \\return         A negative error code on failure."]
pub type mbedtls_x509_crt_ext_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::c_types::c_void,
        crt: *const mbedtls_x509_crt,
        oid: *const mbedtls_x509_buf,
        critical: crate::c_types::c_int,
        p: *const crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief            Parse a single DER formatted certificate and add it"]
    #[doc = "                   to the end of the provided chained list."]
    #[doc = ""]
    #[doc = " \\note             If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                   subsystem must have been initialized by calling"]
    #[doc = "                   psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param chain      The pointer to the start of the CRT chain to attach to."]
    #[doc = "                   When parsing the first CRT in a chain, this should point"]
    #[doc = "                   to an instance of ::mbedtls_x509_crt initialized through"]
    #[doc = "                   mbedtls_x509_crt_init()."]
    #[doc = " \\param buf        The buffer holding the DER encoded certificate."]
    #[doc = " \\param buflen     The size in Bytes of \\p buf."]
    #[doc = " \\param make_copy  When not zero this function makes an internal copy of the"]
    #[doc = "                   CRT buffer \\p buf. In particular, \\p buf may be destroyed"]
    #[doc = "                   or reused after this call returns."]
    #[doc = "                   When zero this function avoids duplicating the CRT buffer"]
    #[doc = "                   by taking temporary ownership thereof until the CRT"]
    #[doc = "                   is destroyed (like mbedtls_x509_crt_parse_der_nocopy())"]
    #[doc = " \\param cb         A callback invoked for every unsupported certificate"]
    #[doc = "                   extension."]
    #[doc = " \\param p_ctx      An opaque context passed to the callback."]
    #[doc = ""]
    #[doc = " \\note             This call is functionally equivalent to"]
    #[doc = "                   mbedtls_x509_crt_parse_der(), and/or"]
    #[doc = "                   mbedtls_x509_crt_parse_der_nocopy()"]
    #[doc = "                   but it calls the callback with every unsupported"]
    #[doc = "                   certificate extension and additionally the"]
    #[doc = "                   \"certificate policies\" extension if it contains any"]
    #[doc = "                   unsupported certificate policies."]
    #[doc = "                   The callback must return a negative error code if it"]
    #[doc = "                   does not know how to handle such an extension."]
    #[doc = "                   When the callback fails to parse a critical extension"]
    #[doc = "                   mbedtls_x509_crt_parse_der_with_ext_cb() also fails."]
    #[doc = "                   When the callback fails to parse a non critical extension"]
    #[doc = "                   mbedtls_x509_crt_parse_der_with_ext_cb() simply skips"]
    #[doc = "                   the extension and continues parsing."]
    #[doc = "                   Future versions of the library may invoke the callback"]
    #[doc = "                   in other cases, if and when the need arises."]
    #[doc = ""]
    #[doc = " \\return           \\c 0 if successful."]
    #[doc = " \\return           A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der_with_ext_cb(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
        make_copy: crate::c_types::c_int,
        cb: mbedtls_x509_crt_ext_cb_t,
        p_ctx: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it"]
    #[doc = "                 to the end of the provided chained list. This is a"]
    #[doc = "                 variant of mbedtls_x509_crt_parse_der() which takes"]
    #[doc = "                 temporary ownership of the CRT buffer until the CRT"]
    #[doc = "                 is destroyed."]
    #[doc = ""]
    #[doc = " \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                 subsystem must have been initialized by calling"]
    #[doc = "                 psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param chain    The pointer to the start of the CRT chain to attach to."]
    #[doc = "                 When parsing the first CRT in a chain, this should point"]
    #[doc = "                 to an instance of ::mbedtls_x509_crt initialized through"]
    #[doc = "                 mbedtls_x509_crt_init()."]
    #[doc = " \\param buf      The address of the readable buffer holding the DER encoded"]
    #[doc = "                 certificate to use. On success, this buffer must be"]
    #[doc = "                 retained and not be changed for the lifetime of the"]
    #[doc = "                 CRT chain \\p chain, that is, until \\p chain is destroyed"]
    #[doc = "                 through a call to mbedtls_x509_crt_free()."]
    #[doc = " \\param buflen   The size in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\note           This call is functionally equivalent to"]
    #[doc = "                 mbedtls_x509_crt_parse_der(), but it avoids creating a"]
    #[doc = "                 copy of the input buffer at the cost of stronger lifetime"]
    #[doc = "                 constraints. This is useful in constrained environments"]
    #[doc = "                 where duplication of the CRT cannot be tolerated."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der_nocopy(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one DER-encoded or one or more concatenated PEM-encoded"]
    #[doc = "                 certificates and add them to the chained list."]
    #[doc = ""]
    #[doc = "                 For CRTs in PEM encoding, the function parses permissively:"]
    #[doc = "                 if at least one certificate can be parsed, the function"]
    #[doc = "                 returns the number of certificates for which parsing failed"]
    #[doc = "                 (hence \\c 0 if all certificates were parsed successfully)."]
    #[doc = "                 If no certificate could be parsed, the function returns"]
    #[doc = "                 the first (negative) error encountered during parsing."]
    #[doc = ""]
    #[doc = "                 PEM encoded certificates may be interleaved by other data"]
    #[doc = "                 such as human readable descriptions of their content, as"]
    #[doc = "                 long as the certificates are enclosed in the PEM specific"]
    #[doc = "                 '-----{BEGIN/END} CERTIFICATE-----' delimiters."]
    #[doc = ""]
    #[doc = " \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                 subsystem must have been initialized by calling"]
    #[doc = "                 psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param chain    The chain to which to add the parsed certificates."]
    #[doc = " \\param buf      The buffer holding the certificate data in PEM or DER format."]
    #[doc = "                 For certificates in PEM encoding, this may be a concatenation"]
    #[doc = "                 of multiple certificates; for DER encoding, the buffer must"]
    #[doc = "                 comprise exactly one certificate."]
    #[doc = " \\param buflen   The size of \\p buf, including the terminating \\c NULL byte"]
    #[doc = "                 in case of PEM encoded data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if all certificates were parsed successfully."]
    #[doc = " \\return         The (positive) number of certificates that couldn't"]
    #[doc = "                 be parsed if parsing was partly successful (see above)."]
    #[doc = " \\return         A negative X509 or PEM error code otherwise."]
    #[doc = ""]
    pub fn mbedtls_x509_crt_parse(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the"]
    #[doc = "                 certificate."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param crt      The X509 certificate to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_info(
        buf: *mut crate::c_types::c_char,
        size: size_t,
        prefix: *const crate::c_types::c_char,
        crt: *const mbedtls_x509_crt,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the"]
    #[doc = "                 verification status of a certificate."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param flags    Verification flags created by mbedtls_x509_crt_verify()"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_verify_info(
        buf: *mut crate::c_types::c_char,
        size: size_t,
        prefix: *const crate::c_types::c_char,
        flags: u32,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates."]
    #[doc = ""]
    #[doc = "                 The verify callback is a user-supplied callback that"]
    #[doc = "                 can clear / modify / add flags for a certificate. If set,"]
    #[doc = "                 the verification callback is called for each"]
    #[doc = "                 certificate in the chain (from the trust-ca down to the"]
    #[doc = "                 presented crt). The parameters for the callback are:"]
    #[doc = "                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,"]
    #[doc = "                 int *flags). With the flags representing current flags for"]
    #[doc = "                 that specific certificate and the certificate depth from"]
    #[doc = "                 the bottom (Peer cert depth = 0)."]
    #[doc = ""]
    #[doc = "                 All flags left after returning from the callback"]
    #[doc = "                 are also returned to the application. The function should"]
    #[doc = "                 return 0 for anything (including invalid certificates)"]
    #[doc = "                 other than fatal error, as a non-zero return code"]
    #[doc = "                 immediately aborts the verification process. For fatal"]
    #[doc = "                 errors, a specific error code should be used (different"]
    #[doc = "                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not"]
    #[doc = "                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR"]
    #[doc = "                 can be used if no better code is available."]
    #[doc = ""]
    #[doc = " \\note           In case verification failed, the results can be displayed"]
    #[doc = "                 using \\c mbedtls_x509_crt_verify_info()"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_x509_crt_verify_with_profile() with the"]
    #[doc = "                 default security profile."]
    #[doc = ""]
    #[doc = " \\note           It is your responsibility to provide up-to-date CRLs for"]
    #[doc = "                 all trusted CAs. If no CRL is provided for the CA that was"]
    #[doc = "                 used to sign the certificate, CRL verification is skipped"]
    #[doc = "                 silently, that is *without* setting any flag."]
    #[doc = ""]
    #[doc = " \\note           The \\c trust_ca list can contain two types of certificates:"]
    #[doc = "                 (1) those of trusted root CAs, so that certificates"]
    #[doc = "                 chaining up to those CAs will be trusted, and (2)"]
    #[doc = "                 self-signed end-entity certificates to be trusted (for"]
    #[doc = "                 specific peers you know) - in that case, the self-signed"]
    #[doc = "                 certificate doesn't need to have the CA bit set."]
    #[doc = ""]
    #[doc = " \\param crt      The certificate chain to be verified."]
    #[doc = " \\param trust_ca The list of trusted CAs."]
    #[doc = " \\param ca_crl   The list of CRLs for trusted CAs."]
    #[doc = " \\param cn       The expected Common Name. This will be checked to be"]
    #[doc = "                 present in the certificate's subjectAltNames extension or,"]
    #[doc = "                 if this extension is absent, as a CN component in its"]
    #[doc = "                 Subject name. Currently only DNS names are supported. This"]
    #[doc = "                 may be \\c NULL if the CN need not be verified."]
    #[doc = " \\param flags    The address at which to store the result of the verification."]
    #[doc = "                 If the verification couldn't be completed, the flag value is"]
    #[doc = "                 set to (uint32_t) -1."]
    #[doc = " \\param f_vrfy   The verification callback to use. See the documentation"]
    #[doc = "                 of mbedtls_x509_crt_verify() for more information."]
    #[doc = " \\param p_vrfy   The context to be passed to \\p f_vrfy."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the chain is valid with respect to the"]
    #[doc = "                 passed CN, CAs, CRLs and security profile."]
    #[doc = " \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the"]
    #[doc = "                 certificate chain verification failed. In this case,"]
    #[doc = "                 \\c *flags will have one or more"]
    #[doc = "                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX"]
    #[doc = "                 flags set."]
    #[doc = " \\return         Another negative error code in case of a fatal error"]
    #[doc = "                 encountered during the verification process."]
    pub fn mbedtls_x509_crt_verify(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates with respect to"]
    #[doc = "                 a configurable security profile."]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_x509_crt_verify(), but with explicit"]
    #[doc = "                 security profile."]
    #[doc = ""]
    #[doc = " \\note           The restrictions on keys (RSA minimum size, allowed curves"]
    #[doc = "                 for ECDSA) apply to all certificates: trusted root,"]
    #[doc = "                 intermediate CAs if any, and end entity certificate."]
    #[doc = ""]
    #[doc = " \\param crt      The certificate chain to be verified."]
    #[doc = " \\param trust_ca The list of trusted CAs."]
    #[doc = " \\param ca_crl   The list of CRLs for trusted CAs."]
    #[doc = " \\param profile  The security profile to use for the verification."]
    #[doc = " \\param cn       The expected Common Name. This may be \\c NULL if the"]
    #[doc = "                 CN need not be verified."]
    #[doc = " \\param flags    The address at which to store the result of the verification."]
    #[doc = "                 If the verification couldn't be completed, the flag value is"]
    #[doc = "                 set to (uint32_t) -1."]
    #[doc = " \\param f_vrfy   The verification callback to use. See the documentation"]
    #[doc = "                 of mbedtls_x509_crt_verify() for more information."]
    #[doc = " \\param p_vrfy   The context to be passed to \\p f_vrfy."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the chain is valid with respect to the"]
    #[doc = "                 passed CN, CAs, CRLs and security profile."]
    #[doc = " \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the"]
    #[doc = "                 certificate chain verification failed. In this case,"]
    #[doc = "                 \\c *flags will have one or more"]
    #[doc = "                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX"]
    #[doc = "                 flags set."]
    #[doc = " \\return         Another negative error code in case of a fatal error"]
    #[doc = "                 encountered during the verification process."]
    pub fn mbedtls_x509_crt_verify_with_profile(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Restartable version of \\c mbedtls_crt_verify_with_profile()"]
    #[doc = ""]
    #[doc = " \\note           Performs the same job as \\c mbedtls_crt_verify_with_profile()"]
    #[doc = "                 but can return early and restart according to the limit"]
    #[doc = "                 set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param crt      The certificate chain to be verified."]
    #[doc = " \\param trust_ca The list of trusted CAs."]
    #[doc = " \\param ca_crl   The list of CRLs for trusted CAs."]
    #[doc = " \\param profile  The security profile to use for the verification."]
    #[doc = " \\param cn       The expected Common Name. This may be \\c NULL if the"]
    #[doc = "                 CN need not be verified."]
    #[doc = " \\param flags    The address at which to store the result of the verification."]
    #[doc = "                 If the verification couldn't be completed, the flag value is"]
    #[doc = "                 set to (uint32_t) -1."]
    #[doc = " \\param f_vrfy   The verification callback to use. See the documentation"]
    #[doc = "                 of mbedtls_x509_crt_verify() for more information."]
    #[doc = " \\param p_vrfy   The context to be passed to \\p f_vrfy."]
    #[doc = " \\param rs_ctx   The restart context to use. This may be set to \\c NULL"]
    #[doc = "                 to disable restartable ECC."]
    #[doc = ""]
    #[doc = " \\return         See \\c mbedtls_crt_verify_with_profile(), or"]
    #[doc = " \\return         #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                 operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_x509_crt_verify_restartable(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_x509_crt_restart_ctx,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief               The type of trusted certificate callbacks."]
#[doc = ""]
#[doc = "                      Callbacks of this type are passed to and used by the CRT"]
#[doc = "                      verification routine mbedtls_x509_crt_verify_with_ca_cb()"]
#[doc = "                      when looking for trusted signers of a given certificate."]
#[doc = ""]
#[doc = "                      On success, the callback returns a list of trusted"]
#[doc = "                      certificates to be considered as potential signers"]
#[doc = "                      for the input certificate."]
#[doc = ""]
#[doc = " \\param p_ctx         An opaque context passed to the callback."]
#[doc = " \\param child         The certificate for which to search a potential signer."]
#[doc = "                      This will point to a readable certificate."]
#[doc = " \\param candidate_cas The address at which to store the address of the first"]
#[doc = "                      entry in the generated linked list of candidate signers."]
#[doc = "                      This will not be \\c NULL."]
#[doc = ""]
#[doc = " \\note                The callback must only return a non-zero value on a"]
#[doc = "                      fatal error. If, in contrast, the search for a potential"]
#[doc = "                      signer completes without a single candidate, the"]
#[doc = "                      callback must return \\c 0 and set \\c *candidate_cas"]
#[doc = "                      to \\c NULL."]
#[doc = ""]
#[doc = " \\return              \\c 0 on success. In this case, \\c *candidate_cas points"]
#[doc = "                      to a heap-allocated linked list of instances of"]
#[doc = "                      ::mbedtls_x509_crt, and ownership of this list is passed"]
#[doc = "                      to the caller."]
#[doc = " \\return              A negative error code on failure."]
pub type mbedtls_x509_crt_ca_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::c_types::c_void,
        child: *const mbedtls_x509_crt,
        candidate_cas: *mut *mut mbedtls_x509_crt,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief          Check usage of certificate against keyUsage extension."]
    #[doc = ""]
    #[doc = " \\param crt      Leaf certificate used."]
    #[doc = " \\param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT"]
    #[doc = "                 before using the certificate to perform an RSA key"]
    #[doc = "                 exchange)."]
    #[doc = ""]
    #[doc = " \\note           Except for decipherOnly and encipherOnly, a bit set in the"]
    #[doc = "                 usage argument means this bit MUST be set in the"]
    #[doc = "                 certificate. For decipherOnly and encipherOnly, it means"]
    #[doc = "                 that bit MAY be set."]
    #[doc = ""]
    #[doc = " \\return         0 is these uses of the certificate are allowed,"]
    #[doc = "                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension"]
    #[doc = "                 is present but does not match the usage argument."]
    #[doc = ""]
    #[doc = " \\note           You should only call this function on leaf certificates, on"]
    #[doc = "                 (intermediate) CAs the keyUsage extension is automatically"]
    #[doc = "                 checked by \\c mbedtls_x509_crt_verify()."]
    pub fn mbedtls_x509_crt_check_key_usage(
        crt: *const mbedtls_x509_crt,
        usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check usage of certificate against extendedKeyUsage."]
    #[doc = ""]
    #[doc = " \\param crt       Leaf certificate used."]
    #[doc = " \\param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or"]
    #[doc = "                  MBEDTLS_OID_CLIENT_AUTH)."]
    #[doc = " \\param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE())."]
    #[doc = ""]
    #[doc = " \\return          0 if this use of the certificate is allowed,"]
    #[doc = "                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if not."]
    #[doc = ""]
    #[doc = " \\note            Usually only makes sense on leaf certificates."]
    pub fn mbedtls_x509_crt_check_extended_key_usage(
        crt: *const mbedtls_x509_crt,
        usage_oid: *const crate::c_types::c_char,
        usage_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify the certificate revocation status"]
    #[doc = ""]
    #[doc = " \\param crt      a certificate to be verified"]
    #[doc = " \\param crl      the CRL to verify against"]
    #[doc = ""]
    #[doc = " \\return         1 if the certificate is revoked, 0 otherwise"]
    #[doc = ""]
    pub fn mbedtls_x509_crt_is_revoked(
        crt: *const mbedtls_x509_crt,
        crl: *const mbedtls_x509_crl,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a certificate (chain)"]
    #[doc = ""]
    #[doc = " \\param crt      Certificate chain to initialize"]
    pub fn mbedtls_x509_crt_init(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief          Unallocate all certificate data"]
    #[doc = ""]
    #[doc = " \\param crt      Certificate chain to free"]
    pub fn mbedtls_x509_crt_free(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief           Initialize a CRT writing context"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to initialize"]
    pub fn mbedtls_x509write_crt_init(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Set the version for a Certificate"]
    #[doc = "                  Default: MBEDTLS_X509_CRT_VERSION_3"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or"]
    #[doc = "                                  MBEDTLS_X509_CRT_VERSION_3)"]
    pub fn mbedtls_x509write_crt_set_version(
        ctx: *mut mbedtls_x509write_cert,
        version: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief           Set the serial number for a Certificate."]
    #[doc = ""]
    #[doc = " \\deprecated      This function is deprecated and will be removed in a"]
    #[doc = "                  future version of the library. Please use"]
    #[doc = "                  mbedtls_x509write_crt_set_serial_raw() instead."]
    #[doc = ""]
    #[doc = " \\note            Even though the MBEDTLS_BIGNUM_C guard looks redundant since"]
    #[doc = "                  X509 depends on PK and PK depends on BIGNUM, this emphasizes"]
    #[doc = "                  a direct dependency between X509 and BIGNUM which is going"]
    #[doc = "                  to be deprecated in the future."]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param serial    serial number to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful"]
    pub fn mbedtls_x509write_crt_set_serial(
        ctx: *mut mbedtls_x509write_cert,
        serial: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the serial number for a Certificate."]
    #[doc = ""]
    #[doc = " \\param ctx          CRT context to use"]
    #[doc = " \\param serial       A raw array of bytes containing the serial number in big"]
    #[doc = "                     endian format"]
    #[doc = " \\param serial_len   Length of valid bytes (expressed in bytes) in \\p serial"]
    #[doc = "                     input buffer"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or"]
    #[doc = "                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if the provided input buffer"]
    #[doc = "                  is too big (longer than MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN)"]
    pub fn mbedtls_x509write_crt_set_serial_raw(
        ctx: *mut mbedtls_x509write_cert,
        serial: *mut crate::c_types::c_uchar,
        serial_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the validity period for a Certificate"]
    #[doc = "                  Timestamps should be in string format for UTC timezone"]
    #[doc = "                  i.e. \"YYYYMMDDhhmmss\""]
    #[doc = "                  e.g. \"20131231235959\" for December 31st 2013"]
    #[doc = "                       at 23:59:59"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param not_before    not_before timestamp"]
    #[doc = " \\param not_after     not_after timestamp"]
    #[doc = ""]
    #[doc = " \\return          0 if timestamp was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_validity(
        ctx: *mut mbedtls_x509write_cert,
        not_before: *const crate::c_types::c_char,
        not_after: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the issuer name for a Certificate"]
    #[doc = "                  Issuer names should contain a comma-separated list"]
    #[doc = "                  of OID types and values:"]
    #[doc = "                  e.g. \"C=UK,O=ARM,CN=mbed TLS CA\""]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param issuer_name   issuer name to set"]
    #[doc = ""]
    #[doc = " \\return          0 if issuer name was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_issuer_name(
        ctx: *mut mbedtls_x509write_cert,
        issuer_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject name for a Certificate"]
    #[doc = "                  Subject names should contain a comma-separated list"]
    #[doc = "                  of OID types and values:"]
    #[doc = "                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\""]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param subject_name  subject name to set"]
    #[doc = ""]
    #[doc = " \\return          0 if subject name was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_subject_name(
        ctx: *mut mbedtls_x509write_cert,
        subject_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject public key for the certificate"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key       public key to include"]
    pub fn mbedtls_x509write_crt_set_subject_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the issuer key used for signing the certificate"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key       private key to sign with"]
    pub fn mbedtls_x509write_crt_set_issuer_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the MD algorithm to use for the signature"]
    #[doc = "                  (e.g. MBEDTLS_MD_SHA1)"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param md_alg    MD algorithm to use"]
    pub fn mbedtls_x509write_crt_set_md_alg(
        ctx: *mut mbedtls_x509write_cert,
        md_alg: mbedtls_md_type_t,
    );
}
extern "C" {
    #[doc = " \\brief           Generic function to add to or replace an extension in the"]
    #[doc = "                  CRT"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param oid       OID of the extension"]
    #[doc = " \\param oid_len   length of the OID"]
    #[doc = " \\param critical  if the extension is critical (per the RFC's definition)"]
    #[doc = " \\param val       value of the extension OCTET STRING"]
    #[doc = " \\param val_len   length of the value data"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_extension(
        ctx: *mut mbedtls_x509write_cert,
        oid: *const crate::c_types::c_char,
        oid_len: size_t,
        critical: crate::c_types::c_int,
        val: *const crate::c_types::c_uchar,
        val_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the basicConstraints extension for a CRT"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param is_ca     is this a CA certificate"]
    #[doc = " \\param max_pathlen   maximum length of certificate chains below this"]
    #[doc = "                      certificate (only for CA certificates, -1 is"]
    #[doc = "                      unlimited)"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_basic_constraints(
        ctx: *mut mbedtls_x509write_cert,
        is_ca: crate::c_types::c_int,
        max_pathlen: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subjectKeyIdentifier extension for a CRT"]
    #[doc = "                  Requires that mbedtls_x509write_crt_set_subject_key() has been"]
    #[doc = "                  called before"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_subject_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the authorityKeyIdentifier extension for a CRT"]
    #[doc = "                  Requires that mbedtls_x509write_crt_set_issuer_key() has been"]
    #[doc = "                  called before"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_authority_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Key Usage Extension flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key_usage key usage flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        key_usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Extended Key Usage Extension"]
    #[doc = "                  (e.g. MBEDTLS_OID_SERVER_AUTH)"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param exts      extended key usage extensions to set, a sequence of"]
    #[doc = "                  MBEDTLS_ASN1_OID objects"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_ext_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        exts: *const mbedtls_asn1_sequence,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Netscape Cert Type flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)"]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param ns_cert_type  Netscape Cert Type flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_ns_cert_type(
        ctx: *mut mbedtls_x509write_cert,
        ns_cert_type: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Free the contents of a CRT write context"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to free"]
    pub fn mbedtls_x509write_crt_free(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       certificate to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    #[doc = ""]
    #[doc = " \\note            \\p f_rng is used for the signature operation."]
    pub fn mbedtls_x509write_crt_der(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut crate::c_types::c_uchar,
        size: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       certificate to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    #[doc = ""]
    #[doc = " \\note            \\p f_rng is used for the signature operation."]
    pub fn mbedtls_x509write_crt_pem(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut crate::c_types::c_uchar,
        size: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
#[doc = "<  The prime modulus."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_P: mbedtls_dhm_parameter = 0;
#[doc = "<  The generator."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_G: mbedtls_dhm_parameter = 1;
#[doc = "<  Our secret value."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_X: mbedtls_dhm_parameter = 2;
#[doc = "<  Our public key = \\c G^X mod \\c P."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_GX: mbedtls_dhm_parameter = 3;
#[doc = "<  The public key of the peer = \\c G^Y mod \\c P."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_GY: mbedtls_dhm_parameter = 4;
#[doc = "<  The shared secret = \\c G^(XY) mod \\c P."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_K: mbedtls_dhm_parameter = 5;
#[doc = " Which parameter to access in mbedtls_dhm_get_value()."]
pub type mbedtls_dhm_parameter = crate::c_types::c_uint;
#[doc = " \\brief          The DHM context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_dhm_context {
    pub private_P: mbedtls_mpi,
    pub private_G: mbedtls_mpi,
    pub private_X: mbedtls_mpi,
    pub private_GX: mbedtls_mpi,
    pub private_GY: mbedtls_mpi,
    pub private_K: mbedtls_mpi,
    pub private_RP: mbedtls_mpi,
    pub private_Vi: mbedtls_mpi,
    pub private_Vf: mbedtls_mpi,
    pub private_pX: mbedtls_mpi,
}
extern "C" {
    #[doc = " \\brief          This function initializes the DHM context."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to initialize."]
    pub fn mbedtls_dhm_init(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    #[doc = " \\brief          This function parses the DHM parameters in a"]
    #[doc = "                 TLS ServerKeyExchange handshake message"]
    #[doc = "                 (DHM modulus, generator, and public key)."]
    #[doc = ""]
    #[doc = " \\note           In a TLS handshake, this is the how the client"]
    #[doc = "                 sets up its DHM context from the server's public"]
    #[doc = "                 DHM key material."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized."]
    #[doc = " \\param p        On input, *p must be the start of the input buffer."]
    #[doc = "                 On output, *p is updated to point to the end of the data"]
    #[doc = "                 that has been read. On success, this is the first byte"]
    #[doc = "                 past the end of the ServerKeyExchange parameters."]
    #[doc = "                 On error, this is the point at which an error has been"]
    #[doc = "                 detected, which is usually not useful except to debug"]
    #[doc = "                 failures."]
    #[doc = " \\param end      The end of the input buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_read_params(
        ctx: *mut mbedtls_dhm_context,
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates a DHM key pair and exports its"]
    #[doc = "                 public part together with the DHM parameters in the format"]
    #[doc = "                 used in a TLS ServerKeyExchange handshake message."]
    #[doc = ""]
    #[doc = " \\note           This function assumes that the DHM parameters \\c ctx->P"]
    #[doc = "                 and \\c ctx->G have already been properly set. For that, use"]
    #[doc = "                 mbedtls_dhm_set_group() below in conjunction with"]
    #[doc = "                 mbedtls_mpi_read_binary() and mbedtls_mpi_read_string()."]
    #[doc = ""]
    #[doc = " \\note           In a TLS handshake, this is the how the server generates"]
    #[doc = "                 and exports its DHM key material."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized"]
    #[doc = "                 and have the DHM parameters set. It may or may not"]
    #[doc = "                 already have imported the peer's public key."]
    #[doc = " \\param x_size   The private key size in Bytes."]
    #[doc = " \\param olen     The address at which to store the number of Bytes"]
    #[doc = "                 written on success. This must not be \\c NULL."]
    #[doc = " \\param output   The destination buffer. This must be a writable buffer of"]
    #[doc = "                 sufficient size to hold the reduced binary presentation of"]
    #[doc = "                 the modulus, the generator and the public key, each wrapped"]
    #[doc = "                 with a 2-byte length field. It is the responsibility of the"]
    #[doc = "                 caller to ensure that enough space is available. Refer to"]
    #[doc = "                 mbedtls_mpi_size() to computing the byte-size of an MPI."]
    #[doc = " \\param f_rng    The RNG function. Must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_make_params(
        ctx: *mut mbedtls_dhm_context,
        x_size: crate::c_types::c_int,
        output: *mut crate::c_types::c_uchar,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the prime modulus and generator."]
    #[doc = ""]
    #[doc = " \\note           This function can be used to set \\c ctx->P, \\c ctx->G"]
    #[doc = "                 in preparation for mbedtls_dhm_make_params()."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to configure. This must be initialized."]
    #[doc = " \\param P        The MPI holding the DHM prime modulus. This must be"]
    #[doc = "                 an initialized MPI."]
    #[doc = " \\param G        The MPI holding the DHM generator. This must be an"]
    #[doc = "                 initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_set_group(
        ctx: *mut mbedtls_dhm_context,
        P: *const mbedtls_mpi,
        G: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports the raw public value of the peer."]
    #[doc = ""]
    #[doc = " \\note           In a TLS handshake, this is the how the server imports"]
    #[doc = "                 the Client's public DHM key."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized and have"]
    #[doc = "                 its DHM parameters set, e.g. via mbedtls_dhm_set_group()."]
    #[doc = "                 It may or may not already have generated its own private key."]
    #[doc = " \\param input    The input buffer containing the \\c G^Y value of the peer."]
    #[doc = "                 This must be a readable buffer of size \\p ilen Bytes."]
    #[doc = " \\param ilen     The size of the input buffer \\p input in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_read_public(
        ctx: *mut mbedtls_dhm_context,
        input: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function creates a DHM key pair and exports"]
    #[doc = "                 the raw public key in big-endian format."]
    #[doc = ""]
    #[doc = " \\note           The destination buffer is always fully written"]
    #[doc = "                 so as to contain a big-endian representation of G^X mod P."]
    #[doc = "                 If it is larger than \\c ctx->len, it is padded accordingly"]
    #[doc = "                 with zero-bytes at the beginning."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized and"]
    #[doc = "                 have the DHM parameters set. It may or may not already"]
    #[doc = "                 have imported the peer's public key."]
    #[doc = " \\param x_size   The private key size in Bytes."]
    #[doc = " \\param output   The destination buffer. This must be a writable buffer of"]
    #[doc = "                 size \\p olen Bytes."]
    #[doc = " \\param olen     The length of the destination buffer. This must be at least"]
    #[doc = "                 equal to `ctx->len` (the size of \\c P)."]
    #[doc = " \\param f_rng    The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_make_public(
        ctx: *mut mbedtls_dhm_context,
        x_size: crate::c_types::c_int,
        output: *mut crate::c_types::c_uchar,
        olen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function derives and exports the shared secret"]
    #[doc = "                 \\c (G^Y)^X mod \\c P."]
    #[doc = ""]
    #[doc = " \\note           If \\p f_rng is not \\c NULL, it is used to blind the input as"]
    #[doc = "                 a countermeasure against timing attacks. Blinding is used"]
    #[doc = "                 only if our private key \\c X is re-used, and not used"]
    #[doc = "                 otherwise. We recommend always passing a non-NULL"]
    #[doc = "                 \\p f_rng argument."]
    #[doc = ""]
    #[doc = " \\param ctx           The DHM context to use. This must be initialized"]
    #[doc = "                      and have its own private key generated and the peer's"]
    #[doc = "                      public key imported."]
    #[doc = " \\param output        The buffer to write the generated shared key to. This"]
    #[doc = "                      must be a writable buffer of size \\p output_size Bytes."]
    #[doc = " \\param output_size   The size of the destination buffer. This must be at"]
    #[doc = "                      least the size of \\c ctx->len (the size of \\c P)."]
    #[doc = " \\param olen          On exit, holds the actual number of Bytes written."]
    #[doc = " \\param f_rng         The RNG function. Must not be \\c NULL. Used for"]
    #[doc = "                      blinding."]
    #[doc = " \\param p_rng         The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                      \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_calc_secret(
        ctx: *mut mbedtls_dhm_context,
        output: *mut crate::c_types::c_uchar,
        output_size: size_t,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function returns the size of the prime modulus in bits."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to query."]
    #[doc = ""]
    #[doc = " \\return         The size of the prime modulus in bits,"]
    #[doc = "                 i.e. the number n such that 2^(n-1) <= P < 2^n."]
    pub fn mbedtls_dhm_get_bitlen(ctx: *const mbedtls_dhm_context) -> size_t;
}
extern "C" {
    #[doc = " \\brief          This function returns the size of the prime modulus in bytes."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to query."]
    #[doc = ""]
    #[doc = " \\return         The size of the prime modulus in bytes,"]
    #[doc = "                 i.e. the number n such that 2^(8*(n-1)) <= P < 2^(8*n)."]
    pub fn mbedtls_dhm_get_len(ctx: *const mbedtls_dhm_context) -> size_t;
}
extern "C" {
    #[doc = " \\brief          This function copies a parameter of a DHM key."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to query."]
    #[doc = " \\param param    The parameter to copy."]
    #[doc = " \\param dest     The MPI object to copy the value into. It must be"]
    #[doc = "                 initialized."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_DHM_BAD_INPUT_DATA if \\p field is invalid."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_MPI_XXX error code if the copy fails."]
    pub fn mbedtls_dhm_get_value(
        ctx: *const mbedtls_dhm_context,
        param: mbedtls_dhm_parameter,
        dest: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees and clears the components"]
    #[doc = "                 of a DHM context."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to free and clear. This may be \\c NULL,"]
    #[doc = "                 in which case this function is a no-op. If it is not \\c NULL,"]
    #[doc = "                 it must point to an initialized DHM context."]
    pub fn mbedtls_dhm_free(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    #[doc = " \\brief             This function parses DHM parameters in PEM or DER format."]
    #[doc = ""]
    #[doc = " \\param dhm         The DHM context to import the DHM parameters into."]
    #[doc = "                    This must be initialized."]
    #[doc = " \\param dhmin       The input buffer. This must be a readable buffer of"]
    #[doc = "                    length \\p dhminlen Bytes."]
    #[doc = " \\param dhminlen    The size of the input buffer \\p dhmin, including the"]
    #[doc = "                    terminating \\c NULL Byte for PEM data."]
    #[doc = ""]
    #[doc = " \\return            \\c 0 on success."]
    #[doc = " \\return            An \\c MBEDTLS_ERR_DHM_XXX or \\c MBEDTLS_ERR_PEM_XXX error"]
    #[doc = "                    code on failure."]
    pub fn mbedtls_dhm_parse_dhm(
        dhm: *mut mbedtls_dhm_context,
        dhmin: *const crate::c_types::c_uchar,
        dhminlen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The DMH checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_dhm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< Our key."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_OURS: mbedtls_ecdh_side = 0;
#[doc = "< The key of the peer."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_THEIRS: mbedtls_ecdh_side = 1;
#[doc = " Defines the source of the imported EC key."]
pub type mbedtls_ecdh_side = crate::c_types::c_uint;
#[doc = "< Implementation not defined."]
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_NONE: mbedtls_ecdh_variant = 0;
#[doc = "< The default Mbed TLS implementation"]
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0: mbedtls_ecdh_variant = 1;
#[doc = " Defines the ECDH implementation used."]
#[doc = ""]
#[doc = " Later versions of the library may add new variants, therefore users should"]
#[doc = " not make any assumptions about them."]
pub type mbedtls_ecdh_variant = crate::c_types::c_uint;
#[doc = " The context used by the default ECDH implementation."]
#[doc = ""]
#[doc = " Later versions might change the structure of this context, therefore users"]
#[doc = " should not make any assumptions about the structure of"]
#[doc = " mbedtls_ecdh_context_mbed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecdh_context_mbed {
    pub private_grp: mbedtls_ecp_group,
    pub private_d: mbedtls_mpi,
    pub private_Q: mbedtls_ecp_point,
    pub private_Qp: mbedtls_ecp_point,
    pub private_z: mbedtls_mpi,
}
#[doc = " \\warning         Performing multiple operations concurrently on the same"]
#[doc = "                  ECDSA context is not supported; objects of this type"]
#[doc = "                  should not be shared between multiple threads."]
#[doc = " \\brief           The ECDH context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecdh_context {
    pub private_point_format: u8,
    pub private_grp_id: mbedtls_ecp_group_id,
    pub private_var: mbedtls_ecdh_variant,
    pub private_ctx: mbedtls_ecdh_context__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ecdh_context__bindgen_ty_1 {
    pub private_mbed_ecdh: mbedtls_ecdh_context_mbed,
}
extern "C" {
    #[doc = " \\brief          Check whether a given group can be used for ECDH."]
    #[doc = ""]
    #[doc = " \\param gid      The ECP group ID to check."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    pub fn mbedtls_ecdh_can_do(gid: mbedtls_ecp_group_id) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECDH keypair on an elliptic"]
    #[doc = "                  curve."]
    #[doc = ""]
    #[doc = "                  This function performs the first of two core computations"]
    #[doc = "                  implemented during the ECDH key exchange. The second core"]
    #[doc = "                  computation is performed by mbedtls_ecdh_compute_shared()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use. This must be initialized and have"]
    #[doc = "                  domain parameters loaded, for example through"]
    #[doc = "                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group()."]
    #[doc = " \\param d         The destination MPI (private key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The destination point (public key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL in case \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX or"]
    #[doc = "                  \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdh_gen_public(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the shared secret."]
    #[doc = ""]
    #[doc = "                  This function performs the second of two core computations"]
    #[doc = "                  implemented during the ECDH key exchange. The first core"]
    #[doc = "                  computation is performed by mbedtls_ecdh_gen_public()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to implement"]
    #[doc = "                  countermeasures against side-channel attacks."]
    #[doc = "                  For more information, see mbedtls_ecp_mul()."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use. This must be initialized and have"]
    #[doc = "                  domain parameters loaded, for example through"]
    #[doc = "                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group()."]
    #[doc = " \\param z         The destination MPI (shared secret)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The public key from another party."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param d         Our secret exponent (private key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng is \\c NULL or doesn't need a"]
    #[doc = "                  context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX or"]
    #[doc = "                  \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdh_compute_shared(
        grp: *mut mbedtls_ecp_group,
        z: *mut mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        d: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDH context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_ecdh_init(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function sets up the ECDH context with the information"]
    #[doc = "                  given."]
    #[doc = ""]
    #[doc = "                  This function should be called after mbedtls_ecdh_init() but"]
    #[doc = "                  before mbedtls_ecdh_make_params(). There is no need to call"]
    #[doc = "                  this function before mbedtls_ecdh_read_params()."]
    #[doc = ""]
    #[doc = "                  This is the first function used by a TLS server for ECDHE"]
    #[doc = "                  ciphersuites."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to set up. This must be initialized."]
    #[doc = " \\param grp_id    The group id of the group to set up the context for."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_ecdh_setup(
        ctx: *mut mbedtls_ecdh_context,
        grp_id: mbedtls_ecp_group_id,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function frees a context."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to free. This may be \\c NULL, in which"]
    #[doc = "                  case this function does nothing. If it is not \\c NULL,"]
    #[doc = "                  it must point to an initialized ECDH context."]
    pub fn mbedtls_ecdh_free(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function generates an EC key pair and exports its"]
    #[doc = "                  in the format used in a TLS ServerKeyExchange handshake"]
    #[doc = "                  message."]
    #[doc = ""]
    #[doc = "                  This is the second function used by a TLS server for ECDHE"]
    #[doc = "                  ciphersuites. (It is called after mbedtls_ecdh_setup().)"]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to use. This must be initialized"]
    #[doc = "                  and bound to a group, for example via mbedtls_ecdh_setup()."]
    #[doc = " \\param olen      The address at which to store the number of Bytes written."]
    #[doc = " \\param buf       The destination buffer. This must be a writable buffer of"]
    #[doc = "                  length \\p blen Bytes."]
    #[doc = " \\param blen      The length of the destination buffer \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL in case \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_params(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut size_t,
        buf: *mut crate::c_types::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function parses the ECDHE parameters in a"]
    #[doc = "                  TLS ServerKeyExchange handshake message."]
    #[doc = ""]
    #[doc = " \\note            In a TLS handshake, this is the how the client"]
    #[doc = "                  sets up its ECDHE context from the server's public"]
    #[doc = "                  ECDHE key material."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDHE context to use. This must be initialized."]
    #[doc = " \\param buf       On input, \\c *buf must be the start of the input buffer."]
    #[doc = "                  On output, \\c *buf is updated to point to the end of the"]
    #[doc = "                  data that has been read. On success, this is the first byte"]
    #[doc = "                  past the end of the ServerKeyExchange parameters."]
    #[doc = "                  On error, this is the point at which an error has been"]
    #[doc = "                  detected, which is usually not useful except to debug"]
    #[doc = "                  failures."]
    #[doc = " \\param end       The end of the input buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_ecdh_read_params(
        ctx: *mut mbedtls_ecdh_context,
        buf: *mut *const crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDH context from an EC key."]
    #[doc = ""]
    #[doc = "                  It is used by clients and servers in place of the"]
    #[doc = "                  ServerKeyEchange for static ECDH, and imports ECDH"]
    #[doc = "                  parameters from the EC key information of a certificate."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to set up. This must be initialized."]
    #[doc = " \\param key       The EC key to use. This must be initialized."]
    #[doc = " \\param side      Defines the source of the key. Possible values are:"]
    #[doc = "                  - #MBEDTLS_ECDH_OURS: The key is ours."]
    #[doc = "                  - #MBEDTLS_ECDH_THEIRS: The key is that of the peer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_ecdh_get_params(
        ctx: *mut mbedtls_ecdh_context,
        key: *const mbedtls_ecp_keypair,
        side: mbedtls_ecdh_side,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a public key and exports it"]
    #[doc = "                  as a TLS ClientKeyExchange payload."]
    #[doc = ""]
    #[doc = "                  This is the second function used by a TLS client for ECDH(E)"]
    #[doc = "                  ciphersuites."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to use. This must be initialized"]
    #[doc = "                  and bound to a group, the latter usually by"]
    #[doc = "                  mbedtls_ecdh_read_params()."]
    #[doc = " \\param olen      The address at which to store the number of Bytes written."]
    #[doc = "                  This must not be \\c NULL."]
    #[doc = " \\param buf       The destination buffer. This must be a writable buffer"]
    #[doc = "                  of length \\p blen Bytes."]
    #[doc = " \\param blen      The size of the destination buffer \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL in case \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_public(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut size_t,
        buf: *mut crate::c_types::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       This function parses and processes the ECDHE payload of a"]
    #[doc = "              TLS ClientKeyExchange message."]
    #[doc = ""]
    #[doc = "              This is the third function used by a TLS server for ECDH(E)"]
    #[doc = "              ciphersuites. (It is called after mbedtls_ecdh_setup() and"]
    #[doc = "              mbedtls_ecdh_make_params().)"]
    #[doc = ""]
    #[doc = " \\see         ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx   The ECDH context to use. This must be initialized"]
    #[doc = "              and bound to a group, for example via mbedtls_ecdh_setup()."]
    #[doc = " \\param buf   The pointer to the ClientKeyExchange payload. This must"]
    #[doc = "              be a readable buffer of length \\p blen Bytes."]
    #[doc = " \\param blen  The length of the input buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return      \\c 0 on success."]
    #[doc = " \\return      An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_read_public(
        ctx: *mut mbedtls_ecdh_context,
        buf: *const crate::c_types::c_uchar,
        blen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function derives and exports the shared secret."]
    #[doc = ""]
    #[doc = "                  This is the last function used by both TLS client"]
    #[doc = "                  and servers."]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to implement"]
    #[doc = "                  countermeasures against side-channel attacks."]
    #[doc = "                  For more information, see mbedtls_ecp_mul()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to use. This must be initialized"]
    #[doc = "                  and have its own private key generated and the peer's"]
    #[doc = "                  public key imported."]
    #[doc = " \\param olen      The address at which to store the total number of"]
    #[doc = "                  Bytes written on success. This must not be \\c NULL."]
    #[doc = " \\param buf       The buffer to write the generated shared key to. This"]
    #[doc = "                  must be a writable buffer of size \\p blen Bytes."]
    #[doc = " \\param blen      The length of the destination buffer \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context. This may be \\c NULL if \\p f_rng"]
    #[doc = "                  doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_calc_secret(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut size_t,
        buf: *mut crate::c_types::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_premaster_secret {
    pub _pms_rsa: [crate::c_types::c_uchar; 48usize],
    pub _pms_dhm: [crate::c_types::c_uchar; 1024usize],
    pub _pms_ecdh: [crate::c_types::c_uchar; 66usize],
    pub _pms_psk: [crate::c_types::c_uchar; 100usize],
    pub _pms_dhe_psk: [crate::c_types::c_uchar; 1076usize],
    pub _pms_rsa_psk: [crate::c_types::c_uchar; 100usize],
    pub _pms_ecdhe_psk: [crate::c_types::c_uchar; 118usize],
}
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_REQUEST: mbedtls_ssl_states = 0;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_HELLO: mbedtls_ssl_states = 1;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO: mbedtls_ssl_states = 2;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CERTIFICATE: mbedtls_ssl_states = 3;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_KEY_EXCHANGE: mbedtls_ssl_states = 4;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_REQUEST: mbedtls_ssl_states = 5;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_DONE: mbedtls_ssl_states = 6;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE: mbedtls_ssl_states = 7;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_KEY_EXCHANGE: mbedtls_ssl_states = 8;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_VERIFY: mbedtls_ssl_states = 9;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 10;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_FINISHED: mbedtls_ssl_states = 11;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 12;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_FINISHED: mbedtls_ssl_states = 13;
pub const mbedtls_ssl_states_MBEDTLS_SSL_FLUSH_BUFFERS: mbedtls_ssl_states = 14;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_WRAPUP: mbedtls_ssl_states = 15;
pub const mbedtls_ssl_states_MBEDTLS_SSL_NEW_SESSION_TICKET: mbedtls_ssl_states = 16;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: mbedtls_ssl_states = 17;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_RETRY_REQUEST: mbedtls_ssl_states = 18;
pub const mbedtls_ssl_states_MBEDTLS_SSL_ENCRYPTED_EXTENSIONS: mbedtls_ssl_states = 19;
pub const mbedtls_ssl_states_MBEDTLS_SSL_END_OF_EARLY_DATA: mbedtls_ssl_states = 20;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY: mbedtls_ssl_states = 21;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED: mbedtls_ssl_states = 22;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO: mbedtls_ssl_states =
    23;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO: mbedtls_ssl_states = 24;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO: mbedtls_ssl_states = 25;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST: mbedtls_ssl_states =
    26;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_OVER: mbedtls_ssl_states = 27;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET: mbedtls_ssl_states = 28;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH: mbedtls_ssl_states = 29;
pub type mbedtls_ssl_states = crate::c_types::c_uint;
#[doc = " \\brief          Callback type: send data on the network."]
#[doc = ""]
#[doc = " \\note           That callback may be either blocking or non-blocking."]
#[doc = ""]
#[doc = " \\param ctx      Context for the send callback (typically a file descriptor)"]
#[doc = " \\param buf      Buffer holding the data to send"]
#[doc = " \\param len      Length of the data to send"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes sent if any,"]
#[doc = "                 or a non-zero error code."]
#[doc = "                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_WRITE"]
#[doc = "                 must be returned when the operation would block."]
#[doc = ""]
#[doc = " \\note           The callback is allowed to send fewer bytes than requested."]
#[doc = "                 It must always return the number of bytes actually sent."]
pub type mbedtls_ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network."]
#[doc = ""]
#[doc = " \\note           That callback may be either blocking or non-blocking."]
#[doc = ""]
#[doc = " \\param ctx      Context for the receive callback (typically a file"]
#[doc = "                 descriptor)"]
#[doc = " \\param buf      Buffer to write the received data to"]
#[doc = " \\param len      Length of the receive buffer"]
#[doc = ""]
#[doc = " \\returns        If data has been received, the positive number of bytes received."]
#[doc = " \\returns        \\c 0 if the connection has been closed."]
#[doc = " \\returns        If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_READ"]
#[doc = "                 must be returned when the operation would block."]
#[doc = " \\returns        Another negative error code on other kinds of failures."]
#[doc = ""]
#[doc = " \\note           The callback may receive fewer bytes than the length of the"]
#[doc = "                 buffer. It must always return the number of bytes actually"]
#[doc = "                 received and written to the buffer."]
pub type mbedtls_ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network, with timeout"]
#[doc = ""]
#[doc = " \\note           That callback must block until data is received, or the"]
#[doc = "                 timeout delay expires, or the operation is interrupted by a"]
#[doc = "                 signal."]
#[doc = ""]
#[doc = " \\param ctx      Context for the receive callback (typically a file descriptor)"]
#[doc = " \\param buf      Buffer to write the received data to"]
#[doc = " \\param len      Length of the receive buffer"]
#[doc = " \\param timeout  Maximum number of milliseconds to wait for data"]
#[doc = "                 0 means no timeout (potentially waiting forever)"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes received,"]
#[doc = "                 or a non-zero error code:"]
#[doc = "                 \\c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,"]
#[doc = "                 \\c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal."]
#[doc = ""]
#[doc = " \\note           The callback may receive fewer bytes than the length of the"]
#[doc = "                 buffer. It must always return the number of bytes actually"]
#[doc = "                 received and written to the buffer."]
pub type mbedtls_ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
        timeout: u32,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: set a pair of timers/delays to watch"]
#[doc = ""]
#[doc = " \\param ctx      Context pointer"]
#[doc = " \\param int_ms   Intermediate delay in milliseconds"]
#[doc = " \\param fin_ms   Final delay in milliseconds"]
#[doc = "                 0 cancels the current timer."]
#[doc = ""]
#[doc = " \\note           This callback must at least store the necessary information"]
#[doc = "                 for the associated \\c mbedtls_ssl_get_timer_t callback to"]
#[doc = "                 return correct information."]
#[doc = ""]
#[doc = " \\note           If using an event-driven style of programming, an event must"]
#[doc = "                 be generated when the final delay is passed. The event must"]
#[doc = "                 cause a call to \\c mbedtls_ssl_handshake() with the proper"]
#[doc = "                 SSL context to be scheduled. Care must be taken to ensure"]
#[doc = "                 that at most one such call happens at a time."]
#[doc = ""]
#[doc = " \\note           Only one timer at a time must be running. Calling this"]
#[doc = "                 function while a timer is running must cancel it. Cancelled"]
#[doc = "                 timers must not generate any event."]
pub type mbedtls_ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void, int_ms: u32, fin_ms: u32),
>;
#[doc = " \\brief          Callback type: get status of timers/delays"]
#[doc = ""]
#[doc = " \\param ctx      Context pointer"]
#[doc = ""]
#[doc = " \\return         This callback must return:"]
#[doc = "                 -1 if cancelled (fin_ms == 0),"]
#[doc = "                  0 if none of the delays have passed,"]
#[doc = "                  1 if only the intermediate delay has passed,"]
#[doc = "                  2 if the final delay has passed."]
pub type mbedtls_ssl_get_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_transform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_handshake_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_sig_hash_set_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_key_cert {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_flight_item {
    _unused: [u8; 0],
}
#[doc = " \\brief          Callback type: server-side session cache getter"]
#[doc = ""]
#[doc = "                 The session cache is logically a key value store, with"]
#[doc = "                 keys being session IDs and values being instances of"]
#[doc = "                 mbedtls_ssl_session."]
#[doc = ""]
#[doc = "                 This callback retrieves an entry in this key-value store."]
#[doc = ""]
#[doc = " \\param data            The address of the session cache structure to query."]
#[doc = " \\param session_id      The buffer holding the session ID to query."]
#[doc = " \\param session_id_len  The length of \\p session_id in Bytes."]
#[doc = " \\param session         The address of the session structure to populate."]
#[doc = "                        It is initialized with mbdtls_ssl_session_init(),"]
#[doc = "                        and the callback must always leave it in a state"]
#[doc = "                        where it can safely be freed via"]
#[doc = "                        mbedtls_ssl_session_free() independent of the"]
#[doc = "                        return code of this function."]
#[doc = ""]
#[doc = " \\return                \\c 0 on success"]
#[doc = " \\return                A non-zero return value on failure."]
#[doc = ""]
pub type mbedtls_ssl_cache_get_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        session_id: *const crate::c_types::c_uchar,
        session_id_len: size_t,
        session: *mut mbedtls_ssl_session,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: server-side session cache setter"]
#[doc = ""]
#[doc = "                 The session cache is logically a key value store, with"]
#[doc = "                 keys being session IDs and values being instances of"]
#[doc = "                 mbedtls_ssl_session."]
#[doc = ""]
#[doc = "                 This callback sets an entry in this key-value store."]
#[doc = ""]
#[doc = " \\param data            The address of the session cache structure to modify."]
#[doc = " \\param session_id      The buffer holding the session ID to query."]
#[doc = " \\param session_id_len  The length of \\p session_id in Bytes."]
#[doc = " \\param session         The address of the session to be stored in the"]
#[doc = "                        session cache."]
#[doc = ""]
#[doc = " \\return                \\c 0 on success"]
#[doc = " \\return                A non-zero return value on failure."]
pub type mbedtls_ssl_cache_set_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        session_id: *const crate::c_types::c_uchar,
        session_id_len: size_t,
        session: *const mbedtls_ssl_session,
    ) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_tls13_application_secrets {
    pub client_application_traffic_secret_N: [crate::c_types::c_uchar; 64usize],
    pub server_application_traffic_secret_N: [crate::c_types::c_uchar; 64usize],
    pub exporter_master_secret: [crate::c_types::c_uchar; 64usize],
    pub resumption_master_secret: [crate::c_types::c_uchar; 64usize],
}
#[doc = "< Context not in use or version not yet negotiated."]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_UNKNOWN: mbedtls_ssl_protocol_version =
    0;
#[doc = "< (D)TLS 1.2"]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_2: mbedtls_ssl_protocol_version =
    771;
#[doc = "< (D)TLS 1.3"]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_3: mbedtls_ssl_protocol_version =
    772;
#[doc = " Human-friendly representation of the (D)TLS protocol version."]
pub type mbedtls_ssl_protocol_version = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_session {
    pub private_mfl_code: crate::c_types::c_uchar,
    pub private_exported: crate::c_types::c_uchar,
    pub private_tls_version: mbedtls_ssl_protocol_version,
    pub private_ciphersuite: crate::c_types::c_int,
    pub private_id_len: size_t,
    pub private_id: [crate::c_types::c_uchar; 32usize],
    pub private_master: [crate::c_types::c_uchar; 48usize],
    pub private_peer_cert: *mut mbedtls_x509_crt,
    pub private_verify_result: u32,
    pub private_ticket: *mut crate::c_types::c_uchar,
    pub private_ticket_len: size_t,
    pub private_ticket_lifetime: u32,
    pub private_endpoint: u8,
    pub private_ticket_flags: u8,
    pub private_ticket_age_add: u32,
    pub private_resumption_key_len: u8,
    pub private_resumption_key: [crate::c_types::c_uchar; 48usize],
    pub private_hostname: *mut crate::c_types::c_char,
    pub private_encrypt_then_mac: crate::c_types::c_int,
    pub private_app_secrets: mbedtls_ssl_tls13_application_secrets,
}
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_NONE: mbedtls_tls_prf_types = 0;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA384: mbedtls_tls_prf_types = 1;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA256: mbedtls_tls_prf_types = 2;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA384: mbedtls_tls_prf_types = 3;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA256: mbedtls_tls_prf_types = 4;
pub type mbedtls_tls_prf_types = crate::c_types::c_uint;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET:
    mbedtls_ssl_key_export_type = 0;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_EARLY_SECRET:
    mbedtls_ssl_key_export_type = 1;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_EARLY_EXPORTER_SECRET:
    mbedtls_ssl_key_export_type = 2;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_HANDSHAKE_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 3 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_HANDSHAKE_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 4 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_APPLICATION_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 5 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_APPLICATION_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 6 ;
pub type mbedtls_ssl_key_export_type = crate::c_types::c_uint;
#[doc = " \\brief           Callback type: Export key alongside random values for"]
#[doc = "                                 session identification, and PRF for"]
#[doc = "                                 implementation of TLS key exporters."]
#[doc = ""]
#[doc = " \\param p_expkey   Context for the callback."]
#[doc = " \\param type       The type of the key that is being exported."]
#[doc = " \\param secret     The address of the buffer holding the secret"]
#[doc = "                   that's being exporterd."]
#[doc = " \\param secret_len The length of \\p secret in bytes."]
#[doc = " \\param client_random The client random bytes."]
#[doc = " \\param server_random The server random bytes."]
#[doc = " \\param tls_prf_type The identifier for the PRF used in the handshake"]
#[doc = "                     to which the key belongs."]
pub type mbedtls_ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut crate::c_types::c_void,
        type_: mbedtls_ssl_key_export_type,
        secret: *const crate::c_types::c_uchar,
        secret_len: size_t,
        client_random: *const crate::c_types::c_uchar,
        server_random: *const crate::c_types::c_uchar,
        tls_prf_type: mbedtls_tls_prf_types,
    ),
>;
#[doc = " \\brief           Callback type: generic handshake callback"]
#[doc = ""]
#[doc = " \\note            Callbacks may use user_data funcs to set/get app user data."]
#[doc = "                  See \\c mbedtls_ssl_get_user_data_p()"]
#[doc = "                      \\c mbedtls_ssl_get_user_data_n()"]
#[doc = "                      \\c mbedtls_ssl_conf_get_user_data_p()"]
#[doc = "                      \\c mbedtls_ssl_conf_get_user_data_n()"]
#[doc = ""]
#[doc = " \\param ssl       \\c mbedtls_ssl_context on which the callback is run"]
#[doc = ""]
#[doc = " \\return          The return value of the callback is 0 if successful,"]
#[doc = "                  or a specific MBEDTLS_ERR_XXX code, which will cause"]
#[doc = "                  the handshake to be aborted."]
pub type mbedtls_ssl_hs_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_user_data_t {
    pub n: usize,
    pub p: *mut crate::c_types::c_void,
}
#[doc = " SSL/TLS configuration to be shared between mbedtls_ssl_context structures."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_config {
    pub private_max_tls_version: mbedtls_ssl_protocol_version,
    pub private_min_tls_version: mbedtls_ssl_protocol_version,
    pub private_endpoint: u8,
    pub private_transport: u8,
    pub private_authmode: u8,
    pub private_allow_legacy_renegotiation: u8,
    pub private_mfl_code: u8,
    pub private_encrypt_then_mac: u8,
    pub private_extended_ms: u8,
    pub private_anti_replay: u8,
    pub private_disable_renegotiation: u8,
    pub private_session_tickets: u8,
    pub private_new_session_tickets_count: u16,
    pub private_cert_req_ca_list: u8,
    pub private_respect_cli_pref: u8,
    pub private_ignore_unexpected_cid: u8,
    pub private_ciphersuite_list: *const crate::c_types::c_int,
    pub private_tls13_kex_modes: crate::c_types::c_int,
    pub private_f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: crate::c_types::c_int,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
            arg5: *const crate::c_types::c_char,
        ),
    >,
    pub private_p_dbg: *mut crate::c_types::c_void,
    pub private_f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut crate::c_types::c_uchar,
            arg3: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_rng: *mut crate::c_types::c_void,
    pub private_f_get_cache: mbedtls_ssl_cache_get_t,
    pub private_f_set_cache: mbedtls_ssl_cache_set_t,
    pub private_p_cache: *mut crate::c_types::c_void,
    pub private_f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const crate::c_types::c_uchar,
            arg4: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_sni: *mut crate::c_types::c_void,
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: crate::c_types::c_int,
            arg4: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_vrfy: *mut crate::c_types::c_void,
    pub private_f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const crate::c_types::c_uchar,
            arg4: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_psk: *mut crate::c_types::c_void,
    pub private_f_cookie_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut *mut crate::c_types::c_uchar,
            arg3: *mut crate::c_types::c_uchar,
            arg4: *const crate::c_types::c_uchar,
            arg5: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_f_cookie_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *const crate::c_types::c_uchar,
            arg3: size_t,
            arg4: *const crate::c_types::c_uchar,
            arg5: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_cookie: *mut crate::c_types::c_void,
    pub private_f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *const mbedtls_ssl_session,
            arg3: *mut crate::c_types::c_uchar,
            arg4: *const crate::c_types::c_uchar,
            arg5: *mut size_t,
            arg6: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub private_f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_session,
            arg3: *mut crate::c_types::c_uchar,
            arg4: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_ticket: *mut crate::c_types::c_void,
    pub private_cid_len: size_t,
    pub private_cert_profile: *const mbedtls_x509_crt_profile,
    pub private_key_cert: *mut mbedtls_ssl_key_cert,
    pub private_ca_chain: *mut mbedtls_x509_crt,
    pub private_ca_crl: *mut mbedtls_x509_crl,
    pub private_sig_hashes: *const crate::c_types::c_int,
    pub private_sig_algs: *const u16,
    pub private_curve_list: *const mbedtls_ecp_group_id,
    pub private_group_list: *const u16,
    pub private_dhm_P: mbedtls_mpi,
    pub private_dhm_G: mbedtls_mpi,
    pub private_psk: *mut crate::c_types::c_uchar,
    pub private_psk_len: size_t,
    pub private_psk_identity: *mut crate::c_types::c_uchar,
    pub private_psk_identity_len: size_t,
    pub private_alpn_list: *mut *const crate::c_types::c_char,
    pub private_read_timeout: u32,
    pub private_hs_timeout_min: u32,
    pub private_hs_timeout_max: u32,
    pub private_renego_max_records: crate::c_types::c_int,
    pub private_renego_period: [crate::c_types::c_uchar; 8usize],
    pub private_badmac_limit: crate::c_types::c_uint,
    pub private_dhm_min_bitlen: crate::c_types::c_uint,
    pub private_user_data: mbedtls_ssl_user_data_t,
    pub private_f_cert_cb: mbedtls_ssl_hs_cb_t,
    pub private_dn_hints: *const mbedtls_x509_crt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_context {
    pub private_conf: *const mbedtls_ssl_config,
    pub private_state: crate::c_types::c_int,
    pub private_renego_status: crate::c_types::c_int,
    pub private_renego_records_seen: crate::c_types::c_int,
    pub private_tls_version: mbedtls_ssl_protocol_version,
    pub private_badmac_seen: crate::c_types::c_uint,
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: crate::c_types::c_int,
            arg4: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_vrfy: *mut crate::c_types::c_void,
    pub private_f_send: mbedtls_ssl_send_t,
    pub private_f_recv: mbedtls_ssl_recv_t,
    pub private_f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    pub private_p_bio: *mut crate::c_types::c_void,
    pub private_session_in: *mut mbedtls_ssl_session,
    pub private_session_out: *mut mbedtls_ssl_session,
    pub private_session: *mut mbedtls_ssl_session,
    pub private_session_negotiate: *mut mbedtls_ssl_session,
    pub private_handshake: *mut mbedtls_ssl_handshake_params,
    pub private_transform_in: *mut mbedtls_ssl_transform,
    pub private_transform_out: *mut mbedtls_ssl_transform,
    pub private_transform: *mut mbedtls_ssl_transform,
    pub private_transform_negotiate: *mut mbedtls_ssl_transform,
    pub private_transform_application: *mut mbedtls_ssl_transform,
    pub private_p_timer: *mut crate::c_types::c_void,
    pub private_f_set_timer: mbedtls_ssl_set_timer_t,
    pub private_f_get_timer: mbedtls_ssl_get_timer_t,
    pub private_in_buf: *mut crate::c_types::c_uchar,
    pub private_in_ctr: *mut crate::c_types::c_uchar,
    pub private_in_hdr: *mut crate::c_types::c_uchar,
    pub private_in_cid: *mut crate::c_types::c_uchar,
    pub private_in_len: *mut crate::c_types::c_uchar,
    pub private_in_iv: *mut crate::c_types::c_uchar,
    pub private_in_msg: *mut crate::c_types::c_uchar,
    pub private_in_offt: *mut crate::c_types::c_uchar,
    pub private_in_msgtype: crate::c_types::c_int,
    pub private_in_msglen: size_t,
    pub private_in_left: size_t,
    pub private_in_epoch: u16,
    pub private_next_record_offset: size_t,
    pub private_in_window_top: u64,
    pub private_in_window: u64,
    pub private_in_hslen: size_t,
    pub private_nb_zero: crate::c_types::c_int,
    pub private_keep_current_message: crate::c_types::c_int,
    pub private_send_alert: crate::c_types::c_uchar,
    pub private_alert_type: crate::c_types::c_uchar,
    pub private_alert_reason: crate::c_types::c_int,
    pub private_disable_datagram_packing: u8,
    pub private_out_buf: *mut crate::c_types::c_uchar,
    pub private_out_ctr: *mut crate::c_types::c_uchar,
    pub private_out_hdr: *mut crate::c_types::c_uchar,
    pub private_out_cid: *mut crate::c_types::c_uchar,
    pub private_out_len: *mut crate::c_types::c_uchar,
    pub private_out_iv: *mut crate::c_types::c_uchar,
    pub private_out_msg: *mut crate::c_types::c_uchar,
    pub private_out_msgtype: crate::c_types::c_int,
    pub private_out_msglen: size_t,
    pub private_out_left: size_t,
    pub private_cur_out_ctr: [crate::c_types::c_uchar; 8usize],
    pub private_mtu: u16,
    pub private_hostname: *mut crate::c_types::c_char,
    pub private_alpn_chosen: *const crate::c_types::c_char,
    pub private_cli_id: *mut crate::c_types::c_uchar,
    pub private_cli_id_len: size_t,
    pub private_secure_renegotiation: crate::c_types::c_int,
    pub private_verify_data_len: size_t,
    pub private_own_verify_data: [crate::c_types::c_char; 12usize],
    pub private_peer_verify_data: [crate::c_types::c_char; 12usize],
    pub private_own_cid: [crate::c_types::c_uchar; 32usize],
    pub private_own_cid_len: u8,
    pub private_negotiate_cid: u8,
    pub private_f_export_keys: mbedtls_ssl_export_keys_t,
    pub private_p_export_keys: *mut crate::c_types::c_void,
    pub private_user_data: mbedtls_ssl_user_data_t,
}
extern "C" {
    #[doc = " \\brief               Return the name of the ciphersuite associated with the"]
    #[doc = "                      given ID"]
    #[doc = ""]
    #[doc = " \\param ciphersuite_id SSL ciphersuite ID"]
    #[doc = ""]
    #[doc = " \\return              a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite_name(
        ciphersuite_id: crate::c_types::c_int,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief               Return the ID of the ciphersuite associated with the"]
    #[doc = "                      given name"]
    #[doc = ""]
    #[doc = " \\param ciphersuite_name SSL ciphersuite name"]
    #[doc = ""]
    #[doc = " \\return              the ID with the ciphersuite or 0 if not found"]
    pub fn mbedtls_ssl_get_ciphersuite_id(
        ciphersuite_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL context"]
    #[doc = "                 Just makes the context ready for mbedtls_ssl_setup() or"]
    #[doc = "                 mbedtls_ssl_free()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    pub fn mbedtls_ssl_init(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Set up an SSL context for use"]
    #[doc = ""]
    #[doc = " \\note           No copy of the configuration context is made, it can be"]
    #[doc = "                 shared by many mbedtls_ssl_context structures."]
    #[doc = ""]
    #[doc = " \\warning        The conf structure will be accessed during the session."]
    #[doc = "                 It must not be modified or freed as long as the session"]
    #[doc = "                 is active."]
    #[doc = ""]
    #[doc = " \\warning        This function must be called exactly once per context."]
    #[doc = "                 Calling mbedtls_ssl_setup again is not supported, even"]
    #[doc = "                 if no session is active."]
    #[doc = ""]
    #[doc = " \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                 subsystem must have been initialized by calling"]
    #[doc = "                 psa_crypto_init() before calling this function."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param conf     SSL configuration to use"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if"]
    #[doc = "                 memory allocation failed"]
    pub fn mbedtls_ssl_setup(
        ssl: *mut mbedtls_ssl_context,
        conf: *const mbedtls_ssl_config,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Reset an already initialized SSL context for re-use"]
    #[doc = "                 while retaining application-set variables, function"]
    #[doc = "                 pointers and data."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED or"]
    #[doc = "MBEDTLS_ERR_SSL_HW_ACCEL_FAILED"]
    pub fn mbedtls_ssl_session_reset(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the current endpoint type"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    pub fn mbedtls_ssl_conf_endpoint(
        conf: *mut mbedtls_ssl_config,
        endpoint: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief           Set the transport type (TLS or DTLS)."]
    #[doc = "                  Default: TLS"]
    #[doc = ""]
    #[doc = " \\note            For DTLS, you must either provide a recv callback that"]
    #[doc = "                  doesn't block, or one that handles timeouts, see"]
    #[doc = "                  \\c mbedtls_ssl_set_bio(). You also need to provide timer"]
    #[doc = "                  callbacks with \\c mbedtls_ssl_set_timer_cb()."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param transport transport type:"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS."]
    pub fn mbedtls_ssl_conf_transport(
        conf: *mut mbedtls_ssl_config,
        transport: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the certificate verification mode"]
    #[doc = "                 Default: NONE on server, REQUIRED on client"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param authmode can be:"]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked"]
    #[doc = "                        (default on server)"]
    #[doc = "                        (insecure on client)"]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the"]
    #[doc = "                        handshake continues even if verification failed;"]
    #[doc = "                        mbedtls_ssl_get_verify_result() can be called after the"]
    #[doc = "                        handshake is complete."]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,"]
    #[doc = "                        handshake is aborted if verification failed."]
    #[doc = "                        (default on client)"]
    #[doc = ""]
    #[doc = " \\note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode."]
    #[doc = " With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at"]
    #[doc = " the right time(s), which may not be obvious, while REQUIRED always perform"]
    #[doc = " the verification as soon as possible. For example, REQUIRED was protecting"]
    #[doc = " against the \"triple handshake\" attack even before it was found."]
    pub fn mbedtls_ssl_conf_authmode(
        conf: *mut mbedtls_ssl_config,
        authmode: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the verification callback (Optional)."]
    #[doc = ""]
    #[doc = "                 If set, the provided verify callback is called for each"]
    #[doc = "                 certificate in the peer's CRT chain, including the trusted"]
    #[doc = "                 root. For more information, please see the documentation of"]
    #[doc = "                 \\c mbedtls_x509_crt_verify()."]
    #[doc = ""]
    #[doc = " \\note           For per context callbacks and contexts, please use"]
    #[doc = "                 mbedtls_ssl_set_verify() instead."]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to use."]
    #[doc = " \\param f_vrfy   The verification callback to use during CRT verification."]
    #[doc = " \\param p_vrfy   The opaque context to be passed to the callback."]
    pub fn mbedtls_ssl_conf_verify(
        conf: *mut mbedtls_ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the random number generator callback"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_rng    RNG function (mandatory)"]
    #[doc = " \\param p_rng    RNG parameter"]
    pub fn mbedtls_ssl_conf_rng(
        conf: *mut mbedtls_ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the debug callback"]
    #[doc = ""]
    #[doc = "                 The callback has the following argument:"]
    #[doc = "                 void *           opaque context for the callback"]
    #[doc = "                 int              debug level"]
    #[doc = "                 const char *     file name"]
    #[doc = "                 int              line number"]
    #[doc = "                 const char *     message"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_dbg    debug function"]
    #[doc = " \\param p_dbg    debug parameter"]
    pub fn mbedtls_ssl_conf_dbg(
        conf: *mut mbedtls_ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: crate::c_types::c_int,
                arg3: *const crate::c_types::c_char,
                arg4: crate::c_types::c_int,
                arg5: *const crate::c_types::c_char,
            ),
        >,
        p_dbg: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the underlying BIO callbacks for write, read and"]
    #[doc = "                 read-with-timeout."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param p_bio    parameter (context) shared by BIO callbacks"]
    #[doc = " \\param f_send   write callback"]
    #[doc = " \\param f_recv   read callback"]
    #[doc = " \\param f_recv_timeout blocking read callback with timeout."]
    #[doc = ""]
    #[doc = " \\note           One of f_recv or f_recv_timeout can be NULL, in which case"]
    #[doc = "                 the other is used. If both are non-NULL, f_recv_timeout is"]
    #[doc = "                 used and f_recv is ignored (as if it were NULL)."]
    #[doc = ""]
    #[doc = " \\note           The two most common use cases are:"]
    #[doc = "                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL"]
    #[doc = "                 - blocking I/O, f_recv == NULL, f_recv_timeout != NULL"]
    #[doc = ""]
    #[doc = " \\note           For DTLS, you need to provide either a non-NULL"]
    #[doc = "                 f_recv_timeout callback, or a f_recv that doesn't block."]
    #[doc = ""]
    #[doc = " \\note           See the documentations of \\c mbedtls_ssl_send_t,"]
    #[doc = "                 \\c mbedtls_ssl_recv_t and \\c mbedtls_ssl_recv_timeout_t for"]
    #[doc = "                 the conventions those callbacks must follow."]
    #[doc = ""]
    #[doc = " \\note           On some platforms, net_sockets.c provides"]
    #[doc = "                 \\c mbedtls_net_send(), \\c mbedtls_net_recv() and"]
    #[doc = "                 \\c mbedtls_net_recv_timeout() that are suitable to be used"]
    #[doc = "                 here."]
    pub fn mbedtls_ssl_set_bio(
        ssl: *mut mbedtls_ssl_context,
        p_bio: *mut crate::c_types::c_void,
        f_send: mbedtls_ssl_send_t,
        f_recv: mbedtls_ssl_recv_t,
        f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    );
}
extern "C" {
    #[doc = " \\brief             Configure the use of the Connection ID (CID)"]
    #[doc = "                    extension in the next handshake."]
    #[doc = ""]
    #[doc = "                    Reference: RFC 9146 (or draft-ietf-tls-dtls-connection-id-05"]
    #[doc = "                    https://tools.ietf.org/html/draft-ietf-tls-dtls-connection-id-05"]
    #[doc = "                    for legacy version)"]
    #[doc = ""]
    #[doc = "                    The DTLS CID extension allows the reliable association of"]
    #[doc = "                    DTLS records to DTLS connections across changes in the"]
    #[doc = "                    underlying transport (changed IP and Port metadata) by"]
    #[doc = "                    adding explicit connection identifiers (CIDs) to the"]
    #[doc = "                    headers of encrypted DTLS records. The desired CIDs are"]
    #[doc = "                    configured by the application layer and are exchanged in"]
    #[doc = "                    new `ClientHello` / `ServerHello` extensions during the"]
    #[doc = "                    handshake, where each side indicates the CID it wants the"]
    #[doc = "                    peer to use when writing encrypted messages. The CIDs are"]
    #[doc = "                    put to use once records get encrypted: the stack discards"]
    #[doc = "                    any incoming records that don't include the configured CID"]
    #[doc = "                    in their header, and adds the peer's requested CID to the"]
    #[doc = "                    headers of outgoing messages."]
    #[doc = ""]
    #[doc = "                    This API enables or disables the use of the CID extension"]
    #[doc = "                    in the next handshake and sets the value of the CID to"]
    #[doc = "                    be used for incoming messages."]
    #[doc = ""]
    #[doc = " \\param ssl         The SSL context to configure. This must be initialized."]
    #[doc = " \\param enable      This value determines whether the CID extension should"]
    #[doc = "                    be used or not. Possible values are:"]
    #[doc = "                    - MBEDTLS_SSL_CID_ENABLED to enable the use of the CID."]
    #[doc = "                    - MBEDTLS_SSL_CID_DISABLED (default) to disable the use"]
    #[doc = "                      of the CID."]
    #[doc = " \\param own_cid     The address of the readable buffer holding the CID we want"]
    #[doc = "                    the peer to use when sending encrypted messages to us."]
    #[doc = "                    This may be \\c NULL if \\p own_cid_len is \\c 0."]
    #[doc = "                    This parameter is unused if \\p enabled is set to"]
    #[doc = "                    MBEDTLS_SSL_CID_DISABLED."]
    #[doc = " \\param own_cid_len The length of \\p own_cid."]
    #[doc = "                    This parameter is unused if \\p enabled is set to"]
    #[doc = "                    MBEDTLS_SSL_CID_DISABLED."]
    #[doc = ""]
    #[doc = " \\note              The value of \\p own_cid_len must match the value of the"]
    #[doc = "                    \\c len parameter passed to mbedtls_ssl_conf_cid()"]
    #[doc = "                    when configuring the ::mbedtls_ssl_config that \\p ssl"]
    #[doc = "                    is bound to."]
    #[doc = ""]
    #[doc = " \\note              This CID configuration applies to subsequent handshakes"]
    #[doc = "                    performed on the SSL context \\p ssl, but does not trigger"]
    #[doc = "                    one. You still have to call `mbedtls_ssl_handshake()`"]
    #[doc = "                    (for the initial handshake) or `mbedtls_ssl_renegotiate()`"]
    #[doc = "                    (for a renegotiation handshake) explicitly after a"]
    #[doc = "                    successful call to this function to run the handshake."]
    #[doc = ""]
    #[doc = " \\note              This call cannot guarantee that the use of the CID"]
    #[doc = "                    will be successfully negotiated in the next handshake,"]
    #[doc = "                    because the peer might not support it. Specifically:"]
    #[doc = "                    - On the Client, enabling the use of the CID through"]
    #[doc = "                      this call implies that the `ClientHello` in the next"]
    #[doc = "                      handshake will include the CID extension, thereby"]
    #[doc = "                      offering the use of the CID to the server. Only if"]
    #[doc = "                      the `ServerHello` contains the CID extension, too,"]
    #[doc = "                      the CID extension will actually be put to use."]
    #[doc = "                    - On the Server, enabling the use of the CID through"]
    #[doc = "                      this call implies that the server will look for"]
    #[doc = "                      the CID extension in a `ClientHello` from the client,"]
    #[doc = "                      and, if present, reply with a CID extension in its"]
    #[doc = "                      `ServerHello`."]
    #[doc = ""]
    #[doc = " \\note              To check whether the use of the CID was negotiated"]
    #[doc = "                    after the subsequent handshake has completed, please"]
    #[doc = "                    use the API mbedtls_ssl_get_peer_cid()."]
    #[doc = ""]
    #[doc = " \\warning           If the use of the CID extension is enabled in this call"]
    #[doc = "                    and the subsequent handshake negotiates its use, Mbed TLS"]
    #[doc = "                    will silently drop every packet whose CID does not match"]
    #[doc = "                    the CID configured in \\p own_cid. It is the responsibility"]
    #[doc = "                    of the user to adapt the underlying transport to take care"]
    #[doc = "                    of CID-based demultiplexing before handing datagrams to"]
    #[doc = "                    Mbed TLS."]
    #[doc = ""]
    #[doc = " \\return            \\c 0 on success. In this case, the CID configuration"]
    #[doc = "                    applies to the next handshake."]
    #[doc = " \\return            A negative error code on failure."]
    pub fn mbedtls_ssl_set_cid(
        ssl: *mut mbedtls_ssl_context,
        enable: crate::c_types::c_int,
        own_cid: *const crate::c_types::c_uchar,
        own_cid_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief              Get information about our request for usage of the CID"]
    #[doc = "                     extension in the current connection."]
    #[doc = ""]
    #[doc = " \\param ssl          The SSL context to query."]
    #[doc = " \\param enabled      The address at which to store whether the CID extension"]
    #[doc = "                     is requested to be used or not. If the CID is"]
    #[doc = "                     requested, `*enabled` is set to"]
    #[doc = "                     MBEDTLS_SSL_CID_ENABLED; otherwise, it is set to"]
    #[doc = "                     MBEDTLS_SSL_CID_DISABLED."]
    #[doc = " \\param own_cid      The address of the buffer in which to store our own"]
    #[doc = "                     CID (if the CID extension is requested). This may be"]
    #[doc = "                     \\c NULL in case the value of our CID isn't needed. If"]
    #[doc = "                     it is not \\c NULL, \\p own_cid_len must not be \\c NULL."]
    #[doc = " \\param own_cid_len  The address at which to store the size of our own CID"]
    #[doc = "                     (if the CID extension is requested). This is also the"]
    #[doc = "                     number of Bytes in \\p own_cid that have been written."]
    #[doc = "                     This may be \\c NULL in case the length of our own CID"]
    #[doc = "                     isn't needed. If it is \\c NULL, \\p own_cid must be"]
    #[doc = "                     \\c NULL, too."]
    #[doc = ""]
    #[doc = "\\note                If we are requesting an empty CID this function sets"]
    #[doc = "                     `*enabled` to #MBEDTLS_SSL_CID_DISABLED (the rationale"]
    #[doc = "                     for this is that the resulting outcome is the"]
    #[doc = "                     same as if the CID extensions wasn't requested)."]
    #[doc = ""]
    #[doc = " \\return            \\c 0 on success."]
    #[doc = " \\return            A negative error code on failure."]
    pub fn mbedtls_ssl_get_own_cid(
        ssl: *mut mbedtls_ssl_context,
        enabled: *mut crate::c_types::c_int,
        own_cid: *mut crate::c_types::c_uchar,
        own_cid_len: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief              Get information about the use of the CID extension"]
    #[doc = "                     in the current connection."]
    #[doc = ""]
    #[doc = " \\param ssl          The SSL context to query."]
    #[doc = " \\param enabled      The address at which to store whether the CID extension"]
    #[doc = "                     is currently in use or not. If the CID is in use,"]
    #[doc = "                     `*enabled` is set to MBEDTLS_SSL_CID_ENABLED;"]
    #[doc = "                     otherwise, it is set to MBEDTLS_SSL_CID_DISABLED."]
    #[doc = " \\param peer_cid     The address of the buffer in which to store the CID"]
    #[doc = "                     chosen by the peer (if the CID extension is used)."]
    #[doc = "                     This may be \\c NULL in case the value of peer CID"]
    #[doc = "                     isn't needed. If it is not \\c NULL, \\p peer_cid_len"]
    #[doc = "                     must not be \\c NULL."]
    #[doc = " \\param peer_cid_len The address at which to store the size of the CID"]
    #[doc = "                     chosen by the peer (if the CID extension is used)."]
    #[doc = "                     This is also the number of Bytes in \\p peer_cid that"]
    #[doc = "                     have been written."]
    #[doc = "                     This may be \\c NULL in case the length of the peer CID"]
    #[doc = "                     isn't needed. If it is \\c NULL, \\p peer_cid must be"]
    #[doc = "                     \\c NULL, too."]
    #[doc = ""]
    #[doc = " \\note               This applies to the state of the CID negotiated in"]
    #[doc = "                     the last complete handshake. If a handshake is in"]
    #[doc = "                     progress, this function will attempt to complete"]
    #[doc = "                     the handshake first."]
    #[doc = ""]
    #[doc = " \\note               If CID extensions have been exchanged but both client"]
    #[doc = "                     and server chose to use an empty CID, this function"]
    #[doc = "                     sets `*enabled` to #MBEDTLS_SSL_CID_DISABLED"]
    #[doc = "                     (the rationale for this is that the resulting"]
    #[doc = "                     communication is the same as if the CID extensions"]
    #[doc = "                     hadn't been used)."]
    #[doc = ""]
    #[doc = " \\return            \\c 0 on success."]
    #[doc = " \\return            A negative error code on failure."]
    pub fn mbedtls_ssl_get_peer_cid(
        ssl: *mut mbedtls_ssl_context,
        enabled: *mut crate::c_types::c_int,
        peer_cid: *mut crate::c_types::c_uchar,
        peer_cid_len: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Maximum Transport Unit (MTU)."]
    #[doc = "                 Special value: 0 means unset (no limit)."]
    #[doc = "                 This represents the maximum size of a datagram payload"]
    #[doc = "                 handled by the transport layer (usually UDP) as determined"]
    #[doc = "                 by the network link and stack. In practice, this controls"]
    #[doc = "                 the maximum size datagram the DTLS layer will pass to the"]
    #[doc = "                 \\c f_send() callback set using \\c mbedtls_ssl_set_bio()."]
    #[doc = ""]
    #[doc = " \\note           The limit on datagram size is converted to a limit on"]
    #[doc = "                 record payload by subtracting the current overhead of"]
    #[doc = "                 encapsulation and encryption/authentication if any."]
    #[doc = ""]
    #[doc = " \\note           This can be called at any point during the connection, for"]
    #[doc = "                 example when a Path Maximum Transfer Unit (PMTU)"]
    #[doc = "                 estimate becomes available from other sources,"]
    #[doc = "                 such as lower (or higher) protocol layers."]
    #[doc = ""]
    #[doc = " \\note           This setting only controls the size of the packets we send,"]
    #[doc = "                 and does not restrict the size of the datagrams we're"]
    #[doc = "                 willing to receive. Client-side, you can request the"]
    #[doc = "                 server to use smaller records with \\c"]
    #[doc = "                 mbedtls_ssl_conf_max_frag_len()."]
    #[doc = ""]
    #[doc = " \\note           If both a MTU and a maximum fragment length have been"]
    #[doc = "                 configured (or negotiated with the peer), the resulting"]
    #[doc = "                 lower limit on record payload (see first note) is used."]
    #[doc = ""]
    #[doc = " \\note           This can only be used to decrease the maximum size"]
    #[doc = "                 of datagrams (hence records, see first note) sent. It"]
    #[doc = "                 cannot be used to increase the maximum size of records over"]
    #[doc = "                 the limit set by #MBEDTLS_SSL_OUT_CONTENT_LEN."]
    #[doc = ""]
    #[doc = " \\note           Values lower than the current record layer expansion will"]
    #[doc = "                 result in an error when trying to send data."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param mtu      Value of the path MTU in bytes"]
    pub fn mbedtls_ssl_set_mtu(ssl: *mut mbedtls_ssl_context, mtu: u16);
}
extern "C" {
    #[doc = " \\brief          Set a connection-specific verification callback (optional)."]
    #[doc = ""]
    #[doc = "                 If set, the provided verify callback is called for each"]
    #[doc = "                 certificate in the peer's CRT chain, including the trusted"]
    #[doc = "                 root. For more information, please see the documentation of"]
    #[doc = "                 \\c mbedtls_x509_crt_verify()."]
    #[doc = ""]
    #[doc = " \\note           This call is analogous to mbedtls_ssl_conf_verify() but"]
    #[doc = "                 binds the verification callback and context to an SSL context"]
    #[doc = "                 as opposed to an SSL configuration."]
    #[doc = "                 If mbedtls_ssl_conf_verify() and mbedtls_ssl_set_verify()"]
    #[doc = "                 are both used, mbedtls_ssl_set_verify() takes precedence."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to use."]
    #[doc = " \\param f_vrfy   The verification callback to use during CRT verification."]
    #[doc = " \\param p_vrfy   The opaque context to be passed to the callback."]
    pub fn mbedtls_ssl_set_verify(
        ssl: *mut mbedtls_ssl_context,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the timeout period for mbedtls_ssl_read()"]
    #[doc = "                 (Default: no timeout.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[doc = " \\param timeout  Timeout value in milliseconds."]
    #[doc = "                 Use 0 for no timeout (default)."]
    #[doc = ""]
    #[doc = " \\note           With blocking I/O, this will only work if a non-NULL"]
    #[doc = "                 \\c f_recv_timeout was set with \\c mbedtls_ssl_set_bio()."]
    #[doc = "                 With non-blocking I/O, this will only work if timer"]
    #[doc = "                 callbacks were set with \\c mbedtls_ssl_set_timer_cb()."]
    #[doc = ""]
    #[doc = " \\note           With non-blocking I/O, you may also skip this function"]
    #[doc = "                 altogether and handle timeouts at the application layer."]
    pub fn mbedtls_ssl_conf_read_timeout(conf: *mut mbedtls_ssl_config, timeout: u32);
}
extern "C" {
    #[doc = " \\brief          Check whether a buffer contains a valid and authentic record"]
    #[doc = "                 that has not been seen before. (DTLS only)."]
    #[doc = ""]
    #[doc = "                 This function does not change the user-visible state"]
    #[doc = "                 of the SSL context. Its sole purpose is to provide"]
    #[doc = "                 an indication of the legitimacy of an incoming record."]
    #[doc = ""]
    #[doc = "                 This can be useful e.g. in distributed server environments"]
    #[doc = "                 using the DTLS Connection ID feature, in which connections"]
    #[doc = "                 might need to be passed between service instances on a change"]
    #[doc = "                 of peer address, but where such disruptive operations should"]
    #[doc = "                 only happen after the validity of incoming records has been"]
    #[doc = "                 confirmed."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to use."]
    #[doc = " \\param buf      The address of the buffer holding the record to be checked."]
    #[doc = "                 This must be a read/write buffer of length \\p buflen Bytes."]
    #[doc = " \\param buflen   The length of \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\note           This routine only checks whether the provided buffer begins"]
    #[doc = "                 with a valid and authentic record that has not been seen"]
    #[doc = "                 before, but does not check potential data following the"]
    #[doc = "                 initial record. In particular, it is possible to pass DTLS"]
    #[doc = "                 datagrams containing multiple records, in which case only"]
    #[doc = "                 the first record is checked."]
    #[doc = ""]
    #[doc = " \\note           This function modifies the input buffer \\p buf. If you need"]
    #[doc = "                 to preserve the original record, you have to maintain a copy."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the record is valid and authentic and has not been"]
    #[doc = "                 seen before."]
    #[doc = " \\return         MBEDTLS_ERR_SSL_INVALID_MAC if the check completed"]
    #[doc = "                 successfully but the record was found to be not authentic."]
    #[doc = " \\return         MBEDTLS_ERR_SSL_INVALID_RECORD if the check completed"]
    #[doc = "                 successfully but the record was found to be invalid for"]
    #[doc = "                 a reason different from authenticity checking."]
    #[doc = " \\return         MBEDTLS_ERR_SSL_UNEXPECTED_RECORD if the check completed"]
    #[doc = "                 successfully but the record was found to be unexpected"]
    #[doc = "                 in the state of the SSL context, including replayed records."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = "                 In this case, the SSL context becomes unusable and needs"]
    #[doc = "                 to be freed or reset before reuse."]
    pub fn mbedtls_ssl_check_record(
        ssl: *const mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        buflen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the timer callbacks (Mandatory for DTLS.)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param p_timer  parameter (context) shared by timer callbacks"]
    #[doc = " \\param f_set_timer   set timer callback"]
    #[doc = " \\param f_get_timer   get timer callback. Must return:"]
    #[doc = ""]
    #[doc = " \\note           See the documentation of \\c mbedtls_ssl_set_timer_t and"]
    #[doc = "                 \\c mbedtls_ssl_get_timer_t for the conventions this pair of"]
    #[doc = "                 callbacks must follow."]
    #[doc = ""]
    #[doc = " \\note           On some platforms, timing.c provides"]
    #[doc = "                 \\c mbedtls_timing_set_delay() and"]
    #[doc = "                 \\c mbedtls_timing_get_delay() that are suitable for using"]
    #[doc = "                 here, except if using an event-driven style."]
    #[doc = ""]
    #[doc = " \\note           See also the \"DTLS tutorial\" article in our knowledge base."]
    #[doc = "                 https://mbed-tls.readthedocs.io/en/latest/kb/how-to/dtls-tutorial"]
    pub fn mbedtls_ssl_set_timer_cb(
        ssl: *mut mbedtls_ssl_context,
        p_timer: *mut crate::c_types::c_void,
        f_set_timer: mbedtls_ssl_set_timer_t,
        f_get_timer: mbedtls_ssl_get_timer_t,
    );
}
#[doc = " \\brief           Callback type: generate and write session ticket"]
#[doc = ""]
#[doc = " \\note            This describes what a callback implementation should do."]
#[doc = "                  This callback should generate an encrypted and"]
#[doc = "                  authenticated ticket for the session and write it to the"]
#[doc = "                  output buffer. Here, ticket means the opaque ticket part"]
#[doc = "                  of the NewSessionTicket structure of RFC 5077."]
#[doc = ""]
#[doc = " \\param p_ticket  Context for the callback"]
#[doc = " \\param session   SSL session to be written in the ticket"]
#[doc = " \\param start     Start of the output buffer"]
#[doc = " \\param end       End of the output buffer"]
#[doc = " \\param tlen      On exit, holds the length written"]
#[doc = " \\param lifetime  On exit, holds the lifetime of the ticket in seconds"]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  a specific MBEDTLS_ERR_XXX code."]
pub type mbedtls_ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::c_types::c_void,
        session: *const mbedtls_ssl_session,
        start: *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        tlen: *mut size_t,
        lifetime: *mut u32,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief           Callback type: parse and load session ticket"]
#[doc = ""]
#[doc = " \\note            This describes what a callback implementation should do."]
#[doc = "                  This callback should parse a session ticket as generated"]
#[doc = "                  by the corresponding mbedtls_ssl_ticket_write_t function,"]
#[doc = "                  and, if the ticket is authentic and valid, load the"]
#[doc = "                  session."]
#[doc = ""]
#[doc = " \\note            The implementation is allowed to modify the first len"]
#[doc = "                  bytes of the input buffer, eg to use it as a temporary"]
#[doc = "                  area for the decrypted ticket contents."]
#[doc = ""]
#[doc = " \\param p_ticket  Context for the callback"]
#[doc = " \\param session   SSL session to be loaded"]
#[doc = " \\param buf       Start of the buffer containing the ticket"]
#[doc = " \\param len       Length of the ticket."]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or"]
#[doc = "                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or"]
#[doc = "                  any other non-zero code for other failures."]
pub type mbedtls_ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::c_types::c_void,
        session: *mut mbedtls_ssl_session,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief           Configure SSL session ticket callbacks (server only)."]
    #[doc = "                  (Default: none.)"]
    #[doc = ""]
    #[doc = " \\note            On server, session tickets are enabled by providing"]
    #[doc = "                  non-NULL callbacks."]
    #[doc = ""]
    #[doc = " \\note            On client, use \\c mbedtls_ssl_conf_session_tickets()."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration context"]
    #[doc = " \\param f_ticket_write    Callback for writing a ticket"]
    #[doc = " \\param f_ticket_parse    Callback for parsing a ticket"]
    #[doc = " \\param p_ticket          Context shared by the two callbacks"]
    pub fn mbedtls_ssl_conf_session_tickets_cb(
        conf: *mut mbedtls_ssl_config,
        f_ticket_write: mbedtls_ssl_ticket_write_t,
        f_ticket_parse: mbedtls_ssl_ticket_parse_t,
        p_ticket: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief   Configure a key export callback."]
    #[doc = "          (Default: none.)"]
    #[doc = ""]
    #[doc = "          This API can be used for two purposes:"]
    #[doc = "          - Debugging: Use this API to e.g. generate an NSSKeylog"]
    #[doc = "            file and use it to inspect encrypted traffic in tools"]
    #[doc = "            such as Wireshark."]
    #[doc = "          - Application-specific export: Use this API to implement"]
    #[doc = "            key exporters, e.g. for EAP-TLS or DTLS-SRTP."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ssl            The SSL context to which the export"]
    #[doc = "                       callback should be attached."]
    #[doc = " \\param f_export_keys  The callback for the key export."]
    #[doc = " \\param p_export_keys  The opaque context pointer to be passed to the"]
    #[doc = "                       callback \\p f_export_keys."]
    pub fn mbedtls_ssl_set_export_keys_cb(
        ssl: *mut mbedtls_ssl_context,
        f_export_keys: mbedtls_ssl_export_keys_t,
        p_export_keys: *mut crate::c_types::c_void,
    );
}
#[doc = " \\brief          Callback type: generate a cookie"]
#[doc = ""]
#[doc = " \\param ctx      Context for the callback"]
#[doc = " \\param p        Buffer to write to,"]
#[doc = "                 must be updated to point right after the cookie"]
#[doc = " \\param end      Pointer to one past the end of the output buffer"]
#[doc = " \\param info     Client ID info that was passed to"]
#[doc = "                 \\c mbedtls_ssl_set_client_transport_id()"]
#[doc = " \\param ilen     Length of info in bytes"]
#[doc = ""]
#[doc = " \\return         The callback must return 0 on success,"]
#[doc = "                 or a negative error code."]
pub type mbedtls_ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        p: *mut *mut crate::c_types::c_uchar,
        end: *mut crate::c_types::c_uchar,
        info: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: verify a cookie"]
#[doc = ""]
#[doc = " \\param ctx      Context for the callback"]
#[doc = " \\param cookie   Cookie to verify"]
#[doc = " \\param clen     Length of cookie"]
#[doc = " \\param info     Client ID info that was passed to"]
#[doc = "                 \\c mbedtls_ssl_set_client_transport_id()"]
#[doc = " \\param ilen     Length of info in bytes"]
#[doc = ""]
#[doc = " \\return         The callback must return 0 if cookie is valid,"]
#[doc = "                 or a negative error code."]
pub type mbedtls_ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        cookie: *const crate::c_types::c_uchar,
        clen: size_t,
        info: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief           Register callbacks for DTLS cookies"]
    #[doc = "                  (Server only. DTLS only.)"]
    #[doc = ""]
    #[doc = "                  Default: dummy callbacks that fail, in order to force you to"]
    #[doc = "                  register working callbacks (and initialize their context)."]
    #[doc = ""]
    #[doc = "                  To disable HelloVerifyRequest, register NULL callbacks."]
    #[doc = ""]
    #[doc = " \\warning         Disabling hello verification allows your server to be used"]
    #[doc = "                  for amplification in DoS attacks against other hosts."]
    #[doc = "                  Only disable if you known this can't happen in your"]
    #[doc = "                  particular environment."]
    #[doc = ""]
    #[doc = " \\note            See comments on \\c mbedtls_ssl_handshake() about handling"]
    #[doc = "                  the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected"]
    #[doc = "                  on the first handshake attempt when this is enabled."]
    #[doc = ""]
    #[doc = " \\note            This is also necessary to handle client reconnection from"]
    #[doc = "                  the same port as described in RFC 6347 section 4.2.8 (only"]
    #[doc = "                  the variant with cookies is supported currently). See"]
    #[doc = "                  comments on \\c mbedtls_ssl_read() for details."]
    #[doc = ""]
    #[doc = " \\param conf              SSL configuration"]
    #[doc = " \\param f_cookie_write    Cookie write callback"]
    #[doc = " \\param f_cookie_check    Cookie check callback"]
    #[doc = " \\param p_cookie          Context for both callbacks"]
    pub fn mbedtls_ssl_conf_dtls_cookies(
        conf: *mut mbedtls_ssl_config,
        f_cookie_write: mbedtls_ssl_cookie_write_t,
        f_cookie_check: mbedtls_ssl_cookie_check_t,
        p_cookie: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set client's transport-level identification info."]
    #[doc = "                 (Server only. DTLS only.)"]
    #[doc = ""]
    #[doc = "                 This is usually the IP address (and port), but could be"]
    #[doc = "                 anything identify the client depending on the underlying"]
    #[doc = "                 network stack. Used for HelloVerifyRequest with DTLS."]
    #[doc = "                 This is *not* used to route the actual packets."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param info     Transport-level info identifying the client (eg IP + port)"]
    #[doc = " \\param ilen     Length of info in bytes"]
    #[doc = ""]
    #[doc = " \\note           An internal copy is made, so the info buffer can be reused."]
    #[doc = ""]
    #[doc = " \\return         0 on success,"]
    #[doc = "                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,"]
    #[doc = "                 MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory."]
    pub fn mbedtls_ssl_set_client_transport_id(
        ssl: *mut mbedtls_ssl_context,
        info: *const crate::c_types::c_uchar,
        ilen: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Enable or disable anti-replay protection for DTLS."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = "                 Default: enabled."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED."]
    #[doc = ""]
    #[doc = " \\warning        Disabling this is a security risk unless the application"]
    #[doc = "                 protocol handles duplicated packets in a safe way. You"]
    #[doc = "                 should not disable this without careful consideration."]
    #[doc = "                 However, if your application already detects duplicated"]
    #[doc = "                 packets and needs information about them to adjust its"]
    #[doc = "                 transmission strategy, then you'll want to disable this."]
    pub fn mbedtls_ssl_conf_dtls_anti_replay(
        conf: *mut mbedtls_ssl_config,
        mode: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Set a limit on the number of records with a bad MAC"]
    #[doc = "                 before terminating the connection."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = "                 Default: 0 (disabled)."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param limit    Limit, or 0 to disable."]
    #[doc = ""]
    #[doc = " \\note           If the limit is N, then the connection is terminated when"]
    #[doc = "                 the Nth non-authentic record is seen."]
    #[doc = ""]
    #[doc = " \\note           Records with an invalid header are not counted, only the"]
    #[doc = "                 ones going through the authentication-decryption phase."]
    #[doc = ""]
    #[doc = " \\note           This is a security trade-off related to the fact that it's"]
    #[doc = "                 often relatively easy for an active attacker to inject UDP"]
    #[doc = "                 datagrams. On one hand, setting a low limit here makes it"]
    #[doc = "                 easier for such an attacker to forcibly terminated a"]
    #[doc = "                 connection. On the other hand, a high limit or no limit"]
    #[doc = "                 might make us waste resources checking authentication on"]
    #[doc = "                 many bogus packets."]
    pub fn mbedtls_ssl_conf_dtls_badmac_limit(
        conf: *mut mbedtls_ssl_config,
        limit: crate::c_types::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Allow or disallow packing of multiple handshake records"]
    #[doc = "                 within a single datagram."]
    #[doc = ""]
    #[doc = " \\param ssl           The SSL context to configure."]
    #[doc = " \\param allow_packing This determines whether datagram packing may"]
    #[doc = "                      be used or not. A value of \\c 0 means that every"]
    #[doc = "                      record will be sent in a separate datagram; a"]
    #[doc = "                      value of \\c 1 means that, if space permits,"]
    #[doc = "                      multiple handshake messages (including CCS) belonging to"]
    #[doc = "                      a single flight may be packed within a single datagram."]
    #[doc = ""]
    #[doc = " \\note           This is enabled by default and should only be disabled"]
    #[doc = "                 for test purposes, or if datagram packing causes"]
    #[doc = "                 interoperability issues with peers that don't support it."]
    #[doc = ""]
    #[doc = " \\note           Allowing datagram packing reduces the network load since"]
    #[doc = "                 there's less overhead if multiple messages share the same"]
    #[doc = "                 datagram. Also, it increases the handshake efficiency"]
    #[doc = "                 since messages belonging to a single datagram will not"]
    #[doc = "                 be reordered in transit, and so future message buffering"]
    #[doc = "                 or flight retransmission (if no buffering is used) as"]
    #[doc = "                 means to deal with reordering are needed less frequently."]
    #[doc = ""]
    #[doc = " \\note           Application records are not affected by this option and"]
    #[doc = "                 are currently always sent in separate datagrams."]
    #[doc = ""]
    pub fn mbedtls_ssl_set_datagram_packing(
        ssl: *mut mbedtls_ssl_context,
        allow_packing: crate::c_types::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Set retransmit timeout values for the DTLS handshake."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param min      Initial timeout value in milliseconds."]
    #[doc = "                 Default: 1000 (1 second)."]
    #[doc = " \\param max      Maximum timeout value in milliseconds."]
    #[doc = "                 Default: 60000 (60 seconds)."]
    #[doc = ""]
    #[doc = " \\note           Default values are from RFC 6347 section 4.2.4.1."]
    #[doc = ""]
    #[doc = " \\note           The 'min' value should typically be slightly above the"]
    #[doc = "                 expected round-trip time to your peer, plus whatever time"]
    #[doc = "                 it takes for the peer to process the message. For example,"]
    #[doc = "                 if your RTT is about 600ms and you peer needs up to 1s to"]
    #[doc = "                 do the cryptographic operations in the handshake, then you"]
    #[doc = "                 should set 'min' slightly above 1600. Lower values of 'min'"]
    #[doc = "                 might cause spurious resends which waste network resources,"]
    #[doc = "                 while larger value of 'min' will increase overall latency"]
    #[doc = "                 on unreliable network links."]
    #[doc = ""]
    #[doc = " \\note           The more unreliable your network connection is, the larger"]
    #[doc = "                 your max / min ratio needs to be in order to achieve"]
    #[doc = "                 reliable handshakes."]
    #[doc = ""]
    #[doc = " \\note           Messages are retransmitted up to log2(ceil(max/min)) times."]
    #[doc = "                 For example, if min = 1s and max = 5s, the retransmit plan"]
    #[doc = "                 goes: send ... 1s -> resend ... 2s -> resend ... 4s ->"]
    #[doc = "                 resend ... 5s -> give up and return a timeout error."]
    pub fn mbedtls_ssl_conf_handshake_timeout(conf: *mut mbedtls_ssl_config, min: u32, max: u32);
}
extern "C" {
    #[doc = " \\brief          Set the session cache callbacks (server-side only)"]
    #[doc = "                 If not set, no session resuming is done (except if session"]
    #[doc = "                 tickets are enabled too)."]
    #[doc = ""]
    #[doc = "                 The session cache has the responsibility to check for stale"]
    #[doc = "                 entries based on timeout. See RFC 5246 for recommendations."]
    #[doc = ""]
    #[doc = "                 Warning: session.peer_cert is cleared by the SSL/TLS layer on"]
    #[doc = "                 connection shutdown, so do not cache the pointer! Either set"]
    #[doc = "                 it to NULL or make a full copy of the certificate."]
    #[doc = ""]
    #[doc = "                 The get callback is called once during the initial handshake"]
    #[doc = "                 to enable session resuming. The get function has the"]
    #[doc = "                 following parameters: (void *parameter, mbedtls_ssl_session *session)"]
    #[doc = "                 If a valid entry is found, it should fill the master of"]
    #[doc = "                 the session object with the cached values and return 0,"]
    #[doc = "                 return 1 otherwise. Optionally peer_cert can be set as well"]
    #[doc = "                 if it is properly present in cache entry."]
    #[doc = ""]
    #[doc = "                 The set callback is called once during the initial handshake"]
    #[doc = "                 to enable session resuming after the entire handshake has"]
    #[doc = "                 been finished. The set function has the following parameters:"]
    #[doc = "                 (void *parameter, const mbedtls_ssl_session *session). The function"]
    #[doc = "                 should create a cache entry for future retrieval based on"]
    #[doc = "                 the data in the session structure and should keep in mind"]
    #[doc = "                 that the mbedtls_ssl_session object presented (and all its referenced"]
    #[doc = "                 data) is cleared by the SSL/TLS layer when the connection is"]
    #[doc = "                 terminated. It is recommended to add metadata to determine if"]
    #[doc = "                 an entry is still valid in the future. Return 0 if"]
    #[doc = "                 successfully cached, return 1 otherwise."]
    #[doc = ""]
    #[doc = " \\param conf           SSL configuration"]
    #[doc = " \\param p_cache        parameter (context) for both callbacks"]
    #[doc = " \\param f_get_cache    session get callback"]
    #[doc = " \\param f_set_cache    session set callback"]
    pub fn mbedtls_ssl_conf_session_cache(
        conf: *mut mbedtls_ssl_config,
        p_cache: *mut crate::c_types::c_void,
        f_get_cache: mbedtls_ssl_cache_get_t,
        f_set_cache: mbedtls_ssl_cache_set_t,
    );
}
extern "C" {
    #[doc = " \\brief          Load a session for session resumption."]
    #[doc = ""]
    #[doc = "                 Sessions loaded through this call will be considered"]
    #[doc = "                 for session resumption in the next handshake."]
    #[doc = ""]
    #[doc = " \\note           Even if this call succeeds, it is not guaranteed that"]
    #[doc = "                 the next handshake will indeed be shortened through the"]
    #[doc = "                 use of session resumption: The server is always free"]
    #[doc = "                 to reject any attempt for resumption and fall back to"]
    #[doc = "                 a full handshake."]
    #[doc = ""]
    #[doc = " \\note           This function can handle a variety of mechanisms for session"]
    #[doc = "                 resumption: For TLS 1.2, both session ID-based resumption and"]
    #[doc = "                 ticket-based resumption will be considered. For TLS 1.3,"]
    #[doc = "                 once implemented, sessions equate to tickets, and loading"]
    #[doc = "                 one or more sessions via this call will lead to their"]
    #[doc = "                 corresponding tickets being advertised as resumption PSKs"]
    #[doc = "                 by the client."]
    #[doc = ""]
    #[doc = " \\note           Calling this function multiple times will only be useful"]
    #[doc = "                 once TLS 1.3 is supported. For TLS 1.2 connections, this"]
    #[doc = "                 function should be called at most once."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context representing the connection which should"]
    #[doc = "                 be attempted to be setup using session resumption. This"]
    #[doc = "                 must be initialized via mbedtls_ssl_init() and bound to"]
    #[doc = "                 an SSL configuration via mbedtls_ssl_setup(), but"]
    #[doc = "                 the handshake must not yet have been started."]
    #[doc = " \\param session  The session to be considered for session resumption."]
    #[doc = "                 This must be a session previously exported via"]
    #[doc = "                 mbedtls_ssl_get_session(), and potentially serialized and"]
    #[doc = "                 deserialized through mbedtls_ssl_session_save() and"]
    #[doc = "                 mbedtls_ssl_session_load() in the meantime."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         \\c MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if the session"]
    #[doc = "                 could not be loaded because of an implementation limitation."]
    #[doc = "                 This error is non-fatal, and has no observable effect on"]
    #[doc = "                 the SSL context or the session that was attempted to be loaded."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_get_session()"]
    #[doc = " \\sa             mbedtls_ssl_session_load()"]
    pub fn mbedtls_ssl_set_session(
        ssl: *mut mbedtls_ssl_context,
        session: *const mbedtls_ssl_session,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Load serialized session data into a session structure."]
    #[doc = "                 On client, this can be used for loading saved sessions"]
    #[doc = "                 before resuming them with mbedtls_ssl_set_session()."]
    #[doc = "                 On server, this can be used for alternative implementations"]
    #[doc = "                 of session cache or session tickets."]
    #[doc = ""]
    #[doc = " \\warning        If a peer certificate chain is associated with the session,"]
    #[doc = "                 the serialized state will only contain the peer's"]
    #[doc = "                 end-entity certificate and the result of the chain"]
    #[doc = "                 verification (unless verification was disabled), but not"]
    #[doc = "                 the rest of the chain."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_session_save()"]
    #[doc = " \\see            mbedtls_ssl_set_session()"]
    #[doc = ""]
    #[doc = " \\param session  The session structure to be populated. It must have been"]
    #[doc = "                 initialised with mbedtls_ssl_session_init() but not"]
    #[doc = "                 populated yet."]
    #[doc = " \\param buf      The buffer holding the serialized session data. It must be a"]
    #[doc = "                 readable buffer of at least \\p len bytes."]
    #[doc = " \\param len      The size of the serialized data in bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data"]
    #[doc = "                 was generated in a different version or configuration of"]
    #[doc = "                 Mbed TLS."]
    #[doc = " \\return         Another negative value for other kinds of errors (for"]
    #[doc = "                 example, unsupported features in the embedded certificate)."]
    pub fn mbedtls_ssl_session_load(
        session: *mut mbedtls_ssl_session,
        buf: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Save session structure as serialized data in a buffer."]
    #[doc = "                 On client, this can be used for saving session data,"]
    #[doc = "                 potentially in non-volatile storage, for resuming later."]
    #[doc = "                 On server, this can be used for alternative implementations"]
    #[doc = "                 of session cache or session tickets."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_session_load()"]
    #[doc = ""]
    #[doc = " \\param session  The session structure to be saved."]
    #[doc = " \\param buf      The buffer to write the serialized data to. It must be a"]
    #[doc = "                 writeable buffer of at least \\p len bytes, or may be \\c"]
    #[doc = "                 NULL if \\p len is \\c 0."]
    #[doc = " \\param buf_len  The number of bytes available for writing in \\p buf."]
    #[doc = " \\param olen     The size in bytes of the data that has been or would have"]
    #[doc = "                 been written. It must point to a valid \\c size_t."]
    #[doc = ""]
    #[doc = " \\note           \\p olen is updated to the correct value regardless of"]
    #[doc = "                 whether \\p buf_len was large enough. This makes it possible"]
    #[doc = "                 to determine the necessary size by calling this function"]
    #[doc = "                 with \\p buf set to \\c NULL and \\p buf_len to \\c 0."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \\p buf is too small."]
    pub fn mbedtls_ssl_session_save(
        session: *const mbedtls_ssl_session,
        buf: *mut crate::c_types::c_uchar,
        buf_len: size_t,
        olen: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               Set the list of allowed ciphersuites and the preference"]
    #[doc = "                      order. First in the list has the highest preference."]
    #[doc = ""]
    #[doc = "                      For TLS 1.2, the notion of ciphersuite determines both"]
    #[doc = "                      the key exchange mechanism and the suite of symmetric"]
    #[doc = "                      algorithms to be used during and after the handshake."]
    #[doc = ""]
    #[doc = "                      For TLS 1.3 (in development), the notion of ciphersuite"]
    #[doc = "                      only determines the suite of symmetric algorithms to be"]
    #[doc = "                      used during and after the handshake, while key exchange"]
    #[doc = "                      mechanisms are configured separately."]
    #[doc = ""]
    #[doc = "                      In Mbed TLS, ciphersuites for both TLS 1.2 and TLS 1.3"]
    #[doc = "                      are configured via this function. For users of TLS 1.3,"]
    #[doc = "                      there will be separate API for the configuration of key"]
    #[doc = "                      exchange mechanisms."]
    #[doc = ""]
    #[doc = "                      The list of ciphersuites passed to this function may"]
    #[doc = "                      contain a mixture of TLS 1.2 and TLS 1.3 ciphersuite"]
    #[doc = "                      identifiers. This is useful if negotiation of TLS 1.3"]
    #[doc = "                      should be attempted, but a fallback to TLS 1.2 would"]
    #[doc = "                      be tolerated."]
    #[doc = ""]
    #[doc = " \\note                By default, the server chooses its preferred"]
    #[doc = "                      ciphersuite among those that the client supports. If"]
    #[doc = "                      mbedtls_ssl_conf_preference_order() is called to prefer"]
    #[doc = "                      the client's preferences, the server instead chooses"]
    #[doc = "                      the client's preferred ciphersuite among those that"]
    #[doc = "                      the server supports."]
    #[doc = ""]
    #[doc = " \\warning             The ciphersuites array \\p ciphersuites is not copied."]
    #[doc = "                      It must remain valid for the lifetime of the SSL"]
    #[doc = "                      configuration \\p conf."]
    #[doc = ""]
    #[doc = " \\param conf          The SSL configuration to modify."]
    #[doc = " \\param ciphersuites  A 0-terminated list of IANA identifiers of supported"]
    #[doc = "                      ciphersuites, accessible through \\c MBEDTLS_TLS_XXX"]
    #[doc = "                      and \\c MBEDTLS_TLS1_3_XXX macros defined in"]
    #[doc = "                      ssl_ciphersuites.h."]
    pub fn mbedtls_ssl_conf_ciphersuites(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set the supported key exchange modes for TLS 1.3 connections."]
    #[doc = ""]
    #[doc = "        In contrast to TLS 1.2, the ciphersuite concept in TLS 1.3 does not"]
    #[doc = "        include the choice of key exchange mechanism. It is therefore not"]
    #[doc = "        covered by the API mbedtls_ssl_conf_ciphersuites(). See the"]
    #[doc = "        documentation of mbedtls_ssl_conf_ciphersuites() for more"]
    #[doc = "        information on the ciphersuite concept in TLS 1.2 and TLS 1.3."]
    #[doc = ""]
    #[doc = "        The present function is specific to TLS 1.3 and allows users to"]
    #[doc = "        configure the set of supported key exchange mechanisms in TLS 1.3."]
    #[doc = ""]
    #[doc = " \\param conf       The SSL configuration the change should apply to."]
    #[doc = " \\param kex_modes  A bitwise combination of one or more of the following:"]
    #[doc = "                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK"]
    #[doc = "                     This flag enables pure-PSK key exchanges."]
    #[doc = "                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL"]
    #[doc = "                     This flag enables combined PSK-ephemeral key exchanges."]
    #[doc = "                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL"]
    #[doc = "                     This flag enables pure-ephemeral key exchanges."]
    #[doc = "                   For convenience, the following pre-defined macros are"]
    #[doc = "                   available for combinations of the above:"]
    #[doc = "                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL"]
    #[doc = "                     Includes all of pure-PSK, PSK-ephemeral and pure-ephemeral."]
    #[doc = "                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL"]
    #[doc = "                     Includes both pure-PSK and combined PSK-ephemeral"]
    #[doc = "                     key exchanges, but excludes pure-ephemeral key exchanges."]
    #[doc = "                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL"]
    #[doc = "                     Includes both pure-ephemeral and combined PSK-ephemeral"]
    #[doc = "                     key exchanges."]
    #[doc = ""]
    #[doc = " \\note  If a PSK-based key exchange mode shall be supported, applications"]
    #[doc = "        must also use the APIs mbedtls_ssl_conf_psk() or"]
    #[doc = "        mbedtls_ssl_conf_psk_cb() or mbedtls_ssl_conf_psk_opaque()"]
    #[doc = "        to configure the PSKs to be used."]
    #[doc = ""]
    #[doc = " \\note  If a pure-ephemeral key exchange mode shall be supported,"]
    #[doc = "        server-side applications must also provide a certificate via"]
    #[doc = "        mbedtls_ssl_conf_own_cert()."]
    #[doc = ""]
    pub fn mbedtls_ssl_conf_tls13_key_exchange_modes(
        conf: *mut mbedtls_ssl_config,
        kex_modes: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               Specify the length of Connection IDs for incoming"]
    #[doc = "                      encrypted DTLS records, as well as the behaviour"]
    #[doc = "                      on unexpected CIDs."]
    #[doc = ""]
    #[doc = "                      By default, the CID length is set to \\c 0,"]
    #[doc = "                      and unexpected CIDs are silently ignored."]
    #[doc = ""]
    #[doc = " \\param conf          The SSL configuration to modify."]
    #[doc = " \\param len           The length in Bytes of the CID fields in encrypted"]
    #[doc = "                      DTLS records using the CID mechanism. This must"]
    #[doc = "                      not be larger than #MBEDTLS_SSL_CID_OUT_LEN_MAX."]
    #[doc = " \\param ignore_other_cids This determines the stack's behaviour when"]
    #[doc = "                          receiving a record with an unexpected CID."]
    #[doc = "                          Possible values are:"]
    #[doc = "                          - #MBEDTLS_SSL_UNEXPECTED_CID_IGNORE"]
    #[doc = "                            In this case, the record is silently ignored."]
    #[doc = "                          - #MBEDTLS_SSL_UNEXPECTED_CID_FAIL"]
    #[doc = "                            In this case, the stack fails with the specific"]
    #[doc = "                            error code #MBEDTLS_ERR_SSL_UNEXPECTED_CID."]
    #[doc = ""]
    #[doc = " \\note                The CID specification allows implementations to either"]
    #[doc = "                      use a common length for all incoming connection IDs or"]
    #[doc = "                      allow variable-length incoming IDs. Mbed TLS currently"]
    #[doc = "                      requires a common length for all connections sharing the"]
    #[doc = "                      same SSL configuration; this allows simpler parsing of"]
    #[doc = "                      record headers."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if \\p own_cid_len"]
    #[doc = "                      is too large."]
    pub fn mbedtls_ssl_conf_cid(
        conf: *mut mbedtls_ssl_config,
        len: size_t,
        ignore_other_cids: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the X.509 security profile used for verification"]
    #[doc = ""]
    #[doc = " \\note           The restrictions are enforced for all certificates in the"]
    #[doc = "                 chain. However, signatures in the handshake are not covered"]
    #[doc = "                 by this setting but by \\b mbedtls_ssl_conf_sig_hashes()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param profile  Profile to use"]
    pub fn mbedtls_ssl_conf_cert_profile(
        conf: *mut mbedtls_ssl_config,
        profile: *const mbedtls_x509_crt_profile,
    );
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate"]
    #[doc = ""]
    #[doc = " \\note           See \\c mbedtls_x509_crt_verify() for notes regarding the"]
    #[doc = "                 parameters ca_chain (maps to trust_ca for that function)"]
    #[doc = "                 and ca_crl."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)"]
    #[doc = " \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_conf_ca_chain(
        conf: *mut mbedtls_ssl_config,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set own certificate chain and private key"]
    #[doc = ""]
    #[doc = " \\note           own_cert should contain in order from the bottom up your"]
    #[doc = "                 certificate chain. The top certificate (self-signed)"]
    #[doc = "                 can be omitted."]
    #[doc = ""]
    #[doc = " \\note           On server, this function can be called multiple times to"]
    #[doc = "                 provision more than one cert/key pair (eg one ECDSA, one"]
    #[doc = "                 RSA with SHA-256, one RSA with SHA-1). An adequate"]
    #[doc = "                 certificate will be selected according to the client's"]
    #[doc = "                 advertised capabilities. In case multiple certificates are"]
    #[doc = "                 adequate, preference is given to the one set by the first"]
    #[doc = "                 call to this function, then second, etc."]
    #[doc = ""]
    #[doc = " \\note           On client, only the first call has any effect. That is,"]
    #[doc = "                 only one client certificate can be provisioned. The"]
    #[doc = "                 server's preferences in its CertificateRequest message will"]
    #[doc = "                 be ignored and our only cert will be sent regardless of"]
    #[doc = "                 whether it matches those preferences - the server can then"]
    #[doc = "                 decide what it wants to do with it."]
    #[doc = ""]
    #[doc = " \\note           The provided \\p pk_key needs to match the public key in the"]
    #[doc = "                 first certificate in \\p own_cert, or all handshakes using"]
    #[doc = "                 that certificate will fail. It is your responsibility"]
    #[doc = "                 to ensure that; this function will not perform any check."]
    #[doc = "                 You may use mbedtls_pk_check_pair() in order to perform"]
    #[doc = "                 this check yourself, but be aware that this function can"]
    #[doc = "                 be computationally expensive on some key types."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param own_cert own public certificate chain"]
    #[doc = " \\param pk_key   own private key"]
    #[doc = ""]
    #[doc = " \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_conf_own_cert(
        conf: *mut mbedtls_ssl_config,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Configure pre-shared keys (PSKs) and their"]
    #[doc = "                 identities to be used in PSK-based ciphersuites."]
    #[doc = ""]
    #[doc = "                 Only one PSK can be registered, through either"]
    #[doc = "                 mbedtls_ssl_conf_psk() or mbedtls_ssl_conf_psk_opaque()."]
    #[doc = "                 If you attempt to register more than one PSK, this function"]
    #[doc = "                 fails, though this may change in future versions, which"]
    #[doc = "                 may add support for multiple PSKs."]
    #[doc = ""]
    #[doc = " \\note           This is mainly useful for clients. Servers will usually"]
    #[doc = "                 want to use \\c mbedtls_ssl_conf_psk_cb() instead."]
    #[doc = ""]
    #[doc = " \\note           A PSK set by \\c mbedtls_ssl_set_hs_psk() in the PSK callback"]
    #[doc = "                 takes precedence over a PSK configured by this function."]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to register the PSK with."]
    #[doc = " \\param psk      The pointer to the pre-shared key to use."]
    #[doc = " \\param psk_len  The length of the pre-shared key in bytes."]
    #[doc = " \\param psk_identity      The pointer to the pre-shared key identity."]
    #[doc = " \\param psk_identity_len  The length of the pre-shared key identity"]
    #[doc = "                          in bytes."]
    #[doc = ""]
    #[doc = " \\note           The PSK and its identity are copied internally and"]
    #[doc = "                 hence need not be preserved by the caller for the lifetime"]
    #[doc = "                 of the SSL configuration."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no more PSKs"]
    #[doc = "                 can be configured. In this case, the old PSK(s) remain intact."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_ssl_conf_psk(
        conf: *mut mbedtls_ssl_config,
        psk: *const crate::c_types::c_uchar,
        psk_len: size_t,
        psk_identity: *const crate::c_types::c_uchar,
        psk_identity_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the pre-shared Key (PSK) for the current handshake."]
    #[doc = ""]
    #[doc = " \\note           This should only be called inside the PSK callback,"]
    #[doc = "                 i.e. the function passed to \\c mbedtls_ssl_conf_psk_cb()."]
    #[doc = ""]
    #[doc = " \\note           A PSK set by this function takes precedence over a PSK"]
    #[doc = "                 configured by \\c mbedtls_ssl_conf_psk()."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to configure a PSK for."]
    #[doc = " \\param psk      The pointer to the pre-shared key."]
    #[doc = " \\param psk_len  The length of the pre-shared key in bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_SSL_XXX error code on failure."]
    pub fn mbedtls_ssl_set_hs_psk(
        ssl: *mut mbedtls_ssl_context,
        psk: *const crate::c_types::c_uchar,
        psk_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the PSK callback (server-side only)."]
    #[doc = ""]
    #[doc = "                 If set, the PSK callback is called for each"]
    #[doc = "                 handshake where a PSK-based ciphersuite was negotiated."]
    #[doc = "                 The caller provides the identity received and wants to"]
    #[doc = "                 receive the actual PSK data and length."]
    #[doc = ""]
    #[doc = "                 The callback has the following parameters:"]
    #[doc = "                 - \\c void*: The opaque pointer \\p p_psk."]
    #[doc = "                 - \\c mbedtls_ssl_context*: The SSL context to which"]
    #[doc = "                                            the operation applies."]
    #[doc = "                 - \\c const unsigned char*: The PSK identity"]
    #[doc = "                                            selected by the client."]
    #[doc = "                 - \\c size_t: The length of the PSK identity"]
    #[doc = "                              selected by the client."]
    #[doc = ""]
    #[doc = "                 If a valid PSK identity is found, the callback should use"]
    #[doc = "                 \\c mbedtls_ssl_set_hs_psk() or"]
    #[doc = "                 \\c mbedtls_ssl_set_hs_psk_opaque()"]
    #[doc = "                 on the SSL context to set the correct PSK and return \\c 0."]
    #[doc = "                 Any other return value will result in a denied PSK identity."]
    #[doc = ""]
    #[doc = " \\note           A dynamic PSK (i.e. set by the PSK callback) takes"]
    #[doc = "                 precedence over a static PSK (i.e. set by"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk() or"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk_opaque())."]
    #[doc = "                 This means that if you set a PSK callback using this"]
    #[doc = "                 function, you don't need to set a PSK using"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk() or"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk_opaque())."]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to register the callback with."]
    #[doc = " \\param f_psk    The callback for selecting and setting the PSK based"]
    #[doc = "                 in the PSK identity chosen by the client."]
    #[doc = " \\param p_psk    A pointer to an opaque structure to be passed to"]
    #[doc = "                 the callback, for example a PSK store."]
    pub fn mbedtls_ssl_conf_psk_cb(
        conf: *mut mbedtls_ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const crate::c_types::c_uchar,
                arg4: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_psk: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values"]
    #[doc = "                 from big-endian binary presentations."]
    #[doc = "                 (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_P    Diffie-Hellman-Merkle modulus in big-endian binary form"]
    #[doc = " \\param P_len    Length of DHM modulus"]
    #[doc = " \\param dhm_G    Diffie-Hellman-Merkle generator in big-endian binary form"]
    #[doc = " \\param G_len    Length of DHM generator"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ssl_conf_dh_param_bin(
        conf: *mut mbedtls_ssl_config,
        dhm_P: *const crate::c_types::c_uchar,
        P_len: size_t,
        dhm_G: *const crate::c_types::c_uchar,
        G_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values,"]
    #[doc = "                 read from existing context (server-side only)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_ctx  Diffie-Hellman-Merkle context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ssl_conf_dh_param_ctx(
        conf: *mut mbedtls_ssl_config,
        dhm_ctx: *mut mbedtls_dhm_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the minimum length for Diffie-Hellman parameters."]
    #[doc = "                 (Client-side only.)"]
    #[doc = "                 (Default: 1024 bits.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param bitlen   Minimum bit length of the DHM prime"]
    pub fn mbedtls_ssl_conf_dhm_min_bitlen(
        conf: *mut mbedtls_ssl_config,
        bitlen: crate::c_types::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Set the allowed curves in order of preference."]
    #[doc = ""]
    #[doc = "                 On server: this only affects selection of the ECDHE curve;"]
    #[doc = "                 the curves used for ECDH and ECDSA are determined by the"]
    #[doc = "                 list of available certificates instead."]
    #[doc = ""]
    #[doc = "                 On client: this affects the list of curves offered for any"]
    #[doc = "                 use. The server can override our preference order."]
    #[doc = ""]
    #[doc = "                 Both sides: limits the set of curves accepted for use in"]
    #[doc = "                 ECDHE and in the peer's end-entity certificate."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_ssl_conf_groups()."]
    #[doc = ""]
    #[doc = " \\note           This has no influence on which curves are allowed inside the"]
    #[doc = "                 certificate chains, see \\c mbedtls_ssl_conf_cert_profile()"]
    #[doc = "                 for that. For the end-entity certificate however, the key"]
    #[doc = "                 will be accepted only if it is allowed both by this list"]
    #[doc = "                 and by the cert profile."]
    #[doc = ""]
    #[doc = " \\note           This list should be ordered by decreasing preference"]
    #[doc = "                 (preferred curve first)."]
    #[doc = ""]
    #[doc = " \\note           The default list is the same set of curves that"]
    #[doc = "                 #mbedtls_x509_crt_profile_default allows, plus"]
    #[doc = "                 ECDHE-only curves selected according to the same criteria."]
    #[doc = "                 The order favors curves with the lowest resource usage."]
    #[doc = ""]
    #[doc = " \\note           New minor versions of Mbed TLS may extend this list,"]
    #[doc = "                 for example if new curves are added to the library."]
    #[doc = "                 New minor versions of Mbed TLS will not remove items"]
    #[doc = "                 from this list unless serious security concerns require it."]
    #[doc = "                 New minor versions of Mbed TLS may change the order in"]
    #[doc = "                 keeping with the general principle of favoring the lowest"]
    #[doc = "                 resource usage."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param curves   Ordered list of allowed curves,"]
    #[doc = "                 terminated by MBEDTLS_ECP_DP_NONE."]
    pub fn mbedtls_ssl_conf_curves(
        conf: *mut mbedtls_ssl_config,
        curves: *const mbedtls_ecp_group_id,
    );
}
extern "C" {
    #[doc = " \\brief          Set the allowed groups in order of preference."]
    #[doc = ""]
    #[doc = "                 On server: This only affects the choice of key agreement mechanism"]
    #[doc = ""]
    #[doc = "                 On client: this affects the list of groups offered for any"]
    #[doc = "                 use. The server can override our preference order."]
    #[doc = ""]
    #[doc = "                 Both sides: limits the set of groups accepted for use in"]
    #[doc = "                 key sharing."]
    #[doc = ""]
    #[doc = " \\note           This function replaces the deprecated mbedtls_ssl_conf_curves(),"]
    #[doc = "                 which only allows ECP curves to be configured."]
    #[doc = ""]
    #[doc = " \\note           The most recent invocation of either mbedtls_ssl_conf_curves()"]
    #[doc = "                 or mbedtls_ssl_conf_groups() nullifies all previous invocations"]
    #[doc = "                 of both."]
    #[doc = ""]
    #[doc = " \\note           This list should be ordered by decreasing preference"]
    #[doc = "                 (preferred group first)."]
    #[doc = ""]
    #[doc = " \\note           When this function is not called, a default list is used,"]
    #[doc = "                 consisting of all supported curves at 255 bits and above,"]
    #[doc = "                 and all supported finite fields at 2048 bits and above."]
    #[doc = "                 The order favors groups with the lowest resource usage."]
    #[doc = ""]
    #[doc = " \\note           New minor versions of Mbed TLS will not remove items"]
    #[doc = "                 from the default list unless serious security concerns require it."]
    #[doc = "                 New minor versions of Mbed TLS may change the order in"]
    #[doc = "                 keeping with the general principle of favoring the lowest"]
    #[doc = "                 resource usage."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param groups   List of allowed groups ordered by preference, terminated by 0."]
    #[doc = "                 Must contain valid IANA NamedGroup IDs (provided via either an integer"]
    #[doc = "                 or using MBEDTLS_TLS1_3_NAMED_GROUP_XXX macros)."]
    pub fn mbedtls_ssl_conf_groups(conf: *mut mbedtls_ssl_config, groups: *const u16);
}
extern "C" {
    #[doc = " \\brief          Set the allowed hashes for signatures during the handshake."]
    #[doc = ""]
    #[doc = " \\note           This only affects which hashes are offered and can be used"]
    #[doc = "                 for signatures during the handshake. Hashes for message"]
    #[doc = "                 authentication and the TLS PRF are controlled by the"]
    #[doc = "                 ciphersuite, see \\c mbedtls_ssl_conf_ciphersuites(). Hashes"]
    #[doc = "                 used for certificate signature are controlled by the"]
    #[doc = "                 verification profile, see \\c mbedtls_ssl_conf_cert_profile()."]
    #[doc = ""]
    #[doc = " \\note           This list should be ordered by decreasing preference"]
    #[doc = "                 (preferred hash first)."]
    #[doc = ""]
    #[doc = " \\note           By default, all supported hashes whose length is at least"]
    #[doc = "                 256 bits are allowed. This is the same set as the default"]
    #[doc = "                 for certificate verification"]
    #[doc = "                 (#mbedtls_x509_crt_profile_default)."]
    #[doc = "                 The preference order is currently unspecified and may"]
    #[doc = "                 change in future versions."]
    #[doc = ""]
    #[doc = " \\note           New minor versions of Mbed TLS may extend this list,"]
    #[doc = "                 for example if new curves are added to the library."]
    #[doc = "                 New minor versions of Mbed TLS will not remove items"]
    #[doc = "                 from this list unless serious security concerns require it."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param hashes   Ordered list of allowed signature hashes,"]
    #[doc = "                 terminated by \\c MBEDTLS_MD_NONE."]
    pub fn mbedtls_ssl_conf_sig_hashes(
        conf: *mut mbedtls_ssl_config,
        hashes: *const crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Configure allowed signature algorithms for use in TLS 1.3"]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to use."]
    #[doc = " \\param sig_algs List of allowed IANA values for TLS 1.3 signature algorithms,"]
    #[doc = "                 terminated by \\c MBEDTLS_TLS1_3_SIG_NONE. The list must remain"]
    #[doc = "                 available throughout the lifetime of the conf object. Supported"]
    #[doc = "                 values are available as \\c MBEDTLS_TLS1_3_SIG_XXXX"]
    pub fn mbedtls_ssl_conf_sig_algs(conf: *mut mbedtls_ssl_config, sig_algs: *const u16);
}
extern "C" {
    #[doc = " \\brief          Set or reset the hostname to check against the received"]
    #[doc = "                 server certificate. It sets the ServerName TLS extension,"]
    #[doc = "                 too, if that extension is enabled. (client-side only)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param hostname the server hostname, may be NULL to clear hostname"]
    #[doc = ""]
    #[doc = " \\note           Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN."]
    #[doc = ""]
    #[doc = " \\return         0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on"]
    #[doc = "                 allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on"]
    #[doc = "                 too long input hostname."]
    #[doc = ""]
    #[doc = "                 Hostname set to the one provided on success (cleared"]
    #[doc = "                 when NULL). On allocation failure hostname is cleared."]
    #[doc = "                 On too long input failure, old hostname is unchanged."]
    pub fn mbedtls_ssl_set_hostname(
        ssl: *mut mbedtls_ssl_context,
        hostname: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Retrieve SNI extension value for the current handshake."]
    #[doc = "                 Available in \\p f_cert_cb of \\c mbedtls_ssl_conf_cert_cb(),"]
    #[doc = "                 this is the same value passed to \\p f_sni callback of"]
    #[doc = "                 \\c mbedtls_ssl_conf_sni() and may be used instead of"]
    #[doc = "                 \\c mbedtls_ssl_conf_sni()."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param name_len pointer into which to store length of returned value."]
    #[doc = "                 0 if SNI extension is not present or not yet processed."]
    #[doc = ""]
    #[doc = " \\return         const pointer to SNI extension value."]
    #[doc = "                 - value is valid only when called in \\p f_cert_cb"]
    #[doc = "                   registered with \\c mbedtls_ssl_conf_cert_cb()."]
    #[doc = "                 - value is NULL if SNI extension is not present."]
    #[doc = "                 - value is not '\\0'-terminated.  Use \\c name_len for len."]
    #[doc = "                 - value must not be freed."]
    pub fn mbedtls_ssl_get_hs_sni(
        ssl: *mut mbedtls_ssl_context,
        name_len: *mut size_t,
    ) -> *const crate::c_types::c_uchar;
}
extern "C" {
    #[doc = " \\brief          Set own certificate and key for the current handshake"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_own_cert() but for use within"]
    #[doc = "                 the SNI callback or the certificate selection callback."]
    #[doc = ""]
    #[doc = " \\note           Passing null \\c own_cert clears the certificate list for"]
    #[doc = "                 the current handshake."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param own_cert own public certificate chain"]
    #[doc = " \\param pk_key   own private key"]
    #[doc = ""]
    #[doc = " \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_set_hs_own_cert(
        ssl: *mut mbedtls_ssl_context,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate for the"]
    #[doc = "                 current handshake"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_ca_chain() but for use within"]
    #[doc = "                 the SNI callback or the certificate selection callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)"]
    #[doc = " \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_set_hs_ca_chain(
        ssl: *mut mbedtls_ssl_context,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set DN hints sent to client in CertificateRequest message"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_dn_hints() but for use within"]
    #[doc = "                 the SNI callback or the certificate selection callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param crt      crt chain whose subject DNs are issuer DNs of client certs"]
    #[doc = "                 from which the client should select client peer certificate."]
    pub fn mbedtls_ssl_set_hs_dn_hints(ssl: *mut mbedtls_ssl_context, crt: *const mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief          Set authmode for the current handshake."]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_authmode() but for use within"]
    #[doc = "                 the SNI callback or the certificate selection callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or"]
    #[doc = "                 MBEDTLS_SSL_VERIFY_REQUIRED"]
    pub fn mbedtls_ssl_set_hs_authmode(
        ssl: *mut mbedtls_ssl_context,
        authmode: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set server side ServerName TLS extension callback"]
    #[doc = "                 (optional, server-side only)."]
    #[doc = ""]
    #[doc = "                 If set, the ServerName callback is called whenever the"]
    #[doc = "                 server receives a ServerName TLS extension from the client"]
    #[doc = "                 during a handshake. The ServerName callback has the"]
    #[doc = "                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,"]
    #[doc = "                 const unsigned char *hostname, size_t len). If a suitable"]
    #[doc = "                 certificate is found, the callback must set the"]
    #[doc = "                 certificate(s) and key(s) to use with \\c"]
    #[doc = "                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),"]
    #[doc = "                 and may optionally adjust the CA and associated CRL with \\c"]
    #[doc = "                 mbedtls_ssl_set_hs_ca_chain() as well as the client"]
    #[doc = "                 authentication mode with \\c mbedtls_ssl_set_hs_authmode(),"]
    #[doc = "                 then must return 0. If no matching name is found, the"]
    #[doc = "                 callback may return non-zero to abort the handshake."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_sni    verification function"]
    #[doc = " \\param p_sni    verification parameter"]
    pub fn mbedtls_ssl_conf_sni(
        conf: *mut mbedtls_ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const crate::c_types::c_uchar,
                arg4: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_sni: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the supported Application Layer Protocols."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param protos   Pointer to a NULL-terminated list of supported protocols,"]
    #[doc = "                 in decreasing preference order. The pointer to the list is"]
    #[doc = "                 recorded by the library for later reference as required, so"]
    #[doc = "                 the lifetime of the table must be at least as long as the"]
    #[doc = "                 lifetime of the SSL configuration structure."]
    #[doc = ""]
    #[doc = " \\return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA."]
    pub fn mbedtls_ssl_conf_alpn_protocols(
        conf: *mut mbedtls_ssl_config,
        protos: *mut *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Get the name of the negotiated Application Layer Protocol."]
    #[doc = "                 This function should be called after the handshake is"]
    #[doc = "                 completed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Protocol name, or NULL if no protocol was negotiated."]
    pub fn mbedtls_ssl_get_alpn_protocol(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief          Set the maximum supported version sent from the client side"]
    #[doc = "                 and/or accepted at the server side."]
    #[doc = ""]
    #[doc = "                 See also the documentation of mbedtls_ssl_conf_min_version()."]
    #[doc = ""]
    #[doc = " \\note           This ignores ciphersuites from higher versions."]
    #[doc = ""]
    #[doc = " \\note           This function is deprecated and has been replaced by"]
    #[doc = "                 \\c mbedtls_ssl_conf_max_tls_version()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)"]
    #[doc = " \\param minor    Minor version number"]
    #[doc = "                 (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,"]
    #[doc = "                 #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)"]
    pub fn mbedtls_ssl_conf_max_version(
        conf: *mut mbedtls_ssl_config,
        major: crate::c_types::c_int,
        minor: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the minimum accepted SSL/TLS protocol version"]
    #[doc = ""]
    #[doc = " \\note           By default, all supported versions are accepted."]
    #[doc = "                 Future versions of the library may disable older"]
    #[doc = "                 protocol versions by default if they become deprecated."]
    #[doc = ""]
    #[doc = " \\note           The following versions are supported (if enabled at"]
    #[doc = "                 compile time):"]
    #[doc = "                 - (D)TLS 1.2: \\p major = #MBEDTLS_SSL_MAJOR_VERSION_3,"]
    #[doc = "                   \\p minor = #MBEDTLS_SSL_MINOR_VERSION_3"]
    #[doc = "                 - TLS 1.3: \\p major = #MBEDTLS_SSL_MAJOR_VERSION_3,"]
    #[doc = "                   \\p minor = #MBEDTLS_SSL_MINOR_VERSION_4"]
    #[doc = ""]
    #[doc = "                 Note that the numbers in the constant names are the"]
    #[doc = "                 TLS internal protocol numbers, and the minor versions"]
    #[doc = "                 differ by one from the human-readable versions!"]
    #[doc = ""]
    #[doc = " \\note           Input outside of the SSL_MAX_XXXXX_VERSION and"]
    #[doc = "                 SSL_MIN_XXXXX_VERSION range is ignored."]
    #[doc = ""]
    #[doc = " \\note           After the handshake, you can call"]
    #[doc = "                 mbedtls_ssl_get_version_number() to see what version was"]
    #[doc = "                 negotiated."]
    #[doc = ""]
    #[doc = " \\note           This function is deprecated and has been replaced by"]
    #[doc = "                 \\c mbedtls_ssl_conf_min_tls_version()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)"]
    #[doc = " \\param minor    Minor version number"]
    #[doc = "                 (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,"]
    #[doc = "                 #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)"]
    pub fn mbedtls_ssl_conf_min_version(
        conf: *mut mbedtls_ssl_config,
        major: crate::c_types::c_int,
        minor: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief           Enable or disable Encrypt-then-MAC"]
    #[doc = "                  (Default: MBEDTLS_SSL_ETM_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note            This should always be enabled, it is a security"]
    #[doc = "                  improvement, and should not cause any interoperability"]
    #[doc = "                  issue (used only if the peer supports it too)."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED"]
    pub fn mbedtls_ssl_conf_encrypt_then_mac(
        conf: *mut mbedtls_ssl_config,
        etm: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief           Enable or disable Extended Master Secret negotiation."]
    #[doc = "                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note            This should always be enabled, it is a security fix to the"]
    #[doc = "                  protocol, and should not cause any interoperability issue"]
    #[doc = "                  (used only if the peer supports it too)."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED"]
    pub fn mbedtls_ssl_conf_extended_master_secret(
        conf: *mut mbedtls_ssl_config,
        ems: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Whether to send a list of acceptable CAs in"]
    #[doc = "                 CertificateRequest messages."]
    #[doc = "                 (Default: do send)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or"]
    #[doc = "                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED"]
    pub fn mbedtls_ssl_conf_cert_req_ca_list(
        conf: *mut mbedtls_ssl_config,
        cert_req_ca_list: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Set the maximum fragment length to emit and/or negotiate."]
    #[doc = "                 (Typical: the smaller of #MBEDTLS_SSL_IN_CONTENT_LEN and"]
    #[doc = "                 #MBEDTLS_SSL_OUT_CONTENT_LEN, usually `2^14` bytes)"]
    #[doc = "                 (Server: set maximum fragment length to emit,"]
    #[doc = "                 usually negotiated by the client during handshake)"]
    #[doc = "                 (Client: set maximum fragment length to emit *and*"]
    #[doc = "                 negotiate with the server during handshake)"]
    #[doc = "                 (Default: #MBEDTLS_SSL_MAX_FRAG_LEN_NONE)"]
    #[doc = ""]
    #[doc = " \\note           On the client side, the maximum fragment length extension"]
    #[doc = "                 *will not* be used, unless the maximum fragment length has"]
    #[doc = "                 been set via this function to a value different than"]
    #[doc = "                 #MBEDTLS_SSL_MAX_FRAG_LEN_NONE."]
    #[doc = ""]
    #[doc = " \\note           With TLS, this currently only affects ApplicationData (sent"]
    #[doc = "                 with \\c mbedtls_ssl_read()), not handshake messages."]
    #[doc = "                 With DTLS, this affects both ApplicationData and handshake."]
    #[doc = ""]
    #[doc = " \\note           This sets the maximum length for a record's payload,"]
    #[doc = "                 excluding record overhead that will be added to it, see"]
    #[doc = "                 \\c mbedtls_ssl_get_record_expansion()."]
    #[doc = ""]
    #[doc = " \\note           For DTLS, it is also possible to set a limit for the total"]
    #[doc = "                 size of datagrams passed to the transport layer, including"]
    #[doc = "                 record overhead, see \\c mbedtls_ssl_set_mtu()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param mfl_code Code for maximum fragment length (allowed values:"]
    #[doc = "                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,"]
    #[doc = "                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA"]
    pub fn mbedtls_ssl_conf_max_frag_len(
        conf: *mut mbedtls_ssl_config,
        mfl_code: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Pick the ciphersuites order according to the second parameter"]
    #[doc = "                 in the SSL Server module (MBEDTLS_SSL_SRV_C)."]
    #[doc = "                 (Default, if never called: MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param order    Server or client (MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER"]
    #[doc = "                                or MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT)"]
    pub fn mbedtls_ssl_conf_preference_order(
        conf: *mut mbedtls_ssl_config,
        order: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enable / Disable session tickets (client only)."]
    #[doc = "                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)"]
    #[doc = ""]
    #[doc = " \\note           On server, use \\c mbedtls_ssl_conf_session_tickets_cb()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or"]
    #[doc = "                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)"]
    pub fn mbedtls_ssl_conf_session_tickets(
        conf: *mut mbedtls_ssl_config,
        use_tickets: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief   Number of NewSessionTicket messages for the server to send"]
    #[doc = "          after handshake completion."]
    #[doc = ""]
    #[doc = " \\note    The default value is"]
    #[doc = "          \\c MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS."]
    #[doc = ""]
    #[doc = " \\note    In case of a session resumption, this setting only partially apply."]
    #[doc = "          At most one ticket is sent in that case to just renew the pool of"]
    #[doc = "          tickets of the client. The rationale is to avoid the number of"]
    #[doc = "          tickets on the server to become rapidly out of control when the"]
    #[doc = "          server has the same configuration for all its connection instances."]
    #[doc = ""]
    #[doc = " \\param conf    SSL configuration"]
    #[doc = " \\param num_tickets    Number of NewSessionTicket."]
    #[doc = ""]
    pub fn mbedtls_ssl_conf_new_session_tickets(conf: *mut mbedtls_ssl_config, num_tickets: u16);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable renegotiation support for connection when"]
    #[doc = "                 initiated by peer"]
    #[doc = "                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    #[doc = ""]
    #[doc = " \\warning        It is recommended to always disable renegotiation unless you"]
    #[doc = "                 know you need it and you know what you're doing. In the"]
    #[doc = "                 past, there have been several issues associated with"]
    #[doc = "                 renegotiation or a poor understanding of its properties."]
    #[doc = ""]
    #[doc = " \\note           Server-side, enabling renegotiation also makes the server"]
    #[doc = "                 susceptible to a resource DoS by a malicious client."]
    #[doc = ""]
    #[doc = " \\param conf    SSL configuration"]
    #[doc = " \\param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or"]
    #[doc = "                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    pub fn mbedtls_ssl_conf_renegotiation(
        conf: *mut mbedtls_ssl_config,
        renegotiation: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Prevent or allow legacy renegotiation."]
    #[doc = "                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to"]
    #[doc = "                 be established even if the peer does not support"]
    #[doc = "                 secure renegotiation, but does not allow renegotiation"]
    #[doc = "                 to take place if not secure."]
    #[doc = "                 (Interoperable and secure option)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations"]
    #[doc = "                 with non-upgraded peers. Allowing legacy renegotiation"]
    #[doc = "                 makes the connection vulnerable to specific man in the"]
    #[doc = "                 middle attacks. (See RFC 5746)"]
    #[doc = "                 (Most interoperable and least secure option)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections"]
    #[doc = "                 if peer does not support secure renegotiation. Results"]
    #[doc = "                 in interoperability issues with non-upgraded peers"]
    #[doc = "                 that do not support renegotiation altogether."]
    #[doc = "                 (Most secure option, interoperability issues)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,"]
    #[doc = "                                        SSL_ALLOW_LEGACY_RENEGOTIATION or"]
    #[doc = "                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)"]
    pub fn mbedtls_ssl_conf_legacy_renegotiation(
        conf: *mut mbedtls_ssl_config,
        allow_legacy: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enforce renegotiation requests."]
    #[doc = "                 (Default: enforced, max_records = 16)"]
    #[doc = ""]
    #[doc = "                 When we request a renegotiation, the peer can comply or"]
    #[doc = "                 ignore the request. This function allows us to decide"]
    #[doc = "                 whether to enforce our renegotiation requests by closing"]
    #[doc = "                 the connection if the peer doesn't comply."]
    #[doc = ""]
    #[doc = "                 However, records could already be in transit from the peer"]
    #[doc = "                 when the request is emitted. In order to increase"]
    #[doc = "                 reliability, we can accept a number of records before the"]
    #[doc = "                 expected handshake records."]
    #[doc = ""]
    #[doc = "                 The optimal value is highly dependent on the specific usage"]
    #[doc = "                 scenario."]
    #[doc = ""]
    #[doc = " \\note           With DTLS and server-initiated renegotiation, the"]
    #[doc = "                 HelloRequest is retransmitted every time mbedtls_ssl_read() times"]
    #[doc = "                 out or receives Application Data, until:"]
    #[doc = "                 - max_records records have beens seen, if it is >= 0, or"]
    #[doc = "                 - the number of retransmits that would happen during an"]
    #[doc = "                 actual handshake has been reached."]
    #[doc = "                 Please remember the request might be lost a few times"]
    #[doc = "                 if you consider setting max_records to a really low value."]
    #[doc = ""]
    #[doc = " \\warning        On client, the grace period can only happen during"]
    #[doc = "                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()"]
    #[doc = "                 which always behave as if max_record was 0. The reason is,"]
    #[doc = "                 if we receive application data from the server, we need a"]
    #[doc = "                 place to write it, which only happens during mbedtls_ssl_read()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to"]
    #[doc = "                 enforce renegotiation, or a non-negative value to enforce"]
    #[doc = "                 it but allow for a grace period of max_records records."]
    pub fn mbedtls_ssl_conf_renegotiation_enforced(
        conf: *mut mbedtls_ssl_config,
        max_records: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set record counter threshold for periodic renegotiation."]
    #[doc = "                 (Default: 2^48 - 1)"]
    #[doc = ""]
    #[doc = "                 Renegotiation is automatically triggered when a record"]
    #[doc = "                 counter (outgoing or incoming) crosses the defined"]
    #[doc = "                 threshold. The default value is meant to prevent the"]
    #[doc = "                 connection from being closed when the counter is about to"]
    #[doc = "                 reached its maximal value (it is not allowed to wrap)."]
    #[doc = ""]
    #[doc = "                 Lower values can be used to enforce policies such as \"keys"]
    #[doc = "                 must be refreshed every N packets with cipher X\"."]
    #[doc = ""]
    #[doc = "                 The renegotiation period can be disabled by setting"]
    #[doc = "                 conf->disable_renegotiation to"]
    #[doc = "                 MBEDTLS_SSL_RENEGOTIATION_DISABLED."]
    #[doc = ""]
    #[doc = " \\note           When the configured transport is"]
    #[doc = "                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation"]
    #[doc = "                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,"]
    #[doc = "                 the maximum renegotiation period is 2^64 - 1."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param period   The threshold value: a big-endian 64-bit number."]
    pub fn mbedtls_ssl_conf_renegotiation_period(
        conf: *mut mbedtls_ssl_config,
        period: *const crate::c_types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Check if there is data already read from the"]
    #[doc = "                 underlying transport but not yet processed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if nothing's pending, 1 otherwise."]
    #[doc = ""]
    #[doc = " \\note           This is different in purpose and behaviour from"]
    #[doc = "                 \\c mbedtls_ssl_get_bytes_avail in that it considers"]
    #[doc = "                 any kind of unprocessed data, not only unread"]
    #[doc = "                 application data. If \\c mbedtls_ssl_get_bytes"]
    #[doc = "                 returns a non-zero value, this function will"]
    #[doc = "                 also signal pending data, but the converse does"]
    #[doc = "                 not hold. For example, in DTLS there might be"]
    #[doc = "                 further records waiting to be processed from"]
    #[doc = "                 the current underlying transport's datagram."]
    #[doc = ""]
    #[doc = " \\note           If this function returns 1 (data pending), this"]
    #[doc = "                 does not imply that a subsequent call to"]
    #[doc = "                 \\c mbedtls_ssl_read will provide any data;"]
    #[doc = "                 e.g., the unprocessed data might turn out"]
    #[doc = "                 to be an alert or a handshake message."]
    #[doc = ""]
    #[doc = " \\note           This function is useful in the following situation:"]
    #[doc = "                 If the SSL/TLS module successfully returns from an"]
    #[doc = "                 operation - e.g. a handshake or an application record"]
    #[doc = "                 read - and you're awaiting incoming data next, you"]
    #[doc = "                 must not immediately idle on the underlying transport"]
    #[doc = "                 to have data ready, but you need to check the value"]
    #[doc = "                 of this function first. The reason is that the desired"]
    #[doc = "                 data might already be read but not yet processed."]
    #[doc = "                 If, in contrast, a previous call to the SSL/TLS module"]
    #[doc = "                 returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary"]
    #[doc = "                 to call this function, as the latter error code entails"]
    #[doc = "                 that all internal data has been processed."]
    #[doc = ""]
    pub fn mbedtls_ssl_check_pending(ssl: *const mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of application data bytes"]
    #[doc = "                 remaining to be read from the current record."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         How many bytes are available in the application"]
    #[doc = "                 data record read buffer."]
    #[doc = ""]
    #[doc = " \\note           When working over a datagram transport, this is"]
    #[doc = "                 useful to detect the current datagram's boundary"]
    #[doc = "                 in case \\c mbedtls_ssl_read has written the maximal"]
    #[doc = "                 amount of data fitting into the input buffer."]
    #[doc = ""]
    pub fn mbedtls_ssl_get_bytes_avail(ssl: *const mbedtls_ssl_context) -> size_t;
}
extern "C" {
    #[doc = " \\brief          Return the result of the certificate verification"]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to use."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the certificate verification was successful."]
    #[doc = " \\return         \\c -1u if the result is not available. This may happen"]
    #[doc = "                 e.g. if the handshake aborts early, or a verification"]
    #[doc = "                 callback returned a fatal error."]
    #[doc = " \\return         A bitwise combination of \\c MBEDTLS_X509_BADCERT_XXX"]
    #[doc = "                 and \\c MBEDTLS_X509_BADCRL_XXX failure flags; see x509.h."]
    pub fn mbedtls_ssl_get_verify_result(ssl: *const mbedtls_ssl_context) -> u32;
}
extern "C" {
    #[doc = " \\brief          Return the id of the current ciphersuite"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         a ciphersuite id"]
    pub fn mbedtls_ssl_get_ciphersuite_id_from_ssl(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the name of the current ciphersuite"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the current TLS version"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         a string containing the TLS version"]
    pub fn mbedtls_ssl_get_version(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the (maximum) number of bytes added by the record"]
    #[doc = "                 layer: header + encryption/MAC overhead (inc. padding)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum record expansion in bytes"]
    pub fn mbedtls_ssl_get_record_expansion(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum outgoing record payload in bytes."]
    #[doc = ""]
    #[doc = " \\note           The logic to determine the maximum outgoing record payload is"]
    #[doc = "                 version-specific. It takes into account various factors, such as"]
    #[doc = "                 the mbedtls_config.h setting \\c MBEDTLS_SSL_OUT_CONTENT_LEN, extensions"]
    #[doc = "                 such as the max fragment length or record size limit extension if"]
    #[doc = "                 used, and for DTLS the path MTU as configured and current"]
    #[doc = "                 record expansion."]
    #[doc = ""]
    #[doc = " \\note           With DTLS, \\c mbedtls_ssl_write() will return an error if"]
    #[doc = "                 called with a larger length value."]
    #[doc = "                 With TLS, \\c mbedtls_ssl_write() will fragment the input if"]
    #[doc = "                 necessary and return the number of bytes written; it is up"]
    #[doc = "                 to the caller to call \\c mbedtls_ssl_write() again in"]
    #[doc = "                 order to send the remaining bytes if any."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_get_max_out_record_payload()"]
    #[doc = " \\sa             mbedtls_ssl_get_record_expansion()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum payload for an outgoing record,"]
    #[doc = "                 or a negative error code."]
    pub fn mbedtls_ssl_get_max_out_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum incoming record payload in bytes."]
    #[doc = ""]
    #[doc = " \\note           The logic to determine the maximum incoming record payload is"]
    #[doc = "                 version-specific. It takes into account various factors, such as"]
    #[doc = "                 the mbedtls_config.h setting \\c MBEDTLS_SSL_IN_CONTENT_LEN, extensions"]
    #[doc = "                 such as the max fragment length extension or record size limit"]
    #[doc = "                 extension if used, and the current record expansion."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_set_mtu()"]
    #[doc = " \\sa             mbedtls_ssl_get_max_in_record_payload()"]
    #[doc = " \\sa             mbedtls_ssl_get_record_expansion()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum payload for an incoming record,"]
    #[doc = "                 or a negative error code."]
    pub fn mbedtls_ssl_get_max_in_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the peer certificate from the current connection."]
    #[doc = ""]
    #[doc = " \\param  ssl     The SSL context to use. This must be initialized and setup."]
    #[doc = ""]
    #[doc = " \\return         The current peer certificate, if available."]
    #[doc = "                 The returned certificate is owned by the SSL context and"]
    #[doc = "                 is valid only until the next call to the SSL API."]
    #[doc = " \\return         \\c NULL if no peer certificate is available. This might"]
    #[doc = "                 be because the chosen ciphersuite doesn't use CRTs"]
    #[doc = "                 (PSK-based ciphersuites, for example), or because"]
    #[doc = "                 #MBEDTLS_SSL_KEEP_PEER_CERTIFICATE has been disabled,"]
    #[doc = "                 allowing the stack to free the peer's CRT to save memory."]
    #[doc = ""]
    #[doc = " \\note           For one-time inspection of the peer's certificate during"]
    #[doc = "                 the handshake, consider registering an X.509 CRT verification"]
    #[doc = "                 callback through mbedtls_ssl_conf_verify() instead of calling"]
    #[doc = "                 this function. Using mbedtls_ssl_conf_verify() also comes at"]
    #[doc = "                 the benefit of allowing you to influence the verification"]
    #[doc = "                 process, for example by masking expected and tolerated"]
    #[doc = "                 verification failures."]
    #[doc = ""]
    #[doc = " \\warning        You must not use the pointer returned by this function"]
    #[doc = "                 after any further call to the SSL API, including"]
    #[doc = "                 mbedtls_ssl_read() and mbedtls_ssl_write(); this is"]
    #[doc = "                 because the pointer might change during renegotiation,"]
    #[doc = "                 which happens transparently to the user."]
    #[doc = "                 If you want to use the certificate across API calls,"]
    #[doc = "                 you must make a copy."]
    pub fn mbedtls_ssl_get_peer_cert(ssl: *const mbedtls_ssl_context) -> *const mbedtls_x509_crt;
}
extern "C" {
    #[doc = " \\brief          Export a session in order to resume it later."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context representing the connection for which to"]
    #[doc = "                 to export a session structure for later resumption."]
    #[doc = " \\param session  The target structure in which to store the exported session."]
    #[doc = "                 This must have been initialized with mbedtls_ssl_init_session()"]
    #[doc = "                 but otherwise be unused."]
    #[doc = ""]
    #[doc = " \\note           This function can handle a variety of mechanisms for session"]
    #[doc = "                 resumption: For TLS 1.2, both session ID-based resumption and"]
    #[doc = "                 ticket-based resumption will be considered. For TLS 1.3,"]
    #[doc = "                 once implemented, sessions equate to tickets, and calling"]
    #[doc = "                 this function multiple times will export the available"]
    #[doc = "                 tickets one a time until no further tickets are available,"]
    #[doc = "                 in which case MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE will"]
    #[doc = "                 be returned."]
    #[doc = ""]
    #[doc = " \\note           Calling this function multiple times will only be useful"]
    #[doc = "                 once TLS 1.3 is supported. For TLS 1.2 connections, this"]
    #[doc = "                 function should be called at most once."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful. In this case, \\p session can be used for"]
    #[doc = "                 session resumption by passing it to mbedtls_ssl_set_session(),"]
    #[doc = "                 and serialized for storage via mbedtls_ssl_session_save()."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no further session"]
    #[doc = "                 is available for export."]
    #[doc = "                 This error is a non-fatal, and has no observable effect on"]
    #[doc = "                 the SSL context or the destination session."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_set_session()"]
    #[doc = " \\sa             mbedtls_ssl_session_save()"]
    pub fn mbedtls_ssl_get_session(
        ssl: *const mbedtls_ssl_context,
        session: *mut mbedtls_ssl_session,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform the SSL handshake"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE"]
    #[doc = "                 if the handshake is incomplete and waiting for data to"]
    #[doc = "                 be available for reading from or writing to the underlying"]
    #[doc = "                 transport - in this case you must call this function again"]
    #[doc = "                 when the underlying transport is ready for the operation."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous"]
    #[doc = "                 operation is in progress (see"]
    #[doc = "                 mbedtls_ssl_conf_async_private_cb()) - in this case you"]
    #[doc = "                 must call this function again when the operation is ready."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic"]
    #[doc = "                 operation is in progress (see mbedtls_ecp_set_max_ops()) -"]
    #[doc = "                 in this case you must call this function again to complete"]
    #[doc = "                 the handshake when you're done attending other tasks."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use"]
    #[doc = "                 and the client did not demonstrate reachability yet - in"]
    #[doc = "                 this case you must stop using the context (see below)."]
    #[doc = " \\return         Another SSL error code - in this case you must stop using"]
    #[doc = "                 the context (see below)."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than"]
    #[doc = "                 \\c 0,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,"]
    #[doc = "                 you must stop using the SSL context for reading or writing,"]
    #[doc = "                 and either free it or call \\c mbedtls_ssl_session_reset()"]
    #[doc = "                 on it before re-using it for a new connection; the current"]
    #[doc = "                 connection must be closed."]
    #[doc = ""]
    #[doc = " \\note           If DTLS is in use, then you may choose to handle"]
    #[doc = "                 #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging"]
    #[doc = "                 purposes, as it is an expected return value rather than an"]
    #[doc = "                 actual error, but you still need to reset/free the context."]
    #[doc = ""]
    #[doc = " \\note           Remarks regarding event-driven DTLS:"]
    #[doc = "                 If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram"]
    #[doc = "                 from the underlying transport layer is currently being processed,"]
    #[doc = "                 and it is safe to idle until the timer or the underlying transport"]
    #[doc = "                 signal a new event. This is not true for a successful handshake,"]
    #[doc = "                 in which case the datagram of the underlying transport that is"]
    #[doc = "                 currently being processed might or might not contain further"]
    #[doc = "                 DTLS records."]
    #[doc = ""]
    #[doc = " \\note           If the context is configured to allow TLS 1.3, or if"]
    #[doc = "                 #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto"]
    #[doc = "                 subsystem must have been initialized by calling"]
    #[doc = "                 psa_crypto_init() before calling this function."]
    pub fn mbedtls_ssl_handshake(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a single step of the SSL handshake"]
    #[doc = ""]
    #[doc = " \\note           The state of the context (ssl->state) will be at"]
    #[doc = "                 the next state after this function returns \\c 0. Do not"]
    #[doc = "                 call this function if mbedtls_ssl_is_handshake_over()"]
    #[doc = "                 returns \\c 1."]
    #[doc = ""]
    #[doc = " \\warning        Whilst in the past you may have used direct access to the"]
    #[doc = "                 context state (ssl->state) in order to ascertain when to"]
    #[doc = "                 stop calling this function and although you can still do"]
    #[doc = "                 so with something like ssl->MBEDTLS_PRIVATE(state) or by"]
    #[doc = "                 defining MBEDTLS_ALLOW_PRIVATE_ACCESS, this is now"]
    #[doc = "                 considered deprecated and could be broken in any future"]
    #[doc = "                 release. If you still find you have good reason for such"]
    #[doc = "                 direct access, then please do contact the team to explain"]
    #[doc = "                 this (raise an issue or post to the mailing list), so that"]
    #[doc = "                 we can add a solution to your problem that will be"]
    #[doc = "                 guaranteed to work in the future."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         See mbedtls_ssl_handshake()."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than \\c 0,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it"]
    #[doc = "                 or call \\c mbedtls_ssl_session_reset() on it before"]
    #[doc = "                 re-using it for a new connection; the current connection"]
    #[doc = "                 must be closed."]
    pub fn mbedtls_ssl_handshake_step(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initiate an SSL renegotiation on the running connection."]
    #[doc = "                 Client: perform the renegotiation right now."]
    #[doc = "                 Server: request renegotiation, which will be performed"]
    #[doc = "                 during the next call to mbedtls_ssl_read() if honored by"]
    #[doc = "                 client."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or any mbedtls_ssl_handshake() return"]
    #[doc = "                 value except #MBEDTLS_ERR_SSL_CLIENT_RECONNECT that can't"]
    #[doc = "                 happen during a renegotiation."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than \\c 0,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it"]
    #[doc = "                 or call \\c mbedtls_ssl_session_reset() on it before"]
    #[doc = "                 re-using it for a new connection; the current connection"]
    #[doc = "                 must be closed."]
    #[doc = ""]
    pub fn mbedtls_ssl_renegotiate(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Read at most 'len' application data bytes"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param buf      buffer that will hold the data"]
    #[doc = " \\param len      maximum number of bytes to read"]
    #[doc = ""]
    #[doc = " \\return         The (positive) number of bytes read if successful."]
    #[doc = " \\return         \\c 0 if the read end of the underlying transport was closed"]
    #[doc = "                 without sending a CloseNotify beforehand, which might happen"]
    #[doc = "                 because of various reasons (internal error of an underlying"]
    #[doc = "                 stack, non-conformant peer not sending a CloseNotify and"]
    #[doc = "                 such) - in this case you must stop using the context"]
    #[doc = "                 (see below)."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY if the underlying"]
    #[doc = "                 transport is still functional, but the peer has"]
    #[doc = "                 acknowledged to not send anything anymore."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE"]
    #[doc = "                 if the handshake is incomplete and waiting for data to"]
    #[doc = "                 be available for reading from or writing to the underlying"]
    #[doc = "                 transport - in this case you must call this function again"]
    #[doc = "                 when the underlying transport is ready for the operation."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous"]
    #[doc = "                 operation is in progress (see"]
    #[doc = "                 mbedtls_ssl_conf_async_private_cb()) - in this case you"]
    #[doc = "                 must call this function again when the operation is ready."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic"]
    #[doc = "                 operation is in progress (see mbedtls_ecp_set_max_ops()) -"]
    #[doc = "                 in this case you must call this function again to complete"]
    #[doc = "                 the handshake when you're done attending other tasks."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CLIENT_RECONNECT if we're at the server"]
    #[doc = "                 side of a DTLS connection and the client is initiating a"]
    #[doc = "                 new connection using the same source port. See below."]
    #[doc = " \\return         Another SSL error code - in this case you must stop using"]
    #[doc = "                 the context (see below)."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than"]
    #[doc = "                 a positive value,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CLIENT_RECONNECT,"]
    #[doc = "                 you must stop using the SSL context for reading or writing,"]
    #[doc = "                 and either free it or call \\c mbedtls_ssl_session_reset()"]
    #[doc = "                 on it before re-using it for a new connection; the current"]
    #[doc = "                 connection must be closed."]
    #[doc = ""]
    #[doc = " \\note           When this function returns #MBEDTLS_ERR_SSL_CLIENT_RECONNECT"]
    #[doc = "                 (which can only happen server-side), it means that a client"]
    #[doc = "                 is initiating a new connection using the same source port."]
    #[doc = "                 You can either treat that as a connection close and wait"]
    #[doc = "                 for the client to resend a ClientHello, or directly"]
    #[doc = "                 continue with \\c mbedtls_ssl_handshake() with the same"]
    #[doc = "                 context (as it has been reset internally). Either way, you"]
    #[doc = "                 must make sure this is seen by the application as a new"]
    #[doc = "                 connection: application state, if any, should be reset, and"]
    #[doc = "                 most importantly the identity of the client must be checked"]
    #[doc = "                 again. WARNING: not validating the identity of the client"]
    #[doc = "                 again, or not transmitting the new identity to the"]
    #[doc = "                 application layer, would allow authentication bypass!"]
    #[doc = ""]
    #[doc = " \\note           Remarks regarding event-driven DTLS:"]
    #[doc = "                 - If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram"]
    #[doc = "                   from the underlying transport layer is currently being processed,"]
    #[doc = "                   and it is safe to idle until the timer or the underlying transport"]
    #[doc = "                   signal a new event."]
    #[doc = "                 - This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was"]
    #[doc = "                   initially available on the underlying transport, as this data may have"]
    #[doc = "                   been only e.g. duplicated messages or a renegotiation request."]
    #[doc = "                   Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even"]
    #[doc = "                   when reacting to an incoming-data event from the underlying transport."]
    #[doc = "                 - On success, the datagram of the underlying transport that is currently"]
    #[doc = "                   being processed may contain further DTLS records. You should call"]
    #[doc = "                   \\c mbedtls_ssl_check_pending to check for remaining records."]
    #[doc = ""]
    pub fn mbedtls_ssl_read(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Try to write exactly 'len' application data bytes"]
    #[doc = ""]
    #[doc = " \\warning        This function will do partial writes in some cases. If the"]
    #[doc = "                 return value is non-negative but less than length, the"]
    #[doc = "                 function must be called again with updated arguments:"]
    #[doc = "                 buf + ret, len - ret (if ret is the return value) until"]
    #[doc = "                 it returns a value equal to the last 'len' argument."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param buf      buffer holding the data"]
    #[doc = " \\param len      how many bytes must be written"]
    #[doc = ""]
    #[doc = " \\return         The (non-negative) number of bytes actually written if"]
    #[doc = "                 successful (may be less than \\p len)."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE"]
    #[doc = "                 if the handshake is incomplete and waiting for data to"]
    #[doc = "                 be available for reading from or writing to the underlying"]
    #[doc = "                 transport - in this case you must call this function again"]
    #[doc = "                 when the underlying transport is ready for the operation."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous"]
    #[doc = "                 operation is in progress (see"]
    #[doc = "                 mbedtls_ssl_conf_async_private_cb()) - in this case you"]
    #[doc = "                 must call this function again when the operation is ready."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic"]
    #[doc = "                 operation is in progress (see mbedtls_ecp_set_max_ops()) -"]
    #[doc = "                 in this case you must call this function again to complete"]
    #[doc = "                 the handshake when you're done attending other tasks."]
    #[doc = " \\return         Another SSL error code - in this case you must stop using"]
    #[doc = "                 the context (see below)."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than"]
    #[doc = "                 a non-negative value,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,"]
    #[doc = "                 you must stop using the SSL context for reading or writing,"]
    #[doc = "                 and either free it or call \\c mbedtls_ssl_session_reset()"]
    #[doc = "                 on it before re-using it for a new connection; the current"]
    #[doc = "                 connection must be closed."]
    #[doc = ""]
    #[doc = " \\note           When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ,"]
    #[doc = "                 it must be called later with the *same* arguments,"]
    #[doc = "                 until it returns a value greater than or equal to 0. When"]
    #[doc = "                 the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be"]
    #[doc = "                 some partial data in the output buffer, however this is not"]
    #[doc = "                 yet sent."]
    #[doc = ""]
    #[doc = " \\note           If the requested length is greater than the maximum"]
    #[doc = "                 fragment length (either the built-in limit or the one set"]
    #[doc = "                 or negotiated with the peer), then:"]
    #[doc = "                 - with TLS, less bytes than requested are written."]
    #[doc = "                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned."]
    #[doc = "                 \\c mbedtls_ssl_get_max_out_record_payload() may be used to"]
    #[doc = "                 query the active maximum fragment length."]
    #[doc = ""]
    #[doc = " \\note           Attempting to write 0 bytes will result in an empty TLS"]
    #[doc = "                 application record being sent."]
    pub fn mbedtls_ssl_write(
        ssl: *mut mbedtls_ssl_context,
        buf: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Send an alert message"]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     The alert level of the message"]
    #[doc = "                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)"]
    #[doc = " \\param message   The alert message (SSL_ALERT_MSG_*)"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific SSL error code."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_send_alert_message(
        ssl: *mut mbedtls_ssl_context,
        level: crate::c_types::c_uchar,
        message: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Notify the peer that the connection is being closed"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific SSL error code."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_close_notify(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL context and clear memory"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    pub fn mbedtls_ssl_free(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Save an active connection as serialized data in a buffer."]
    #[doc = "                 This allows the freeing or re-using of the SSL context"]
    #[doc = "                 while still picking up the connection later in a way that"]
    #[doc = "                 it entirely transparent to the peer."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_context_load()"]
    #[doc = ""]
    #[doc = " \\note           The serialized data only contains the data that is"]
    #[doc = "                 necessary to resume the connection: negotiated protocol"]
    #[doc = "                 options, session identifier, keys, etc."]
    #[doc = "                 Loading a saved SSL context does not restore settings and"]
    #[doc = "                 state related to how the application accesses the context,"]
    #[doc = "                 such as configured callback functions, user data, pending"]
    #[doc = "                 incoming or outgoing data, etc."]
    #[doc = ""]
    #[doc = " \\note           This feature is currently only available under certain"]
    #[doc = "                 conditions, see the documentation of the return value"]
    #[doc = "                 #MBEDTLS_ERR_SSL_BAD_INPUT_DATA for details."]
    #[doc = ""]
    #[doc = " \\note           When this function succeeds, it calls"]
    #[doc = "                 mbedtls_ssl_session_reset() on \\p ssl which as a result is"]
    #[doc = "                 no longer associated with the connection that has been"]
    #[doc = "                 serialized. This avoids creating copies of the connection"]
    #[doc = "                 state. You're then free to either re-use the context"]
    #[doc = "                 structure for a different connection, or call"]
    #[doc = "                 mbedtls_ssl_free() on it. See the documentation of"]
    #[doc = "                 mbedtls_ssl_session_reset() for more details."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to save. On success, it is no longer"]
    #[doc = "                 associated with the connection that has been serialized."]
    #[doc = " \\param buf      The buffer to write the serialized data to. It must be a"]
    #[doc = "                 writeable buffer of at least \\p buf_len bytes, or may be \\c"]
    #[doc = "                 NULL if \\p buf_len is \\c 0."]
    #[doc = " \\param buf_len  The number of bytes available for writing in \\p buf."]
    #[doc = " \\param olen     The size in bytes of the data that has been or would have"]
    #[doc = "                 been written. It must point to a valid \\c size_t."]
    #[doc = ""]
    #[doc = " \\note           \\p olen is updated to the correct value regardless of"]
    #[doc = "                 whether \\p buf_len was large enough. This makes it possible"]
    #[doc = "                 to determine the necessary size by calling this function"]
    #[doc = "                 with \\p buf set to \\c NULL and \\p buf_len to \\c 0. However,"]
    #[doc = "                 the value of \\p olen is only guaranteed to be correct when"]
    #[doc = "                 the function returns #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL or"]
    #[doc = "                 \\c 0. If the return value is different, then the value of"]
    #[doc = "                 \\p olen is undefined."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \\p buf is too small."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed"]
    #[doc = "                 while resetting the context."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if a handshake is in"]
    #[doc = "                 progress, or there is pending data for reading or sending,"]
    #[doc = "                 or the connection does not use DTLS 1.2 with an AEAD"]
    #[doc = "                 ciphersuite, or renegotiation is enabled."]
    pub fn mbedtls_ssl_context_save(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        buf_len: size_t,
        olen: *mut size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Load serialized connection data to an SSL context."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_context_save()"]
    #[doc = ""]
    #[doc = " \\warning        The same serialized data must never be loaded into more"]
    #[doc = "                 that one context. In order to ensure that, after"]
    #[doc = "                 successfully loading serialized data to an SSL context, you"]
    #[doc = "                 should immediately destroy or invalidate all copies of the"]
    #[doc = "                 serialized data that was loaded. Loading the same data in"]
    #[doc = "                 more than one context would cause severe security failures"]
    #[doc = "                 including but not limited to loss of confidentiality."]
    #[doc = ""]
    #[doc = " \\note           Before calling this function, the SSL context must be"]
    #[doc = "                 prepared in one of the two following ways. The first way is"]
    #[doc = "                 to take a context freshly initialised with"]
    #[doc = "                 mbedtls_ssl_init() and call mbedtls_ssl_setup() on it with"]
    #[doc = "                 the same ::mbedtls_ssl_config structure that was used in"]
    #[doc = "                 the original connection. The second way is to"]
    #[doc = "                 call mbedtls_ssl_session_reset() on a context that was"]
    #[doc = "                 previously prepared as above but used in the meantime."]
    #[doc = "                 Either way, you must not use the context to perform a"]
    #[doc = "                 handshake between calling mbedtls_ssl_setup() or"]
    #[doc = "                 mbedtls_ssl_session_reset() and calling this function. You"]
    #[doc = "                 may however call other setter functions in that time frame"]
    #[doc = "                 as indicated in the note below."]
    #[doc = ""]
    #[doc = " \\note           Before or after calling this function successfully, you"]
    #[doc = "                 also need to configure some connection-specific callbacks"]
    #[doc = "                 and settings before you can use the connection again"]
    #[doc = "                 (unless they were already set before calling"]
    #[doc = "                 mbedtls_ssl_session_reset() and the values are suitable for"]
    #[doc = "                 the present connection). Specifically, you want to call"]
    #[doc = "                 at least mbedtls_ssl_set_bio(),"]
    #[doc = "                 mbedtls_ssl_set_timer_cb(), and"]
    #[doc = "                 mbedtls_ssl_set_user_data_n() or"]
    #[doc = "                 mbedtls_ssl_set_user_data_p() if they were set originally."]
    #[doc = "                 All other SSL setter functions"]
    #[doc = "                 are not necessary to call, either because they're only used"]
    #[doc = "                 in handshakes, or because the setting is already saved. You"]
    #[doc = "                 might choose to call them anyway, for example in order to"]
    #[doc = "                 share code between the cases of establishing a new"]
    #[doc = "                 connection and the case of loading an already-established"]
    #[doc = "                 connection."]
    #[doc = ""]
    #[doc = " \\note           If you have new information about the path MTU, you want to"]
    #[doc = "                 call mbedtls_ssl_set_mtu() after calling this function, as"]
    #[doc = "                 otherwise this function would overwrite your"]
    #[doc = "                 newly-configured value with the value that was active when"]
    #[doc = "                 the context was saved."]
    #[doc = ""]
    #[doc = " \\note           When this function returns an error code, it calls"]
    #[doc = "                 mbedtls_ssl_free() on \\p ssl. In this case, you need to"]
    #[doc = "                 prepare the context with the usual sequence starting with a"]
    #[doc = "                 call to mbedtls_ssl_init() if you want to use it again."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context structure to be populated. It must have"]
    #[doc = "                 been prepared as described in the note above."]
    #[doc = " \\param buf      The buffer holding the serialized connection data. It must"]
    #[doc = "                 be a readable buffer of at least \\p len bytes."]
    #[doc = " \\param len      The size of the serialized data in bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data"]
    #[doc = "                 comes from a different Mbed TLS version or build."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid."]
    pub fn mbedtls_ssl_context_load(
        ssl: *mut mbedtls_ssl_context,
        buf: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL configuration context"]
    #[doc = "                 Just makes the context ready for"]
    #[doc = "                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free()."]
    #[doc = ""]
    #[doc = " \\note           You need to call mbedtls_ssl_config_defaults() unless you"]
    #[doc = "                 manually set all of the relevant fields yourself."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_init(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Load reasonable default SSL configuration values."]
    #[doc = "                 (You need to call mbedtls_ssl_config_init() first.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[doc = " \\param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    #[doc = " \\param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS"]
    #[doc = " \\param preset   a MBEDTLS_SSL_PRESET_XXX value"]
    #[doc = ""]
    #[doc = " \\note           See \\c mbedtls_ssl_conf_transport() for notes on DTLS."]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or"]
    #[doc = "                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error."]
    pub fn mbedtls_ssl_config_defaults(
        conf: *mut mbedtls_ssl_config,
        endpoint: crate::c_types::c_int,
        transport: crate::c_types::c_int,
        preset: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free an SSL configuration context"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_free(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Initialize SSL session structure"]
    #[doc = ""]
    #[doc = " \\param session  SSL session"]
    pub fn mbedtls_ssl_session_init(session: *mut mbedtls_ssl_session);
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL session including the"]
    #[doc = "                 peer certificate and clear memory"]
    #[doc = ""]
    #[doc = " \\note           A session object can be freed even if the SSL context"]
    #[doc = "                 that was used to retrieve the session is still in use."]
    #[doc = ""]
    #[doc = " \\param session  SSL session"]
    pub fn mbedtls_ssl_session_free(session: *mut mbedtls_ssl_session);
}
extern "C" {
    #[doc = " \\brief          TLS-PRF function for key derivation."]
    #[doc = ""]
    #[doc = " \\param prf      The tls_prf type function type to be used."]
    #[doc = " \\param secret   Secret for the key derivation function."]
    #[doc = " \\param slen     Length of the secret."]
    #[doc = " \\param label    String label for the key derivation function,"]
    #[doc = "                 terminated with null character."]
    #[doc = " \\param random   Random bytes."]
    #[doc = " \\param rlen     Length of the random bytes buffer."]
    #[doc = " \\param dstbuf   The buffer holding the derived key."]
    #[doc = " \\param dlen     Length of the output buffer."]
    #[doc = ""]
    #[doc = " \\return         0 on success. An SSL specific error on failure."]
    pub fn mbedtls_ssl_tls_prf(
        prf: mbedtls_tls_prf_types,
        secret: *const crate::c_types::c_uchar,
        slen: size_t,
        label: *const crate::c_types::c_char,
        random: *const crate::c_types::c_uchar,
        rlen: size_t,
        dstbuf: *mut crate::c_types::c_uchar,
        dlen: size_t,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief           Entropy poll callback pointer"]
#[doc = ""]
#[doc = " \\param data      Callback-specific data pointer"]
#[doc = " \\param output    Data to fill"]
#[doc = " \\param len       Maximum size to provide"]
#[doc = " \\param olen      The actual amount of bytes put into the buffer (Can be 0)"]
#[doc = ""]
#[doc = " \\return          0 if no critical failures occurred,"]
#[doc = "                  MBEDTLS_ERR_ENTROPY_SOURCE_FAILED otherwise"]
pub type mbedtls_entropy_f_source_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        len: size_t,
        olen: *mut size_t,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief           Entropy source state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_entropy_source_state {
    pub private_f_source: mbedtls_entropy_f_source_ptr,
    pub private_p_source: *mut crate::c_types::c_void,
    pub private_size: size_t,
    pub private_threshold: size_t,
    pub private_strong: crate::c_types::c_int,
}
#[doc = " \\brief           Entropy context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_entropy_context {
    pub private_accumulator_started: crate::c_types::c_int,
    pub private_accumulator: mbedtls_sha512_context,
    pub private_source_count: crate::c_types::c_int,
    pub private_source: [mbedtls_entropy_source_state; 20usize],
}
extern "C" {
    #[doc = " \\brief           Initialize the context"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context to initialize"]
    pub fn mbedtls_entropy_init(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    #[doc = " \\brief           Free the data in the context"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context to free"]
    pub fn mbedtls_entropy_free(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    #[doc = " \\brief           Adds an entropy source to poll"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = " \\param f_source  Entropy function"]
    #[doc = " \\param p_source  Function data"]
    #[doc = " \\param threshold Minimum required from source before entropy is released"]
    #[doc = "                  ( with mbedtls_entropy_func() ) (in bytes)"]
    #[doc = " \\param strong    MBEDTLS_ENTROPY_SOURCE_STRONG or"]
    #[doc = "                  MBEDTLS_ENTROPY_SOURCE_WEAK."]
    #[doc = "                  At least one strong source needs to be added."]
    #[doc = "                  Weaker sources (such as the cycle counter) can be used as"]
    #[doc = "                  a complement."]
    #[doc = ""]
    #[doc = " \\return          0 if successful or MBEDTLS_ERR_ENTROPY_MAX_SOURCES"]
    pub fn mbedtls_entropy_add_source(
        ctx: *mut mbedtls_entropy_context,
        f_source: mbedtls_entropy_f_source_ptr,
        p_source: *mut crate::c_types::c_void,
        threshold: size_t,
        strong: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Trigger an extra gather poll for the accumulator"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_gather(ctx: *mut mbedtls_entropy_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Retrieve entropy from the accumulator"]
    #[doc = "                  (Maximum length: MBEDTLS_ENTROPY_BLOCK_SIZE)"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param data      Entropy context"]
    #[doc = " \\param output    Buffer to fill"]
    #[doc = " \\param len       Number of bytes desired, must be at most MBEDTLS_ENTROPY_BLOCK_SIZE"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_func(
        data: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Add data to the accumulator manually"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = " \\param data      Data to add"]
    #[doc = " \\param len       Length of data"]
    #[doc = ""]
    #[doc = " \\return          0 if successful"]
    pub fn mbedtls_entropy_update_manual(
        ctx: *mut mbedtls_entropy_context,
        data: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = "                 This module self-test also calls the entropy self-test,"]
    #[doc = "                 mbedtls_entropy_source_self_test();"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if a test failed"]
    pub fn mbedtls_entropy_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief   Set the threshold error level to handle globally all debug output."]
    #[doc = "          Debug messages that have a level over the threshold value are"]
    #[doc = "          discarded."]
    #[doc = "          (Default value: 0 = No debug )"]
    #[doc = ""]
    #[doc = " \\param threshold     threshold level of messages to filter on. Messages at a"]
    #[doc = "                      higher level will be discarded."]
    #[doc = "                          - Debug levels"]
    #[doc = "                              - 0 No debug"]
    #[doc = "                              - 1 Error"]
    #[doc = "                              - 2 State change"]
    #[doc = "                              - 3 Informational"]
    #[doc = "                              - 4 Verbose"]
    pub fn mbedtls_debug_set_threshold(threshold: crate::c_types::c_int);
}
extern "C" {
    #[doc = " \\brief    Print a message to the debug output. This function is always used"]
    #[doc = "          through the MBEDTLS_SSL_DEBUG_MSG() macro, which supplies the ssl"]
    #[doc = "          context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the message has occurred in"]
    #[doc = " \\param line      line number the message has occurred at"]
    #[doc = " \\param format    format specifier, in printf format"]
    #[doc = " \\param ...       variables used by the format specifier"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    pub fn mbedtls_debug_print_msg(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        format: *const crate::c_types::c_char,
        ...
    );
}
extern "C" {
    #[doc = " \\brief   Print the return value of a function to the debug output. This"]
    #[doc = "          function is always used through the MBEDTLS_SSL_DEBUG_RET() macro,"]
    #[doc = "          which supplies the ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      the name of the function that returned the error"]
    #[doc = " \\param ret       the return code value"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    pub fn mbedtls_debug_print_ret(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        ret: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief   Output a buffer of size len bytes to the debug output. This function"]
    #[doc = "          is always used through the MBEDTLS_SSL_DEBUG_BUF() macro,"]
    #[doc = "          which supplies the ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the buffer being dumped. Normally the"]
    #[doc = "                  variable or buffer name"]
    #[doc = " \\param buf       the buffer to be outputted"]
    #[doc = " \\param len       length of the buffer"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    pub fn mbedtls_debug_print_buf(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        buf: *const crate::c_types::c_uchar,
        len: size_t,
    );
}
extern "C" {
    #[doc = " \\brief   Print a MPI variable to the debug output. This function is always"]
    #[doc = "          used through the MBEDTLS_SSL_DEBUG_MPI() macro, which supplies the"]
    #[doc = "          ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the MPI being output. Normally the"]
    #[doc = "                  variable name"]
    #[doc = " \\param X         the MPI variable"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    pub fn mbedtls_debug_print_mpi(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        X: *const mbedtls_mpi,
    );
}
extern "C" {
    #[doc = " \\brief   Print an ECP point to the debug output. This function is always"]
    #[doc = "          used through the MBEDTLS_SSL_DEBUG_ECP() macro, which supplies the"]
    #[doc = "          ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the ECP point being output. Normally the"]
    #[doc = "                  variable name"]
    #[doc = " \\param X         the ECP point"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    pub fn mbedtls_debug_print_ecp(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        X: *const mbedtls_ecp_point,
    );
}
extern "C" {
    #[doc = " \\brief   Print a X.509 certificate structure to the debug output. This"]
    #[doc = "          function is always used through the MBEDTLS_SSL_DEBUG_CRT() macro,"]
    #[doc = "          which supplies the ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the certificate being output"]
    #[doc = " \\param crt       X.509 certificate structure"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    pub fn mbedtls_debug_print_crt(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        crt: *const mbedtls_x509_crt,
    );
}
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_Q: mbedtls_debug_ecdh_attr = 0;
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_QP: mbedtls_debug_ecdh_attr = 1;
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_Z: mbedtls_debug_ecdh_attr = 2;
pub type mbedtls_debug_ecdh_attr = crate::c_types::c_uint;
extern "C" {
    #[doc = " \\brief   Print a field of the ECDH structure in the SSL context to the debug"]
    #[doc = "          output. This function is always used through the"]
    #[doc = "          MBEDTLS_SSL_DEBUG_ECDH() macro, which supplies the ssl context, file"]
    #[doc = "          and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param ecdh      the ECDH context"]
    #[doc = " \\param attr      the identifier of the attribute being output"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    pub fn mbedtls_debug_printf_ecdh(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        ecdh: *const mbedtls_ecdh_context,
        attr: mbedtls_debug_ecdh_attr,
    );
}
#[doc = " \\brief The AES context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_context {
    pub private_nr: crate::c_types::c_int,
    pub private_rk_offset: size_t,
    pub private_buf: [u32; 68usize],
}
#[doc = " \\brief The AES XTS context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_xts_context {
    pub private_crypt: mbedtls_aes_context,
    pub private_tweak: mbedtls_aes_context,
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES context."]
    #[doc = ""]
    #[doc = "                 It must be the first API called before using"]
    #[doc = "                 the context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_aes_init(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to clear."]
    #[doc = "                 If this is \\c NULL, this function does nothing."]
    #[doc = "                 Otherwise, the context must have been at least initialized."]
    pub fn mbedtls_aes_free(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES XTS context."]
    #[doc = ""]
    #[doc = "                 It must be the first API called before using"]
    #[doc = "                 the context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_aes_xts_init(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES XTS context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to clear."]
    #[doc = "                 If this is \\c NULL, this function does nothing."]
    #[doc = "                 Otherwise, the context must have been at least initialized."]
    pub fn mbedtls_aes_xts_free(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The encryption key."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of data passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_setkey_enc(
        ctx: *mut mbedtls_aes_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the decryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The decryption key."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of data passed. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_setkey_dec(
        ctx: *mut mbedtls_aes_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for encryption and"]
    #[doc = "                 sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The encryption key. This is comprised of the XTS key1"]
    #[doc = "                 concatenated with the XTS key2."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of \\p key passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>"]
    #[doc = "                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_xts_setkey_enc(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for decryption and"]
    #[doc = "                 sets the decryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The decryption key. This is comprised of the XTS key1"]
    #[doc = "                 concatenated with the XTS key2."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of \\p key passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>"]
    #[doc = "                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_xts_setkey_dec(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an AES single-block encryption or"]
    #[doc = "                 decryption operation."]
    #[doc = ""]
    #[doc = "                 It performs the operation defined in the \\p mode parameter"]
    #[doc = "                 (encrypt or decrypt), on the input data buffer defined in"]
    #[doc = "                 the \\p input parameter."]
    #[doc = ""]
    #[doc = "                 mbedtls_aes_init(), and either mbedtls_aes_setkey_enc() or"]
    #[doc = "                 mbedtls_aes_setkey_dec() must be called before the first"]
    #[doc = "                 call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and at least \\c 16 Bytes long."]
    #[doc = " \\param output   The buffer where the output data will be written."]
    #[doc = "                 It must be writeable and at least \\c 16 Bytes long."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ecb(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief  This function performs an AES-CBC encryption or decryption operation"]
    #[doc = "         on full blocks."]
    #[doc = ""]
    #[doc = "         It performs the operation defined in the \\p mode"]
    #[doc = "         parameter (encrypt/decrypt), on the input data buffer defined in"]
    #[doc = "         the \\p input parameter."]
    #[doc = ""]
    #[doc = "         It can be called as many times as needed, until all the input"]
    #[doc = "         data is processed. mbedtls_aes_init(), and either"]
    #[doc = "         mbedtls_aes_setkey_enc() or mbedtls_aes_setkey_dec() must be called"]
    #[doc = "         before the first call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\note   This function operates on full blocks, that is, the input size"]
    #[doc = "         must be a multiple of the AES block size of \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\note   Upon exit, the content of the IV is updated so that you can"]
    #[doc = "         call the same function again on the next"]
    #[doc = "         block(s) of data and get the same result as if it was"]
    #[doc = "         encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "         If you need to retain the contents of the IV, you should"]
    #[doc = "         either save it manually or use the cipher module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length   The length of the input data in Bytes. This must be a"]
    #[doc = "                 multiple of the block size (\\c 16 Bytes)."]
    #[doc = " \\param iv       Initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH"]
    #[doc = "                 on failure."]
    pub fn mbedtls_aes_crypt_cbc(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: size_t,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-XTS encryption or decryption"]
    #[doc = "             operation for an entire XTS data unit."]
    #[doc = ""]
    #[doc = "             AES-XTS encrypts or decrypts blocks based on their location as"]
    #[doc = "             defined by a data unit number. The data unit number must be"]
    #[doc = "             provided by \\p data_unit."]
    #[doc = ""]
    #[doc = "             NIST SP 800-38E limits the maximum size of a data unit to 2^20"]
    #[doc = "             AES blocks. If the data unit is larger than this, this function"]
    #[doc = "             returns #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH."]
    #[doc = ""]
    #[doc = " \\param ctx          The AES XTS context to use for AES XTS operations."]
    #[doc = "                     It must be initialized and bound to a key."]
    #[doc = " \\param mode         The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                     #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length       The length of a data unit in Bytes. This can be any"]
    #[doc = "                     length between 16 bytes and 2^24 bytes inclusive"]
    #[doc = "                     (between 1 and 2^20 block cipher blocks)."]
    #[doc = " \\param data_unit    The address of the data unit encoded as an array of 16"]
    #[doc = "                     bytes in little-endian format. For disk encryption, this"]
    #[doc = "                     is typically the index of the block device sector that"]
    #[doc = "                     contains the data."]
    #[doc = " \\param input        The buffer holding the input data (which is an entire"]
    #[doc = "                     data unit). This function reads \\p length Bytes from \\p"]
    #[doc = "                     input."]
    #[doc = " \\param output       The buffer holding the output data (which is an entire"]
    #[doc = "                     data unit). This function writes \\p length Bytes to \\p"]
    #[doc = "                     output."]
    #[doc = ""]
    #[doc = " \\return             \\c 0 on success."]
    #[doc = " \\return             #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH if \\p length is"]
    #[doc = "                     smaller than an AES block in size (16 Bytes) or if \\p"]
    #[doc = "                     length is larger than 2^20 blocks (16 MiB)."]
    pub fn mbedtls_aes_crypt_xts(
        ctx: *mut mbedtls_aes_xts_context,
        mode: crate::c_types::c_int,
        length: size_t,
        data_unit: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB128 encryption or decryption"]
    #[doc = "        operation."]
    #[doc = ""]
    #[doc = "        It performs the operation defined in the \\p mode"]
    #[doc = "        parameter (encrypt or decrypt), on the input data buffer"]
    #[doc = "        defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "        For CFB, you must set up the context with mbedtls_aes_setkey_enc(),"]
    #[doc = "        regardless of whether you are performing an encryption or decryption"]
    #[doc = "        operation, that is, regardless of the \\p mode parameter. This is"]
    #[doc = "        because CFB mode uses the same key schedule for encryption and"]
    #[doc = "        decryption."]
    #[doc = ""]
    #[doc = " \\note  Upon exit, the content of the IV is updated so that you can"]
    #[doc = "        call the same function again on the next"]
    #[doc = "        block(s) of data and get the same result as if it was"]
    #[doc = "        encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "        If you need to retain the contents of the"]
    #[doc = "        IV, you must either save it manually or use the cipher"]
    #[doc = "        module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length   The length of the input data in Bytes."]
    #[doc = " \\param iv_off   The offset in IV (updated after use)."]
    #[doc = "                 It must point to a valid \\c size_t."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_cfb128(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: size_t,
        iv_off: *mut size_t,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB8 encryption or decryption"]
    #[doc = "        operation."]
    #[doc = ""]
    #[doc = "        It performs the operation defined in the \\p mode"]
    #[doc = "        parameter (encrypt/decrypt), on the input data buffer defined"]
    #[doc = "        in the \\p input parameter."]
    #[doc = ""]
    #[doc = "        Due to the nature of CFB, you must use the same key schedule for"]
    #[doc = "        both encryption and decryption operations. Therefore, you must"]
    #[doc = "        use the context initialized with mbedtls_aes_setkey_enc() for"]
    #[doc = "        both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT."]
    #[doc = ""]
    #[doc = " \\note  Upon exit, the content of the IV is updated so that you can"]
    #[doc = "        call the same function again on the next"]
    #[doc = "        block(s) of data and get the same result as if it was"]
    #[doc = "        encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "        If you need to retain the contents of the"]
    #[doc = "        IV, you should either save it manually or use the cipher"]
    #[doc = "        module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT"]
    #[doc = " \\param length   The length of the input data."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_cfb8(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: size_t,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       This function performs an AES-OFB (Output Feedback Mode)"]
    #[doc = "              encryption or decryption operation."]
    #[doc = ""]
    #[doc = "              For OFB, you must set up the context with"]
    #[doc = "              mbedtls_aes_setkey_enc(), regardless of whether you are"]
    #[doc = "              performing an encryption or decryption operation. This is"]
    #[doc = "              because OFB mode uses the same key schedule for encryption and"]
    #[doc = "              decryption."]
    #[doc = ""]
    #[doc = "              The OFB operation is identical for encryption or decryption,"]
    #[doc = "              therefore no operation mode needs to be specified."]
    #[doc = ""]
    #[doc = " \\note        Upon exit, the content of iv, the Initialisation Vector, is"]
    #[doc = "              updated so that you can call the same function again on the next"]
    #[doc = "              block(s) of data and get the same result as if it was encrypted"]
    #[doc = "              in one call. This allows a \"streaming\" usage, by initialising"]
    #[doc = "              iv_off to 0 before the first call, and preserving its value"]
    #[doc = "              between calls."]
    #[doc = ""]
    #[doc = "              For non-streaming use, the iv should be initialised on each call"]
    #[doc = "              to a unique value, and iv_off set to 0 on each call."]
    #[doc = ""]
    #[doc = "              If you need to retain the contents of the initialisation vector,"]
    #[doc = "              you must either save it manually or use the cipher module"]
    #[doc = "              instead."]
    #[doc = ""]
    #[doc = " \\warning     For the OFB mode, the initialisation vector must be unique"]
    #[doc = "              every encryption operation. Reuse of an initialisation vector"]
    #[doc = "              will compromise security."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param length   The length of the input data."]
    #[doc = " \\param iv_off   The offset in IV (updated after use)."]
    #[doc = "                 It must point to a valid \\c size_t."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ofb(
        ctx: *mut mbedtls_aes_context,
        length: size_t,
        iv_off: *mut size_t,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-CTR encryption or decryption"]
    #[doc = "             operation."]
    #[doc = ""]
    #[doc = "             Due to the nature of CTR, you must use the same key schedule"]
    #[doc = "             for both encryption and decryption operations. Therefore, you"]
    #[doc = "             must use the context initialized with mbedtls_aes_setkey_enc()"]
    #[doc = "             for both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT."]
    #[doc = ""]
    #[doc = " \\warning    You must never reuse a nonce value with the same key. Doing so"]
    #[doc = "             would void the encryption for the two messages encrypted with"]
    #[doc = "             the same nonce and key."]
    #[doc = ""]
    #[doc = "             There are two common strategies for managing nonces with CTR:"]
    #[doc = ""]
    #[doc = "             1. You can handle everything as a single message processed over"]
    #[doc = "             successive calls to this function. In that case, you want to"]
    #[doc = "             set \\p nonce_counter and \\p nc_off to 0 for the first call, and"]
    #[doc = "             then preserve the values of \\p nonce_counter, \\p nc_off and \\p"]
    #[doc = "             stream_block across calls to this function as they will be"]
    #[doc = "             updated by this function."]
    #[doc = ""]
    #[doc = "             With this strategy, you must not encrypt more than 2**128"]
    #[doc = "             blocks of data with the same key."]
    #[doc = ""]
    #[doc = "             2. You can encrypt separate messages by dividing the \\p"]
    #[doc = "             nonce_counter buffer in two areas: the first one used for a"]
    #[doc = "             per-message nonce, handled by yourself, and the second one"]
    #[doc = "             updated by this function internally."]
    #[doc = ""]
    #[doc = "             For example, you might reserve the first 12 bytes for the"]
    #[doc = "             per-message nonce, and the last 4 bytes for internal use. In that"]
    #[doc = "             case, before calling this function on a new message you need to"]
    #[doc = "             set the first 12 bytes of \\p nonce_counter to your chosen nonce"]
    #[doc = "             value, the last 4 to 0, and \\p nc_off to 0 (which will cause \\p"]
    #[doc = "             stream_block to be ignored). That way, you can encrypt at most"]
    #[doc = "             2**96 messages of up to 2**32 blocks each with the same key."]
    #[doc = ""]
    #[doc = "             The per-message nonce (or information sufficient to reconstruct"]
    #[doc = "             it) needs to be communicated with the ciphertext and must be unique."]
    #[doc = "             The recommended way to ensure uniqueness is to use a message"]
    #[doc = "             counter. An alternative is to generate random nonces, but this"]
    #[doc = "             limits the number of messages that can be securely encrypted:"]
    #[doc = "             for example, with 96-bit random nonces, you should not encrypt"]
    #[doc = "             more than 2**32 messages with the same key."]
    #[doc = ""]
    #[doc = "             Note that for both strategies, sizes are measured in blocks and"]
    #[doc = "             that an AES block is 16 bytes."]
    #[doc = ""]
    #[doc = " \\warning    Upon return, \\p stream_block contains sensitive data. Its"]
    #[doc = "             content must not be written to insecure storage and should be"]
    #[doc = "             securely discarded as soon as it's no longer needed."]
    #[doc = ""]
    #[doc = " \\param ctx              The AES context to use for encryption or decryption."]
    #[doc = "                         It must be initialized and bound to a key."]
    #[doc = " \\param length           The length of the input data."]
    #[doc = " \\param nc_off           The offset in the current \\p stream_block, for"]
    #[doc = "                         resuming within the current cipher stream. The"]
    #[doc = "                         offset pointer should be 0 at the start of a stream."]
    #[doc = "                         It must point to a valid \\c size_t."]
    #[doc = " \\param nonce_counter    The 128-bit nonce and counter."]
    #[doc = "                         It must be a readable-writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param stream_block     The saved stream block for resuming. This is"]
    #[doc = "                         overwritten by the function."]
    #[doc = "                         It must be a readable-writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input            The buffer holding the input data."]
    #[doc = "                         It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output           The buffer holding the output data."]
    #[doc = "                         It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return                 \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ctr(
        ctx: *mut mbedtls_aes_context,
        length: size_t,
        nc_off: *mut size_t,
        nonce_counter: *mut crate::c_types::c_uchar,
        stream_block: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block encryption function. This is only"]
    #[doc = "                  exposed to allow overriding it using"]
    #[doc = "                  \\c MBEDTLS_AES_ENCRYPT_ALT."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for encryption."]
    #[doc = " \\param input     The plaintext block."]
    #[doc = " \\param output    The output (ciphertext) block."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_internal_aes_encrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block decryption function. This is only"]
    #[doc = "                  exposed to allow overriding it using see"]
    #[doc = "                  \\c MBEDTLS_AES_DECRYPT_ALT."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for decryption."]
    #[doc = " \\param input     The ciphertext block."]
    #[doc = " \\param output    The output (plaintext) block."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_internal_aes_decrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_aes_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The CTR_DRBG context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ctr_drbg_context {
    pub private_counter: [crate::c_types::c_uchar; 16usize],
    pub private_reseed_counter: crate::c_types::c_int,
    pub private_prediction_resistance: crate::c_types::c_int,
    pub private_entropy_len: size_t,
    pub private_reseed_interval: crate::c_types::c_int,
    pub private_aes_ctx: mbedtls_aes_context,
    pub private_f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut crate::c_types::c_uchar,
            arg3: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_entropy: *mut crate::c_types::c_void,
}
extern "C" {
    #[doc = " \\brief               This function initializes the CTR_DRBG context,"]
    #[doc = "                      and prepares it for mbedtls_ctr_drbg_seed()"]
    #[doc = "                      or mbedtls_ctr_drbg_free()."]
    #[doc = ""]
    #[doc = " \\note                The reseed interval is"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_RESEED_INTERVAL by default."]
    #[doc = "                      You can override it by calling"]
    #[doc = "                      mbedtls_ctr_drbg_set_reseed_interval()."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to initialize."]
    pub fn mbedtls_ctr_drbg_init(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    #[doc = " - The \\p custom string."]
    #[doc = ""]
    #[doc = " \\note                To achieve the nominal security strength permitted"]
    #[doc = "                      by CTR_DRBG, the entropy length must be:"]
    #[doc = "                      - at least 16 bytes for a 128-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-128);"]
    #[doc = "                      - at least 32 bytes for a 256-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-256)."]
    #[doc = ""]
    #[doc = "                      In addition, if you do not pass a nonce in \\p custom,"]
    #[doc = "                      the sum of the entropy length"]
    #[doc = "                      and the entropy nonce length must be:"]
    #[doc = "                      - at least 24 bytes for a 128-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-128);"]
    #[doc = "                      - at least 48 bytes for a 256-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-256)."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to seed."]
    #[doc = "                      It must have been initialized with"]
    #[doc = "                      mbedtls_ctr_drbg_init()."]
    #[doc = "                      After a successful call to mbedtls_ctr_drbg_seed(),"]
    #[doc = "                      you may not call mbedtls_ctr_drbg_seed() again on"]
    #[doc = "                      the same context unless you call"]
    #[doc = "                      mbedtls_ctr_drbg_free() and mbedtls_ctr_drbg_init()"]
    #[doc = "                      again first."]
    #[doc = "                      After a failed call to mbedtls_ctr_drbg_seed(),"]
    #[doc = "                      you must call mbedtls_ctr_drbg_free()."]
    #[doc = " \\param f_entropy     The entropy callback, taking as arguments the"]
    #[doc = "                      \\p p_entropy context, the buffer to fill, and the"]
    #[doc = "                      length of the buffer."]
    #[doc = "                      \\p f_entropy is always called with a buffer size"]
    #[doc = "                      less than or equal to the entropy length."]
    #[doc = " \\param p_entropy     The entropy context to pass to \\p f_entropy."]
    #[doc = " \\param custom        The personalization string."]
    #[doc = "                      This can be \\c NULL, in which case the personalization"]
    #[doc = "                      string is empty regardless of the value of \\p len."]
    #[doc = " \\param len           The length of the personalization string."]
    #[doc = "                      This must be at most"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT"]
    #[doc = "                      - #MBEDTLS_CTR_DRBG_ENTROPY_LEN."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    pub fn mbedtls_ctr_drbg_seed(
        ctx: *mut mbedtls_ctr_drbg_context,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: size_t,
            ) -> crate::c_types::c_int,
        >,
        p_entropy: *mut crate::c_types::c_void,
        custom: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function resets CTR_DRBG context to the state immediately"]
    #[doc = "                      after initial call of mbedtls_ctr_drbg_init()."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to clear."]
    pub fn mbedtls_ctr_drbg_free(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    #[doc = " \\brief               This function turns prediction resistance on or off."]
    #[doc = "                      The default value is off."]
    #[doc = ""]
    #[doc = " \\note                If enabled, entropy is gathered at the beginning of"]
    #[doc = "                      every call to mbedtls_ctr_drbg_random_with_add()"]
    #[doc = "                      or mbedtls_ctr_drbg_random()."]
    #[doc = "                      Only use this if your entropy source has sufficient"]
    #[doc = "                      throughput."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param resistance    #MBEDTLS_CTR_DRBG_PR_ON or #MBEDTLS_CTR_DRBG_PR_OFF."]
    pub fn mbedtls_ctr_drbg_set_prediction_resistance(
        ctx: *mut mbedtls_ctr_drbg_context,
        resistance: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed on each"]
    #[doc = "                      seed or reseed."]
    #[doc = ""]
    #[doc = " The default value is #MBEDTLS_CTR_DRBG_ENTROPY_LEN."]
    #[doc = ""]
    #[doc = " \\note                The security strength of CTR_DRBG is bounded by the"]
    #[doc = "                      entropy length. Thus:"]
    #[doc = "                      - When using AES-256"]
    #[doc = "                        (\\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is disabled,"]
    #[doc = "                        which is the default),"]
    #[doc = "                        \\p len must be at least 32 (in bytes)"]
    #[doc = "                        to achieve a 256-bit strength."]
    #[doc = "                      - When using AES-128"]
    #[doc = "                        (\\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is enabled)"]
    #[doc = "                        \\p len must be at least 16 (in bytes)"]
    #[doc = "                        to achieve a 128-bit strength."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param len           The amount of entropy to grab, in bytes."]
    #[doc = "                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT"]
    #[doc = "                      and at most the maximum length accepted by the"]
    #[doc = "                      entropy function that is set in the context."]
    pub fn mbedtls_ctr_drbg_set_entropy_len(ctx: *mut mbedtls_ctr_drbg_context, len: size_t);
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed"]
    #[doc = "                      as a nonce for the initial seeding."]
    #[doc = ""]
    #[doc = " Call this function before calling mbedtls_ctr_drbg_seed() to read"]
    #[doc = " a nonce from the entropy source during the initial seeding."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param len           The amount of entropy to grab for the nonce, in bytes."]
    #[doc = "                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT"]
    #[doc = "                      and at most the maximum length accepted by the"]
    #[doc = "                      entropy function that is set in the context."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if \\p len is"]
    #[doc = "                      more than #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED"]
    #[doc = "                      if the initial seeding has already taken place."]
    pub fn mbedtls_ctr_drbg_set_nonce_len(
        ctx: *mut mbedtls_ctr_drbg_context,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the reseed interval."]
    #[doc = ""]
    #[doc = " The reseed interval is the number of calls to mbedtls_ctr_drbg_random()"]
    #[doc = " or mbedtls_ctr_drbg_random_with_add() after which the entropy function"]
    #[doc = " is called again."]
    #[doc = ""]
    #[doc = " The default value is #MBEDTLS_CTR_DRBG_RESEED_INTERVAL."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param interval      The reseed interval."]
    pub fn mbedtls_ctr_drbg_set_reseed_interval(
        ctx: *mut mbedtls_ctr_drbg_context,
        interval: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function reseeds the CTR_DRBG context, that is"]
    #[doc = "                      extracts data from the entropy source."]
    #[doc = ""]
    #[doc = " \\note                This function is not thread-safe. It is not safe"]
    #[doc = "                      to call this function if another thread might be"]
    #[doc = "                      concurrently obtaining random numbers from the same"]
    #[doc = "                      context or updating or reseeding the same context."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param additional    Additional data to add to the state. Can be \\c NULL."]
    #[doc = " \\param len           The length of the additional data."]
    #[doc = "                      This must be less than"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \\c entropy_len"]
    #[doc = "                      where \\c entropy_len is the entropy length"]
    #[doc = "                      configured for the context."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    pub fn mbedtls_ctr_drbg_reseed(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const crate::c_types::c_uchar,
        len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief              This function updates the state of the CTR_DRBG context."]
    #[doc = ""]
    #[doc = " \\note                This function is not thread-safe. It is not safe"]
    #[doc = "                      to call this function if another thread might be"]
    #[doc = "                      concurrently obtaining random numbers from the same"]
    #[doc = "                      context or updating or reseeding the same context."]
    #[doc = ""]
    #[doc = " \\param ctx          The CTR_DRBG context."]
    #[doc = " \\param additional   The data to update the state with. This must not be"]
    #[doc = "                     \\c NULL unless \\p add_len is \\c 0."]
    #[doc = " \\param add_len      Length of \\p additional in bytes. This must be at"]
    #[doc = "                     most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT."]
    #[doc = ""]
    #[doc = " \\return             \\c 0 on success."]
    #[doc = " \\return             #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if"]
    #[doc = "                     \\p add_len is more than"]
    #[doc = "                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT."]
    #[doc = " \\return             An error from the underlying AES cipher on failure."]
    pub fn mbedtls_ctr_drbg_update(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const crate::c_types::c_uchar,
        add_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function updates a CTR_DRBG instance with additional"]
    #[doc = "          data and uses it to generate random data."]
    #[doc = ""]
    #[doc = " This function automatically reseeds if the reseed counter is exceeded"]
    #[doc = " or prediction resistance is enabled."]
    #[doc = ""]
    #[doc = " \\note                This function is not thread-safe. It is not safe"]
    #[doc = "                      to call this function if another thread might be"]
    #[doc = "                      concurrently obtaining random numbers from the same"]
    #[doc = "                      context or updating or reseeding the same context."]
    #[doc = ""]
    #[doc = " \\param p_rng         The CTR_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_ctr_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param output_len    The length of the buffer in bytes."]
    #[doc = " \\param additional    Additional data to update. Can be \\c NULL, in which"]
    #[doc = "                      case the additional data is empty regardless of"]
    #[doc = "                      the value of \\p add_len."]
    #[doc = " \\param add_len       The length of the additional data"]
    #[doc = "                      if \\p additional is not \\c NULL."]
    #[doc = "                      This must be less than #MBEDTLS_CTR_DRBG_MAX_INPUT"]
    #[doc = "                      and less than"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \\c entropy_len"]
    #[doc = "                      where \\c entropy_len is the entropy length"]
    #[doc = "                      configured for the context."]
    #[doc = ""]
    #[doc = " \\return    \\c 0 on success."]
    #[doc = " \\return    #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or"]
    #[doc = "            #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    pub fn mbedtls_ctr_drbg_random_with_add(
        p_rng: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        output_len: size_t,
        additional: *const crate::c_types::c_uchar,
        add_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\param p_rng         The CTR_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_ctr_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param output_len    The length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or"]
    #[doc = "                      #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    pub fn mbedtls_ctr_drbg_random(
        p_rng: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        output_len: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The CTR_DRBG checkup routine."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              \\c 1 on failure."]
    pub fn mbedtls_ctr_drbg_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
