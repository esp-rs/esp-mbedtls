/* automatically generated by rust-bindgen 0.68.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MBEDTLS_CONFIG_FILE: &[u8; 9] = b"config.h\0";
pub const MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT: u32 = 0;
pub const MBEDTLS_SSL_MAX_EARLY_DATA_SIZE: u32 = 1024;
pub const MBEDTLS_SSL_TLS1_3_TICKET_AGE_TOLERANCE: u32 = 6000;
pub const MBEDTLS_SSL_TLS1_3_TICKET_NONCE_LENGTH: u32 = 32;
pub const MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS: u32 = 1;
pub const MBEDTLS_VERSION_MAJOR: u32 = 3;
pub const MBEDTLS_VERSION_MINOR: u32 = 4;
pub const MBEDTLS_VERSION_PATCH: u32 = 0;
pub const MBEDTLS_VERSION_NUMBER: u32 = 50593792;
pub const MBEDTLS_VERSION_STRING: &[u8; 6] = b"3.4.0\0";
pub const MBEDTLS_VERSION_STRING_FULL: &[u8; 15] = b"mbed TLS 3.4.0\0";
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const PSA_WANT_ALG_CCM: u32 = 1;
pub const PSA_WANT_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CMAC: u32 = 1;
pub const PSA_WANT_ALG_CMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDH: u32 = 1;
pub const PSA_WANT_ALG_ECDH: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA_ANY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_GCM: u32 = 1;
pub const PSA_WANT_ALG_GCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HMAC: u32 = 1;
pub const PSA_WANT_ALG_HMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF: u32 = 1;
pub const PSA_WANT_ALG_HKDF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXTRACT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXPAND: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PRF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_MD5: u32 = 1;
pub const PSA_WANT_ALG_MD5: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_PAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_JPAKE: u32 = 1;
pub const PSA_WANT_ALG_JPAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RIPEMD160: u32 = 1;
pub const PSA_WANT_ALG_RIPEMD160: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN_RAW: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_OAEP: u32 = 1;
pub const PSA_WANT_ALG_RSA_OAEP: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS: u32 = 1;
pub const PSA_WANT_ALG_RSA_PSS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_1: u32 = 1;
pub const PSA_WANT_ALG_SHA_1: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_224: u32 = 1;
pub const PSA_WANT_ALG_SHA_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_256: u32 = 1;
pub const PSA_WANT_ALG_SHA_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_384: u32 = 1;
pub const PSA_WANT_ALG_SHA_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_KEY_TYPE_AES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ARIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CAMELLIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CAMELLIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CHACHA20: u32 = 1;
pub const PSA_WANT_ALG_STREAM_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CHACHA20: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_STREAM_CIPHER: u32 = 1;
pub const PSA_WANT_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_CBC_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7: u32 = 1;
pub const PSA_WANT_ALG_CBC_PKCS7: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_ECB_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CFB: u32 = 1;
pub const PSA_WANT_ALG_CFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CTR: u32 = 1;
pub const PSA_WANT_ALG_CTR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_OFB: u32 = 1;
pub const PSA_WANT_ALG_OFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_255: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_448: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_521: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_256: u32 = 1;
pub const PSA_HAVE_FULL_ECDSA: u32 = 1;
pub const PSA_HAVE_FULL_JPAKE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DERIVE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD_HASH: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RAW_DATA: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NANO_MALLOC: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_BACKWARD_BINARY_COMPAT: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const ARG_MAX: u32 = 65536;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 2;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const MBEDTLS_ECP_DP_MAX: u32 = 14;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 4;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_MD_MAX_BLOCK_SIZE: u32 = 128;
pub const MBEDTLS_ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const MBEDTLS_ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const MBEDTLS_ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const MBEDTLS_ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const MBEDTLS_ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const MBEDTLS_ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const MBEDTLS_ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const MBEDTLS_ERR_RSA_RNG_FAILED: i32 = -17536;
pub const MBEDTLS_RSA_PKCS_V15: u32 = 0;
pub const MBEDTLS_RSA_PKCS_V21: u32 = 1;
pub const MBEDTLS_RSA_SIGN: u32 = 1;
pub const MBEDTLS_RSA_CRYPT: u32 = 2;
pub const MBEDTLS_RSA_SALT_LEN_ANY: i32 = -1;
pub const MBEDTLS_ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const MBEDTLS_ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const MBEDTLS_ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const MBEDTLS_ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const MBEDTLS_ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const MBEDTLS_ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const MBEDTLS_ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const MBEDTLS_ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const MBEDTLS_ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const MBEDTLS_ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const MBEDTLS_ERR_PK_INVALID_ALG: i32 = -14976;
pub const MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const MBEDTLS_ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const MBEDTLS_ERR_PK_BUFFER_TOO_SMALL: i32 = -14464;
pub const MBEDTLS_PK_SIGNATURE_MAX_SIZE: u32 = 0;
pub const MBEDTLS_PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_KEY_LENGTH: u32 = 64;
pub const MBEDTLS_TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 148;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 149;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256: u32 = 168;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384: u32 = 169;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 170;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 171;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 172;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 173;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA256: u32 = 176;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA384: u32 = 177;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 180;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 181;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 182;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 183;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 186;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 190;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 192;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49212;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49213;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49220;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49221;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49224;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49225;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49226;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49227;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49228;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49229;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49230;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49231;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49232;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49233;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49234;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49235;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49244;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49245;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49246;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49247;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49248;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49249;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49250;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49251;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49252;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49253;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49254;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49255;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49256;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49257;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49258;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49259;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49260;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49261;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49262;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49263;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49264;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49265;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49286;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49287;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49288;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49289;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49290;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49291;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49292;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49293;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49294;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49295;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49296;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49297;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49298;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49299;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49300;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49301;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49302;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49303;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49304;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49305;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49306;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49307;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM_8: u32 = 49322;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM_8: u32 = 49323;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8: u32 = 49407;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52392;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52393;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52394;
pub const MBEDTLS_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52395;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52396;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52397;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52398;
pub const MBEDTLS_TLS1_3_AES_128_GCM_SHA256: u32 = 4865;
pub const MBEDTLS_TLS1_3_AES_256_GCM_SHA384: u32 = 4866;
pub const MBEDTLS_TLS1_3_CHACHA20_POLY1305_SHA256: u32 = 4867;
pub const MBEDTLS_TLS1_3_AES_128_CCM_SHA256: u32 = 4868;
pub const MBEDTLS_TLS1_3_AES_128_CCM_8_SHA256: u32 = 4869;
pub const MBEDTLS_CIPHERSUITE_WEAK: u32 = 1;
pub const MBEDTLS_CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const MBEDTLS_CIPHERSUITE_NODTLS: u32 = 4;
pub const PSA_CRYPTO_API_VERSION_MAJOR: u32 = 1;
pub const PSA_CRYPTO_API_VERSION_MINOR: u32 = 0;
pub const PSA_MAC_TRUNCATION_OFFSET: u32 = 16;
pub const PSA_AEAD_TAG_LENGTH_OFFSET: u32 = 16;
pub const PSA_HASH_MAX_SIZE: u32 = 64;
pub const PSA_HMAC_MAX_HASH_BLOCK_SIZE: u32 = 128;
pub const PSA_MAC_MAX_SIZE: u32 = 64;
pub const PSA_AEAD_TAG_MAX_SIZE: u32 = 16;
pub const PSA_VENDOR_RSA_MAX_KEY_BITS: u32 = 4096;
pub const PSA_VENDOR_ECC_MAX_CURVE_BITS: u32 = 521;
pub const PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE: u32 = 128;
pub const PSA_TLS12_ECJPAKE_TO_PMS_INPUT_SIZE: u32 = 65;
pub const PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE: u32 = 32;
pub const PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_NONCE_MAX_SIZE: u32 = 13;
pub const PSA_AEAD_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_IV_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const MBEDTLS_AES_BLOCK_SIZE: u32 = 16;
pub const MBEDTLS_DES3_BLOCK_SIZE: u32 = 8;
pub const MBEDTLS_CIPHER_BLKSIZE_MAX: u32 = 16;
pub const MBEDTLS_GCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_GCM_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_GCM_AUTH_FAILED: i32 = -18;
pub const MBEDTLS_ERR_GCM_BAD_INPUT: i32 = -20;
pub const MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL: i32 = -22;
pub const MBEDTLS_CCM_DECRYPT: u32 = 0;
pub const MBEDTLS_CCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_CCM_STAR_DECRYPT: u32 = 2;
pub const MBEDTLS_CCM_STAR_ENCRYPT: u32 = 3;
pub const MBEDTLS_ERR_CCM_BAD_INPUT: i32 = -13;
pub const MBEDTLS_ERR_CCM_AUTH_FAILED: i32 = -15;
pub const MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const MBEDTLS_ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const MBEDTLS_ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const MBEDTLS_ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const MBEDTLS_ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const MBEDTLS_PSA_BUILTIN_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_AEAD: u32 = 1;
pub const MBEDTLS_PSA_JPAKE_BUFFER_SIZE: u32 = 336;
pub const PSA_MAX_KEY_BITS: u32 = 65528;
pub const MBEDTLS_PSA_KA_MASK_DUAL_USE: u32 = 0;
pub const PSA_CRYPTO_ITS_RANDOM_SEED_UID: u32 = 4294967122;
pub const MBEDTLS_PSA_KEY_SLOT_COUNT: u32 = 32;
pub const PSA_PAKE_OPERATION_STAGE_SETUP: u32 = 0;
pub const PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS: u32 = 1;
pub const PSA_PAKE_OPERATION_STAGE_COMPUTATION: u32 = 2;
pub const PSA_PAKE_OUTPUT_MAX_SIZE: u32 = 65;
pub const PSA_PAKE_INPUT_MAX_SIZE: u32 = 65;
pub const MBEDTLS_ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const MBEDTLS_ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const MBEDTLS_ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const MBEDTLS_ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const MBEDTLS_ERR_ASN1_INVALID_DATA: i32 = -104;
pub const MBEDTLS_ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const MBEDTLS_ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const MBEDTLS_ASN1_BOOLEAN: u32 = 1;
pub const MBEDTLS_ASN1_INTEGER: u32 = 2;
pub const MBEDTLS_ASN1_BIT_STRING: u32 = 3;
pub const MBEDTLS_ASN1_OCTET_STRING: u32 = 4;
pub const MBEDTLS_ASN1_NULL: u32 = 5;
pub const MBEDTLS_ASN1_OID: u32 = 6;
pub const MBEDTLS_ASN1_ENUMERATED: u32 = 10;
pub const MBEDTLS_ASN1_UTF8_STRING: u32 = 12;
pub const MBEDTLS_ASN1_SEQUENCE: u32 = 16;
pub const MBEDTLS_ASN1_SET: u32 = 17;
pub const MBEDTLS_ASN1_PRINTABLE_STRING: u32 = 19;
pub const MBEDTLS_ASN1_T61_STRING: u32 = 20;
pub const MBEDTLS_ASN1_IA5_STRING: u32 = 22;
pub const MBEDTLS_ASN1_UTC_TIME: u32 = 23;
pub const MBEDTLS_ASN1_GENERALIZED_TIME: u32 = 24;
pub const MBEDTLS_ASN1_UNIVERSAL_STRING: u32 = 28;
pub const MBEDTLS_ASN1_BMP_STRING: u32 = 30;
pub const MBEDTLS_ASN1_PRIMITIVE: u32 = 0;
pub const MBEDTLS_ASN1_CONSTRUCTED: u32 = 32;
pub const MBEDTLS_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const MBEDTLS_ASN1_TAG_CLASS_MASK: u32 = 192;
pub const MBEDTLS_ASN1_TAG_PC_MASK: u32 = 32;
pub const MBEDTLS_ASN1_TAG_VALUE_MASK: u32 = 31;
pub const MBEDTLS_X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const MBEDTLS_ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const MBEDTLS_ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const MBEDTLS_ERR_X509_INVALID_VERSION: i32 = -8704;
pub const MBEDTLS_ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const MBEDTLS_ERR_X509_INVALID_ALG: i32 = -8960;
pub const MBEDTLS_ERR_X509_INVALID_NAME: i32 = -9088;
pub const MBEDTLS_ERR_X509_INVALID_DATE: i32 = -9216;
pub const MBEDTLS_ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const MBEDTLS_ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const MBEDTLS_ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const MBEDTLS_ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const MBEDTLS_ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const MBEDTLS_ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const MBEDTLS_ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const MBEDTLS_ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const MBEDTLS_ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const MBEDTLS_ERR_X509_FATAL_ERROR: i32 = -12288;
pub const MBEDTLS_X509_BADCERT_EXPIRED: u32 = 1;
pub const MBEDTLS_X509_BADCERT_REVOKED: u32 = 2;
pub const MBEDTLS_X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const MBEDTLS_X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const MBEDTLS_X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const MBEDTLS_X509_BADCRL_EXPIRED: u32 = 32;
pub const MBEDTLS_X509_BADCERT_MISSING: u32 = 64;
pub const MBEDTLS_X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const MBEDTLS_X509_BADCERT_OTHER: u32 = 256;
pub const MBEDTLS_X509_BADCERT_FUTURE: u32 = 512;
pub const MBEDTLS_X509_BADCRL_FUTURE: u32 = 1024;
pub const MBEDTLS_X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const MBEDTLS_X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const MBEDTLS_X509_BADCERT_BAD_MD: u32 = 16384;
pub const MBEDTLS_X509_BADCERT_BAD_PK: u32 = 32768;
pub const MBEDTLS_X509_BADCERT_BAD_KEY: u32 = 65536;
pub const MBEDTLS_X509_BADCRL_BAD_MD: u32 = 131072;
pub const MBEDTLS_X509_BADCRL_BAD_PK: u32 = 262144;
pub const MBEDTLS_X509_BADCRL_BAD_KEY: u32 = 524288;
pub const MBEDTLS_X509_SAN_OTHER_NAME: u32 = 0;
pub const MBEDTLS_X509_SAN_RFC822_NAME: u32 = 1;
pub const MBEDTLS_X509_SAN_DNS_NAME: u32 = 2;
pub const MBEDTLS_X509_SAN_X400_ADDRESS_NAME: u32 = 3;
pub const MBEDTLS_X509_SAN_DIRECTORY_NAME: u32 = 4;
pub const MBEDTLS_X509_SAN_EDI_PARTY_NAME: u32 = 5;
pub const MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: u32 = 6;
pub const MBEDTLS_X509_SAN_IP_ADDRESS: u32 = 7;
pub const MBEDTLS_X509_SAN_REGISTERED_ID: u32 = 8;
pub const MBEDTLS_X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const MBEDTLS_X509_KU_NON_REPUDIATION: u32 = 64;
pub const MBEDTLS_X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const MBEDTLS_X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const MBEDTLS_X509_KU_KEY_AGREEMENT: u32 = 8;
pub const MBEDTLS_X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const MBEDTLS_X509_KU_CRL_SIGN: u32 = 2;
pub const MBEDTLS_X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const MBEDTLS_X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const MBEDTLS_X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const MBEDTLS_X509_FORMAT_DER: u32 = 1;
pub const MBEDTLS_X509_FORMAT_PEM: u32 = 2;
pub const MBEDTLS_X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const MBEDTLS_X509_CRT_VERSION_1: u32 = 0;
pub const MBEDTLS_X509_CRT_VERSION_2: u32 = 1;
pub const MBEDTLS_X509_CRT_VERSION_3: u32 = 2;
pub const MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN: u32 = 20;
pub const MBEDTLS_X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const MBEDTLS_X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE: u32 = 10;
pub const MBEDTLS_ERR_DHM_BAD_INPUT_DATA: i32 = -12416;
pub const MBEDTLS_ERR_DHM_READ_PARAMS_FAILED: i32 = -12544;
pub const MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED: i32 = -12672;
pub const MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED: i32 = -12800;
pub const MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED: i32 = -12928;
pub const MBEDTLS_ERR_DHM_CALC_SECRET_FAILED: i32 = -13056;
pub const MBEDTLS_ERR_DHM_INVALID_FORMAT: i32 = -13184;
pub const MBEDTLS_ERR_DHM_ALLOC_FAILED: i32 = -13312;
pub const MBEDTLS_ERR_DHM_FILE_IO_ERROR: i32 = -13440;
pub const MBEDTLS_ERR_DHM_SET_GROUP_FAILED: i32 = -13696;
pub const MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS: i32 = -28672;
pub const MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const MBEDTLS_ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const MBEDTLS_ERR_SSL_INVALID_MAC: i32 = -29056;
pub const MBEDTLS_ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const MBEDTLS_ERR_SSL_CONN_EOF: i32 = -29312;
pub const MBEDTLS_ERR_SSL_DECODE_ERROR: i32 = -29440;
pub const MBEDTLS_ERR_SSL_NO_RNG: i32 = -29696;
pub const MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION: i32 = -29952;
pub const MBEDTLS_ERR_SSL_NO_APPLICATION_PROTOCOL: i32 = -30080;
pub const MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const MBEDTLS_ERR_SSL_UNRECOGNIZED_NAME: i32 = -30720;
pub const MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const MBEDTLS_ERR_SSL_BAD_CERTIFICATE: i32 = -31232;
pub const MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET: i32 = -31488;
pub const MBEDTLS_ERR_SSL_CANNOT_READ_EARLY_DATA: i32 = -31616;
pub const MBEDTLS_ERR_SSL_CANNOT_WRITE_EARLY_DATA: i32 = -31744;
pub const MBEDTLS_ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION: i32 = -28288;
pub const MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE: i32 = -28160;
pub const MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const MBEDTLS_ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const MBEDTLS_ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const MBEDTLS_ERR_SSL_WANT_READ: i32 = -26880;
pub const MBEDTLS_ERR_SSL_WANT_WRITE: i32 = -26752;
pub const MBEDTLS_ERR_SSL_TIMEOUT: i32 = -26624;
pub const MBEDTLS_ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const MBEDTLS_ERR_SSL_NON_FATAL: i32 = -26240;
pub const MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER: i32 = -26112;
pub const MBEDTLS_ERR_SSL_CONTINUE_PROCESSING: i32 = -25984;
pub const MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS: i32 = -25856;
pub const MBEDTLS_ERR_SSL_EARLY_MESSAGE: i32 = -25728;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_CID: i32 = -24576;
pub const MBEDTLS_ERR_SSL_VERSION_MISMATCH: i32 = -24320;
pub const MBEDTLS_ERR_SSL_BAD_CONFIG: i32 = -24192;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_PURE: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_ECDHE: u32 = 1;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_NONE: u32 = 0;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192K1: u32 = 18;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192R1: u32 = 19;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224K1: u32 = 20;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224R1: u32 = 21;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256K1: u32 = 22;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1: u32 = 23;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP384R1: u32 = 24;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP521R1: u32 = 25;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP256R1: u32 = 26;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP384R1: u32 = 27;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP512R1: u32 = 28;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X25519: u32 = 29;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X448: u32 = 30;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE2048: u32 = 256;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE3072: u32 = 257;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE4096: u32 = 258;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE6144: u32 = 259;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE8192: u32 = 260;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK: u32 = 1;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL: u32 = 2;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL: u32 = 4;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL: u32 = 7;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL: u32 = 5;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL: u32 = 6;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAJOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_4: u32 = 4;
pub const MBEDTLS_SSL_TRANSPORT_STREAM: u32 = 0;
pub const MBEDTLS_SSL_TRANSPORT_DATAGRAM: u32 = 1;
pub const MBEDTLS_SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_LIST_LEN: u32 = 65535;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const MBEDTLS_SSL_IS_CLIENT: u32 = 0;
pub const MBEDTLS_SSL_IS_SERVER: u32 = 1;
pub const MBEDTLS_SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CID_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_CID_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ETM_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ETM_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_COMPRESS_NULL: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_NONE: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_OPTIONAL: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_REQUIRED: u32 = 2;
pub const MBEDTLS_SSL_VERIFY_UNSET: u32 = 3;
pub const MBEDTLS_SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const MBEDTLS_SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const MBEDTLS_SSL_SESSION_TICKETS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_SESSION_TICKETS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_PRESET_DEFAULT: u32 = 0;
pub const MBEDTLS_SSL_PRESET_SUITEB: u32 = 2;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_UNSUPPORTED: u32 = 0;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_TICKET_RESUMPTION_KEY_LEN: u32 = 48;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_DTLS_MAX_BUFFERING: u32 = 32768;
pub const MBEDTLS_SSL_CID_IN_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_OUT_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_TLS1_3_PADDING_GRANULARITY: u32 = 16;
pub const MBEDTLS_SSL_VERIFY_DATA_MAX_LEN: u32 = 12;
pub const MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const MBEDTLS_SSL_HASH_NONE: u32 = 0;
pub const MBEDTLS_SSL_HASH_MD5: u32 = 1;
pub const MBEDTLS_SSL_HASH_SHA1: u32 = 2;
pub const MBEDTLS_SSL_HASH_SHA224: u32 = 3;
pub const MBEDTLS_SSL_HASH_SHA256: u32 = 4;
pub const MBEDTLS_SSL_HASH_SHA384: u32 = 5;
pub const MBEDTLS_SSL_HASH_SHA512: u32 = 6;
pub const MBEDTLS_SSL_SIG_ANON: u32 = 0;
pub const MBEDTLS_SSL_SIG_RSA: u32 = 1;
pub const MBEDTLS_SSL_SIG_ECDSA: u32 = 3;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA256: u32 = 1025;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA384: u32 = 1281;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA512: u32 = 1537;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP256R1_SHA256: u32 = 1027;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP384R1_SHA384: u32 = 1283;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP521R1_SHA512: u32 = 1539;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA256: u32 = 2052;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA384: u32 = 2053;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA512: u32 = 2054;
pub const MBEDTLS_TLS1_3_SIG_ED25519: u32 = 2055;
pub const MBEDTLS_TLS1_3_SIG_ED448: u32 = 2056;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA256: u32 = 2057;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA384: u32 = 2058;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA512: u32 = 2059;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA1: u32 = 513;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SHA1: u32 = 515;
pub const MBEDTLS_TLS1_3_SIG_NONE: u32 = 0;
pub const MBEDTLS_SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const MBEDTLS_SSL_MSG_ALERT: u32 = 21;
pub const MBEDTLS_SSL_MSG_HANDSHAKE: u32 = 22;
pub const MBEDTLS_SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const MBEDTLS_SSL_MSG_CID: u32 = 25;
pub const MBEDTLS_SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const MBEDTLS_SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const MBEDTLS_SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const MBEDTLS_SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const MBEDTLS_SSL_ALERT_MSG_MISSING_EXTENSION: u32 = 109;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REQUIRED: u32 = 116;
pub const MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const MBEDTLS_SSL_HS_HELLO_REQUEST: u32 = 0;
pub const MBEDTLS_SSL_HS_CLIENT_HELLO: u32 = 1;
pub const MBEDTLS_SSL_HS_SERVER_HELLO: u32 = 2;
pub const MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const MBEDTLS_SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const MBEDTLS_SSL_HS_END_OF_EARLY_DATA: u32 = 5;
pub const MBEDTLS_SSL_HS_ENCRYPTED_EXTENSIONS: u32 = 8;
pub const MBEDTLS_SSL_HS_CERTIFICATE: u32 = 11;
pub const MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const MBEDTLS_SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const MBEDTLS_SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const MBEDTLS_SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const MBEDTLS_SSL_HS_FINISHED: u32 = 20;
pub const MBEDTLS_SSL_HS_MESSAGE_HASH: u32 = 254;
pub const MBEDTLS_TLS_EXT_SERVERNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const MBEDTLS_TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const MBEDTLS_TLS_EXT_STATUS_REQUEST: u32 = 5;
pub const MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_GROUPS: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const MBEDTLS_TLS_EXT_SIG_ALG: u32 = 13;
pub const MBEDTLS_TLS_EXT_USE_SRTP: u32 = 14;
pub const MBEDTLS_TLS_EXT_HEARTBEAT: u32 = 15;
pub const MBEDTLS_TLS_EXT_ALPN: u32 = 16;
pub const MBEDTLS_TLS_EXT_SCT: u32 = 18;
pub const MBEDTLS_TLS_EXT_CLI_CERT_TYPE: u32 = 19;
pub const MBEDTLS_TLS_EXT_SERV_CERT_TYPE: u32 = 20;
pub const MBEDTLS_TLS_EXT_PADDING: u32 = 21;
pub const MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const MBEDTLS_TLS_EXT_RECORD_SIZE_LIMIT: u32 = 28;
pub const MBEDTLS_TLS_EXT_SESSION_TICKET: u32 = 35;
pub const MBEDTLS_TLS_EXT_PRE_SHARED_KEY: u32 = 41;
pub const MBEDTLS_TLS_EXT_EARLY_DATA: u32 = 42;
pub const MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS: u32 = 43;
pub const MBEDTLS_TLS_EXT_COOKIE: u32 = 44;
pub const MBEDTLS_TLS_EXT_PSK_KEY_EXCHANGE_MODES: u32 = 45;
pub const MBEDTLS_TLS_EXT_CERT_AUTH: u32 = 47;
pub const MBEDTLS_TLS_EXT_OID_FILTERS: u32 = 48;
pub const MBEDTLS_TLS_EXT_POST_HANDSHAKE_AUTH: u32 = 49;
pub const MBEDTLS_TLS_EXT_SIG_ALG_CERT: u32 = 50;
pub const MBEDTLS_TLS_EXT_KEY_SHARE: u32 = 51;
pub const MBEDTLS_TLS_EXT_CID: u32 = 54;
pub const MBEDTLS_TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const MBEDTLS_TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const MBEDTLS_PSK_MAX_LEN: u32 = 48;
pub const MBEDTLS_TLS1_3_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_SSL_SEQUENCE_NUMBER_LEN: u32 = 8;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_PSK_RESUMPTION: u32 = 1;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_PSK_EPHEMERAL_RESUMPTION: u32 = 4;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_EARLY_DATA: u32 = 8;
pub const MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK: u32 = 13;
pub const MBEDTLS_SSL_UNEXPECTED_CID_IGNORE: u32 = 0;
pub const MBEDTLS_SSL_UNEXPECTED_CID_FAIL: u32 = 1;
pub const MBEDTLS_ERR_ENTROPY_SOURCE_FAILED: i32 = -60;
pub const MBEDTLS_ERR_ENTROPY_MAX_SOURCES: i32 = -62;
pub const MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED: i32 = -64;
pub const MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE: i32 = -61;
pub const MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR: i32 = -63;
pub const MBEDTLS_ENTROPY_MAX_SOURCES: u32 = 20;
pub const MBEDTLS_ENTROPY_MAX_GATHER: u32 = 128;
pub const MBEDTLS_ENTROPY_BLOCK_SIZE: u32 = 64;
pub const MBEDTLS_ENTROPY_MAX_SEED_SIZE: u32 = 1024;
pub const MBEDTLS_ENTROPY_SOURCE_MANUAL: u32 = 20;
pub const MBEDTLS_ENTROPY_SOURCE_STRONG: u32 = 1;
pub const MBEDTLS_ENTROPY_SOURCE_WEAK: u32 = 0;
pub const MBEDTLS_PRINTF_SIZET: &[u8; 3] = b"zu\0";
pub const MBEDTLS_PRINTF_LONGLONG: &[u8; 4] = b"lld\0";
pub const MBEDTLS_AES_ENCRYPT: u32 = 1;
pub const MBEDTLS_AES_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_AES_INVALID_KEY_LENGTH: i32 = -32;
pub const MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH: i32 = -34;
pub const MBEDTLS_ERR_AES_BAD_INPUT_DATA: i32 = -33;
pub const MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED: i32 = -52;
pub const MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG: i32 = -54;
pub const MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG: i32 = -56;
pub const MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR: i32 = -58;
pub const MBEDTLS_CTR_DRBG_BLOCKSIZE: u32 = 16;
pub const MBEDTLS_CTR_DRBG_KEYSIZE: u32 = 32;
pub const MBEDTLS_CTR_DRBG_KEYBITS: u32 = 256;
pub const MBEDTLS_CTR_DRBG_SEEDLEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_ENTROPY_LEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const MBEDTLS_CTR_DRBG_MAX_INPUT: u32 = 256;
pub const MBEDTLS_CTR_DRBG_MAX_REQUEST: u32 = 1024;
pub const MBEDTLS_CTR_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const MBEDTLS_CTR_DRBG_PR_OFF: u32 = 0;
pub const MBEDTLS_CTR_DRBG_PR_ON: u32 = 1;
pub const MBEDTLS_CTR_DRBG_ENTROPY_NONCE_LEN: u32 = 0;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
pub type mbedtls_iso_c_forbids_empty_translation_units = crate::c_types::c_int;
extern "C" {
    /// \brief       Securely zeroize a buffer
    ///
    ///              The function is meant to wipe the data contained in a buffer so
    ///              that it can no longer be recovered even if the program memory
    ///              is later compromised. Call this function on sensitive data
    ///              stored on the stack before returning from a function, and on
    ///              sensitive data stored on the heap before freeing the heap
    ///              object.
    ///
    ///              It is extremely difficult to guarantee that calls to
    ///              mbedtls_platform_zeroize() are not removed by aggressive
    ///              compiler optimizations in a portable way. For this reason, Mbed
    ///              TLS provides the configuration option
    ///              MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure
    ///              mbedtls_platform_zeroize() to use a suitable implementation for
    ///              their platform and needs
    ///
    /// \param buf   Buffer to be zeroized
    /// \param len   Length of the buffer in bytes
    pub fn mbedtls_platform_zeroize(buf: *mut crate::c_types::c_void, len: usize);
}
pub type mbedtls_mpi_sint = i32;
pub type mbedtls_mpi_uint = u32;
pub type mbedtls_t_udbl = u64;
/// \brief          MPI structure
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_mpi {
    /// Sign: -1 if the mpi is negative, 1 otherwise.
    ///
    /// The number 0 must be represented with `s = +1`. Although many library
    /// functions treat all-limbs-zero as equivalent to a valid representation
    /// of 0 regardless of the sign bit, there are exceptions, so bignum
    /// functions and external callers must always set \c s to +1 for the
    /// number zero.
    ///
    /// Note that this implies that calloc() or `... = {0}` does not create
    /// a valid MPI representation. You must call mbedtls_mpi_init().
    pub private_s: crate::c_types::c_int,
    /// Total number of limbs in \c p.
    pub private_n: usize,
    /// Pointer to limbs.
    ///
    /// This may be \c NULL if \c n is 0.
    pub private_p: *mut mbedtls_mpi_uint,
}
extern "C" {
    /// \brief           Initialize an MPI context.
    ///
    ///                  This makes the MPI ready to be set or freed,
    ///                  but does not define a value for the MPI.
    ///
    /// \param X         The MPI context to initialize. This must not be \c NULL.
    pub fn mbedtls_mpi_init(X: *mut mbedtls_mpi);
}
extern "C" {
    /// \brief          This function frees the components of an MPI context.
    ///
    /// \param X        The MPI context to be cleared. This may be \c NULL,
    ///                 in which case this function is a no-op. If it is
    ///                 not \c NULL, it must point to an initialized MPI.
    pub fn mbedtls_mpi_free(X: *mut mbedtls_mpi);
}
extern "C" {
    /// \brief          Enlarge an MPI to the specified number of limbs.
    ///
    /// \note           This function does nothing if the MPI is
    ///                 already large enough.
    ///
    /// \param X        The MPI to grow. It must be initialized.
    /// \param nblimbs  The target number of limbs.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_grow(X: *mut mbedtls_mpi, nblimbs: usize) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function resizes an MPI downwards, keeping at least the
    ///                 specified number of limbs.
    ///
    ///                 If \c X is smaller than \c nblimbs, it is resized up
    ///                 instead.
    ///
    /// \param X        The MPI to shrink. This must point to an initialized MPI.
    /// \param nblimbs  The minimum number of limbs to keep.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed
    ///                 (this can only happen when resizing up).
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_shrink(X: *mut mbedtls_mpi, nblimbs: usize) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Make a copy of an MPI.
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param Y        The source MPI. This must point to an initialized MPI.
    ///
    /// \note           The limb-buffer in the destination MPI is enlarged
    ///                 if necessary to hold the value in the source MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_copy(X: *mut mbedtls_mpi, Y: *const mbedtls_mpi) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Swap the contents of two MPIs.
    ///
    /// \param X        The first MPI. It must be initialized.
    /// \param Y        The second MPI. It must be initialized.
    pub fn mbedtls_mpi_swap(X: *mut mbedtls_mpi, Y: *mut mbedtls_mpi);
}
extern "C" {
    /// \brief          Perform a safe conditional copy of MPI which doesn't
    ///                 reveal whether the condition was true or not.
    ///
    /// \param X        The MPI to conditionally assign to. This must point
    ///                 to an initialized MPI.
    /// \param Y        The MPI to be assigned from. This must point to an
    ///                 initialized MPI.
    /// \param assign   The condition deciding whether to perform the
    ///                 assignment or not. Must be either 0 or 1:
    ///                 * \c 1: Perform the assignment `X = Y`.
    ///                 * \c 0: Keep the original value of \p X.
    ///
    /// \note           This function is equivalent to
    ///                      `if( assign ) mbedtls_mpi_copy( X, Y );`
    ///                 except that it avoids leaking any information about whether
    ///                 the assignment was done or not (the above code may leak
    ///                 information through branch prediction and/or memory access
    ///                 patterns analysis).
    ///
    /// \warning        If \p assign is neither 0 nor 1, the result of this function
    ///                 is indeterminate, and the resulting value in \p X might be
    ///                 neither its original value nor the value in \p Y.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_safe_cond_assign(
        X: *mut mbedtls_mpi,
        Y: *const mbedtls_mpi,
        assign: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a safe conditional swap which doesn't
    ///                 reveal whether the condition was true or not.
    ///
    /// \param X        The first MPI. This must be initialized.
    /// \param Y        The second MPI. This must be initialized.
    /// \param swap     The condition deciding whether to perform
    ///                 the swap or not. Must be either 0 or 1:
    ///                 * \c 1: Swap the values of \p X and \p Y.
    ///                 * \c 0: Keep the original values of \p X and \p Y.
    ///
    /// \note           This function is equivalent to
    ///                      if( swap ) mbedtls_mpi_swap( X, Y );
    ///                 except that it avoids leaking any information about whether
    ///                 the swap was done or not (the above code may leak
    ///                 information through branch prediction and/or memory access
    ///                 patterns analysis).
    ///
    /// \warning        If \p swap is neither 0 nor 1, the result of this function
    ///                 is indeterminate, and both \p X and \p Y might end up with
    ///                 values different to either of the original ones.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_safe_cond_swap(
        X: *mut mbedtls_mpi,
        Y: *mut mbedtls_mpi,
        swap: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Store integer value in MPI.
    ///
    /// \param X        The MPI to set. This must be initialized.
    /// \param z        The value to use.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_lset(X: *mut mbedtls_mpi, z: mbedtls_mpi_sint) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Get a specific bit from an MPI.
    ///
    /// \param X        The MPI to query. This must be initialized.
    /// \param pos      Zero-based index of the bit to query.
    ///
    /// \return         \c 0 or \c 1 on success, depending on whether bit \c pos
    ///                 of \c X is unset or set.
    /// \return         A negative error code on failure.
    pub fn mbedtls_mpi_get_bit(X: *const mbedtls_mpi, pos: usize) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Modify a specific bit in an MPI.
    ///
    /// \note           This function will grow the target MPI if necessary to set a
    ///                 bit to \c 1 in a not yet existing limb. It will not grow if
    ///                 the bit should be set to \c 0.
    ///
    /// \param X        The MPI to modify. This must be initialized.
    /// \param pos      Zero-based index of the bit to modify.
    /// \param val      The desired value of bit \c pos: \c 0 or \c 1.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_set_bit(
        X: *mut mbedtls_mpi,
        pos: usize,
        val: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Return the number of bits of value \c 0 before the
    ///                 least significant bit of value \c 1.
    ///
    /// \note           This is the same as the zero-based index of
    ///                 the least significant bit of value \c 1.
    ///
    /// \param X        The MPI to query.
    ///
    /// \return         The number of bits of value \c 0 before the least significant
    ///                 bit of value \c 1 in \p X.
    pub fn mbedtls_mpi_lsb(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    /// \brief          Return the number of bits up to and including the most
    ///                 significant bit of value \c 1.
    ///
    /// * \note         This is same as the one-based index of the most
    ///                 significant bit of value \c 1.
    ///
    /// \param X        The MPI to query. This must point to an initialized MPI.
    ///
    /// \return         The number of bits up to and including the most
    ///                 significant bit of value \c 1.
    pub fn mbedtls_mpi_bitlen(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    /// \brief          Return the total size of an MPI value in bytes.
    ///
    /// \param X        The MPI to use. This must point to an initialized MPI.
    ///
    /// \note           The value returned by this function may be less than
    ///                 the number of bytes used to store \p X internally.
    ///                 This happens if and only if there are trailing bytes
    ///                 of value zero.
    ///
    /// \return         The least number of bytes capable of storing
    ///                 the absolute value of \p X.
    pub fn mbedtls_mpi_size(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    /// \brief          Import an MPI from an ASCII string.
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param radix    The numeric base of the input string.
    /// \param s        Null-terminated string buffer.
    ///
    /// \return         \c 0 if successful.
    /// \return         A negative error code on failure.
    pub fn mbedtls_mpi_read_string(
        X: *mut mbedtls_mpi,
        radix: crate::c_types::c_int,
        s: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Export an MPI to an ASCII string.
    ///
    /// \param X        The source MPI. This must point to an initialized MPI.
    /// \param radix    The numeric base of the output string.
    /// \param buf      The buffer to write the string to. This must be writable
    ///                 buffer of length \p buflen Bytes.
    /// \param buflen   The available size in Bytes of \p buf.
    /// \param olen     The address at which to store the length of the string
    ///                 written, including the  final \c NULL byte. This must
    ///                 not be \c NULL.
    ///
    /// \note           You can call this function with `buflen == 0` to obtain the
    ///                 minimum required buffer size in `*olen`.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the target buffer \p buf
    ///                 is too small to hold the value of \p X in the desired base.
    ///                 In this case, `*olen` is nonetheless updated to contain the
    ///                 size of \p buf required for a successful call.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_write_string(
        X: *const mbedtls_mpi,
        radix: crate::c_types::c_int,
        buf: *mut crate::c_types::c_char,
        buflen: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Import an MPI from unsigned big endian binary data.
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param buf      The input buffer. This must be a readable buffer of length
    ///                 \p buflen Bytes.
    /// \param buflen   The length of the input buffer \p p in Bytes.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_read_binary(
        X: *mut mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Import X from unsigned binary data, little endian
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param buf      The input buffer. This must be a readable buffer of length
    ///                 \p buflen Bytes.
    /// \param buflen   The length of the input buffer \p p in Bytes.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_read_binary_le(
        X: *mut mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Export X into unsigned binary data, big endian.
    ///                 Always fills the whole buffer, which will start with zeros
    ///                 if the number is smaller.
    ///
    /// \param X        The source MPI. This must point to an initialized MPI.
    /// \param buf      The output buffer. This must be a writable buffer of length
    ///                 \p buflen Bytes.
    /// \param buflen   The size of the output buffer \p buf in Bytes.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \p buf isn't
    ///                 large enough to hold the value of \p X.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_write_binary(
        X: *const mbedtls_mpi,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Export X into unsigned binary data, little endian.
    ///                 Always fills the whole buffer, which will end with zeros
    ///                 if the number is smaller.
    ///
    /// \param X        The source MPI. This must point to an initialized MPI.
    /// \param buf      The output buffer. This must be a writable buffer of length
    ///                 \p buflen Bytes.
    /// \param buflen   The size of the output buffer \p buf in Bytes.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \p buf isn't
    ///                 large enough to hold the value of \p X.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_write_binary_le(
        X: *const mbedtls_mpi,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a left-shift on an MPI: X <<= count
    ///
    /// \param X        The MPI to shift. This must point to an initialized MPI.
    /// \param count    The number of bits to shift by.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_shift_l(X: *mut mbedtls_mpi, count: usize) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a right-shift on an MPI: X >>= count
    ///
    /// \param X        The MPI to shift. This must point to an initialized MPI.
    /// \param count    The number of bits to shift by.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_shift_r(X: *mut mbedtls_mpi, count: usize) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Compare the absolute values of two MPIs.
    ///
    /// \param X        The left-hand MPI. This must point to an initialized MPI.
    /// \param Y        The right-hand MPI. This must point to an initialized MPI.
    ///
    /// \return         \c 1 if `|X|` is greater than `|Y|`.
    /// \return         \c -1 if `|X|` is lesser than `|Y|`.
    /// \return         \c 0 if `|X|` is equal to `|Y|`.
    pub fn mbedtls_mpi_cmp_abs(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Compare two MPIs.
    ///
    /// \param X        The left-hand MPI. This must point to an initialized MPI.
    /// \param Y        The right-hand MPI. This must point to an initialized MPI.
    ///
    /// \return         \c 1 if \p X is greater than \p Y.
    /// \return         \c -1 if \p X is lesser than \p Y.
    /// \return         \c 0 if \p X is equal to \p Y.
    pub fn mbedtls_mpi_cmp_mpi(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Check if an MPI is less than the other in constant time.
    ///
    /// \param X        The left-hand MPI. This must point to an initialized MPI
    ///                 with the same allocated length as Y.
    /// \param Y        The right-hand MPI. This must point to an initialized MPI
    ///                 with the same allocated length as X.
    /// \param ret      The result of the comparison:
    ///                 \c 1 if \p X is less than \p Y.
    ///                 \c 0 if \p X is greater than or equal to \p Y.
    ///
    /// \return         0 on success.
    /// \return         MBEDTLS_ERR_MPI_BAD_INPUT_DATA if the allocated length of
    ///                 the two input MPIs is not the same.
    pub fn mbedtls_mpi_lt_mpi_ct(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
        ret: *mut crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Compare an MPI with an integer.
    ///
    /// \param X        The left-hand MPI. This must point to an initialized MPI.
    /// \param z        The integer value to compare \p X to.
    ///
    /// \return         \c 1 if \p X is greater than \p z.
    /// \return         \c -1 if \p X is lesser than \p z.
    /// \return         \c 0 if \p X is equal to \p z.
    pub fn mbedtls_mpi_cmp_int(X: *const mbedtls_mpi, z: mbedtls_mpi_sint)
        -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform an unsigned addition of MPIs: X = |A| + |B|
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The first summand. This must point to an initialized MPI.
    /// \param B        The second summand. This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_add_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform an unsigned subtraction of MPIs: X = |A| - |B|
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The minuend. This must point to an initialized MPI.
    /// \param B        The subtrahend. This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \p B is greater than \p A.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_sub_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a signed addition of MPIs: X = A + B
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The first summand. This must point to an initialized MPI.
    /// \param B        The second summand. This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_add_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a signed subtraction of MPIs: X = A - B
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The minuend. This must point to an initialized MPI.
    /// \param B        The subtrahend. This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_sub_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a signed addition of an MPI and an integer: X = A + b
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The first summand. This must point to an initialized MPI.
    /// \param b        The second summand.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_add_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a signed subtraction of an MPI and an integer:
    ///                 X = A - b
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The minuend. This must point to an initialized MPI.
    /// \param b        The subtrahend.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_sub_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a multiplication of two MPIs: X = A * B
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The first factor. This must point to an initialized MPI.
    /// \param B        The second factor. This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_mul_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a multiplication of an MPI with an unsigned integer:
    ///                 X = A * b
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The first factor. This must point to an initialized MPI.
    /// \param b        The second factor.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_mul_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a division with remainder of two MPIs:
    ///                 A = Q * B + R
    ///
    /// \param Q        The destination MPI for the quotient.
    ///                 This may be \c NULL if the value of the
    ///                 quotient is not needed. This must not alias A or B.
    /// \param R        The destination MPI for the remainder value.
    ///                 This may be \c NULL if the value of the
    ///                 remainder is not needed. This must not alias A or B.
    /// \param A        The dividend. This must point to an initialized MPI.
    /// \param B        The divisor. This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p B equals zero.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_div_mpi(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a division with remainder of an MPI by an integer:
    ///                 A = Q * b + R
    ///
    /// \param Q        The destination MPI for the quotient.
    ///                 This may be \c NULL if the value of the
    ///                 quotient is not needed.  This must not alias A.
    /// \param R        The destination MPI for the remainder value.
    ///                 This may be \c NULL if the value of the
    ///                 remainder is not needed.  This must not alias A.
    /// \param A        The dividend. This must point to an initialized MPi.
    /// \param b        The divisor.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p b equals zero.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_div_int(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a modular reduction. R = A mod B
    ///
    /// \param R        The destination MPI for the residue value.
    ///                 This must point to an initialized MPI.
    /// \param A        The MPI to compute the residue of.
    ///                 This must point to an initialized MPI.
    /// \param B        The base of the modular reduction.
    ///                 This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p B equals zero.
    /// \return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \p B is negative.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_mod_mpi(
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a modular reduction with respect to an integer.
    ///                 r = A mod b
    ///
    /// \param r        The address at which to store the residue.
    ///                 This must not be \c NULL.
    /// \param A        The MPI to compute the residue of.
    ///                 This must point to an initialized MPi.
    /// \param b        The integer base of the modular reduction.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p b equals zero.
    /// \return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \p b is negative.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_mod_int(
        r: *mut mbedtls_mpi_uint,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a sliding-window exponentiation: X = A^E mod N
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    ///                 This must not alias E or N.
    /// \param A        The base of the exponentiation.
    ///                 This must point to an initialized MPI.
    /// \param E        The exponent MPI. This must point to an initialized MPI.
    /// \param N        The base for the modular reduction. This must point to an
    ///                 initialized MPI.
    /// \param prec_RR  A helper MPI depending solely on \p N which can be used to
    ///                 speed-up multiple modular exponentiations for the same value
    ///                 of \p N. This may be \c NULL. If it is not \c NULL, it must
    ///                 point to an initialized MPI. If it hasn't been used after
    ///                 the call to mbedtls_mpi_init(), this function will compute
    ///                 the helper value and store it in \p prec_RR for reuse on
    ///                 subsequent calls to this function. Otherwise, the function
    ///                 will assume that \p prec_RR holds the helper value set by a
    ///                 previous call to mbedtls_mpi_exp_mod(), and reuse it.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \c N is negative or
    ///                 even, or if \c E is negative.
    /// \return         Another negative error code on different kinds of failures.
    pub fn mbedtls_mpi_exp_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        prec_RR: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Fill an MPI with a number of random bytes.
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param size     The number of random bytes to generate.
    /// \param f_rng    The RNG function to use. This must not be \c NULL.
    /// \param p_rng    The RNG parameter to be passed to \p f_rng. This may be
    ///                 \c NULL if \p f_rng doesn't need a context argument.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on failure.
    ///
    /// \note           The bytes obtained from the RNG are interpreted
    ///                 as a big-endian representation of an MPI; this can
    ///                 be relevant in applications like deterministic ECDSA.
    pub fn mbedtls_mpi_fill_random(
        X: *mut mbedtls_mpi,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// Generate a random number uniformly in a range.
    ///
    /// This function generates a random number between \p min inclusive and
    /// \p N exclusive.
    ///
    /// The procedure complies with RFC 6979 §3.3 (deterministic ECDSA)
    /// when the RNG is a suitably parametrized instance of HMAC_DRBG
    /// and \p min is \c 1.
    ///
    /// \note           There are `N - min` possible outputs. The lower bound
    ///                 \p min can be reached, but the upper bound \p N cannot.
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param min      The minimum value to return.
    ///                 It must be nonnegative.
    /// \param N        The upper bound of the range, exclusive.
    ///                 In other words, this is one plus the maximum value to return.
    ///                 \p N must be strictly larger than \p min.
    /// \param f_rng    The RNG function to use. This must not be \c NULL.
    /// \param p_rng    The RNG parameter to be passed to \p f_rng.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \p min or \p N is invalid
    ///                 or if they are incompatible.
    /// \return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if the implementation was
    ///                 unable to find a suitable value within a limited number
    ///                 of attempts. This has a negligible probability if \p N
    ///                 is significantly larger than \p min, which is the case
    ///                 for all usual cryptographic applications.
    /// \return         Another negative error code on failure.
    pub fn mbedtls_mpi_random(
        X: *mut mbedtls_mpi,
        min: mbedtls_mpi_sint,
        N: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Compute the greatest common divisor: G = gcd(A, B)
    ///
    /// \param G        The destination MPI. This must point to an initialized MPI.
    /// \param A        The first operand. This must point to an initialized MPI.
    /// \param B        The second operand. This must point to an initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         Another negative error code on different kinds of failure.
    pub fn mbedtls_mpi_gcd(
        G: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Compute the modular inverse: X = A^-1 mod N
    ///
    /// \param X        The destination MPI. This must point to an initialized MPI.
    /// \param A        The MPI to calculate the modular inverse of. This must point
    ///                 to an initialized MPI.
    /// \param N        The base of the modular inversion. This must point to an
    ///                 initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \p N is less than
    ///                 or equal to one.
    /// \return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \p has no modular inverse
    ///                 with respect to \p N.
    pub fn mbedtls_mpi_inv_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Miller-Rabin primality test.
    ///
    /// \warning        If \p X is potentially generated by an adversary, for example
    ///                 when validating cryptographic parameters that you didn't
    ///                 generate yourself and that are supposed to be prime, then
    ///                 \p rounds should be at least the half of the security
    ///                 strength of the cryptographic algorithm. On the other hand,
    ///                 if \p X is chosen uniformly or non-adversarially (as is the
    ///                 case when mbedtls_mpi_gen_prime calls this function), then
    ///                 \p rounds can be much lower.
    ///
    /// \param X        The MPI to check for primality.
    ///                 This must point to an initialized MPI.
    /// \param rounds   The number of bases to perform the Miller-Rabin primality
    ///                 test for. The probability of returning 0 on a composite is
    ///                 at most 2<sup>-2*\p rounds</sup>.
    /// \param f_rng    The RNG function to use. This must not be \c NULL.
    /// \param p_rng    The RNG parameter to be passed to \p f_rng.
    ///                 This may be \c NULL if \p f_rng doesn't use
    ///                 a context parameter.
    ///
    /// \return         \c 0 if successful, i.e. \p X is probably prime.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \p X is not prime.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_mpi_is_prime_ext(
        X: *const mbedtls_mpi,
        rounds: crate::c_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
///< (X-1)/2 is prime too
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_DH: mbedtls_mpi_gen_prime_flag_t =
    1;
///< lower error rate from 2<sup>-80</sup> to 2<sup>-128</sup>
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR:
    mbedtls_mpi_gen_prime_flag_t = 2;
/// \brief Flags for mbedtls_mpi_gen_prime()
///
/// Each of these flags is a constraint on the result X returned by
/// mbedtls_mpi_gen_prime().
pub type mbedtls_mpi_gen_prime_flag_t = crate::c_types::c_uint;
extern "C" {
    /// \brief          Generate a prime number.
    ///
    /// \param X        The destination MPI to store the generated prime in.
    ///                 This must point to an initialized MPi.
    /// \param nbits    The required size of the destination MPI in bits.
    ///                 This must be between \c 3 and #MBEDTLS_MPI_MAX_BITS.
    /// \param flags    A mask of flags of type #mbedtls_mpi_gen_prime_flag_t.
    /// \param f_rng    The RNG function to use. This must not be \c NULL.
    /// \param p_rng    The RNG parameter to be passed to \p f_rng.
    ///                 This may be \c NULL if \p f_rng doesn't use
    ///                 a context parameter.
    ///
    /// \return         \c 0 if successful, in which case \p X holds a
    ///                 probably prime number.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
    /// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if `nbits` is not between
    ///                 \c 3 and #MBEDTLS_MPI_MAX_BITS.
    pub fn mbedtls_mpi_gen_prime(
        X: *mut mbedtls_mpi,
        nbits: usize,
        flags: crate::c_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Checkup routine
    ///
    /// \return         0 if successful, or 1 if the test failed
    pub fn mbedtls_mpi_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
///< Curve not defined.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
///< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
///< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
///< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
///< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
///< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
///< Domain parameters for 256-bit Brainpool curve.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
///< Domain parameters for 384-bit Brainpool curve.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
///< Domain parameters for 512-bit Brainpool curve.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
///< Domain parameters for Curve25519.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
///< Domain parameters for 192-bit "Koblitz" curve.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
///< Domain parameters for 224-bit "Koblitz" curve.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
///< Domain parameters for 256-bit "Koblitz" curve.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
///< Domain parameters for Curve448.
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE448: mbedtls_ecp_group_id = 13;
/// Domain-parameter identifiers: curve, subgroup, and generator.
///
/// \note Only curves over prime fields are supported.
///
/// \warning This library does not support validation of arbitrary domain
/// parameters. Therefore, only standardized domain parameters from trusted
/// sources should be used. See mbedtls_ecp_group_load().
pub type mbedtls_ecp_group_id = crate::c_types::c_uint;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_NONE: mbedtls_ecp_curve_type = 0;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS: mbedtls_ecp_curve_type = 1;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_MONTGOMERY: mbedtls_ecp_curve_type = 2;
pub type mbedtls_ecp_curve_type = crate::c_types::c_uint;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_NONE: mbedtls_ecp_modulus_type = 0;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_COORDINATE: mbedtls_ecp_modulus_type = 1;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_SCALAR: mbedtls_ecp_modulus_type = 2;
pub type mbedtls_ecp_modulus_type = crate::c_types::c_uint;
/// Curve information, for use by other modules.
///
/// The fields of this structure are part of the public API and can be
/// accessed directly by applications. Future versions of the library may
/// add extra fields or reorder existing fields.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
    ///< An internal identifier.
    pub grp_id: mbedtls_ecp_group_id,
    ///< The TLS NamedCurve identifier.
    pub tls_id: u16,
    ///< The curve size in bits.
    pub bit_size: u16,
    ///< A human-friendly name.
    pub name: *const crate::c_types::c_char,
}
/// \brief           The ECP point structure, in Jacobian coordinates.
///
/// \note            All functions expect and return points satisfying
///                  the following condition: <code>Z == 0</code> or
///                  <code>Z == 1</code>. Other values of \p Z are
///                  used only by internal functions.
///                  The point is zero, or "at infinity", if <code>Z == 0</code>.
///                  Otherwise, \p X and \p Y are its standard (affine)
///                  coordinates.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_point {
    ///< The X coordinate of the ECP point.
    pub private_X: mbedtls_mpi,
    ///< The Y coordinate of the ECP point.
    pub private_Y: mbedtls_mpi,
    ///< The Z coordinate of the ECP point.
    pub private_Z: mbedtls_mpi,
}
/// \brief           The ECP group structure.
///
/// We consider two types of curve equations:
/// <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>
/// (SEC1 + RFC-4492)</li>
/// <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,
/// Curve448)</li></ul>
/// In both cases, the generator (\p G) for a prime-order subgroup is fixed.
///
/// For Short Weierstrass, this subgroup is the whole curve, and its
/// cardinality is denoted by \p N. Our code requires that \p N is an
/// odd prime as mbedtls_ecp_mul() requires an odd number, and
/// mbedtls_ecdsa_sign() requires that it is prime for blinding purposes.
///
/// For Montgomery curves, we do not store \p A, but <code>(A + 2) / 4</code>,
/// which is the quantity used in the formulas. Additionally, \p nbits is
/// not the size of \p N but the required size for private keys.
///
/// If \p modp is NULL, reduction modulo \p P is done using a generic algorithm.
/// Otherwise, \p modp must point to a function that takes an \p mbedtls_mpi in the
/// range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer
/// which is congruent mod \p P to the given MPI, and is close enough to \p pbits
/// in size, so that it may be efficiently brought in the 0..P-1 range by a few
/// additions or subtractions. Therefore, it is only an approximative modular
/// reduction. It must return 0 on success and non-zero on failure.
///
/// \note        Alternative implementations of the ECP module must obey the
///              following constraints.
///              * Group IDs must be distinct: if two group structures have
///                the same ID, then they must be identical.
///              * The fields \c id, \c P, \c A, \c B, \c G, \c N,
///                \c pbits and \c nbits must have the same type and semantics
///                as in the built-in implementation.
///                They must be available for reading, but direct modification
///                of these fields does not need to be supported.
///                They do not need to be at the same offset in the structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_group {
    ///< An internal group identifier.
    pub id: mbedtls_ecp_group_id,
    ///< The prime modulus of the base field.
    pub P: mbedtls_mpi,
    ///< For Short Weierstrass: \p A in the equation. For
    ///Montgomery curves: <code>(A + 2) / 4</code>.
    pub A: mbedtls_mpi,
    ///< For Short Weierstrass: \p B in the equation.
    ///For Montgomery curves: unused.
    pub B: mbedtls_mpi,
    ///< The generator of the subgroup used.
    pub G: mbedtls_ecp_point,
    ///< The order of \p G.
    pub N: mbedtls_mpi,
    ///< The number of bits in \p P.
    pub pbits: usize,
    ///< For Short Weierstrass: The number of bits in \p P.
    ///For Montgomery curves: the number of bits in the
    ///private keys.
    pub nbits: usize,
    ///< \internal 1 if the constants are static.
    pub private_h: crate::c_types::c_uint,
    ///< The function for fast pseudo-reduction
    ///mod \p P (see above).
    pub private_modp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> crate::c_types::c_int,
    >,
    ///< Unused.
    pub private_t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    ///< Unused.
    pub private_t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    ///< Unused.
    pub private_t_data: *mut crate::c_types::c_void,
    ///< Pre-computed points for ecp_mul_comb().
    pub private_T: *mut mbedtls_ecp_point,
    ///< The number of dynamic allocated pre-computed points.
    pub private_T_size: usize,
}
pub type mbedtls_ecp_restart_ctx = crate::c_types::c_void;
/// \brief    The ECP key-pair structure.
///
/// A generic key-pair that may be used for ECDSA and fixed ECDH, for example.
///
/// \note    Members are deliberately in the same order as in the
///          ::mbedtls_ecdsa_context structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_keypair {
    ///<  Elliptic curve and base point
    pub private_grp: mbedtls_ecp_group,
    ///<  our secret value
    pub private_d: mbedtls_mpi,
    ///<  our public value
    pub private_Q: mbedtls_ecp_point,
}
extern "C" {
    pub fn mbedtls_ecp_get_type(grp: *const mbedtls_ecp_group) -> mbedtls_ecp_curve_type;
}
extern "C" {
    /// \brief           This function retrieves the information defined in
    ///                  mbedtls_ecp_curve_info() for all supported curves.
    ///
    /// \note            This function returns information about all curves
    ///                  supported by the library. Some curves may not be
    ///                  supported for all algorithms. Call mbedtls_ecdh_can_do()
    ///                  or mbedtls_ecdsa_can_do() to check if a curve is
    ///                  supported for ECDH or ECDSA.
    ///
    /// \return          A statically allocated array. The last entry is 0.
    pub fn mbedtls_ecp_curve_list() -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    /// \brief           This function retrieves the list of internal group
    ///                  identifiers of all supported curves in the order of
    ///                  preference.
    ///
    /// \note            This function returns information about all curves
    ///                  supported by the library. Some curves may not be
    ///                  supported for all algorithms. Call mbedtls_ecdh_can_do()
    ///                  or mbedtls_ecdsa_can_do() to check if a curve is
    ///                  supported for ECDH or ECDSA.
    ///
    /// \return          A statically allocated array,
    ///                  terminated with MBEDTLS_ECP_DP_NONE.
    pub fn mbedtls_ecp_grp_id_list() -> *const mbedtls_ecp_group_id;
}
extern "C" {
    /// \brief           This function retrieves curve information from an internal
    ///                  group identifier.
    ///
    /// \param grp_id    An \c MBEDTLS_ECP_DP_XXX value.
    ///
    /// \return          The associated curve information on success.
    /// \return          NULL on failure.
    pub fn mbedtls_ecp_curve_info_from_grp_id(
        grp_id: mbedtls_ecp_group_id,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    /// \brief           This function retrieves curve information from a TLS
    ///                  NamedCurve value.
    ///
    /// \param tls_id    An \c MBEDTLS_ECP_DP_XXX value.
    ///
    /// \return          The associated curve information on success.
    /// \return          NULL on failure.
    pub fn mbedtls_ecp_curve_info_from_tls_id(tls_id: u16) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    /// \brief           This function retrieves curve information from a
    ///                  human-readable name.
    ///
    /// \param name      The human-readable name.
    ///
    /// \return          The associated curve information on success.
    /// \return          NULL on failure.
    pub fn mbedtls_ecp_curve_info_from_name(
        name: *const crate::c_types::c_char,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    /// \brief           This function initializes a point as zero.
    ///
    /// \param pt        The point to initialize.
    pub fn mbedtls_ecp_point_init(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    /// \brief           This function initializes an ECP group context
    ///                  without loading any domain parameters.
    ///
    /// \note            After this function is called, domain parameters
    ///                  for various ECP groups can be loaded through the
    ///                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()
    ///                  functions.
    pub fn mbedtls_ecp_group_init(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    /// \brief           This function initializes a key pair as an invalid one.
    ///
    /// \param key       The key pair to initialize.
    pub fn mbedtls_ecp_keypair_init(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    /// \brief           This function frees the components of a point.
    ///
    /// \param pt        The point to free.
    pub fn mbedtls_ecp_point_free(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    /// \brief           This function frees the components of an ECP group.
    ///
    /// \param grp       The group to free. This may be \c NULL, in which
    ///                  case this function returns immediately. If it is not
    ///                  \c NULL, it must point to an initialized ECP group.
    pub fn mbedtls_ecp_group_free(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    /// \brief           This function frees the components of a key pair.
    ///
    /// \param key       The key pair to free. This may be \c NULL, in which
    ///                  case this function returns immediately. If it is not
    ///                  \c NULL, it must point to an initialized ECP key pair.
    pub fn mbedtls_ecp_keypair_free(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    /// \brief           This function copies the contents of point \p Q into
    ///                  point \p P.
    ///
    /// \param P         The destination point. This must be initialized.
    /// \param Q         The source point. This must be initialized.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          Another negative error code for other kinds of failure.
    pub fn mbedtls_ecp_copy(
        P: *mut mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function copies the contents of group \p src into
    ///                  group \p dst.
    ///
    /// \param dst       The destination group. This must be initialized.
    /// \param src       The source group. This must be initialized.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_group_copy(
        dst: *mut mbedtls_ecp_group,
        src: *const mbedtls_ecp_group,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function sets a point to the point at infinity.
    ///
    /// \param pt        The point to set. This must be initialized.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_set_zero(pt: *mut mbedtls_ecp_point) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function checks if a point is the point at infinity.
    ///
    /// \param pt        The point to test. This must be initialized.
    ///
    /// \return          \c 1 if the point is zero.
    /// \return          \c 0 if the point is non-zero.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecp_is_zero(pt: *mut mbedtls_ecp_point) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function compares two points.
    ///
    /// \note            This assumes that the points are normalized. Otherwise,
    ///                  they may compare as "not equal" even if they are.
    ///
    /// \param P         The first point to compare. This must be initialized.
    /// \param Q         The second point to compare. This must be initialized.
    ///
    /// \return          \c 0 if the points are equal.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal.
    pub fn mbedtls_ecp_point_cmp(
        P: *const mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function imports a non-zero point from two ASCII
    ///                  strings.
    ///
    /// \param P         The destination point. This must be initialized.
    /// \param radix     The numeric base of the input.
    /// \param x         The first affine coordinate, as a null-terminated string.
    /// \param y         The second affine coordinate, as a null-terminated string.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_MPI_XXX error code on failure.
    pub fn mbedtls_ecp_point_read_string(
        P: *mut mbedtls_ecp_point,
        radix: crate::c_types::c_int,
        x: *const crate::c_types::c_char,
        y: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function exports a point into unsigned binary data.
    ///
    /// \param grp       The group to which the point should belong.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param P         The point to export. This must be initialized.
    /// \param format    The point format. This must be either
    ///                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.
    ///                  (For groups without these formats, this parameter is
    ///                  ignored. But it still has to be either of the above
    ///                  values.)
    /// \param olen      The address at which to store the length of
    ///                  the output in Bytes. This must not be \c NULL.
    /// \param buf       The output buffer. This must be a writable buffer
    ///                  of length \p buflen Bytes.
    /// \param buflen    The length of the output buffer \p buf in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer
    ///                  is too small to hold the point.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format
    ///                  or the export for the given group is not implemented.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_point_write_binary(
        grp: *const mbedtls_ecp_group,
        P: *const mbedtls_ecp_point,
        format: crate::c_types::c_int,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function imports a point from unsigned binary data.
    ///
    /// \note            This function does not check that the point actually
    ///                  belongs to the given group, see mbedtls_ecp_check_pubkey()
    ///                  for that.
    ///
    /// \note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for
    ///                  limitations.
    ///
    /// \param grp       The group to which the point should belong.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param P         The destination context to import the point to.
    ///                  This must be initialized.
    /// \param buf       The input buffer. This must be a readable buffer
    ///                  of length \p ilen Bytes.
    /// \param ilen      The length of the input buffer \p buf in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the import for the
    ///                  given group is not implemented.
    pub fn mbedtls_ecp_point_read_binary(
        grp: *const mbedtls_ecp_group,
        P: *mut mbedtls_ecp_point,
        buf: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function imports a point from a TLS ECPoint record.
    ///
    /// \note            On function return, \p *buf is updated to point immediately
    ///                  after the ECPoint record.
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param pt        The destination point.
    /// \param buf       The address of the pointer to the start of the input buffer.
    /// \param len       The length of the buffer.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_MPI_XXX error code on initialization
    ///                  failure.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
    pub fn mbedtls_ecp_tls_read_point(
        grp: *const mbedtls_ecp_group,
        pt: *mut mbedtls_ecp_point,
        buf: *mut *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function exports a point as a TLS ECPoint record
    ///                  defined in RFC 4492, Section 5.4.
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param pt        The point to be exported. This must be initialized.
    /// \param format    The point format to use. This must be either
    ///                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.
    /// \param olen      The address at which to store the length in Bytes
    ///                  of the data written.
    /// \param buf       The target buffer. This must be a writable buffer of
    ///                  length \p blen Bytes.
    /// \param blen      The length of the target buffer \p buf in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.
    /// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer
    ///                  is too small to hold the exported point.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_tls_write_point(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
        format: crate::c_types::c_int,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function sets up an ECP group context
    ///                  from a standardized set of domain parameters.
    ///
    /// \note            The index should be a value of the NamedCurve enum,
    ///                  as defined in <em>RFC-4492: Elliptic Curve Cryptography
    ///                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,
    ///                  usually in the form of an \c MBEDTLS_ECP_DP_XXX macro.
    ///
    /// \param grp       The group context to setup. This must be initialized.
    /// \param id        The identifier of the domain parameter set to load.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p id doesn't
    ///                  correspond to a known group.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_group_load(
        grp: *mut mbedtls_ecp_group,
        id: mbedtls_ecp_group_id,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function sets up an ECP group context from a TLS
    ///                  ECParameters record as defined in RFC 4492, Section 5.4.
    ///
    /// \note            The read pointer \p buf is updated to point right after
    ///                  the ECParameters record on exit.
    ///
    /// \param grp       The group context to setup. This must be initialized.
    /// \param buf       The address of the pointer to the start of the input buffer.
    /// \param len       The length of the input buffer \c *buf in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not
    ///                  recognized.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_tls_read_group(
        grp: *mut mbedtls_ecp_group,
        buf: *mut *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function extracts an elliptic curve group ID from a
    ///                  TLS ECParameters record as defined in RFC 4492, Section 5.4.
    ///
    /// \note            The read pointer \p buf is updated to point right after
    ///                  the ECParameters record on exit.
    ///
    /// \param grp       The address at which to store the group id.
    ///                  This must not be \c NULL.
    /// \param buf       The address of the pointer to the start of the input buffer.
    /// \param len       The length of the input buffer \c *buf in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not
    ///                  recognized.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_tls_read_group_id(
        grp: *mut mbedtls_ecp_group_id,
        buf: *mut *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function exports an elliptic curve as a TLS
    ///                  ECParameters record as defined in RFC 4492, Section 5.4.
    ///
    /// \param grp       The ECP group to be exported.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param olen      The address at which to store the number of Bytes written.
    ///                  This must not be \c NULL.
    /// \param buf       The buffer to write to. This must be a writable buffer
    ///                  of length \p blen Bytes.
    /// \param blen      The length of the output buffer \p buf in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output
    ///                  buffer is too small to hold the exported group.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_tls_write_group(
        grp: *const mbedtls_ecp_group,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs a scalar multiplication of a point
    ///                  by an integer: \p R = \p m * \p P.
    ///
    ///                  It is not thread-safe to use same group in multiple threads.
    ///
    /// \note            To prevent timing attacks, this function
    ///                  executes the exact same sequence of base-field
    ///                  operations for any valid \p m. It avoids any if-branch or
    ///                  array index depending on the value of \p m. It also uses
    ///                  \p f_rng to randomize some intermediate results.
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param R         The point in which to store the result of the calculation.
    ///                  This must be initialized.
    /// \param m         The integer by which to multiply. This must be initialized.
    /// \param P         The point to multiply. This must be initialized.
    /// \param f_rng     The RNG function. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be \c
    ///                  NULL if \p f_rng doesn't need a context.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m is not a valid private
    ///                  key, or \p P is not a valid public key.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_mul(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs multiplication of a point by
    ///                  an integer: \p R = \p m * \p P in a restartable way.
    ///
    /// \see             mbedtls_ecp_mul()
    ///
    /// \note            This function does the same as \c mbedtls_ecp_mul(), but
    ///                  it can return early and restart according to the limit set
    ///                  with \c mbedtls_ecp_set_max_ops() to reduce blocking.
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param R         The point in which to store the result of the calculation.
    ///                  This must be initialized.
    /// \param m         The integer by which to multiply. This must be initialized.
    /// \param P         The point to multiply. This must be initialized.
    /// \param f_rng     The RNG function. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be \c
    ///                  NULL if \p f_rng doesn't need a context.
    /// \param rs_ctx    The restart context (NULL disables restart).
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m is not a valid private
    ///                  key, or \p P is not a valid public key.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_mul_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs multiplication and addition of two
    ///                  points by integers: \p R = \p m * \p P + \p n * \p Q
    ///
    ///                  It is not thread-safe to use same group in multiple threads.
    ///
    /// \note            In contrast to mbedtls_ecp_mul(), this function does not
    ///                  guarantee a constant execution flow and timing.
    ///
    /// \note            This function is only defined for short Weierstrass curves.
    ///                  It may not be included in builds without any short
    ///                  Weierstrass curve.
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param R         The point in which to store the result of the calculation.
    ///                  This must be initialized.
    /// \param m         The integer by which to multiply \p P.
    ///                  This must be initialized.
    /// \param P         The point to multiply by \p m. This must be initialized.
    /// \param n         The integer by which to multiply \p Q.
    ///                  This must be initialized.
    /// \param Q         The point to be multiplied by \p n.
    ///                  This must be initialized.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m or \p n are not
    ///                  valid private keys, or \p P or \p Q are not valid public
    ///                  keys.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p grp does not
    ///                  designate a short Weierstrass curve.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_muladd(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs multiplication and addition of two
    ///                  points by integers: \p R = \p m * \p P + \p n * \p Q in a
    ///                  restartable way.
    ///
    /// \see             \c mbedtls_ecp_muladd()
    ///
    /// \note            This function works the same as \c mbedtls_ecp_muladd(),
    ///                  but it can return early and restart according to the limit
    ///                  set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
    ///
    /// \note            This function is only defined for short Weierstrass curves.
    ///                  It may not be included in builds without any short
    ///                  Weierstrass curve.
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param R         The point in which to store the result of the calculation.
    ///                  This must be initialized.
    /// \param m         The integer by which to multiply \p P.
    ///                  This must be initialized.
    /// \param P         The point to multiply by \p m. This must be initialized.
    /// \param n         The integer by which to multiply \p Q.
    ///                  This must be initialized.
    /// \param Q         The point to be multiplied by \p n.
    ///                  This must be initialized.
    /// \param rs_ctx    The restart context (NULL disables restart).
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m or \p n are not
    ///                  valid private keys, or \p P or \p Q are not valid public
    ///                  keys.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p grp does not
    ///                  designate a short Weierstrass curve.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_muladd_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function checks that a point is a valid public key
    ///                  on this curve.
    ///
    ///                  It only checks that the point is non-zero, has
    ///                  valid coordinates and lies on the curve. It does not verify
    ///                  that it is indeed a multiple of \p G. This additional
    ///                  check is computationally more expensive, is not required
    ///                  by standards, and should not be necessary if the group
    ///                  used has a small cofactor. In particular, it is useless for
    ///                  the NIST groups which all have a cofactor of 1.
    ///
    /// \note            This function uses bare components rather than an
    ///                  ::mbedtls_ecp_keypair structure, to ease use with other
    ///                  structures, such as ::mbedtls_ecdh_context or
    ///                  ::mbedtls_ecdsa_context.
    ///
    /// \param grp       The ECP group the point should belong to.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param pt        The point to check. This must be initialized.
    ///
    /// \return          \c 0 if the point is a valid public key.
    /// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not
    ///                  a valid public key for the given curve.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_check_pubkey(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function checks that an \p mbedtls_mpi is a
    ///                  valid private key for this curve.
    ///
    /// \note            This function uses bare components rather than an
    ///                  ::mbedtls_ecp_keypair structure to ease use with other
    ///                  structures, such as ::mbedtls_ecdh_context or
    ///                  ::mbedtls_ecdsa_context.
    ///
    /// \param grp       The ECP group the private key should belong to.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param d         The integer to check. This must be initialized.
    ///
    /// \return          \c 0 if the point is a valid private key.
    /// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid
    ///                  private key for the given curve.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_check_privkey(
        grp: *const mbedtls_ecp_group,
        d: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function generates a private key.
    ///
    /// \param grp       The ECP group to generate a private key for.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param d         The destination MPI (secret part). This must be initialized.
    /// \param f_rng     The RNG function. This must not be \c NULL.
    /// \param p_rng     The RNG parameter to be passed to \p f_rng. This may be
    ///                  \c NULL if \p f_rng doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
    ///                  on failure.
    pub fn mbedtls_ecp_gen_privkey(
        grp: *const mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function generates a keypair with a configurable base
    ///                  point.
    ///
    /// \note            This function uses bare components rather than an
    ///                  ::mbedtls_ecp_keypair structure to ease use with other
    ///                  structures, such as ::mbedtls_ecdh_context or
    ///                  ::mbedtls_ecdsa_context.
    ///
    /// \param grp       The ECP group to generate a key pair for.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param G         The base point to use. This must be initialized
    ///                  and belong to \p grp. It replaces the default base
    ///                  point \c grp->G used by mbedtls_ecp_gen_keypair().
    /// \param d         The destination MPI (secret part).
    ///                  This must be initialized.
    /// \param Q         The destination point (public part).
    ///                  This must be initialized.
    /// \param f_rng     The RNG function. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may
    ///                  be \c NULL if \p f_rng doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
    ///                  on failure.
    pub fn mbedtls_ecp_gen_keypair_base(
        grp: *mut mbedtls_ecp_group,
        G: *const mbedtls_ecp_point,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function generates an ECP keypair.
    ///
    /// \note            This function uses bare components rather than an
    ///                  ::mbedtls_ecp_keypair structure to ease use with other
    ///                  structures, such as ::mbedtls_ecdh_context or
    ///                  ::mbedtls_ecdsa_context.
    ///
    /// \param grp       The ECP group to generate a key pair for.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param d         The destination MPI (secret part).
    ///                  This must be initialized.
    /// \param Q         The destination point (public part).
    ///                  This must be initialized.
    /// \param f_rng     The RNG function. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may
    ///                  be \c NULL if \p f_rng doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
    ///                  on failure.
    pub fn mbedtls_ecp_gen_keypair(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function generates an ECP key.
    ///
    /// \param grp_id    The ECP group identifier.
    /// \param key       The destination key. This must be initialized.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may
    ///                  be \c NULL if \p f_rng doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
    ///                  on failure.
    pub fn mbedtls_ecp_gen_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function reads an elliptic curve private key.
    ///
    /// \param grp_id    The ECP group identifier.
    /// \param key       The destination key.
    /// \param buf       The buffer containing the binary representation of the
    ///                  key. (Big endian integer for Weierstrass curves, byte
    ///                  string for Montgomery curves.)
    /// \param buflen    The length of the buffer in bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_INVALID_KEY error if the key is
    ///                  invalid.
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for
    ///                  the group is not implemented.
    /// \return          Another negative error code on different kinds of failure.
    pub fn mbedtls_ecp_read_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function exports an elliptic curve private key.
    ///
    /// \param key       The private key.
    /// \param buf       The output buffer for containing the binary representation
    ///                  of the key. (Big endian integer for Weierstrass curves, byte
    ///                  string for Montgomery curves.)
    /// \param buflen    The total length of the buffer in bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the \p key
    ///representation is larger than the available space in \p buf.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for
    ///                  the group is not implemented.
    /// \return          Another negative error code on different kinds of failure.
    pub fn mbedtls_ecp_write_key(
        key: *mut mbedtls_ecp_keypair,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function checks that the keypair objects
    ///                  \p pub and \p prv have the same group and the
    ///                  same public point, and that the private key in
    ///                  \p prv is consistent with the public key.
    ///
    /// \param pub       The keypair structure holding the public key. This
    ///                  must be initialized. If it contains a private key, that
    ///                  part is ignored.
    /// \param prv       The keypair structure holding the full keypair.
    ///                  This must be initialized.
    /// \param f_rng     The RNG function. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be \c
    ///                  NULL if \p f_rng doesn't need a context.
    ///
    /// \return          \c 0 on success, meaning that the keys are valid and match.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or an \c MBEDTLS_ERR_MPI_XXX
    ///                  error code on calculation failure.
    pub fn mbedtls_ecp_check_pub_priv(
        pub_: *const mbedtls_ecp_keypair,
        prv: *const mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function exports generic key-pair parameters.
    ///
    /// \param key       The key pair to export from.
    /// \param grp       Slot for exported ECP group.
    ///                  It must point to an initialized ECP group.
    /// \param d         Slot for the exported secret value.
    ///                  It must point to an initialized mpi.
    /// \param Q         Slot for the exported public value.
    ///                  It must point to an initialized ECP point.
    ///
    /// \return          \c 0 on success,
    /// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
    /// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if key id doesn't
    ///                  correspond to a known group.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_ecp_export(
        key: *const mbedtls_ecp_keypair,
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The ECP checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_ecp_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
///< None.
pub const mbedtls_md_type_t_MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
///< The MD5 message digest.
pub const mbedtls_md_type_t_MBEDTLS_MD_MD5: mbedtls_md_type_t = 1;
///< The SHA-1 message digest.
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA1: mbedtls_md_type_t = 2;
///< The SHA-224 message digest.
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA224: mbedtls_md_type_t = 3;
///< The SHA-256 message digest.
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA256: mbedtls_md_type_t = 4;
///< The SHA-384 message digest.
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA384: mbedtls_md_type_t = 5;
///< The SHA-512 message digest.
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA512: mbedtls_md_type_t = 6;
///< The RIPEMD-160 message digest.
pub const mbedtls_md_type_t_MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 7;
/// \brief     Supported message digests.
///
/// \warning   MD5 and SHA-1 are considered weak message digests and
///            their use constitutes a security risk. We recommend considering
///            stronger message digests instead.
pub type mbedtls_md_type_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md_info_t {
    _unused: [u8; 0],
}
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_LEGACY: mbedtls_md_engine_t = 0;
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_PSA: mbedtls_md_engine_t = 1;
/// Used internally to indicate whether a context uses legacy or PSA.
///
/// Internal use only.
pub type mbedtls_md_engine_t = crate::c_types::c_uint;
/// The generic message-digest context.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md_context_t {
    /// Information about the associated message digest.
    pub private_md_info: *const mbedtls_md_info_t,
    /// The digest-specific context (legacy) or the PSA operation.
    pub private_md_ctx: *mut crate::c_types::c_void,
    /// The HMAC part of the context.
    pub private_hmac_ctx: *mut crate::c_types::c_void,
}
extern "C" {
    /// \brief           This function returns the message-digest information
    ///                  associated with the given digest type.
    ///
    /// \param md_type   The type of digest to search for.
    ///
    /// \return          The message-digest information associated with \p md_type.
    /// \return          NULL if the associated message-digest information is not found.
    pub fn mbedtls_md_info_from_type(md_type: mbedtls_md_type_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    /// \brief           This function initializes a message-digest context without
    ///                  binding it to a particular message-digest algorithm.
    ///
    ///                  This function should always be called first. It prepares the
    ///                  context for mbedtls_md_setup() for binding it to a
    ///                  message-digest algorithm.
    pub fn mbedtls_md_init(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    /// \brief           This function clears the internal structure of \p ctx and
    ///                  frees any embedded internal structure, but does not free
    ///                  \p ctx itself.
    ///
    ///                  If you have called mbedtls_md_setup() on \p ctx, you must
    ///                  call mbedtls_md_free() when you are no longer using the
    ///                  context.
    ///                  Calling this function if you have previously
    ///                  called mbedtls_md_init() and nothing else is optional.
    ///                  You must not call this function if you have not called
    ///                  mbedtls_md_init().
    pub fn mbedtls_md_free(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    /// \brief           This function selects the message digest algorithm to use,
    ///                  and allocates internal structures.
    ///
    ///                  It should be called after mbedtls_md_init() or
    ///                  mbedtls_md_free(). Makes it necessary to call
    ///                  mbedtls_md_free() later.
    ///
    /// \param ctx       The context to set up.
    /// \param md_info   The information structure of the message-digest algorithm
    ///                  to use.
    /// \param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),
    ///                  or non-zero: HMAC is used with this context.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    /// \return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure.
    pub fn mbedtls_md_setup(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
        hmac: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function clones the state of a message-digest
    ///                  context.
    ///
    /// \note            You must call mbedtls_md_setup() on \c dst before calling
    ///                  this function.
    ///
    /// \note            The two contexts must have the same type,
    ///                  for example, both are SHA-256.
    ///
    /// \warning         This function clones the message-digest state, not the
    ///                  HMAC state.
    ///
    /// \param dst       The destination context.
    /// \param src       The context to be cloned.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure.
    /// \return          #MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE if both contexts are
    ///                  not using the same engine. This can be avoided by moving
    ///                  the call to psa_crypto_init() before the first call to
    ///                  mbedtls_md_setup().
    pub fn mbedtls_md_clone(
        dst: *mut mbedtls_md_context_t,
        src: *const mbedtls_md_context_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function extracts the message-digest size from the
    ///                  message-digest information structure.
    ///
    /// \param md_info   The information structure of the message-digest algorithm
    ///                  to use.
    ///
    /// \return          The size of the message-digest output in Bytes.
    pub fn mbedtls_md_get_size(md_info: *const mbedtls_md_info_t) -> crate::c_types::c_uchar;
}
extern "C" {
    /// \brief           This function extracts the message-digest type from the
    ///                  message-digest information structure.
    ///
    /// \param md_info   The information structure of the message-digest algorithm
    ///                  to use.
    ///
    /// \return          The type of the message digest.
    pub fn mbedtls_md_get_type(md_info: *const mbedtls_md_info_t) -> mbedtls_md_type_t;
}
extern "C" {
    /// \brief           This function starts a message-digest computation.
    ///
    ///                  You must call this function after setting up the context
    ///                  with mbedtls_md_setup(), and before passing data with
    ///                  mbedtls_md_update().
    ///
    /// \param ctx       The generic message-digest context.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    pub fn mbedtls_md_starts(ctx: *mut mbedtls_md_context_t) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function feeds an input buffer into an ongoing
    ///                  message-digest computation.
    ///
    ///                  You must call mbedtls_md_starts() before calling this
    ///                  function. You may call this function multiple times.
    ///                  Afterwards, call mbedtls_md_finish().
    ///
    /// \param ctx       The generic message-digest context.
    /// \param input     The buffer holding the input data.
    /// \param ilen      The length of the input data.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    pub fn mbedtls_md_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function finishes the digest operation,
    ///                  and writes the result to the output buffer.
    ///
    ///                  Call this function after a call to mbedtls_md_starts(),
    ///                  followed by any number of calls to mbedtls_md_update().
    ///                  Afterwards, you may either clear the context with
    ///                  mbedtls_md_free(), or call mbedtls_md_starts() to reuse
    ///                  the context for another digest operation with the same
    ///                  algorithm.
    ///
    /// \param ctx       The generic message-digest context.
    /// \param output    The buffer for the generic message-digest checksum result.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    pub fn mbedtls_md_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function calculates the message-digest of a buffer,
    ///                 with respect to a configurable message-digest algorithm
    ///                 in a single call.
    ///
    ///                 The result is calculated as
    ///                 Output = message_digest(input buffer).
    ///
    /// \param md_info  The information structure of the message-digest algorithm
    ///                 to use.
    /// \param input    The buffer holding the data.
    /// \param ilen     The length of the input data.
    /// \param output   The generic message-digest checksum result.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                 failure.
    pub fn mbedtls_md(
        md_info: *const mbedtls_md_info_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function returns the list of digests supported by the
    ///                  generic digest module.
    ///
    /// \note            The list starts with the strongest available hashes.
    ///
    /// \return          A statically allocated array of digests. Each element
    ///                  in the returned list is an integer belonging to the
    ///                  message-digest enumeration #mbedtls_md_type_t.
    ///                  The last entry is 0.
    pub fn mbedtls_md_list() -> *const crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function returns the message-digest information
    ///                  associated with the given digest name.
    ///
    /// \param md_name   The name of the digest to search for.
    ///
    /// \return          The message-digest information associated with \p md_name.
    /// \return          NULL if the associated message-digest information is not found.
    pub fn mbedtls_md_info_from_string(
        md_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_md_info_t;
}
extern "C" {
    /// \brief           This function extracts the message-digest name from the
    ///                  message-digest information structure.
    ///
    /// \param md_info   The information structure of the message-digest algorithm
    ///                  to use.
    ///
    /// \return          The name of the message digest.
    pub fn mbedtls_md_get_name(md_info: *const mbedtls_md_info_t) -> *const crate::c_types::c_char;
}
extern "C" {
    /// \brief           This function returns the message-digest information
    ///                  from the given context.
    ///
    /// \param ctx       The context from which to extract the information.
    ///                  This must be initialized (or \c NULL).
    ///
    /// \return          The message-digest information associated with \p ctx.
    /// \return          \c NULL if \p ctx is \c NULL.
    pub fn mbedtls_md_info_from_ctx(ctx: *const mbedtls_md_context_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    /// \brief           This function sets the HMAC key and prepares to
    ///                  authenticate a new message.
    ///
    ///                  Call this function after mbedtls_md_setup(), to use
    ///                  the MD context for an HMAC calculation, then call
    ///                  mbedtls_md_hmac_update() to provide the input data, and
    ///                  mbedtls_md_hmac_finish() to get the HMAC value.
    ///
    /// \param ctx       The message digest context containing an embedded HMAC
    ///                  context.
    /// \param key       The HMAC secret key.
    /// \param keylen    The length of the HMAC key in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    pub fn mbedtls_md_hmac_starts(
        ctx: *mut mbedtls_md_context_t,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function feeds an input buffer into an ongoing HMAC
    ///                  computation.
    ///
    ///                  Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()
    ///                  before calling this function.
    ///                  You may call this function multiple times to pass the
    ///                  input piecewise.
    ///                  Afterwards, call mbedtls_md_hmac_finish().
    ///
    /// \param ctx       The message digest context containing an embedded HMAC
    ///                  context.
    /// \param input     The buffer holding the input data.
    /// \param ilen      The length of the input data.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    pub fn mbedtls_md_hmac_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function finishes the HMAC operation, and writes
    ///                  the result to the output buffer.
    ///
    ///                  Call this function after mbedtls_md_hmac_starts() and
    ///                  mbedtls_md_hmac_update() to get the HMAC value. Afterwards
    ///                  you may either call mbedtls_md_free() to clear the context,
    ///                  or call mbedtls_md_hmac_reset() to reuse the context with
    ///                  the same HMAC key.
    ///
    /// \param ctx       The message digest context containing an embedded HMAC
    ///                  context.
    /// \param output    The generic HMAC checksum result.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    pub fn mbedtls_md_hmac_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function prepares to authenticate a new message with
    ///                  the same key as the previous HMAC operation.
    ///
    ///                  You may call this function after mbedtls_md_hmac_finish().
    ///                  Afterwards call mbedtls_md_hmac_update() to pass the new
    ///                  input.
    ///
    /// \param ctx       The message digest context containing an embedded HMAC
    ///                  context.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                  failure.
    pub fn mbedtls_md_hmac_reset(ctx: *mut mbedtls_md_context_t) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function calculates the full generic HMAC
    ///                 on the input buffer with the provided key.
    ///
    ///                 The function allocates the context, performs the
    ///                 calculation, and frees the context.
    ///
    ///                 The HMAC result is calculated as
    ///                 output = generic HMAC(hmac key, input buffer).
    ///
    /// \param md_info  The information structure of the message-digest algorithm
    ///                 to use.
    /// \param key      The HMAC secret key.
    /// \param keylen   The length of the HMAC secret key in Bytes.
    /// \param input    The buffer holding the input data.
    /// \param ilen     The length of the input data.
    /// \param output   The generic HMAC result.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
    ///                 failure.
    pub fn mbedtls_md_hmac(
        md_info: *const mbedtls_md_info_t,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
/// \brief   The RSA context structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_rsa_context {
    ///<  Reserved for internal purposes.
    ///    Do not set this field in application
    ///    code. Its meaning might change without
    ///    notice.
    pub private_ver: crate::c_types::c_int,
    ///<  The size of \p N in Bytes.
    pub private_len: usize,
    ///<  The public modulus.
    pub private_N: mbedtls_mpi,
    ///<  The public exponent.
    pub private_E: mbedtls_mpi,
    ///<  The private exponent.
    pub private_D: mbedtls_mpi,
    ///<  The first prime factor.
    pub private_P: mbedtls_mpi,
    ///<  The second prime factor.
    pub private_Q: mbedtls_mpi,
    ///<  <code>D % (P - 1)</code>.
    pub private_DP: mbedtls_mpi,
    ///<  <code>D % (Q - 1)</code>.
    pub private_DQ: mbedtls_mpi,
    ///<  <code>1 / (Q % P)</code>.
    pub private_QP: mbedtls_mpi,
    ///<  cached <code>R^2 mod N</code>.
    pub private_RN: mbedtls_mpi,
    ///<  cached <code>R^2 mod P</code>.
    pub private_RP: mbedtls_mpi,
    ///<  cached <code>R^2 mod Q</code>.
    pub private_RQ: mbedtls_mpi,
    ///<  The cached blinding value.
    pub private_Vi: mbedtls_mpi,
    ///<  The cached un-blinding value.
    pub private_Vf: mbedtls_mpi,
    ///< Selects padding mode:
    ///#MBEDTLS_RSA_PKCS_V15 for 1.5 padding and
    ///#MBEDTLS_RSA_PKCS_V21 for OAEP or PSS.
    pub private_padding: crate::c_types::c_int,
    ///< Hash identifier of mbedtls_md_type_t type,
    ///as specified in md.h for use in the MGF
    ///mask generating function used in the
    ///EME-OAEP and EMSA-PSS encodings.
    pub private_hash_id: crate::c_types::c_int,
}
extern "C" {
    /// \brief          This function initializes an RSA context.
    ///
    /// \note           This function initializes the padding and the hash
    ///                 identifier to respectively #MBEDTLS_RSA_PKCS_V15 and
    ///                 #MBEDTLS_MD_NONE. See mbedtls_rsa_set_padding() for more
    ///                 information about those parameters.
    ///
    /// \param ctx      The RSA context to initialize. This must not be \c NULL.
    pub fn mbedtls_rsa_init(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    /// \brief          This function sets padding for an already initialized RSA
    ///                 context.
    ///
    /// \note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP
    ///                 encryption scheme and the RSASSA-PSS signature scheme.
    ///
    /// \note           The \p hash_id parameter is ignored when using
    ///                 #MBEDTLS_RSA_PKCS_V15 padding.
    ///
    /// \note           The choice of padding mode is strictly enforced for private
    ///                 key operations, since there might be security concerns in
    ///                 mixing padding modes. For public key operations it is
    ///                 a default value, which can be overridden by calling specific
    ///                 \c mbedtls_rsa_rsaes_xxx or \c mbedtls_rsa_rsassa_xxx
    ///                 functions.
    ///
    /// \note           The hash selected in \p hash_id is always used for OEAP
    ///                 encryption. For PSS signatures, it is always used for
    ///                 making signatures, but can be overridden for verifying them.
    ///                 If set to #MBEDTLS_MD_NONE, it is always overridden.
    ///
    /// \param ctx      The initialized RSA context to be configured.
    /// \param padding  The padding mode to use. This must be either
    ///                 #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21.
    /// \param hash_id  The hash identifier for PSS or OAEP, if \p padding is
    ///                 #MBEDTLS_RSA_PKCS_V21. #MBEDTLS_MD_NONE is accepted by this
    ///                 function but may be not suitable for some operations.
    ///                 Ignored if \p padding is #MBEDTLS_RSA_PKCS_V15.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_RSA_INVALID_PADDING failure:
    ///                 \p padding or \p hash_id is invalid.
    pub fn mbedtls_rsa_set_padding(
        ctx: *mut mbedtls_rsa_context,
        padding: crate::c_types::c_int,
        hash_id: mbedtls_md_type_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function retrieves padding mode of initialized
    ///                 RSA context.
    ///
    /// \param ctx      The initialized RSA context.
    ///
    /// \return         RSA padding mode.
    pub fn mbedtls_rsa_get_padding_mode(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function retrieves hash identifier of mbedtls_md_type_t
    ///                 type.
    ///
    /// \param ctx      The initialized RSA context.
    ///
    /// \return         Hash identifier of mbedtls_md_type_t type.
    pub fn mbedtls_rsa_get_md_alg(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function imports a set of core parameters into an
    ///                 RSA context.
    ///
    /// \note           This function can be called multiple times for successive
    ///                 imports, if the parameters are not simultaneously present.
    ///
    ///                 Any sequence of calls to this function should be followed
    ///                 by a call to mbedtls_rsa_complete(), which checks and
    ///                 completes the provided information to a ready-for-use
    ///                 public or private RSA key.
    ///
    /// \note           See mbedtls_rsa_complete() for more information on which
    ///                 parameters are necessary to set up a private or public
    ///                 RSA key.
    ///
    /// \note           The imported parameters are copied and need not be preserved
    ///                 for the lifetime of the RSA context being set up.
    ///
    /// \param ctx      The initialized RSA context to store the parameters in.
    /// \param N        The RSA modulus. This may be \c NULL.
    /// \param P        The first prime factor of \p N. This may be \c NULL.
    /// \param Q        The second prime factor of \p N. This may be \c NULL.
    /// \param D        The private exponent. This may be \c NULL.
    /// \param E        The public exponent. This may be \c NULL.
    ///
    /// \return         \c 0 on success.
    /// \return         A non-zero error code on failure.
    pub fn mbedtls_rsa_import(
        ctx: *mut mbedtls_rsa_context,
        N: *const mbedtls_mpi,
        P: *const mbedtls_mpi,
        Q: *const mbedtls_mpi,
        D: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function imports core RSA parameters, in raw big-endian
    ///                 binary format, into an RSA context.
    ///
    /// \note           This function can be called multiple times for successive
    ///                 imports, if the parameters are not simultaneously present.
    ///
    ///                 Any sequence of calls to this function should be followed
    ///                 by a call to mbedtls_rsa_complete(), which checks and
    ///                 completes the provided information to a ready-for-use
    ///                 public or private RSA key.
    ///
    /// \note           See mbedtls_rsa_complete() for more information on which
    ///                 parameters are necessary to set up a private or public
    ///                 RSA key.
    ///
    /// \note           The imported parameters are copied and need not be preserved
    ///                 for the lifetime of the RSA context being set up.
    ///
    /// \param ctx      The initialized RSA context to store the parameters in.
    /// \param N        The RSA modulus. This may be \c NULL.
    /// \param N_len    The Byte length of \p N; it is ignored if \p N == NULL.
    /// \param P        The first prime factor of \p N. This may be \c NULL.
    /// \param P_len    The Byte length of \p P; it is ignored if \p P == NULL.
    /// \param Q        The second prime factor of \p N. This may be \c NULL.
    /// \param Q_len    The Byte length of \p Q; it is ignored if \p Q == NULL.
    /// \param D        The private exponent. This may be \c NULL.
    /// \param D_len    The Byte length of \p D; it is ignored if \p D == NULL.
    /// \param E        The public exponent. This may be \c NULL.
    /// \param E_len    The Byte length of \p E; it is ignored if \p E == NULL.
    ///
    /// \return         \c 0 on success.
    /// \return         A non-zero error code on failure.
    pub fn mbedtls_rsa_import_raw(
        ctx: *mut mbedtls_rsa_context,
        N: *const crate::c_types::c_uchar,
        N_len: usize,
        P: *const crate::c_types::c_uchar,
        P_len: usize,
        Q: *const crate::c_types::c_uchar,
        Q_len: usize,
        D: *const crate::c_types::c_uchar,
        D_len: usize,
        E: *const crate::c_types::c_uchar,
        E_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function completes an RSA context from
    ///                 a set of imported core parameters.
    ///
    ///                 To setup an RSA public key, precisely \p N and \p E
    ///                 must have been imported.
    ///
    ///                 To setup an RSA private key, sufficient information must
    ///                 be present for the other parameters to be derivable.
    ///
    ///                 The default implementation supports the following:
    ///                 <ul><li>Derive \p P, \p Q from \p N, \p D, \p E.</li>
    ///                 <li>Derive \p N, \p D from \p P, \p Q, \p E.</li></ul>
    ///                 Alternative implementations need not support these.
    ///
    ///                 If this function runs successfully, it guarantees that
    ///                 the RSA context can be used for RSA operations without
    ///                 the risk of failure or crash.
    ///
    /// \warning        This function need not perform consistency checks
    ///                 for the imported parameters. In particular, parameters that
    ///                 are not needed by the implementation might be silently
    ///                 discarded and left unchecked. To check the consistency
    ///                 of the key material, see mbedtls_rsa_check_privkey().
    ///
    /// \param ctx      The initialized RSA context holding imported parameters.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_RSA_BAD_INPUT_DATA if the attempted derivations
    ///                 failed.
    pub fn mbedtls_rsa_complete(ctx: *mut mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function exports the core parameters of an RSA key.
    ///
    ///                 If this function runs successfully, the non-NULL buffers
    ///                 pointed to by \p N, \p P, \p Q, \p D, and \p E are fully
    ///                 written, with additional unused space filled leading by
    ///                 zero Bytes.
    ///
    ///                 Possible reasons for returning
    ///                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>
    ///                 <li>An alternative RSA implementation is in use, which
    ///                 stores the key externally, and either cannot or should
    ///                 not export it into RAM.</li>
    ///                 <li>A SW or HW implementation might not support a certain
    ///                 deduction. For example, \p P, \p Q from \p N, \p D,
    ///                 and \p E if the former are not part of the
    ///                 implementation.</li></ul>
    ///
    ///                 If the function fails due to an unsupported operation,
    ///                 the RSA context stays intact and remains usable.
    ///
    /// \param ctx      The initialized RSA context.
    /// \param N        The MPI to hold the RSA modulus.
    ///                 This may be \c NULL if this field need not be exported.
    /// \param P        The MPI to hold the first prime factor of \p N.
    ///                 This may be \c NULL if this field need not be exported.
    /// \param Q        The MPI to hold the second prime factor of \p N.
    ///                 This may be \c NULL if this field need not be exported.
    /// \param D        The MPI to hold the private exponent.
    ///                 This may be \c NULL if this field need not be exported.
    /// \param E        The MPI to hold the public exponent.
    ///                 This may be \c NULL if this field need not be exported.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the
    ///                 requested parameters cannot be done due to missing
    ///                 functionality or because of security policies.
    /// \return         A non-zero return code on any other failure.
    pub fn mbedtls_rsa_export(
        ctx: *const mbedtls_rsa_context,
        N: *mut mbedtls_mpi,
        P: *mut mbedtls_mpi,
        Q: *mut mbedtls_mpi,
        D: *mut mbedtls_mpi,
        E: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function exports core parameters of an RSA key
    ///                 in raw big-endian binary format.
    ///
    ///                 If this function runs successfully, the non-NULL buffers
    ///                 pointed to by \p N, \p P, \p Q, \p D, and \p E are fully
    ///                 written, with additional unused space filled leading by
    ///                 zero Bytes.
    ///
    ///                 Possible reasons for returning
    ///                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>
    ///                 <li>An alternative RSA implementation is in use, which
    ///                 stores the key externally, and either cannot or should
    ///                 not export it into RAM.</li>
    ///                 <li>A SW or HW implementation might not support a certain
    ///                 deduction. For example, \p P, \p Q from \p N, \p D,
    ///                 and \p E if the former are not part of the
    ///                 implementation.</li></ul>
    ///                 If the function fails due to an unsupported operation,
    ///                 the RSA context stays intact and remains usable.
    ///
    /// \note           The length parameters are ignored if the corresponding
    ///                 buffer pointers are NULL.
    ///
    /// \param ctx      The initialized RSA context.
    /// \param N        The Byte array to store the RSA modulus,
    ///                 or \c NULL if this field need not be exported.
    /// \param N_len    The size of the buffer for the modulus.
    /// \param P        The Byte array to hold the first prime factor of \p N,
    ///                 or \c NULL if this field need not be exported.
    /// \param P_len    The size of the buffer for the first prime factor.
    /// \param Q        The Byte array to hold the second prime factor of \p N,
    ///                 or \c NULL if this field need not be exported.
    /// \param Q_len    The size of the buffer for the second prime factor.
    /// \param D        The Byte array to hold the private exponent,
    ///                 or \c NULL if this field need not be exported.
    /// \param D_len    The size of the buffer for the private exponent.
    /// \param E        The Byte array to hold the public exponent,
    ///                 or \c NULL if this field need not be exported.
    /// \param E_len    The size of the buffer for the public exponent.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the
    ///                 requested parameters cannot be done due to missing
    ///                 functionality or because of security policies.
    /// \return         A non-zero return code on any other failure.
    pub fn mbedtls_rsa_export_raw(
        ctx: *const mbedtls_rsa_context,
        N: *mut crate::c_types::c_uchar,
        N_len: usize,
        P: *mut crate::c_types::c_uchar,
        P_len: usize,
        Q: *mut crate::c_types::c_uchar,
        Q_len: usize,
        D: *mut crate::c_types::c_uchar,
        D_len: usize,
        E: *mut crate::c_types::c_uchar,
        E_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function exports CRT parameters of a private RSA key.
    ///
    /// \note           Alternative RSA implementations not using CRT-parameters
    ///                 internally can implement this function based on
    ///                 mbedtls_rsa_deduce_opt().
    ///
    /// \param ctx      The initialized RSA context.
    /// \param DP       The MPI to hold \c D modulo `P-1`,
    ///                 or \c NULL if it need not be exported.
    /// \param DQ       The MPI to hold \c D modulo `Q-1`,
    ///                 or \c NULL if it need not be exported.
    /// \param QP       The MPI to hold modular inverse of \c Q modulo \c P,
    ///                 or \c NULL if it need not be exported.
    ///
    /// \return         \c 0 on success.
    /// \return         A non-zero error code on failure.
    pub fn mbedtls_rsa_export_crt(
        ctx: *const mbedtls_rsa_context,
        DP: *mut mbedtls_mpi,
        DQ: *mut mbedtls_mpi,
        QP: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function retrieves the length of RSA modulus in Bytes.
    ///
    /// \param ctx      The initialized RSA context.
    ///
    /// \return         The length of the RSA modulus in Bytes.
    pub fn mbedtls_rsa_get_len(ctx: *const mbedtls_rsa_context) -> usize;
}
extern "C" {
    /// \brief          This function generates an RSA keypair.
    ///
    /// \note           mbedtls_rsa_init() must be called before this function,
    ///                 to set up the RSA context.
    ///
    /// \param ctx      The initialized RSA context used to hold the key.
    /// \param f_rng    The RNG function to be used for key generation.
    ///                 This is mandatory and must not be \c NULL.
    /// \param p_rng    The RNG context to be passed to \p f_rng.
    ///                 This may be \c NULL if \p f_rng doesn't need a context.
    /// \param nbits    The size of the public key in bits.
    /// \param exponent The public exponent to use. For example, \c 65537.
    ///                 This must be odd and greater than \c 1.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_gen_key(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        nbits: crate::c_types::c_uint,
        exponent: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function checks if a context contains at least an RSA
    ///                 public key.
    ///
    ///                 If the function runs successfully, it is guaranteed that
    ///                 enough information is present to perform an RSA public key
    ///                 operation using mbedtls_rsa_public().
    ///
    /// \param ctx      The initialized RSA context to check.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_check_pubkey(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief      This function checks if a context contains an RSA private key
    ///             and perform basic consistency checks.
    ///
    /// \note       The consistency checks performed by this function not only
    ///             ensure that mbedtls_rsa_private() can be called successfully
    ///             on the given context, but that the various parameters are
    ///             mutually consistent with high probability, in the sense that
    ///             mbedtls_rsa_public() and mbedtls_rsa_private() are inverses.
    ///
    /// \warning    This function should catch accidental misconfigurations
    ///             like swapping of parameters, but it cannot establish full
    ///             trust in neither the quality nor the consistency of the key
    ///             material that was used to setup the given RSA context:
    ///             <ul><li>Consistency: Imported parameters that are irrelevant
    ///             for the implementation might be silently dropped. If dropped,
    ///             the current function does not have access to them,
    ///             and therefore cannot check them. See mbedtls_rsa_complete().
    ///             If you want to check the consistency of the entire
    ///             content of a PKCS1-encoded RSA private key, for example, you
    ///             should use mbedtls_rsa_validate_params() before setting
    ///             up the RSA context.
    ///             Additionally, if the implementation performs empirical checks,
    ///             these checks substantiate but do not guarantee consistency.</li>
    ///             <li>Quality: This function is not expected to perform
    ///             extended quality assessments like checking that the prime
    ///             factors are safe. Additionally, it is the responsibility of the
    ///             user to ensure the trustworthiness of the source of his RSA
    ///             parameters, which goes beyond what is effectively checkable
    ///             by the library.</li></ul>
    ///
    /// \param ctx  The initialized RSA context to check.
    ///
    /// \return     \c 0 on success.
    /// \return     An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_check_privkey(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function checks a public-private RSA key pair.
    ///
    ///                 It checks each of the contexts, and makes sure they match.
    ///
    /// \param pub      The initialized RSA context holding the public key.
    /// \param prv      The initialized RSA context holding the private key.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_check_pub_priv(
        pub_: *const mbedtls_rsa_context,
        prv: *const mbedtls_rsa_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs an RSA public key operation.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param input    The input buffer. This must be a readable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    /// \param output   The output buffer. This must be a writable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \note           This function does not handle message padding.
    ///
    /// \note           Make sure to set \p input[0] = 0 or ensure that
    ///                 input is smaller than \p N.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_public(
        ctx: *mut mbedtls_rsa_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs an RSA private key operation.
    ///
    /// \note           Blinding is used if and only if a PRNG is provided.
    ///
    /// \note           If blinding is used, both the base of exponentiation
    ///                 and the exponent are blinded, providing protection
    ///                 against some side-channel attacks.
    ///
    /// \warning        It is deprecated and a security risk to not provide
    ///                 a PRNG here and thereby prevent the use of blinding.
    ///                 Future versions of the library may enforce the presence
    ///                 of a PRNG.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function, used for blinding. It is mandatory.
    /// \param p_rng    The RNG context to pass to \p f_rng. This may be \c NULL
    ///                 if \p f_rng doesn't need a context.
    /// \param input    The input buffer. This must be a readable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    /// \param output   The output buffer. This must be a writable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_private(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function adds the message padding, then performs an RSA
    ///                 operation.
    ///
    ///                 It is the generic wrapper for performing a PKCS#1 encryption
    ///                 operation.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG to use. It is used for padding generation
    ///                 and it is mandatory.
    /// \param p_rng    The RNG context to be passed to \p f_rng. May be
    ///                 \c NULL if \p f_rng doesn't need a context argument.
    /// \param ilen     The length of the plaintext in Bytes.
    /// \param input    The input data to encrypt. This must be a readable
    ///                 buffer of size \p ilen Bytes. It may be \c NULL if
    ///                 `ilen == 0`.
    /// \param output   The output buffer. This must be a writable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_pkcs1_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        ilen: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v1.5 encryption operation
    ///                 (RSAES-PKCS1-v1_5-ENCRYPT).
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function to use. It is mandatory and used for
    ///                 padding generation.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may
    ///                 be \c NULL if \p f_rng doesn't need a context argument.
    /// \param ilen     The length of the plaintext in Bytes.
    /// \param input    The input data to encrypt. This must be a readable
    ///                 buffer of size \p ilen Bytes. It may be \c NULL if
    ///                 `ilen == 0`.
    /// \param output   The output buffer. This must be a writable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        ilen: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief            This function performs a PKCS#1 v2.1 OAEP encryption
    ///                   operation (RSAES-OAEP-ENCRYPT).
    ///
    /// \note             The output buffer must be as large as the size
    ///                   of ctx->N. For example, 128 Bytes if RSA-1024 is used.
    ///
    /// \param ctx        The initialized RSA context to use.
    /// \param f_rng      The RNG function to use. This is needed for padding
    ///                   generation and is mandatory.
    /// \param p_rng      The RNG context to be passed to \p f_rng. This may
    ///                   be \c NULL if \p f_rng doesn't need a context argument.
    /// \param label      The buffer holding the custom label to use.
    ///                   This must be a readable buffer of length \p label_len
    ///                   Bytes. It may be \c NULL if \p label_len is \c 0.
    /// \param label_len  The length of the label in Bytes.
    /// \param ilen       The length of the plaintext buffer \p input in Bytes.
    /// \param input      The input data to encrypt. This must be a readable
    ///                   buffer of size \p ilen Bytes. It may be \c NULL if
    ///                   `ilen == 0`.
    /// \param output     The output buffer. This must be a writable buffer
    ///                   of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                   for an 2048-bit RSA modulus.
    ///
    /// \return           \c 0 on success.
    /// \return           An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsaes_oaep_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        label: *const crate::c_types::c_uchar,
        label_len: usize,
        ilen: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs an RSA operation, then removes the
    ///                 message padding.
    ///
    ///                 It is the generic wrapper for performing a PKCS#1 decryption
    ///                 operation.
    ///
    /// \note           The output buffer length \c output_max_len should be
    ///                 as large as the size \p ctx->len of \p ctx->N (for example,
    ///                 128 Bytes if RSA-1024 is used) to be able to hold an
    ///                 arbitrary decrypted message. If it is not large enough to
    ///                 hold the decryption of the particular ciphertext provided,
    ///                 the function returns \c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function. This is used for blinding and is
    ///                 mandatory; see mbedtls_rsa_private() for more.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be
    ///                 \c NULL if \p f_rng doesn't need a context.
    /// \param olen     The address at which to store the length of
    ///                 the plaintext. This must not be \c NULL.
    /// \param input    The ciphertext buffer. This must be a readable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    /// \param output   The buffer used to hold the plaintext. This must
    ///                 be a writable buffer of length \p output_max_len Bytes.
    /// \param output_max_len The length in Bytes of the output buffer \p output.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_pkcs1_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v1.5 decryption
    ///                 operation (RSAES-PKCS1-v1_5-DECRYPT).
    ///
    /// \note           The output buffer length \c output_max_len should be
    ///                 as large as the size \p ctx->len of \p ctx->N, for example,
    ///                 128 Bytes if RSA-1024 is used, to be able to hold an
    ///                 arbitrary decrypted message. If it is not large enough to
    ///                 hold the decryption of the particular ciphertext provided,
    ///                 the function returns #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function. This is used for blinding and is
    ///                 mandatory; see mbedtls_rsa_private() for more.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be
    ///                 \c NULL if \p f_rng doesn't need a context.
    /// \param olen     The address at which to store the length of
    ///                 the plaintext. This must not be \c NULL.
    /// \param input    The ciphertext buffer. This must be a readable buffer
    ///                 of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    /// \param output   The buffer used to hold the plaintext. This must
    ///                 be a writable buffer of length \p output_max_len Bytes.
    /// \param output_max_len The length in Bytes of the output buffer \p output.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief            This function performs a PKCS#1 v2.1 OAEP decryption
    ///                   operation (RSAES-OAEP-DECRYPT).
    ///
    /// \note             The output buffer length \c output_max_len should be
    ///                   as large as the size \p ctx->len of \p ctx->N, for
    ///                   example, 128 Bytes if RSA-1024 is used, to be able to
    ///                   hold an arbitrary decrypted message. If it is not
    ///                   large enough to hold the decryption of the particular
    ///                   ciphertext provided, the function returns
    ///                   #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.
    ///
    /// \param ctx        The initialized RSA context to use.
    /// \param f_rng      The RNG function. This is used for blinding and is
    ///                   mandatory.
    /// \param p_rng      The RNG context to be passed to \p f_rng. This may be
    ///                   \c NULL if \p f_rng doesn't need a context.
    /// \param label      The buffer holding the custom label to use.
    ///                   This must be a readable buffer of length \p label_len
    ///                   Bytes. It may be \c NULL if \p label_len is \c 0.
    /// \param label_len  The length of the label in Bytes.
    /// \param olen       The address at which to store the length of
    ///                   the plaintext. This must not be \c NULL.
    /// \param input      The ciphertext buffer. This must be a readable buffer
    ///                   of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                   for an 2048-bit RSA modulus.
    /// \param output     The buffer used to hold the plaintext. This must
    ///                   be a writable buffer of length \p output_max_len Bytes.
    /// \param output_max_len The length in Bytes of the output buffer \p output.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsaes_oaep_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        label: *const crate::c_types::c_uchar,
        label_len: usize,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a private RSA operation to sign
    ///                 a message digest using PKCS#1.
    ///
    ///                 It is the generic wrapper for performing a PKCS#1
    ///                 signature.
    ///
    /// \note           The \p sig buffer must be as large as the size
    ///                 of \p ctx->N. For example, 128 Bytes if RSA-1024 is used.
    ///
    /// \note           For PKCS#1 v2.1 encoding, see comments on
    ///                 mbedtls_rsa_rsassa_pss_sign() for details on
    ///                 \p md_alg and \p hash_id.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function to use. This is mandatory and
    ///                 must not be \c NULL.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
    ///                 if \p f_rng doesn't need a context argument.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param sig      The buffer to hold the signature. This must be a writable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus. A buffer length of
    ///                 #MBEDTLS_MPI_MAX_SIZE is always safe.
    ///
    /// \return         \c 0 if the signing operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_pkcs1_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v1.5 signature
    ///                 operation (RSASSA-PKCS1-v1_5-SIGN).
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function. This is used for blinding and is
    ///                 mandatory; see mbedtls_rsa_private() for more.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
    ///                 if \p f_rng doesn't need a context argument.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param sig      The buffer to hold the signature. This must be a writable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus. A buffer length of
    ///                 #MBEDTLS_MPI_MAX_SIZE is always safe.
    ///
    /// \return         \c 0 if the signing operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v2.1 PSS signature
    ///                 operation (RSASSA-PSS-SIGN).
    ///
    /// \note           The \c hash_id set in \p ctx by calling
    ///                 mbedtls_rsa_set_padding() selects the hash used for the
    ///                 encoding operation and for the mask generation function
    ///                 (MGF1). For more details on the encoding operation and the
    ///                 mask generation function, consult <em>RFC-3447: Public-Key
    ///                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography
    ///                 Specifications</em>.
    ///
    /// \note           This function enforces that the provided salt length complies
    ///                 with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1 v2.2) §9.1.1
    ///                 step 3. The constraint is that the hash length plus the salt
    ///                 length plus 2 bytes must be at most the key length. If this
    ///                 constraint is not met, this function returns
    ///                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function. It is mandatory and must not be \c NULL.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
    ///                 if \p f_rng doesn't need a context argument.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param saltlen  The length of the salt that should be used.
    ///                 If passed #MBEDTLS_RSA_SALT_LEN_ANY, the function will use
    ///                 the largest possible salt length up to the hash length,
    ///                 which is the largest permitted by some standards including
    ///                 FIPS 186-4 §5.5.
    /// \param sig      The buffer to hold the signature. This must be a writable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus. A buffer length of
    ///                 #MBEDTLS_MPI_MAX_SIZE is always safe.
    ///
    /// \return         \c 0 if the signing operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsassa_pss_sign_ext(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        saltlen: crate::c_types::c_int,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v2.1 PSS signature
    ///                 operation (RSASSA-PSS-SIGN).
    ///
    /// \note           The \c hash_id set in \p ctx by calling
    ///                 mbedtls_rsa_set_padding() selects the hash used for the
    ///                 encoding operation and for the mask generation function
    ///                 (MGF1). For more details on the encoding operation and the
    ///                 mask generation function, consult <em>RFC-3447: Public-Key
    ///                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography
    ///                 Specifications</em>.
    ///
    /// \note           This function always uses the maximum possible salt size,
    ///                 up to the length of the payload hash. This choice of salt
    ///                 size complies with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1
    ///                 v2.2) §9.1.1 step 3. Furthermore this function enforces a
    ///                 minimum salt size which is the hash size minus 2 bytes. If
    ///                 this minimum size is too large given the key size (the salt
    ///                 size, plus the hash size, plus 2 bytes must be no more than
    ///                 the key size in bytes), this function returns
    ///                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.
    ///
    /// \param ctx      The initialized RSA context to use.
    /// \param f_rng    The RNG function. It is mandatory and must not be \c NULL.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
    ///                 if \p f_rng doesn't need a context argument.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param sig      The buffer to hold the signature. This must be a writable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus. A buffer length of
    ///                 #MBEDTLS_MPI_MAX_SIZE is always safe.
    ///
    /// \return         \c 0 if the signing operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsassa_pss_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a public RSA operation and checks
    ///                 the message digest.
    ///
    ///                 This is the generic wrapper for performing a PKCS#1
    ///                 verification.
    ///
    /// \note           For PKCS#1 v2.1 encoding, see comments on
    ///                 mbedtls_rsa_rsassa_pss_verify() about \p md_alg and
    ///                 \p hash_id.
    ///
    /// \param ctx      The initialized RSA public key context to use.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param sig      The buffer holding the signature. This must be a readable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \return         \c 0 if the verify operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_pkcs1_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v1.5 verification
    ///                 operation (RSASSA-PKCS1-v1_5-VERIFY).
    ///
    /// \param ctx      The initialized RSA public key context to use.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param sig      The buffer holding the signature. This must be a readable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \return         \c 0 if the verify operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v2.1 PSS verification
    ///                 operation (RSASSA-PSS-VERIFY).
    ///
    /// \note           The \c hash_id set in \p ctx by calling
    ///                 mbedtls_rsa_set_padding() selects the hash used for the
    ///                 encoding operation and for the mask generation function
    ///                 (MGF1). For more details on the encoding operation and the
    ///                 mask generation function, consult <em>RFC-3447: Public-Key
    ///                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography
    ///                 Specifications</em>. If the \c hash_id set in \p ctx by
    ///                 mbedtls_rsa_set_padding() is #MBEDTLS_MD_NONE, the \p md_alg
    ///                 parameter is used.
    ///
    /// \param ctx      The initialized RSA public key context to use.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param sig      The buffer holding the signature. This must be a readable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \return         \c 0 if the verify operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsassa_pss_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs a PKCS#1 v2.1 PSS verification
    ///                 operation (RSASSA-PSS-VERIFY).
    ///
    /// \note           The \p sig buffer must be as large as the size
    ///                 of \p ctx->N. For example, 128 Bytes if RSA-1024 is used.
    ///
    /// \note           The \c hash_id set in \p ctx by mbedtls_rsa_set_padding() is
    ///                 ignored.
    ///
    /// \param ctx      The initialized RSA public key context to use.
    /// \param md_alg   The message-digest algorithm used to hash the original data.
    ///                 Use #MBEDTLS_MD_NONE for signing raw data.
    /// \param hashlen  The length of the message digest or raw data in Bytes.
    ///                 If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
    ///                 output length of the corresponding hash algorithm.
    /// \param hash     The buffer holding the message digest or raw data.
    ///                 This must be a readable buffer of at least \p hashlen Bytes.
    /// \param mgf1_hash_id      The message digest algorithm used for the
    ///                          verification operation and the mask generation
    ///                          function (MGF1). For more details on the encoding
    ///                          operation and the mask generation function, consult
    ///                          <em>RFC-3447: Public-Key Cryptography Standards
    ///                          (PKCS) #1 v2.1: RSA Cryptography
    ///                          Specifications</em>.
    /// \param expected_salt_len The length of the salt used in padding. Use
    ///                          #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length.
    /// \param sig      The buffer holding the signature. This must be a readable
    ///                 buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
    ///                 for an 2048-bit RSA modulus.
    ///
    /// \return         \c 0 if the verify operation was successful.
    /// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
    pub fn mbedtls_rsa_rsassa_pss_verify_ext(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        mgf1_hash_id: mbedtls_md_type_t,
        expected_salt_len: crate::c_types::c_int,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function copies the components of an RSA context.
    ///
    /// \param dst      The destination context. This must be initialized.
    /// \param src      The source context. This must be initialized.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory allocation failure.
    pub fn mbedtls_rsa_copy(
        dst: *mut mbedtls_rsa_context,
        src: *const mbedtls_rsa_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function frees the components of an RSA key.
    ///
    /// \param ctx      The RSA context to free. May be \c NULL, in which case
    ///                 this function is a no-op. If it is not \c NULL, it must
    ///                 point to an initialized RSA context.
    pub fn mbedtls_rsa_free(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    /// \brief          The RSA checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_rsa_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
/// \brief           The ECDSA context structure.
///
/// \warning         Performing multiple operations concurrently on the same
///                  ECDSA context is not supported; objects of this type
///                  should not be shared between multiple threads.
///
/// \note            pk_wrap module assumes that "ecdsa_context" is identical
///                  to "ecp_keypair" (see for example structure
///                  "mbedtls_eckey_info" where ECDSA sign/verify functions
///                  are used also for EC key)
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
pub type mbedtls_ecdsa_restart_ctx = crate::c_types::c_void;
extern "C" {
    /// \brief          This function checks whether a given group can be used
    ///                 for ECDSA.
    ///
    /// \param gid      The ECP group ID to check.
    ///
    /// \return         \c 1 if the group can be used, \c 0 otherwise
    pub fn mbedtls_ecdsa_can_do(gid: mbedtls_ecp_group_id) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function computes the ECDSA signature of a
    ///                  previously-hashed message.
    ///
    /// \note            The deterministic version implemented in
    ///                  mbedtls_ecdsa_sign_det_ext() is usually preferred.
    ///
    /// \note            If the bitlength of the message hash is larger than the
    ///                  bitlength of the group order, then the hash is truncated
    ///                  as defined in <em>Standards for Efficient Cryptography Group
    ///                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section
    ///                  4.1.3, step 5.
    ///
    /// \see             ecp.h
    ///
    /// \param grp       The context for the elliptic curve to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param r         The MPI context in which to store the first part
    ///                  the signature. This must be initialized.
    /// \param s         The MPI context in which to store the second part
    ///                  the signature. This must be initialized.
    /// \param d         The private signing key. This must be initialized.
    /// \param buf       The content to be signed. This is usually the hash of
    ///                  the original data to be signed. This must be a readable
    ///                  buffer of length \p blen Bytes. It may be \c NULL if
    ///                  \p blen is zero.
    /// \param blen      The length of \p buf in Bytes.
    /// \param f_rng     The RNG function. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be
    ///                  \c NULL if \p f_rng doesn't need a context parameter.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX
    ///                  or \c MBEDTLS_MPI_XXX error code on failure.
    pub fn mbedtls_ecdsa_sign(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function computes the ECDSA signature of a
    ///                  previously-hashed message, deterministic version.
    ///
    ///                  For more information, see <em>RFC-6979: Deterministic
    ///                  Usage of the Digital Signature Algorithm (DSA) and Elliptic
    ///                  Curve Digital Signature Algorithm (ECDSA)</em>.
    ///
    /// \note            If the bitlength of the message hash is larger than the
    ///                  bitlength of the group order, then the hash is truncated as
    ///                  defined in <em>Standards for Efficient Cryptography Group
    ///                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section
    ///                  4.1.3, step 5.
    ///
    /// \see             ecp.h
    ///
    /// \param grp           The context for the elliptic curve to use.
    ///                      This must be initialized and have group parameters
    ///                      set, for example through mbedtls_ecp_group_load().
    /// \param r             The MPI context in which to store the first part
    ///                      the signature. This must be initialized.
    /// \param s             The MPI context in which to store the second part
    ///                      the signature. This must be initialized.
    /// \param d             The private signing key. This must be initialized
    ///                      and setup, for example through mbedtls_ecp_gen_privkey().
    /// \param buf           The hashed content to be signed. This must be a readable
    ///                      buffer of length \p blen Bytes. It may be \c NULL if
    ///                      \p blen is zero.
    /// \param blen          The length of \p buf in Bytes.
    /// \param md_alg        The hash algorithm used to hash the original data.
    /// \param f_rng_blind   The RNG function used for blinding. This must not be
    ///                      \c NULL.
    /// \param p_rng_blind   The RNG context to be passed to \p f_rng. This may be
    ///                      \c NULL if \p f_rng doesn't need a context parameter.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
    ///                  error code on failure.
    pub fn mbedtls_ecdsa_sign_det_ext(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        md_alg: mbedtls_md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function computes the ECDSA signature of a
    ///                      previously-hashed message, in a restartable way.
    ///
    /// \note                The deterministic version implemented in
    ///                      mbedtls_ecdsa_sign_det_restartable() is usually
    ///                      preferred.
    ///
    /// \note                This function is like \c mbedtls_ecdsa_sign() but
    ///                      it can return early and restart according to the
    ///                      limit set with \c mbedtls_ecp_set_max_ops() to
    ///                      reduce blocking.
    ///
    /// \note                If the bitlength of the message hash is larger
    ///                      than the bitlength of the group order, then the
    ///                      hash is truncated as defined in <em>Standards for
    ///                      Efficient Cryptography Group (SECG): SEC1 Elliptic
    ///                      Curve Cryptography</em>, section 4.1.3, step 5.
    ///
    /// \see                 ecp.h
    ///
    /// \param grp           The context for the elliptic curve to use.
    ///                      This must be initialized and have group parameters
    ///                      set, for example through mbedtls_ecp_group_load().
    /// \param r             The MPI context in which to store the first part
    ///                      the signature. This must be initialized.
    /// \param s             The MPI context in which to store the second part
    ///                      the signature. This must be initialized.
    /// \param d             The private signing key. This must be initialized
    ///                      and setup, for example through
    ///                      mbedtls_ecp_gen_privkey().
    /// \param buf           The hashed content to be signed. This must be a readable
    ///                      buffer of length \p blen Bytes. It may be \c NULL if
    ///                      \p blen is zero.
    /// \param blen          The length of \p buf in Bytes.
    /// \param f_rng         The RNG function. This must not be \c NULL.
    /// \param p_rng         The RNG context to be passed to \p f_rng. This may be
    ///                      \c NULL if \p f_rng doesn't need a context parameter.
    /// \param f_rng_blind   The RNG function used for blinding. This must not be
    ///                      \c NULL.
    /// \param p_rng_blind   The RNG context to be passed to \p f_rng. This may be
    ///                      \c NULL if \p f_rng doesn't need a context parameter.
    /// \param rs_ctx        The restart context to use. This may be \c NULL
    ///                      to disable restarting. If it is not \c NULL, it
    ///                      must point to an initialized restart context.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                      operations was reached: see \c
    ///                      mbedtls_ecp_set_max_ops().
    /// \return              Another \c MBEDTLS_ERR_ECP_XXX, \c
    ///                      MBEDTLS_ERR_MPI_XXX or \c MBEDTLS_ERR_ASN1_XXX
    ///                      error code on failure.
    pub fn mbedtls_ecdsa_sign_restartable(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function computes the ECDSA signature of a
    ///                      previously-hashed message, in a restartable way.
    ///
    /// \note                This function is like \c
    ///                      mbedtls_ecdsa_sign_det_ext() but it can return
    ///                      early and restart according to the limit set with
    ///                      \c mbedtls_ecp_set_max_ops() to reduce blocking.
    ///
    /// \note                If the bitlength of the message hash is larger
    ///                      than the bitlength of the group order, then the
    ///                      hash is truncated as defined in <em>Standards for
    ///                      Efficient Cryptography Group (SECG): SEC1 Elliptic
    ///                      Curve Cryptography</em>, section 4.1.3, step 5.
    ///
    /// \see                 ecp.h
    ///
    /// \param grp           The context for the elliptic curve to use.
    ///                      This must be initialized and have group parameters
    ///                      set, for example through mbedtls_ecp_group_load().
    /// \param r             The MPI context in which to store the first part
    ///                      the signature. This must be initialized.
    /// \param s             The MPI context in which to store the second part
    ///                      the signature. This must be initialized.
    /// \param d             The private signing key. This must be initialized
    ///                      and setup, for example through
    ///                      mbedtls_ecp_gen_privkey().
    /// \param buf           The hashed content to be signed. This must be a readable
    ///                      buffer of length \p blen Bytes. It may be \c NULL if
    ///                      \p blen is zero.
    /// \param blen          The length of \p buf in Bytes.
    /// \param md_alg        The hash algorithm used to hash the original data.
    /// \param f_rng_blind   The RNG function used for blinding. This must not be
    ///                      \c NULL.
    /// \param p_rng_blind   The RNG context to be passed to \p f_rng. This may be
    ///                      \c NULL if \p f_rng doesn't need a context parameter.
    /// \param rs_ctx        The restart context to use. This may be \c NULL
    ///                      to disable restarting. If it is not \c NULL, it
    ///                      must point to an initialized restart context.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                      operations was reached: see \c
    ///                      mbedtls_ecp_set_max_ops().
    /// \return              Another \c MBEDTLS_ERR_ECP_XXX, \c
    ///                      MBEDTLS_ERR_MPI_XXX or \c MBEDTLS_ERR_ASN1_XXX
    ///                      error code on failure.
    pub fn mbedtls_ecdsa_sign_det_restartable(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        md_alg: mbedtls_md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function verifies the ECDSA signature of a
    ///                  previously-hashed message.
    ///
    /// \note            If the bitlength of the message hash is larger than the
    ///                  bitlength of the group order, then the hash is truncated as
    ///                  defined in <em>Standards for Efficient Cryptography Group
    ///                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section
    ///                  4.1.4, step 3.
    ///
    /// \see             ecp.h
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param buf       The hashed content that was signed. This must be a readable
    ///                  buffer of length \p blen Bytes. It may be \c NULL if
    ///                  \p blen is zero.
    /// \param blen      The length of \p buf in Bytes.
    /// \param Q         The public key to use for verification. This must be
    ///                  initialized and setup.
    /// \param r         The first integer of the signature.
    ///                  This must be initialized.
    /// \param s         The second integer of the signature.
    ///                  This must be initialized.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
    ///                  error code on failure.
    pub fn mbedtls_ecdsa_verify(
        grp: *mut mbedtls_ecp_group,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function verifies the ECDSA signature of a
    ///                  previously-hashed message, in a restartable manner
    ///
    /// \note            If the bitlength of the message hash is larger than the
    ///                  bitlength of the group order, then the hash is truncated as
    ///                  defined in <em>Standards for Efficient Cryptography Group
    ///                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section
    ///                  4.1.4, step 3.
    ///
    /// \see             ecp.h
    ///
    /// \param grp       The ECP group to use.
    ///                  This must be initialized and have group parameters
    ///                  set, for example through mbedtls_ecp_group_load().
    /// \param buf       The hashed content that was signed. This must be a readable
    ///                  buffer of length \p blen Bytes. It may be \c NULL if
    ///                  \p blen is zero.
    /// \param blen      The length of \p buf in Bytes.
    /// \param Q         The public key to use for verification. This must be
    ///                  initialized and setup.
    /// \param r         The first integer of the signature.
    ///                  This must be initialized.
    /// \param s         The second integer of the signature.
    ///                  This must be initialized.
    /// \param rs_ctx    The restart context to use. This may be \c NULL to disable
    ///                  restarting. If it is not \c NULL, it must point to an
    ///                  initialized restart context.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
    ///                  error code on failure.
    pub fn mbedtls_ecdsa_verify_restartable(
        grp: *mut mbedtls_ecp_group,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function computes the ECDSA signature and writes it
    ///                  to a buffer, serialized as defined in <em>RFC-4492:
    ///                  Elliptic Curve Cryptography (ECC) Cipher Suites for
    ///                  Transport Layer Security (TLS)</em>.
    ///
    /// \warning         It is not thread-safe to use the same context in
    ///                  multiple threads.
    ///
    /// \note            The deterministic version is used if
    ///                  #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more
    ///                  information, see <em>RFC-6979: Deterministic Usage
    ///                  of the Digital Signature Algorithm (DSA) and Elliptic
    ///                  Curve Digital Signature Algorithm (ECDSA)</em>.
    ///
    /// \note            If the bitlength of the message hash is larger than the
    ///                  bitlength of the group order, then the hash is truncated as
    ///                  defined in <em>Standards for Efficient Cryptography Group
    ///                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section
    ///                  4.1.3, step 5.
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDSA context to use. This must be initialized
    ///                  and have a group and private key bound to it, for example
    ///                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().
    /// \param md_alg    The message digest that was used to hash the message.
    /// \param hash      The message hash to be signed. This must be a readable
    ///                  buffer of length \p blen Bytes.
    /// \param hlen      The length of the hash \p hash in Bytes.
    /// \param sig       The buffer to which to write the signature. This must be a
    ///                  writable buffer of length at least twice as large as the
    ///                  size of the curve used, plus 9. For example, 73 Bytes if
    ///                  a 256-bit curve is used. A buffer length of
    ///                  #MBEDTLS_ECDSA_MAX_LEN is always safe.
    /// \param sig_size  The size of the \p sig buffer in bytes.
    /// \param slen      The address at which to store the actual length of
    ///                  the signature written. Must not be \c NULL.
    /// \param f_rng     The RNG function. This must not be \c NULL if
    ///                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,
    ///                  it is used only for blinding and may be set to \c NULL, but
    ///                  doing so is DEPRECATED.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be
    ///                  \c NULL if \p f_rng is \c NULL or doesn't use a context.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX, \c MBEDTLS_ERR_MPI_XXX or
    ///                  \c MBEDTLS_ERR_ASN1_XXX error code on failure.
    pub fn mbedtls_ecdsa_write_signature(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function computes the ECDSA signature and writes it
    ///                  to a buffer, in a restartable way.
    ///
    /// \see             \c mbedtls_ecdsa_write_signature()
    ///
    /// \note            This function is like \c mbedtls_ecdsa_write_signature()
    ///                  but it can return early and restart according to the limit
    ///                  set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
    ///
    /// \param ctx       The ECDSA context to use. This must be initialized
    ///                  and have a group and private key bound to it, for example
    ///                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().
    /// \param md_alg    The message digest that was used to hash the message.
    /// \param hash      The message hash to be signed. This must be a readable
    ///                  buffer of length \p blen Bytes.
    /// \param hlen      The length of the hash \p hash in Bytes.
    /// \param sig       The buffer to which to write the signature. This must be a
    ///                  writable buffer of length at least twice as large as the
    ///                  size of the curve used, plus 9. For example, 73 Bytes if
    ///                  a 256-bit curve is used. A buffer length of
    ///                  #MBEDTLS_ECDSA_MAX_LEN is always safe.
    /// \param sig_size  The size of the \p sig buffer in bytes.
    /// \param slen      The address at which to store the actual length of
    ///                  the signature written. Must not be \c NULL.
    /// \param f_rng     The RNG function. This must not be \c NULL if
    ///                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,
    ///                  it is unused and may be set to \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be
    ///                  \c NULL if \p f_rng is \c NULL or doesn't use a context.
    /// \param rs_ctx    The restart context to use. This may be \c NULL to disable
    ///                  restarting. If it is not \c NULL, it must point to an
    ///                  initialized restart context.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX, \c MBEDTLS_ERR_MPI_XXX or
    ///                  \c MBEDTLS_ERR_ASN1_XXX error code on failure.
    pub fn mbedtls_ecdsa_write_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function reads and verifies an ECDSA signature.
    ///
    /// \note            If the bitlength of the message hash is larger than the
    ///                  bitlength of the group order, then the hash is truncated as
    ///                  defined in <em>Standards for Efficient Cryptography Group
    ///                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section
    ///                  4.1.4, step 3.
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDSA context to use. This must be initialized
    ///                  and have a group and public key bound to it.
    /// \param hash      The message hash that was signed. This must be a readable
    ///                  buffer of length \p size Bytes.
    /// \param hlen      The size of the hash \p hash.
    /// \param sig       The signature to read and verify. This must be a readable
    ///                  buffer of length \p slen Bytes.
    /// \param slen      The size of \p sig in Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.
    /// \return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid
    ///                  signature in \p sig, but its length is less than \p siglen.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_ERR_MPI_XXX
    ///                  error code on failure for any other reason.
    pub fn mbedtls_ecdsa_read_signature(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *const crate::c_types::c_uchar,
        slen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function reads and verifies an ECDSA signature,
    ///                  in a restartable way.
    ///
    /// \see             \c mbedtls_ecdsa_read_signature()
    ///
    /// \note            This function is like \c mbedtls_ecdsa_read_signature()
    ///                  but it can return early and restart according to the limit
    ///                  set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
    ///
    /// \param ctx       The ECDSA context to use. This must be initialized
    ///                  and have a group and public key bound to it.
    /// \param hash      The message hash that was signed. This must be a readable
    ///                  buffer of length \p size Bytes.
    /// \param hlen      The size of the hash \p hash.
    /// \param sig       The signature to read and verify. This must be a readable
    ///                  buffer of length \p slen Bytes.
    /// \param slen      The size of \p sig in Bytes.
    /// \param rs_ctx    The restart context to use. This may be \c NULL to disable
    ///                  restarting. If it is not \c NULL, it must point to an
    ///                  initialized restart context.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.
    /// \return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid
    ///                  signature in \p sig, but its length is less than \p siglen.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_ERR_MPI_XXX
    ///                  error code on failure for any other reason.
    pub fn mbedtls_ecdsa_read_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *const crate::c_types::c_uchar,
        slen: usize,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function generates an ECDSA keypair on the given curve.
    ///
    /// \see            ecp.h
    ///
    /// \param ctx      The ECDSA context to store the keypair in.
    ///                 This must be initialized.
    /// \param gid      The elliptic curve to use. One of the various
    ///                 \c MBEDTLS_ECP_DP_XXX macros depending on configuration.
    /// \param f_rng    The RNG function to use. This must not be \c NULL.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be
    ///                 \c NULL if \p f_rng doesn't need a context argument.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_ECP_XXX code on failure.
    pub fn mbedtls_ecdsa_genkey(
        ctx: *mut mbedtls_ecdsa_context,
        gid: mbedtls_ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function sets up an ECDSA context from an EC key pair.
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDSA context to setup. This must be initialized.
    /// \param key       The EC key to use. This must be initialized and hold
    ///                  a private-public key pair or a public key. In the former
    ///                  case, the ECDSA context may be used for signature creation
    ///                  and verification after this call. In the latter case, it
    ///                  may be used for signature verification.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX code on failure.
    pub fn mbedtls_ecdsa_from_keypair(
        ctx: *mut mbedtls_ecdsa_context,
        key: *const mbedtls_ecp_keypair,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function initializes an ECDSA context.
    ///
    /// \param ctx       The ECDSA context to initialize.
    ///                  This must not be \c NULL.
    pub fn mbedtls_ecdsa_init(ctx: *mut mbedtls_ecdsa_context);
}
extern "C" {
    /// \brief           This function frees an ECDSA context.
    ///
    /// \param ctx       The ECDSA context to free. This may be \c NULL,
    ///                  in which case this function does nothing. If it
    ///                  is not \c NULL, it must be initialized.
    pub fn mbedtls_ecdsa_free(ctx: *mut mbedtls_ecdsa_context);
}
pub const mbedtls_pk_type_t_MBEDTLS_PK_NONE: mbedtls_pk_type_t = 0;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA: mbedtls_pk_type_t = 1;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY: mbedtls_pk_type_t = 2;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY_DH: mbedtls_pk_type_t = 3;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECDSA: mbedtls_pk_type_t = 4;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA_ALT: mbedtls_pk_type_t = 5;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSASSA_PSS: mbedtls_pk_type_t = 6;
pub const mbedtls_pk_type_t_MBEDTLS_PK_OPAQUE: mbedtls_pk_type_t = 7;
/// \brief          Public key types
pub type mbedtls_pk_type_t = crate::c_types::c_uint;
/// \brief           Options for RSASSA-PSS signature verification.
///                  See \c mbedtls_rsa_rsassa_pss_verify_ext()
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_rsassa_pss_options {
    /// The digest to use for MGF1 in PSS.
    ///
    /// \note When #MBEDTLS_USE_PSA_CRYPTO is enabled and #MBEDTLS_RSA_C is
    ///       disabled, this must be equal to the \c md_alg argument passed
    ///       to mbedtls_pk_verify_ext(). In a future version of the library,
    ///       this constraint may apply whenever #MBEDTLS_USE_PSA_CRYPTO is
    ///       enabled regardless of the status of #MBEDTLS_RSA_C.
    pub mgf1_hash_id: mbedtls_md_type_t,
    /// The expected length of the salt, in bytes. This may be
    /// #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length.
    ///
    /// \note When #MBEDTLS_USE_PSA_CRYPTO is enabled, only
    ///       #MBEDTLS_RSA_SALT_LEN_ANY is valid. Any other value may be
    ///       ignored (allowing any salt length).
    pub expected_salt_len: crate::c_types::c_int,
}
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_NONE: mbedtls_pk_debug_type = 0;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_MPI: mbedtls_pk_debug_type = 1;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_ECP: mbedtls_pk_debug_type = 2;
/// \brief           Types for interfacing with the debug module
pub type mbedtls_pk_debug_type = crate::c_types::c_uint;
/// \brief           Item to send to the debug module
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_debug_item {
    pub private_type: mbedtls_pk_debug_type,
    pub private_name: *const crate::c_types::c_char,
    pub private_value: *mut crate::c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_info_t {
    _unused: [u8; 0],
}
/// \brief           Public key container
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_context {
    ///< Public key information
    pub private_pk_info: *const mbedtls_pk_info_t,
    ///< Underlying public key context
    pub private_pk_ctx: *mut crate::c_types::c_void,
}
pub type mbedtls_pk_restart_ctx = crate::c_types::c_void;
/// \brief           Types for RSA-alt abstraction
pub type mbedtls_pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int,
>;
pub type mbedtls_pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
pub type mbedtls_pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void) -> usize>;
extern "C" {
    /// \brief           Return information associated with the given PK type
    ///
    /// \param pk_type   PK type to search for.
    ///
    /// \return          The PK info associated with the type or NULL if not found.
    pub fn mbedtls_pk_info_from_type(pk_type: mbedtls_pk_type_t) -> *const mbedtls_pk_info_t;
}
extern "C" {
    /// \brief           Initialize a #mbedtls_pk_context (as NONE).
    ///
    /// \param ctx       The context to initialize.
    ///                  This must not be \c NULL.
    pub fn mbedtls_pk_init(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    /// \brief           Free the components of a #mbedtls_pk_context.
    ///
    /// \param ctx       The context to clear. It must have been initialized.
    ///                  If this is \c NULL, this function does nothing.
    ///
    /// \note            For contexts that have been set up with
    ///                  mbedtls_pk_setup_opaque(), this does not free the underlying
    ///                  PSA key and you still need to call psa_destroy_key()
    ///                  independently if you want to destroy that key.
    pub fn mbedtls_pk_free(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    /// \brief           Initialize a PK context with the information given
    ///                  and allocates the type-specific PK subcontext.
    ///
    /// \param ctx       Context to initialize. It must not have been set
    ///                  up yet (type #MBEDTLS_PK_NONE).
    /// \param info      Information to use
    ///
    /// \return          0 on success,
    ///                  MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,
    ///                  MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure.
    ///
    /// \note            For contexts holding an RSA-alt key, use
    ///                  \c mbedtls_pk_setup_rsa_alt() instead.
    pub fn mbedtls_pk_setup(
        ctx: *mut mbedtls_pk_context,
        info: *const mbedtls_pk_info_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Initialize an RSA-alt context
    ///
    /// \param ctx       Context to initialize. It must not have been set
    ///                  up yet (type #MBEDTLS_PK_NONE).
    /// \param key       RSA key pointer
    /// \param decrypt_func  Decryption function
    /// \param sign_func     Signing function
    /// \param key_len_func  Function returning key length in bytes
    ///
    /// \return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the
    ///                  context wasn't already initialized as RSA_ALT.
    ///
    /// \note            This function replaces \c mbedtls_pk_setup() for RSA-alt.
    pub fn mbedtls_pk_setup_rsa_alt(
        ctx: *mut mbedtls_pk_context,
        key: *mut crate::c_types::c_void,
        decrypt_func: mbedtls_pk_rsa_alt_decrypt_func,
        sign_func: mbedtls_pk_rsa_alt_sign_func,
        key_len_func: mbedtls_pk_rsa_alt_key_len_func,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Get the size in bits of the underlying key
    ///
    /// \param ctx       The context to query. It must have been initialized.
    ///
    /// \return          Key size in bits, or 0 on error
    pub fn mbedtls_pk_get_bitlen(ctx: *const mbedtls_pk_context) -> usize;
}
extern "C" {
    /// \brief           Tell if a context can do the operation given by type
    ///
    /// \param ctx       The context to query. It must have been initialized.
    /// \param type      The desired type.
    ///
    /// \return          1 if the context can do operations on the given type.
    /// \return          0 if the context cannot do the operations on the given
    ///                  type. This is always the case for a context that has
    ///                  been initialized but not set up, or that has been
    ///                  cleared with mbedtls_pk_free().
    pub fn mbedtls_pk_can_do(
        ctx: *const mbedtls_pk_context,
        type_: mbedtls_pk_type_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Verify signature (including padding if relevant).
    ///
    /// \param ctx       The PK context to use. It must have been set up.
    /// \param md_alg    Hash algorithm used.
    ///                  This can be #MBEDTLS_MD_NONE if the signature algorithm
    ///                  does not rely on a hash algorithm (non-deterministic
    ///                  ECDSA, RSA PKCS#1 v1.5).
    ///                  For PKCS#1 v1.5, if \p md_alg is #MBEDTLS_MD_NONE, then
    ///                  \p hash is the DigestInfo structure used by RFC 8017
    ///                  &sect;9.2 steps 3&ndash;6. If \p md_alg is a valid hash
    ///                  algorithm then \p hash is the digest itself, and this
    ///                  function calculates the DigestInfo encoding internally.
    /// \param hash      Hash of the message to sign
    /// \param hash_len  Hash length
    /// \param sig       Signature to verify
    /// \param sig_len   Signature length
    ///
    /// \return          0 on success (signature is valid),
    ///                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid
    ///                  signature in sig but its length is less than \p siglen,
    ///                  or a specific error code.
    ///
    /// \note            For RSA keys, the default padding type is PKCS#1 v1.5.
    ///                  Use \c mbedtls_pk_verify_ext( MBEDTLS_PK_RSASSA_PSS, ... )
    ///                  to verify RSASSA_PSS signatures.
    pub fn mbedtls_pk_verify(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *const crate::c_types::c_uchar,
        sig_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Restartable version of \c mbedtls_pk_verify()
    ///
    /// \note            Performs the same job as \c mbedtls_pk_verify(), but can
    ///                  return early and restart according to the limit set with
    ///                  \c mbedtls_ecp_set_max_ops() to reduce blocking for ECC
    ///                  operations. For RSA, same as \c mbedtls_pk_verify().
    ///
    /// \param ctx       The PK context to use. It must have been set up.
    /// \param md_alg    Hash algorithm used (see notes)
    /// \param hash      Hash of the message to sign
    /// \param hash_len  Hash length or 0 (see notes)
    /// \param sig       Signature to verify
    /// \param sig_len   Signature length
    /// \param rs_ctx    Restart context (NULL to disable restart)
    ///
    /// \return          See \c mbedtls_pk_verify(), or
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    pub fn mbedtls_pk_verify_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *const crate::c_types::c_uchar,
        sig_len: usize,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Verify signature, with options.
    ///                  (Includes verification of the padding depending on type.)
    ///
    /// \param type      Signature type (inc. possible padding type) to verify
    /// \param options   Pointer to type-specific options, or NULL
    /// \param ctx       The PK context to use. It must have been set up.
    /// \param md_alg    Hash algorithm used (see notes)
    /// \param hash      Hash of the message to sign
    /// \param hash_len  Hash length or 0 (see notes)
    /// \param sig       Signature to verify
    /// \param sig_len   Signature length
    ///
    /// \return          0 on success (signature is valid),
    ///                  #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be
    ///                  used for this type of signatures,
    ///                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid
    ///                  signature in sig but its length is less than \p siglen,
    ///                  or a specific error code.
    ///
    /// \note            If hash_len is 0, then the length associated with md_alg
    ///                  is used instead, or an error returned if it is invalid.
    ///
    /// \note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0
    ///
    /// \note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point
    ///                  to a mbedtls_pk_rsassa_pss_options structure,
    ///                  otherwise it must be NULL. Note that if
    ///                  #MBEDTLS_USE_PSA_CRYPTO is defined, the salt length is not
    ///                  verified as PSA_ALG_RSA_PSS_ANY_SALT is used.
    pub fn mbedtls_pk_verify_ext(
        type_: mbedtls_pk_type_t,
        options: *const crate::c_types::c_void,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *const crate::c_types::c_uchar,
        sig_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Make signature, including padding if relevant.
    ///
    /// \param ctx       The PK context to use. It must have been set up
    ///                  with a private key.
    /// \param md_alg    Hash algorithm used (see notes)
    /// \param hash      Hash of the message to sign
    /// \param hash_len  Hash length
    /// \param sig       Place to write the signature.
    ///                  It must have enough room for the signature.
    ///                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.
    ///                  You may use a smaller buffer if it is large enough
    ///                  given the key type.
    /// \param sig_size  The size of the \p sig buffer in bytes.
    /// \param sig_len   On successful return,
    ///                  the number of bytes written to \p sig.
    /// \param f_rng     RNG function, must not be \c NULL.
    /// \param p_rng     RNG parameter
    ///
    /// \return          0 on success, or a specific error code.
    ///
    /// \note            For RSA keys, the default padding type is PKCS#1 v1.5.
    ///                  There is no interface in the PK module to make RSASSA-PSS
    ///                  signatures yet.
    ///
    /// \note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.
    ///                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE.
    pub fn mbedtls_pk_sign(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Make signature given a signature type.
    ///
    /// \param pk_type   Signature type.
    /// \param ctx       The PK context to use. It must have been set up
    ///                  with a private key.
    /// \param md_alg    Hash algorithm used (see notes)
    /// \param hash      Hash of the message to sign
    /// \param hash_len  Hash length
    /// \param sig       Place to write the signature.
    ///                  It must have enough room for the signature.
    ///                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.
    ///                  You may use a smaller buffer if it is large enough
    ///                  given the key type.
    /// \param sig_size  The size of the \p sig buffer in bytes.
    /// \param sig_len   On successful return,
    ///                  the number of bytes written to \p sig.
    /// \param f_rng     RNG function, must not be \c NULL.
    /// \param p_rng     RNG parameter
    ///
    /// \return          0 on success, or a specific error code.
    ///
    /// \note            When \p pk_type is #MBEDTLS_PK_RSASSA_PSS,
    ///                  see #PSA_ALG_RSA_PSS for a description of PSS options used.
    ///
    /// \note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.
    ///                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE.
    pub fn mbedtls_pk_sign_ext(
        pk_type: mbedtls_pk_type_t,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Restartable version of \c mbedtls_pk_sign()
    ///
    /// \note            Performs the same job as \c mbedtls_pk_sign(), but can
    ///                  return early and restart according to the limit set with
    ///                  \c mbedtls_ecp_set_max_ops() to reduce blocking for ECC
    ///                  operations. For RSA, same as \c mbedtls_pk_sign().
    ///
    /// \param ctx       The PK context to use. It must have been set up
    ///                  with a private key.
    /// \param md_alg    Hash algorithm used (see notes for mbedtls_pk_sign())
    /// \param hash      Hash of the message to sign
    /// \param hash_len  Hash length
    /// \param sig       Place to write the signature.
    ///                  It must have enough room for the signature.
    ///                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.
    ///                  You may use a smaller buffer if it is large enough
    ///                  given the key type.
    /// \param sig_size  The size of the \p sig buffer in bytes.
    /// \param sig_len   On successful return,
    ///                  the number of bytes written to \p sig.
    /// \param f_rng     RNG function, must not be \c NULL.
    /// \param p_rng     RNG parameter
    /// \param rs_ctx    Restart context (NULL to disable restart)
    ///
    /// \return          See \c mbedtls_pk_sign().
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    pub fn mbedtls_pk_sign_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Decrypt message (including padding if relevant).
    ///
    /// \param ctx       The PK context to use. It must have been set up
    ///                  with a private key.
    /// \param input     Input to decrypt
    /// \param ilen      Input size
    /// \param output    Decrypted output
    /// \param olen      Decrypted message length
    /// \param osize     Size of the output buffer
    /// \param f_rng     RNG function, must not be \c NULL.
    /// \param p_rng     RNG parameter
    ///
    /// \note            For RSA keys, the default padding type is PKCS#1 v1.5.
    ///
    /// \return          0 on success, or a specific error code.
    pub fn mbedtls_pk_decrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Encrypt message (including padding if relevant).
    ///
    /// \param ctx       The PK context to use. It must have been set up.
    /// \param input     Message to encrypt
    /// \param ilen      Message size
    /// \param output    Encrypted output
    /// \param olen      Encrypted output length
    /// \param osize     Size of the output buffer
    /// \param f_rng     RNG function, must not be \c NULL.
    /// \param p_rng     RNG parameter
    ///
    /// \note            \p f_rng is used for padding generation.
    ///
    /// \note            For RSA keys, the default padding type is PKCS#1 v1.5.
    ///
    /// \return          0 on success, or a specific error code.
    pub fn mbedtls_pk_encrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Check if a public-private pair of keys matches.
    ///
    /// \param pub       Context holding a public key.
    /// \param prv       Context holding a private (and public) key.
    /// \param f_rng     RNG function, must not be \c NULL.
    /// \param p_rng     RNG parameter
    ///
    /// \return          \c 0 on success (keys were checked and match each other).
    /// \return          #MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE if the keys could not
    ///                  be checked - in that case they may or may not match.
    /// \return          #MBEDTLS_ERR_PK_BAD_INPUT_DATA if a context is invalid.
    /// \return          Another non-zero value if the keys do not match.
    pub fn mbedtls_pk_check_pair(
        pub_: *const mbedtls_pk_context,
        prv: *const mbedtls_pk_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Export debug information
    ///
    /// \param ctx       The PK context to use. It must have been initialized.
    /// \param items     Place to write debug items
    ///
    /// \return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA
    pub fn mbedtls_pk_debug(
        ctx: *const mbedtls_pk_context,
        items: *mut mbedtls_pk_debug_item,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Access the type name
    ///
    /// \param ctx       The PK context to use. It must have been initialized.
    ///
    /// \return          Type name on success, or "invalid PK"
    pub fn mbedtls_pk_get_name(ctx: *const mbedtls_pk_context) -> *const crate::c_types::c_char;
}
extern "C" {
    /// \brief           Get the key type
    ///
    /// \param ctx       The PK context to use. It must have been initialized.
    ///
    /// \return          Type on success.
    /// \return          #MBEDTLS_PK_NONE for a context that has not been set up.
    pub fn mbedtls_pk_get_type(ctx: *const mbedtls_pk_context) -> mbedtls_pk_type_t;
}
extern "C" {
    /// \ingroup pk_module */
    ////**
    /// \brief           Parse a private key in PEM or DER format
    ///
    /// \note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                  subsystem must have been initialized by calling
    ///                  psa_crypto_init() before calling this function.
    ///
    /// \param ctx       The PK context to fill. It must have been initialized
    ///                  but not set up.
    /// \param key       Input buffer to parse.
    ///                  The buffer must contain the input exactly, with no
    ///                  extra trailing material. For PEM, the buffer must
    ///                  contain a null-terminated string.
    /// \param keylen    Size of \b key in bytes.
    ///                  For PEM data, this includes the terminating null byte,
    ///                  so \p keylen must be equal to `strlen(key) + 1`.
    /// \param pwd       Optional password for decryption.
    ///                  Pass \c NULL if expecting a non-encrypted key.
    ///                  Pass a string of \p pwdlen bytes if expecting an encrypted
    ///                  key; a non-encrypted key will also be accepted.
    ///                  The empty password is not supported.
    /// \param pwdlen    Size of the password in bytes.
    ///                  Ignored if \p pwd is \c NULL.
    /// \param f_rng     RNG function, must not be \c NULL. Used for blinding.
    /// \param p_rng     RNG parameter
    ///
    /// \note            On entry, ctx must be empty, either freshly initialised
    ///                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
    ///                  specific key type, check the result with mbedtls_pk_can_do().
    ///
    /// \note            The key is also checked for correctness.
    ///
    /// \return          0 if successful, or a specific PK or PEM error code
    pub fn mbedtls_pk_parse_key(
        ctx: *mut mbedtls_pk_context,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
        pwd: *const crate::c_types::c_uchar,
        pwdlen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \ingroup pk_module */
    ////**
    /// \brief           Parse a public key in PEM or DER format
    ///
    /// \note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                  subsystem must have been initialized by calling
    ///                  psa_crypto_init() before calling this function.
    ///
    /// \param ctx       The PK context to fill. It must have been initialized
    ///                  but not set up.
    /// \param key       Input buffer to parse.
    ///                  The buffer must contain the input exactly, with no
    ///                  extra trailing material. For PEM, the buffer must
    ///                  contain a null-terminated string.
    /// \param keylen    Size of \b key in bytes.
    ///                  For PEM data, this includes the terminating null byte,
    ///                  so \p keylen must be equal to `strlen(key) + 1`.
    ///
    /// \note            On entry, ctx must be empty, either freshly initialised
    ///                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
    ///                  specific key type, check the result with mbedtls_pk_can_do().
    ///
    /// \note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for
    ///                  limitations.
    ///
    /// \note            The key is also checked for correctness.
    ///
    /// \return          0 if successful, or a specific PK or PEM error code
    pub fn mbedtls_pk_parse_public_key(
        ctx: *mut mbedtls_pk_context,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Write a private key to a PKCS#1 or SEC1 DER structure
    ///                  Note: data is written at the end of the buffer! Use the
    ///                        return value to determine where you should start
    ///                        using the buffer
    ///
    /// \param ctx       PK context which must contain a valid private key.
    /// \param buf       buffer to write to
    /// \param size      size of the buffer
    ///
    /// \return          length of data written if successful, or a specific
    ///                  error code
    pub fn mbedtls_pk_write_key_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Write a public key to a SubjectPublicKeyInfo DER structure
    ///                  Note: data is written at the end of the buffer! Use the
    ///                        return value to determine where you should start
    ///                        using the buffer
    ///
    /// \param ctx       PK context which must contain a valid public or private key.
    /// \param buf       buffer to write to
    /// \param size      size of the buffer
    ///
    /// \return          length of data written if successful, or a specific
    ///                  error code
    pub fn mbedtls_pk_write_pubkey_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Write a public key to a PEM string
    ///
    /// \param ctx       PK context which must contain a valid public or private key.
    /// \param buf       Buffer to write to. The output includes a
    ///                  terminating null byte.
    /// \param size      Size of the buffer in bytes.
    ///
    /// \return          0 if successful, or a specific error code
    pub fn mbedtls_pk_write_pubkey_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Write a private key to a PKCS#1 or SEC1 PEM string
    ///
    /// \param ctx       PK context which must contain a valid private key.
    /// \param buf       Buffer to write to. The output includes a
    ///                  terminating null byte.
    /// \param size      Size of the buffer in bytes.
    ///
    /// \return          0 if successful, or a specific error code
    pub fn mbedtls_pk_write_key_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Parse a SubjectPublicKeyInfo DER structure
    ///
    /// \param p         the position in the ASN.1 data
    /// \param end       end of the buffer
    /// \param pk        The PK context to fill. It must have been initialized
    ///                  but not set up.
    ///
    /// \return          0 if successful, or a specific PK error code
    pub fn mbedtls_pk_parse_subpubkey(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        pk: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Write a subjectPublicKey to ASN.1 data
    ///                  Note: function works backwards in data buffer
    ///
    /// \param p         reference to current position pointer
    /// \param start     start of the buffer (for bounds-checking)
    /// \param key       PK context which must contain a valid public or private key.
    ///
    /// \return          the length written or a negative error code
    pub fn mbedtls_pk_write_pubkey(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        key: *const mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
///< Placeholder to mark the end of cipher ID lists.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
///< The identity cipher, treated as a stream cipher.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
///< The AES cipher.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
///< The DES cipher. \warning DES is considered weak.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
///< The Triple DES cipher. \warning 3DES is considered weak.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
///< The Camellia cipher.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
///< The Aria cipher.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARIA: mbedtls_cipher_id_t = 6;
///< The ChaCha20 cipher.
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CHACHA20: mbedtls_cipher_id_t = 7;
/// \brief     Supported cipher types.
///
/// \warning   DES/3DES are considered weak ciphers and their use
///            constitutes a security risk. We recommend considering stronger
///            ciphers instead.
pub type mbedtls_cipher_id_t = crate::c_types::c_uint;
///< Placeholder to mark the end of cipher-pair lists.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
///< The identity stream cipher.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
///< AES cipher with 128-bit ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
///< AES cipher with 192-bit ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
///< AES cipher with 256-bit ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
///< AES cipher with 128-bit CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
///< AES cipher with 192-bit CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
///< AES cipher with 256-bit CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
///< AES cipher with 128-bit CFB128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
///< AES cipher with 192-bit CFB128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
///< AES cipher with 256-bit CFB128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
///< AES cipher with 128-bit CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
///< AES cipher with 192-bit CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
///< AES cipher with 256-bit CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
///< AES cipher with 128-bit GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
///< AES cipher with 192-bit GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
///< AES cipher with 256-bit GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
///< Camellia cipher with 128-bit ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
///< Camellia cipher with 192-bit ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
///< Camellia cipher with 256-bit ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
///< Camellia cipher with 128-bit CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
///< Camellia cipher with 192-bit CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
///< Camellia cipher with 256-bit CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
///< Camellia cipher with 128-bit CFB128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
///< Camellia cipher with 192-bit CFB128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
///< Camellia cipher with 256-bit CFB128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
///< Camellia cipher with 128-bit CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
///< Camellia cipher with 192-bit CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
///< Camellia cipher with 256-bit CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
///< Camellia cipher with 128-bit GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
///< Camellia cipher with 192-bit GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
///< Camellia cipher with 256-bit GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
///< DES cipher with ECB mode. \warning DES is considered weak.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
///< DES cipher with CBC mode. \warning DES is considered weak.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
///< DES cipher with EDE ECB mode. \warning 3DES is considered weak.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
///< DES cipher with EDE CBC mode. \warning 3DES is considered weak.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
///< DES cipher with EDE3 ECB mode. \warning 3DES is considered weak.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
///< DES cipher with EDE3 CBC mode. \warning 3DES is considered weak.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
///< AES cipher with 128-bit CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 38;
///< AES cipher with 192-bit CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 39;
///< AES cipher with 256-bit CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 40;
///< AES cipher with 128-bit CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 41;
///< AES cipher with 192-bit CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 42;
///< AES cipher with 256-bit CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 43;
///< Camellia cipher with 128-bit CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 44;
///< Camellia cipher with 192-bit CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 45;
///< Camellia cipher with 256-bit CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 46;
///< Camellia cipher with 128-bit CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    47;
///< Camellia cipher with 192-bit CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    48;
///< Camellia cipher with 256-bit CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    49;
///< Aria cipher with 128-bit key and ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_ECB: mbedtls_cipher_type_t = 50;
///< Aria cipher with 192-bit key and ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_ECB: mbedtls_cipher_type_t = 51;
///< Aria cipher with 256-bit key and ECB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_ECB: mbedtls_cipher_type_t = 52;
///< Aria cipher with 128-bit key and CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CBC: mbedtls_cipher_type_t = 53;
///< Aria cipher with 192-bit key and CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CBC: mbedtls_cipher_type_t = 54;
///< Aria cipher with 256-bit key and CBC mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CBC: mbedtls_cipher_type_t = 55;
///< Aria cipher with 128-bit key and CFB-128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CFB128: mbedtls_cipher_type_t = 56;
///< Aria cipher with 192-bit key and CFB-128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CFB128: mbedtls_cipher_type_t = 57;
///< Aria cipher with 256-bit key and CFB-128 mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CFB128: mbedtls_cipher_type_t = 58;
///< Aria cipher with 128-bit key and CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CTR: mbedtls_cipher_type_t = 59;
///< Aria cipher with 192-bit key and CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CTR: mbedtls_cipher_type_t = 60;
///< Aria cipher with 256-bit key and CTR mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CTR: mbedtls_cipher_type_t = 61;
///< Aria cipher with 128-bit key and GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_GCM: mbedtls_cipher_type_t = 62;
///< Aria cipher with 192-bit key and GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_GCM: mbedtls_cipher_type_t = 63;
///< Aria cipher with 256-bit key and GCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_GCM: mbedtls_cipher_type_t = 64;
///< Aria cipher with 128-bit key and CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM: mbedtls_cipher_type_t = 65;
///< Aria cipher with 192-bit key and CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM: mbedtls_cipher_type_t = 66;
///< Aria cipher with 256-bit key and CCM mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM: mbedtls_cipher_type_t = 67;
///< Aria cipher with 128-bit key and CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 68;
///< Aria cipher with 192-bit key and CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 69;
///< Aria cipher with 256-bit key and CCM_STAR_NO_TAG mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 70;
///< AES 128-bit cipher in OFB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_OFB: mbedtls_cipher_type_t = 71;
///< AES 192-bit cipher in OFB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_OFB: mbedtls_cipher_type_t = 72;
///< AES 256-bit cipher in OFB mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_OFB: mbedtls_cipher_type_t = 73;
///< AES 128-bit cipher in XTS block mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_XTS: mbedtls_cipher_type_t = 74;
///< AES 256-bit cipher in XTS block mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_XTS: mbedtls_cipher_type_t = 75;
///< ChaCha20 stream cipher.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20: mbedtls_cipher_type_t = 76;
///< ChaCha20-Poly1305 AEAD cipher.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20_POLY1305: mbedtls_cipher_type_t = 77;
///< AES cipher with 128-bit NIST KW mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KW: mbedtls_cipher_type_t = 78;
///< AES cipher with 192-bit NIST KW mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KW: mbedtls_cipher_type_t = 79;
///< AES cipher with 256-bit NIST KW mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KW: mbedtls_cipher_type_t = 80;
///< AES cipher with 128-bit NIST KWP mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KWP: mbedtls_cipher_type_t = 81;
///< AES cipher with 192-bit NIST KWP mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KWP: mbedtls_cipher_type_t = 82;
///< AES cipher with 256-bit NIST KWP mode.
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KWP: mbedtls_cipher_type_t = 83;
/// \brief     Supported {cipher type, cipher mode} pairs.
///
/// \warning   DES/3DES are considered weak ciphers and their use
///            constitutes a security risk. We recommend considering stronger
///            ciphers instead.
pub type mbedtls_cipher_type_t = crate::c_types::c_uint;
///< None.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
///< The ECB cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
///< The CBC cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
///< The CFB cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
///< The OFB cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
///< The CTR cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
///< The GCM cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
///< The stream cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
///< The CCM cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
///< The CCM*-no-tag cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM_STAR_NO_TAG: mbedtls_cipher_mode_t = 9;
///< The XTS cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_XTS: mbedtls_cipher_mode_t = 10;
///< The ChaCha-Poly cipher mode.
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CHACHAPOLY: mbedtls_cipher_mode_t = 11;
///< The SP800-38F KW mode
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KW: mbedtls_cipher_mode_t = 12;
///< The SP800-38F KWP mode
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KWP: mbedtls_cipher_mode_t = 13;
/// Supported cipher modes.
pub type mbedtls_cipher_mode_t = crate::c_types::c_uint;
///< PKCS7 padding (default).
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
///< ISO/IEC 7816-4 padding.
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
///< ANSI X.923 padding.
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
///< Zero padding (not reversible).
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
///< Never pad (full blocks only).
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
/// Supported cipher padding types.
pub type mbedtls_cipher_padding_t = crate::c_types::c_uint;
pub const mbedtls_operation_t_MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const mbedtls_operation_t_MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const mbedtls_operation_t_MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
/// Type of operation.
pub type mbedtls_operation_t = crate::c_types::c_int;
/// Undefined key length.
pub const MBEDTLS_KEY_LENGTH_NONE: _bindgen_ty_1 = 0;
/// Key length, in bits (including parity), for DES keys. \warning DES is considered weak.
pub const MBEDTLS_KEY_LENGTH_DES: _bindgen_ty_1 = 64;
/// Key length in bits, including parity, for DES in two-key EDE. \warning 3DES is considered weak.
pub const MBEDTLS_KEY_LENGTH_DES_EDE: _bindgen_ty_1 = 128;
/// Key length in bits, including parity, for DES in three-key EDE. \warning 3DES is considered weak.
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: _bindgen_ty_1 = 192;
pub type _bindgen_ty_1 = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_base_t {
    _unused: [u8; 0],
}
/// Cipher information. Allows calling cipher functions
/// in a generic way.
///
/// \note        The library does not support custom cipher info structures,
///              only built-in structures returned by the functions
///              mbedtls_cipher_info_from_string(),
///              mbedtls_cipher_info_from_type(),
///              mbedtls_cipher_info_from_values(),
///              mbedtls_cipher_info_from_psa().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_info_t {
    /// Full cipher identifier. For example,
    /// MBEDTLS_CIPHER_AES_256_CBC.
    pub private_type: mbedtls_cipher_type_t,
    /// The cipher mode. For example, MBEDTLS_MODE_CBC.
    pub private_mode: mbedtls_cipher_mode_t,
    /// The cipher key length, in bits. This is the
    /// default length for variable sized ciphers.
    /// Includes parity bits for ciphers like DES.
    pub private_key_bitlen: crate::c_types::c_uint,
    /// Name of the cipher.
    pub private_name: *const crate::c_types::c_char,
    /// IV or nonce size, in Bytes.
    /// For ciphers that accept variable IV sizes,
    /// this is the recommended size.
    pub private_iv_size: crate::c_types::c_uint,
    /// Bitflag comprised of MBEDTLS_CIPHER_VARIABLE_IV_LEN and
    ///  MBEDTLS_CIPHER_VARIABLE_KEY_LEN indicating whether the
    ///  cipher supports variable IV or variable key sizes, respectively.
    pub private_flags: crate::c_types::c_int,
    /// The block size, in Bytes.
    pub private_block_size: crate::c_types::c_uint,
    /// Struct for base cipher information and functions.
    pub private_base: *const mbedtls_cipher_base_t,
}
/// Generic cipher context.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_context_t {
    /// Information about the associated cipher.
    pub private_cipher_info: *const mbedtls_cipher_info_t,
    /// Key length to use.
    pub private_key_bitlen: crate::c_types::c_int,
    /// Operation that the key of the context has been
    /// initialized for.
    pub private_operation: mbedtls_operation_t,
    /// Padding functions to use, if relevant for
    /// the specific cipher mode.
    pub private_add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut crate::c_types::c_uchar, olen: usize, data_len: usize),
    >,
    pub private_get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut crate::c_types::c_uchar,
            ilen: usize,
            data_len: *mut usize,
        ) -> crate::c_types::c_int,
    >,
    /// Buffer for input that has not been processed yet.
    pub private_unprocessed_data: [crate::c_types::c_uchar; 16usize],
    /// Number of Bytes that have not been processed yet.
    pub private_unprocessed_len: usize,
    /// Current IV or NONCE_COUNTER for CTR-mode, data unit (or sector) number
    /// for XTS-mode.
    pub private_iv: [crate::c_types::c_uchar; 16usize],
    /// IV size in Bytes, for ciphers with variable-length IVs.
    pub private_iv_size: usize,
    /// The cipher-specific context.
    pub private_cipher_ctx: *mut crate::c_types::c_void,
    /// CMAC-specific context.
    pub private_cmac_ctx: *mut mbedtls_cmac_context_t,
}
extern "C" {
    /// \brief This function retrieves the list of ciphers supported
    ///        by the generic cipher module.
    ///
    ///        For any cipher identifier in the returned list, you can
    ///        obtain the corresponding generic cipher information structure
    ///        via mbedtls_cipher_info_from_type(), which can then be used
    ///        to prepare a cipher context via mbedtls_cipher_setup().
    ///
    ///
    /// \return      A statically-allocated array of cipher identifiers
    ///              of type cipher_type_t. The last entry is zero.
    pub fn mbedtls_cipher_list() -> *const crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function retrieves the cipher-information
    ///                      structure associated with the given cipher name.
    ///
    /// \param cipher_name   Name of the cipher to search for. This must not be
    ///                      \c NULL.
    ///
    /// \return              The cipher information structure associated with the
    ///                      given \p cipher_name.
    /// \return              \c NULL if the associated cipher information is not found.
    pub fn mbedtls_cipher_info_from_string(
        cipher_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    /// \brief               This function retrieves the cipher-information
    ///                      structure associated with the given cipher type.
    ///
    /// \param cipher_type   Type of the cipher to search for.
    ///
    /// \return              The cipher information structure associated with the
    ///                      given \p cipher_type.
    /// \return              \c NULL if the associated cipher information is not found.
    pub fn mbedtls_cipher_info_from_type(
        cipher_type: mbedtls_cipher_type_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    /// \brief               This function retrieves the cipher-information
    ///                      structure associated with the given cipher ID,
    ///                      key size and mode.
    ///
    /// \param cipher_id     The ID of the cipher to search for. For example,
    ///                      #MBEDTLS_CIPHER_ID_AES.
    /// \param key_bitlen    The length of the key in bits.
    /// \param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC.
    ///
    /// \return              The cipher information structure associated with the
    ///                      given \p cipher_id.
    /// \return              \c NULL if the associated cipher information is not found.
    pub fn mbedtls_cipher_info_from_values(
        cipher_id: mbedtls_cipher_id_t,
        key_bitlen: crate::c_types::c_int,
        mode: mbedtls_cipher_mode_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    /// \brief               This function initializes a \p cipher_context as NONE.
    ///
    /// \param ctx           The context to be initialized. This must not be \c NULL.
    pub fn mbedtls_cipher_init(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    /// \brief               This function frees and clears the cipher-specific
    ///                      context of \p ctx. Freeing \p ctx itself remains the
    ///                      responsibility of the caller.
    ///
    /// \param ctx           The context to be freed. If this is \c NULL, the
    ///                      function has no effect, otherwise this must point to an
    ///                      initialized context.
    pub fn mbedtls_cipher_free(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    /// \brief               This function prepares a cipher context for
    ///                      use with the given cipher primitive.
    ///
    /// \note                After calling this function, you should call
    ///                      mbedtls_cipher_setkey() and, if the mode uses padding,
    ///                      mbedtls_cipher_set_padding_mode(), then for each
    ///                      message to encrypt or decrypt with this key, either:
    ///                      - mbedtls_cipher_crypt() for one-shot processing with
    ///                      non-AEAD modes;
    ///                      - mbedtls_cipher_auth_encrypt_ext() or
    ///                      mbedtls_cipher_auth_decrypt_ext() for one-shot
    ///                      processing with AEAD modes or NIST_KW;
    ///                      - for multi-part processing, see the documentation of
    ///                      mbedtls_cipher_reset().
    ///
    /// \param ctx           The context to prepare. This must be initialized by
    ///                      a call to mbedtls_cipher_init() first.
    /// \param cipher_info   The cipher to use.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                      parameter-verification failure.
    /// \return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the
    ///                      cipher-specific context fails.
    pub fn mbedtls_cipher_setup(
        ctx: *mut mbedtls_cipher_context_t,
        cipher_info: *const mbedtls_cipher_info_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function sets the key to use with the given context.
    ///
    /// \param ctx           The generic cipher context. This must be initialized and
    ///                      bound to a cipher information structure.
    /// \param key           The key to use. This must be a readable buffer of at
    ///                      least \p key_bitlen Bits.
    /// \param key_bitlen    The key length to use, in Bits.
    /// \param operation     The operation that the key will be used for:
    ///                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                      parameter-verification failure.
    /// \return              A cipher-specific error code on failure.
    pub fn mbedtls_cipher_setkey(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const crate::c_types::c_uchar,
        key_bitlen: crate::c_types::c_int,
        operation: mbedtls_operation_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function sets the padding mode, for cipher modes
    ///                      that use padding.
    ///
    ///                      The default passing mode is PKCS7 padding.
    ///
    /// \param ctx           The generic cipher context. This must be initialized and
    ///                      bound to a cipher information structure.
    /// \param mode          The padding mode.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE
    ///                      if the selected padding mode is not supported.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode
    ///                      does not support padding.
    pub fn mbedtls_cipher_set_padding_mode(
        ctx: *mut mbedtls_cipher_context_t,
        mode: mbedtls_cipher_padding_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function sets the initialization vector (IV)
    ///                  or nonce.
    ///
    /// \note            Some ciphers do not use IVs nor nonce. For these
    ///                  ciphers, this function has no effect.
    ///
    /// \note            For #MBEDTLS_CIPHER_CHACHA20, the nonce length must
    ///                  be 12, and the initial counter value is 0.
    ///
    /// \note            For #MBEDTLS_CIPHER_CHACHA20_POLY1305, the nonce length
    ///                  must be 12.
    ///
    /// \param ctx       The generic cipher context. This must be initialized and
    ///                  bound to a cipher information structure.
    /// \param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers. This
    ///                  must be a readable buffer of at least \p iv_len Bytes.
    /// \param iv_len    The IV length for ciphers with variable-size IV.
    ///                  This parameter is discarded by ciphers with fixed-size IV.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                  parameter-verification failure.
    pub fn mbedtls_cipher_set_iv(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief         This function resets the cipher state.
    ///
    /// \note          With non-AEAD ciphers, the order of calls for each message
    ///                is as follows:
    ///                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.
    ///                2. mbedtls_cipher_reset()
    ///                3. mbedtls_cipher_update() one or more times
    ///                4. mbedtls_cipher_finish()
    ///                .
    ///                This sequence can be repeated to encrypt or decrypt multiple
    ///                messages with the same key.
    ///
    /// \note          With AEAD ciphers, the order of calls for each message
    ///                is as follows:
    ///                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.
    ///                2. mbedtls_cipher_reset()
    ///                3. mbedtls_cipher_update_ad()
    ///                4. mbedtls_cipher_update() one or more times
    ///                5. mbedtls_cipher_finish()
    ///                6. mbedtls_cipher_check_tag() (for decryption) or
    ///                mbedtls_cipher_write_tag() (for encryption).
    ///                .
    ///                This sequence can be repeated to encrypt or decrypt multiple
    ///                messages with the same key.
    ///
    /// \param ctx     The generic cipher context. This must be bound to a key.
    ///
    /// \return        \c 0 on success.
    /// \return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                parameter-verification failure.
    pub fn mbedtls_cipher_reset(ctx: *mut mbedtls_cipher_context_t) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function adds additional data for AEAD ciphers.
    ///                      Currently supported with GCM and ChaCha20+Poly1305.
    ///
    /// \param ctx           The generic cipher context. This must be initialized.
    /// \param ad            The additional data to use. This must be a readable
    ///                      buffer of at least \p ad_len Bytes.
    /// \param ad_len        The length of \p ad in Bytes.
    ///
    /// \return              \c 0 on success.
    /// \return              A specific error code on failure.
    pub fn mbedtls_cipher_update_ad(
        ctx: *mut mbedtls_cipher_context_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               The generic cipher update function. It encrypts or
    ///                      decrypts using the given cipher context. Writes as
    ///                      many block-sized blocks of data as possible to output.
    ///                      Any data that cannot be written immediately is either
    ///                      added to the next block, or flushed when
    ///                      mbedtls_cipher_finish() is called.
    ///                      Exception: For MBEDTLS_MODE_ECB, expects a single block
    ///                      in size. For example, 16 Bytes for AES.
    ///
    /// \param ctx           The generic cipher context. This must be initialized and
    ///                      bound to a key.
    /// \param input         The buffer holding the input data. This must be a
    ///                      readable buffer of at least \p ilen Bytes.
    /// \param ilen          The length of the input data.
    /// \param output        The buffer for the output data. This must be able to
    ///                      hold at least `ilen + block_size`. This must not be the
    ///                      same buffer as \p input.
    /// \param olen          The length of the output data, to be updated with the
    ///                      actual number of Bytes written. This must not be
    ///                      \c NULL.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                      parameter-verification failure.
    /// \return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an
    ///                      unsupported mode for a cipher.
    /// \return              A cipher-specific error code on failure.
    pub fn mbedtls_cipher_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               The generic cipher finalization function. If data still
    ///                      needs to be flushed from an incomplete block, the data
    ///                      contained in it is padded to the size of
    ///                      the last block, and written to the \p output buffer.
    ///
    /// \param ctx           The generic cipher context. This must be initialized and
    ///                      bound to a key.
    /// \param output        The buffer to write data to. This needs to be a writable
    ///                      buffer of at least \p block_size Bytes.
    /// \param olen          The length of the data written to the \p output buffer.
    ///                      This may not be \c NULL.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                      parameter-verification failure.
    /// \return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption
    ///                      expecting a full block but not receiving one.
    /// \return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding
    ///                      while decrypting.
    /// \return              A cipher-specific error code on failure.
    pub fn mbedtls_cipher_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function writes a tag for AEAD ciphers.
    ///                      Currently supported with GCM and ChaCha20+Poly1305.
    ///                      This must be called after mbedtls_cipher_finish().
    ///
    /// \param ctx           The generic cipher context. This must be initialized,
    ///                      bound to a key, and have just completed a cipher
    ///                      operation through mbedtls_cipher_finish() the tag for
    ///                      which should be written.
    /// \param tag           The buffer to write the tag to. This must be a writable
    ///                      buffer of at least \p tag_len Bytes.
    /// \param tag_len       The length of the tag to write.
    ///
    /// \return              \c 0 on success.
    /// \return              A specific error code on failure.
    pub fn mbedtls_cipher_write_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function checks the tag for AEAD ciphers.
    ///                      Currently supported with GCM and ChaCha20+Poly1305.
    ///                      This must be called after mbedtls_cipher_finish().
    ///
    /// \param ctx           The generic cipher context. This must be initialized.
    /// \param tag           The buffer holding the tag. This must be a readable
    ///                      buffer of at least \p tag_len Bytes.
    /// \param tag_len       The length of the tag to check.
    ///
    /// \return              \c 0 on success.
    /// \return              A specific error code on failure.
    pub fn mbedtls_cipher_check_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               The generic all-in-one encryption/decryption function,
    ///                      for all ciphers except AEAD constructs.
    ///
    /// \param ctx           The generic cipher context. This must be initialized.
    /// \param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.
    ///                      This must be a readable buffer of at least \p iv_len
    ///                      Bytes.
    /// \param iv_len        The IV length for ciphers with variable-size IV.
    ///                      This parameter is discarded by ciphers with fixed-size
    ///                      IV.
    /// \param input         The buffer holding the input data. This must be a
    ///                      readable buffer of at least \p ilen Bytes.
    /// \param ilen          The length of the input data in Bytes.
    /// \param output        The buffer for the output data. This must be able to
    ///                      hold at least `ilen + block_size`. This must not be the
    ///                      same buffer as \p input.
    /// \param olen          The length of the output data, to be updated with the
    ///                      actual number of Bytes written. This must not be
    ///                      \c NULL.
    ///
    /// \note                Some ciphers do not use IVs nor nonce. For these
    ///                      ciphers, use \p iv = NULL and \p iv_len = 0.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                      parameter-verification failure.
    /// \return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption
    ///                      expecting a full block but not receiving one.
    /// \return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding
    ///                      while decrypting.
    /// \return              A cipher-specific error code on failure.
    pub fn mbedtls_cipher_crypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               The authenticated encryption (AEAD/NIST_KW) function.
    ///
    /// \note                For AEAD modes, the tag will be appended to the
    ///                      ciphertext, as recommended by RFC 5116.
    ///                      (NIST_KW doesn't have a separate tag.)
    ///
    /// \param ctx           The generic cipher context. This must be initialized and
    ///                      bound to a key, with an AEAD algorithm or NIST_KW.
    /// \param iv            The nonce to use. This must be a readable buffer of
    ///                      at least \p iv_len Bytes and may be \c NULL if \p
    ///                      iv_len is \c 0.
    /// \param iv_len        The length of the nonce. For AEAD ciphers, this must
    ///                      satisfy the constraints imposed by the cipher used.
    ///                      For NIST_KW, this must be \c 0.
    /// \param ad            The additional data to authenticate. This must be a
    ///                      readable buffer of at least \p ad_len Bytes, and may
    ///                      be \c NULL is \p ad_len is \c 0.
    /// \param ad_len        The length of \p ad. For NIST_KW, this must be \c 0.
    /// \param input         The buffer holding the input data. This must be a
    ///                      readable buffer of at least \p ilen Bytes, and may be
    ///                      \c NULL if \p ilen is \c 0.
    /// \param ilen          The length of the input data.
    /// \param output        The buffer for the output data. This must be a
    ///                      writable buffer of at least \p output_len Bytes, and
    ///                      must not be \c NULL.
    /// \param output_len    The length of the \p output buffer in Bytes. For AEAD
    ///                      ciphers, this must be at least \p ilen + \p tag_len.
    ///                      For NIST_KW, this must be at least \p ilen + 8
    ///                      (rounded up to a multiple of 8 if KWP is used);
    ///                      \p ilen + 15 is always a safe value.
    /// \param olen          This will be filled with the actual number of Bytes
    ///                      written to the \p output buffer. This must point to a
    ///                      writable object of type \c size_t.
    /// \param tag_len       The desired length of the authentication tag. For AEAD
    ///                      ciphers, this must match the constraints imposed by
    ///                      the cipher used, and in particular must not be \c 0.
    ///                      For NIST_KW, this must be \c 0.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                      parameter-verification failure.
    /// \return              A cipher-specific error code on failure.
    pub fn mbedtls_cipher_auth_encrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               The authenticated encryption (AEAD/NIST_KW) function.
    ///
    /// \note                If the data is not authentic, then the output buffer
    ///                      is zeroed out to prevent the unauthentic plaintext being
    ///                      used, making this interface safer.
    ///
    /// \note                For AEAD modes, the tag must be appended to the
    ///                      ciphertext, as recommended by RFC 5116.
    ///                      (NIST_KW doesn't have a separate tag.)
    ///
    /// \param ctx           The generic cipher context. This must be initialized and
    ///                      bound to a key, with an AEAD algorithm or NIST_KW.
    /// \param iv            The nonce to use. This must be a readable buffer of
    ///                      at least \p iv_len Bytes and may be \c NULL if \p
    ///                      iv_len is \c 0.
    /// \param iv_len        The length of the nonce. For AEAD ciphers, this must
    ///                      satisfy the constraints imposed by the cipher used.
    ///                      For NIST_KW, this must be \c 0.
    /// \param ad            The additional data to authenticate. This must be a
    ///                      readable buffer of at least \p ad_len Bytes, and may
    ///                      be \c NULL is \p ad_len is \c 0.
    /// \param ad_len        The length of \p ad. For NIST_KW, this must be \c 0.
    /// \param input         The buffer holding the input data. This must be a
    ///                      readable buffer of at least \p ilen Bytes, and may be
    ///                      \c NULL if \p ilen is \c 0.
    /// \param ilen          The length of the input data. For AEAD ciphers this
    ///                      must be at least \p tag_len. For NIST_KW this must be
    ///                      at least \c 8.
    /// \param output        The buffer for the output data. This must be a
    ///                      writable buffer of at least \p output_len Bytes, and
    ///                      may be \c NULL if \p output_len is \c 0.
    /// \param output_len    The length of the \p output buffer in Bytes. For AEAD
    ///                      ciphers, this must be at least \p ilen - \p tag_len.
    ///                      For NIST_KW, this must be at least \p ilen - 8.
    /// \param olen          This will be filled with the actual number of Bytes
    ///                      written to the \p output buffer. This must point to a
    ///                      writable object of type \c size_t.
    /// \param tag_len       The actual length of the authentication tag. For AEAD
    ///                      ciphers, this must match the constraints imposed by
    ///                      the cipher used, and in particular must not be \c 0.
    ///                      For NIST_KW, this must be \c 0.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
    ///                      parameter-verification failure.
    /// \return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic.
    /// \return              A cipher-specific error code on failure.
    pub fn mbedtls_cipher_auth_decrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_NONE: mbedtls_key_exchange_type_t = 0;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA: mbedtls_key_exchange_type_t = 1;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_RSA: mbedtls_key_exchange_type_t = 2;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: mbedtls_key_exchange_type_t =
    3;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
    mbedtls_key_exchange_type_t = 4;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_PSK: mbedtls_key_exchange_type_t = 5;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_PSK: mbedtls_key_exchange_type_t = 6;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA_PSK: mbedtls_key_exchange_type_t = 7;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_PSK: mbedtls_key_exchange_type_t =
    8;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: mbedtls_key_exchange_type_t =
    9;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: mbedtls_key_exchange_type_t =
    10;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECJPAKE: mbedtls_key_exchange_type_t =
    11;
pub type mbedtls_key_exchange_type_t = crate::c_types::c_uint;
/// \brief   This structure is used for storing ciphersuite information
///
/// \note    members are defined using integral types instead of enums
///          in order to pack structure and reduce memory usage by internal
///          \c ciphersuite_definitions[]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_ciphersuite_t {
    pub private_id: crate::c_types::c_int,
    pub private_name: *const crate::c_types::c_char,
    pub private_cipher: u8,
    pub private_mac: u8,
    pub private_key_exchange: u8,
    pub private_flags: u8,
    pub private_min_tls_version: u16,
    pub private_max_tls_version: u16,
}
extern "C" {
    pub fn mbedtls_ssl_list_ciphersuites() -> *const crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_string(
        ciphersuite_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_id(
        ciphersuite_id: crate::c_types::c_int,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_pk_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_ec(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_psk(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_get_cipher_key_bitlen(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> usize;
}
/// The type of the context passed to mbedtls_psa_external_get_random().
///
/// Mbed TLS initializes the context to all-bits-zero before calling
/// mbedtls_psa_external_get_random() for the first time.
///
/// The definition of this type in the Mbed TLS source code is for
/// demonstration purposes. Implementers of mbedtls_psa_external_get_random()
/// are expected to replace it with a custom definition.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_external_random_context_t {
    pub private_opaque: [usize; 2usize],
}
pub type psa_status_t = i32;
/// \brief Encoding of a key type.
///
/// Values of this type are generally constructed by macros called
/// `PSA_KEY_TYPE_xxx`.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_key_type_t = u16;
/// The type of PSA elliptic curve family identifiers.
///
/// Values of this type are generally constructed by macros called
/// `PSA_ECC_FAMILY_xxx`.
///
/// The curve identifier is required to create an ECC key using the
/// PSA_KEY_TYPE_ECC_KEY_PAIR() or PSA_KEY_TYPE_ECC_PUBLIC_KEY()
/// macros.
///
/// Values defined by this standard will never be in the range 0x80-0xff.
/// Vendors who define additional families must use an encoding in this range.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_ecc_family_t = u8;
/// The type of PSA Diffie-Hellman group family identifiers.
///
/// Values of this type are generally constructed by macros called
/// `PSA_DH_FAMILY_xxx`.
///
/// The group identifier is required to create a Diffie-Hellman key using the
/// PSA_KEY_TYPE_DH_KEY_PAIR() or PSA_KEY_TYPE_DH_PUBLIC_KEY()
/// macros.
///
/// Values defined by this standard will never be in the range 0x80-0xff.
/// Vendors who define additional families must use an encoding in this range.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_dh_family_t = u8;
/// \brief Encoding of a cryptographic algorithm.
///
/// Values of this type are generally constructed by macros called
/// `PSA_ALG_xxx`.
///
/// For algorithms that can be applied to multiple key types, this type
/// does not encode the key type. For example, for symmetric ciphers
/// based on a block cipher, #psa_algorithm_t encodes the block cipher
/// mode and the padding mode while the block cipher itself is encoded
/// via #psa_key_type_t.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_algorithm_t = u32;
/// Encoding of key lifetimes.
///
/// The lifetime of a key indicates where it is stored and what system actions
/// may create and destroy it.
///
/// Lifetime values have the following structure:
/// - Bits 0-7 (#PSA_KEY_LIFETIME_GET_PERSISTENCE(\c lifetime)):
///   persistence level. This value indicates what device management
///   actions can cause it to be destroyed. In particular, it indicates
///   whether the key is _volatile_ or _persistent_.
///   See ::psa_key_persistence_t for more information.
/// - Bits 8-31 (#PSA_KEY_LIFETIME_GET_LOCATION(\c lifetime)):
///   location indicator. This value indicates which part of the system
///   has access to the key material and can perform operations using the key.
///   See ::psa_key_location_t for more information.
///
/// Volatile keys are automatically destroyed when the application instance
/// terminates or on a power reset of the device. Persistent keys are
/// preserved until the application explicitly destroys them or until an
/// integration-specific device management event occurs (for example,
/// a factory reset).
///
/// Persistent keys have a key identifier of type #mbedtls_svc_key_id_t.
/// This identifier remains valid throughout the lifetime of the key,
/// even if the application instance that created the key terminates.
/// The application can call psa_open_key() to open a persistent key that
/// it created previously.
///
/// The default lifetime of a key is #PSA_KEY_LIFETIME_VOLATILE. The lifetime
/// #PSA_KEY_LIFETIME_PERSISTENT is supported if persistent storage is
/// available. Other lifetime values may be supported depending on the
/// library configuration.
///
/// Values of this type are generally constructed by macros called
/// `PSA_KEY_LIFETIME_xxx`.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_key_lifetime_t = u32;
/// Encoding of key persistence levels.
///
/// What distinguishes different persistence levels is what device management
/// events may cause keys to be destroyed. _Volatile_ keys are destroyed
/// by a power reset. Persistent keys may be destroyed by events such as
/// a transfer of ownership or a factory reset. What management events
/// actually affect persistent keys at different levels is outside the
/// scope of the PSA Cryptography specification.
///
/// The PSA Cryptography specification defines the following values of
/// persistence levels:
/// - \c 0 = #PSA_KEY_PERSISTENCE_VOLATILE: volatile key.
///   A volatile key is automatically destroyed by the implementation when
///   the application instance terminates. In particular, a volatile key
///   is automatically destroyed on a power reset of the device.
/// - \c 1 = #PSA_KEY_PERSISTENCE_DEFAULT:
///   persistent key with a default lifetime.
/// - \c 2-254: currently not supported by Mbed TLS.
/// - \c 255 = #PSA_KEY_PERSISTENCE_READ_ONLY:
///   read-only or write-once key.
///   A key with this persistence level cannot be destroyed.
///   Mbed TLS does not currently offer a way to create such keys, but
///   integrations of Mbed TLS can use it for built-in keys that the
///   application cannot modify (for example, a hardware unique key (HUK)).
///
/// \note Key persistence levels are 8-bit values. Key management
///       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which
///       encode the persistence as the lower 8 bits of a 32-bit value.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_key_persistence_t = u8;
/// Encoding of key location indicators.
///
/// If an integration of Mbed TLS can make calls to external
/// cryptoprocessors such as secure elements, the location of a key
/// indicates which secure element performs the operations on the key.
/// Depending on the design of the secure element, the key
/// material may be stored either in the secure element, or
/// in wrapped (encrypted) form alongside the key metadata in the
/// primary local storage.
///
/// The PSA Cryptography API specification defines the following values of
/// location indicators:
/// - \c 0: primary local storage.
///   This location is always available.
///   The primary local storage is typically the same storage area that
///   contains the key metadata.
/// - \c 1: primary secure element.
///   Integrations of Mbed TLS should support this value if there is a secure
///   element attached to the operating environment.
///   As a guideline, secure elements may provide higher resistance against
///   side channel and physical attacks than the primary local storage, but may
///   have restrictions on supported key types, sizes, policies and operations
///   and may have different performance characteristics.
/// - \c 2-0x7fffff: other locations defined by a PSA specification.
///   The PSA Cryptography API does not currently assign any meaning to these
///   locations, but future versions of that specification or other PSA
///   specifications may do so.
/// - \c 0x800000-0xffffff: vendor-defined locations.
///   No PSA specification will assign a meaning to locations in this range.
///
/// \note Key location indicators are 24-bit values. Key management
///       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which
///       encode the location as the upper 24 bits of a 32-bit value.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_key_location_t = u32;
/// Encoding of identifiers of persistent keys.
///
/// - Applications may freely choose key identifiers in the range
///   #PSA_KEY_ID_USER_MIN to #PSA_KEY_ID_USER_MAX.
/// - The implementation may define additional key identifiers in the range
///   #PSA_KEY_ID_VENDOR_MIN to #PSA_KEY_ID_VENDOR_MAX.
/// - 0 is reserved as an invalid key identifier.
/// - Key identifiers outside these ranges are reserved for future use.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to how values are allocated must require careful
///       consideration to allow backward compatibility.
pub type psa_key_id_t = u32;
pub type mbedtls_svc_key_id_t = psa_key_id_t;
/// \brief Encoding of permitted usage on a key.
///
/// Values of this type are generally constructed as bitwise-ors of macros
/// called `PSA_KEY_USAGE_xxx`.
///
/// \note Values of this type are encoded in the persistent key store.
///       Any changes to existing values will require bumping the storage
///       format version and providing a translation when reading the old
///       format.
pub type psa_key_usage_t = u32;
/// The type of a structure containing key attributes.
///
/// This is an opaque structure that can represent the metadata of a key
/// object. Metadata that can be stored in attributes includes:
/// - The location of the key in storage, indicated by its key identifier
///   and its lifetime.
/// - The key's policy, comprising usage flags and a specification of
///   the permitted algorithm(s).
/// - Information about the key itself: the key type and its size.
/// - Additional implementation-defined attributes.
///
/// The actual key material is not considered an attribute of a key.
/// Key attributes do not contain information that is generally considered
/// highly confidential.
///
/// An attribute structure works like a simple data structure where each function
/// `psa_set_key_xxx` sets a field and the corresponding function
/// `psa_get_key_xxx` retrieves the value of the corresponding field.
/// However, a future version of the library  may report values that are
/// equivalent to the original one, but have a different encoding. Invalid
/// values may be mapped to different, also invalid values.
///
/// An attribute structure may contain references to auxiliary resources,
/// for example pointers to allocated memory or indirect references to
/// pre-calculated values. In order to free such resources, the application
/// must call psa_reset_key_attributes(). As an exception, calling
/// psa_reset_key_attributes() on an attribute structure is optional if
/// the structure has only been modified by the following functions
/// since it was initialized or last reset with psa_reset_key_attributes():
/// - psa_set_key_id()
/// - psa_set_key_lifetime()
/// - psa_set_key_type()
/// - psa_set_key_bits()
/// - psa_set_key_usage_flags()
/// - psa_set_key_algorithm()
///
/// Before calling any function on a key attribute structure, the application
/// must initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_key_attributes_t attributes;
///   memset(&attributes, 0, sizeof(attributes));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_key_attributes_t attributes = {0};
///   \endcode
/// - Initialize the structure to the initializer #PSA_KEY_ATTRIBUTES_INIT,
///   for example:
///   \code
///   psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
///   \endcode
/// - Assign the result of the function psa_key_attributes_init()
///   to the structure, for example:
///   \code
///   psa_key_attributes_t attributes;
///   attributes = psa_key_attributes_init();
///   \endcode
///
/// A freshly initialized attribute structure contains the following
/// values:
///
/// - lifetime: #PSA_KEY_LIFETIME_VOLATILE.
/// - key identifier: 0 (which is not a valid key identifier).
/// - type: \c 0 (meaning that the type is unspecified).
/// - key size: \c 0 (meaning that the size is unspecified).
/// - usage flags: \c 0 (which allows no usage except exporting a public key).
/// - algorithm: \c 0 (which allows no cryptographic usage, but allows
///   exporting).
///
/// A typical sequence to create a key is as follows:
/// -# Create and initialize an attribute structure.
/// -# If the key is persistent, call psa_set_key_id().
///    Also call psa_set_key_lifetime() to place the key in a non-default
///    location.
/// -# Set the key policy with psa_set_key_usage_flags() and
///    psa_set_key_algorithm().
/// -# Set the key type with psa_set_key_type().
///    Skip this step if copying an existing key with psa_copy_key().
/// -# When generating a random key with psa_generate_key() or deriving a key
///    with psa_key_derivation_output_key(), set the desired key size with
///    psa_set_key_bits().
/// -# Call a key creation function: psa_import_key(), psa_generate_key(),
///    psa_key_derivation_output_key() or psa_copy_key(). This function reads
///    the attribute structure, creates a key with these attributes, and
///    outputs a key identifier to the newly created key.
/// -# The attribute structure is now no longer necessary.
///    You may call psa_reset_key_attributes(), although this is optional
///    with the workflow presented here because the attributes currently
///    defined in this specification do not require any additional resources
///    beyond the structure itself.
///
/// A typical sequence to query a key's attributes is as follows:
/// -# Call psa_get_key_attributes().
/// -# Call `psa_get_key_xxx` functions to retrieve the attribute(s) that
///    you are interested in.
/// -# Call psa_reset_key_attributes() to free any resources that may be
///    used by the attribute structure.
///
/// Once a key has been created, it is impossible to change its attributes.
pub type psa_key_attributes_t = psa_key_attributes_s;
/// \brief Encoding of the step of a key derivation.
///
/// Values of this type are generally constructed by macros called
/// `PSA_KEY_DERIVATION_INPUT_xxx`.
pub type psa_key_derivation_step_t = u16;
extern "C" {
    /// \brief Library initialization.
    ///
    /// Applications must call this function before calling any other
    /// function in this module.
    ///
    /// Applications may call this function more than once. Once a call
    /// succeeds, subsequent calls are guaranteed to succeed.
    ///
    /// If the application calls other functions before calling psa_crypto_init(),
    /// the behavior is undefined. Implementations are encouraged to either perform
    /// the operation as if the library had been initialized or to return
    /// #PSA_ERROR_BAD_STATE or some other applicable error. In particular,
    /// implementations should not return a success status if the lack of
    /// initialization may have security implications, for example due to improper
    /// seeding of the random number generator.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    pub fn psa_crypto_init() -> psa_status_t;
}
extern "C" {
    /// Retrieve the attributes of a key.
    ///
    /// This function first resets the attribute structure as with
    /// psa_reset_key_attributes(). It then copies the attributes of
    /// the given key into the given attribute structure.
    ///
    /// \note This function may allocate memory or other resources.
    ///       Once you have called this function on an attribute structure,
    ///       you must call psa_reset_key_attributes() to free these resources.
    ///
    /// \param[in] key               Identifier of the key to query.
    /// \param[in,out] attributes    On success, the attributes of the key.
    ///                              On failure, equivalent to a
    ///                              freshly-initialized structure.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_get_key_attributes(
        key: mbedtls_svc_key_id_t,
        attributes: *mut psa_key_attributes_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Reset a key attribute structure to a freshly initialized state.
    ///
    /// You must initialize the attribute structure as described in the
    /// documentation of the type #psa_key_attributes_t before calling this
    /// function. Once the structure has been initialized, you may call this
    /// function at any time.
    ///
    /// This function frees any auxiliary resources that the structure
    /// may contain.
    ///
    /// \param[in,out] attributes    The attribute structure to reset.
    pub fn psa_reset_key_attributes(attributes: *mut psa_key_attributes_t);
}
extern "C" {
    /// Remove non-essential copies of key material from memory.
    ///
    /// If the key identifier designates a volatile key, this functions does not do
    /// anything and returns successfully.
    ///
    /// If the key identifier designates a persistent key, then this function will
    /// free all resources associated with the key in volatile memory. The key
    /// data in persistent storage is not affected and the key can still be used.
    ///
    /// \param key Identifier of the key to purge.
    ///
    /// \retval #PSA_SUCCESS
    ///         The key material will have been removed from memory if it is not
    ///         currently required.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not a valid key identifier.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_purge_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    /// Make a copy of a key.
    ///
    /// Copy key material from one location to another.
    ///
    /// This function is primarily useful to copy a key from one location
    /// to another, since it populates a key using the material from
    /// another key which may have a different lifetime.
    ///
    /// This function may be used to share a key with a different party,
    /// subject to implementation-defined restrictions on key sharing.
    ///
    /// The policy on the source key must have the usage flag
    /// #PSA_KEY_USAGE_COPY set.
    /// This flag is sufficient to permit the copy if the key has the lifetime
    /// #PSA_KEY_LIFETIME_VOLATILE or #PSA_KEY_LIFETIME_PERSISTENT.
    /// Some secure elements do not provide a way to copy a key without
    /// making it extractable from the secure element. If a key is located
    /// in such a secure element, then the key must have both usage flags
    /// #PSA_KEY_USAGE_COPY and #PSA_KEY_USAGE_EXPORT in order to make
    /// a copy of the key outside the secure element.
    ///
    /// The resulting key may only be used in a way that conforms to
    /// both the policy of the original key and the policy specified in
    /// the \p attributes parameter:
    /// - The usage flags on the resulting key are the bitwise-and of the
    ///   usage flags on the source policy and the usage flags in \p attributes.
    /// - If both allow the same algorithm or wildcard-based
    ///   algorithm policy, the resulting key has the same algorithm policy.
    /// - If either of the policies allows an algorithm and the other policy
    ///   allows a wildcard-based algorithm policy that includes this algorithm,
    ///   the resulting key allows the same algorithm.
    /// - If the policies do not allow any algorithm in common, this function
    ///   fails with the status #PSA_ERROR_INVALID_ARGUMENT.
    ///
    /// The effect of this function on implementation-defined attributes is
    /// implementation-defined.
    ///
    /// \param source_key        The key to copy. It must allow the usage
    ///                          #PSA_KEY_USAGE_COPY. If a private or secret key is
    ///                          being copied outside of a secure element it must
    ///                          also allow #PSA_KEY_USAGE_EXPORT.
    /// \param[in] attributes    The attributes for the new key.
    ///                          They are used as follows:
    ///                          - The key type and size may be 0. If either is
    ///                            nonzero, it must match the corresponding
    ///                            attribute of the source key.
    ///                          - The key location (the lifetime and, for
    ///                            persistent keys, the key identifier) is
    ///                            used directly.
    ///                          - The policy constraints (usage flags and
    ///                            algorithm policy) are combined from
    ///                            the source key and \p attributes so that
    ///                            both sets of restrictions apply, as
    ///                            described in the documentation of this function.
    /// \param[out] target_key   On success, an identifier for the newly created
    ///                          key. For persistent keys, this is the key
    ///                          identifier defined in \p attributes.
    ///                          \c 0 on failure.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE
    ///         \p source_key is invalid.
    /// \retval #PSA_ERROR_ALREADY_EXISTS
    ///         This is an attempt to create a persistent key, and there is
    ///         already a persistent key with the given identifier.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The lifetime or identifier in \p attributes are invalid, or
    ///         the policy constraints on the source and specified in
    ///         \p attributes are incompatible, or
    ///         \p attributes specifies a key type or key size
    ///         which does not match the attributes of the source key.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The source key does not have the #PSA_KEY_USAGE_COPY usage flag, or
    ///         the source key is not exportable and its lifetime does not
    ///         allow copying it to the target's lifetime.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_copy_key(
        source_key: mbedtls_svc_key_id_t,
        attributes: *const psa_key_attributes_t,
        target_key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Destroy a key.
    ///
    /// This function destroys a key from both volatile
    /// memory and, if applicable, non-volatile storage. Implementations shall
    /// make a best effort to ensure that the key material cannot be recovered.
    ///
    /// This function also erases any metadata such as policies and frees
    /// resources associated with the key.
    ///
    /// If a key is currently in use in a multipart operation, then destroying the
    /// key will cause the multipart operation to fail.
    ///
    /// \param key  Identifier of the key to erase. If this is \c 0, do nothing and
    ///             return #PSA_SUCCESS.
    ///
    /// \retval #PSA_SUCCESS
    ///         \p key was a valid identifier and the key material that it
    ///         referred to has been erased. Alternatively, \p key is \c 0.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key cannot be erased because it is
    ///         read-only, either due to a policy or due to physical restrictions.
    /// \retval #PSA_ERROR_INVALID_HANDLE
    ///         \p key is not a valid identifier nor \c 0.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE
    ///         There was a failure in communication with the cryptoprocessor.
    ///         The key material may still be present in the cryptoprocessor.
    /// \retval #PSA_ERROR_DATA_INVALID
    ///         This error is typically a result of either storage corruption on a
    ///         cleartext storage backend, or an attempt to read data that was
    ///         written by an incompatible version of the library.
    /// \retval #PSA_ERROR_STORAGE_FAILURE
    ///         The storage is corrupted. Implementations shall make a best effort
    ///         to erase key material even in this stage, however applications
    ///         should be aware that it may be impossible to guarantee that the
    ///         key material is not recoverable in such cases.
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED
    ///         An unexpected condition which is not a storage corruption or
    ///         a communication failure occurred. The cryptoprocessor may have
    ///         been compromised.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_destroy_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    /// \brief Import a key in binary format.
    ///
    /// This function supports any output from psa_export_key(). Refer to the
    /// documentation of psa_export_public_key() for the format of public keys
    /// and to the documentation of psa_export_key() for the format for
    /// other key types.
    ///
    /// The key data determines the key size. The attributes may optionally
    /// specify a key size; in this case it must match the size determined
    /// from the key data. A key size of 0 in \p attributes indicates that
    /// the key size is solely determined by the key data.
    ///
    /// Implementations must reject an attempt to import a key of size 0.
    ///
    /// This specification supports a single format for each key type.
    /// Implementations may support other formats as long as the standard
    /// format is supported. Implementations that support other formats
    /// should ensure that the formats are clearly unambiguous so as to
    /// minimize the risk that an invalid input is accidentally interpreted
    /// according to a different format.
    ///
    /// \param[in] attributes    The attributes for the new key.
    ///                          The key size is always determined from the
    ///                          \p data buffer.
    ///                          If the key size in \p attributes is nonzero,
    ///                          it must be equal to the size from \p data.
    /// \param[out] key          On success, an identifier to the newly created key.
    ///                          For persistent keys, this is the key identifier
    ///                          defined in \p attributes.
    ///                          \c 0 on failure.
    /// \param[in] data    Buffer containing the key data. The content of this
    ///                    buffer is interpreted according to the type declared
    ///                    in \p attributes.
    ///                    All implementations must support at least the format
    ///                    described in the documentation
    ///                    of psa_export_key() or psa_export_public_key() for
    ///                    the chosen type. Implementations may allow other
    ///                    formats, but should be conservative: implementations
    ///                    should err on the side of rejecting content if it
    ///                    may be erroneous (e.g. wrong type or truncated data).
    /// \param data_length Size of the \p data buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    ///         If the key is persistent, the key material and the key's metadata
    ///         have been saved to persistent storage.
    /// \retval #PSA_ERROR_ALREADY_EXISTS
    ///         This is an attempt to create a persistent key, and there is
    ///         already a persistent key with the given identifier.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         The key type or key size is not supported, either by the
    ///         implementation in general or in this particular persistent location.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The key attributes, as a whole, are invalid, or
    ///         the key data is not correctly formatted, or
    ///         the size in \p attributes is nonzero and does not match the size
    ///         of the key data.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_import_key(
        attributes: *const psa_key_attributes_t,
        data: *const u8,
        data_length: usize,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Export a key in binary format.
    ///
    /// The output of this function can be passed to psa_import_key() to
    /// create an equivalent object.
    ///
    /// If the implementation of psa_import_key() supports other formats
    /// beyond the format specified here, the output from psa_export_key()
    /// must use the representation specified here, not the original
    /// representation.
    ///
    /// For standard key types, the output format is as follows:
    ///
    /// - For symmetric keys (including MAC keys), the format is the
    ///   raw bytes of the key.
    /// - For DES, the key data consists of 8 bytes. The parity bits must be
    ///   correct.
    /// - For Triple-DES, the format is the concatenation of the
    ///   two or three DES keys.
    /// - For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format
    ///   is the non-encrypted DER encoding of the representation defined by
    ///   PKCS\#1 (RFC 8017) as `RSAPrivateKey`, version 0.
    ///   ```
    ///   RSAPrivateKey ::= SEQUENCE {
    ///       version             INTEGER,  -- must be 0
    ///       modulus             INTEGER,  -- n
    ///       publicExponent      INTEGER,  -- e
    ///       privateExponent     INTEGER,  -- d
    ///       prime1              INTEGER,  -- p
    ///       prime2              INTEGER,  -- q
    ///       exponent1           INTEGER,  -- d mod (p-1)
    ///       exponent2           INTEGER,  -- d mod (q-1)
    ///       coefficient         INTEGER,  -- (inverse of q) mod p
    ///   }
    ///   ```
    /// - For elliptic curve key pairs (key types for which
    ///   #PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is
    ///   a representation of the private value as a `ceiling(m/8)`-byte string
    ///   where `m` is the bit size associated with the curve, i.e. the bit size
    ///   of the order of the curve's coordinate field. This byte string is
    ///   in little-endian order for Montgomery curves (curve types
    ///   `PSA_ECC_FAMILY_CURVEXXX`), and in big-endian order for Weierstrass
    ///   curves (curve types `PSA_ECC_FAMILY_SECTXXX`, `PSA_ECC_FAMILY_SECPXXX`
    ///   and `PSA_ECC_FAMILY_BRAINPOOL_PXXX`).
    ///   For Weierstrass curves, this is the content of the `privateKey` field of
    ///   the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,
    ///   the format is defined by RFC 7748, and output is masked according to §5.
    ///   For twisted Edwards curves, the private key is as defined by RFC 8032
    ///   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).
    /// - For Diffie-Hellman key exchange key pairs (key types for which
    ///   #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the
    ///   format is the representation of the private key `x` as a big-endian byte
    ///   string. The length of the byte string is the private key size in bytes
    ///   (leading zeroes are not stripped).
    /// - For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is
    ///   true), the format is the same as for psa_export_public_key().
    ///
    /// The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set.
    ///
    /// \param key               Identifier of the key to export. It must allow the
    ///                          usage #PSA_KEY_USAGE_EXPORT, unless it is a public
    ///                          key.
    /// \param[out] data         Buffer where the key data is to be written.
    /// \param data_size         Size of the \p data buffer in bytes.
    /// \param[out] data_length  On success, the number of bytes
    ///                          that make up the key data.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key does not have the #PSA_KEY_USAGE_EXPORT flag.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p data buffer is too small. You can determine a
    ///         sufficient buffer size by calling
    ///         #PSA_EXPORT_KEY_OUTPUT_SIZE(\c type, \c bits)
    ///         where \c type is the key type
    ///         and \c bits is the key size in bits.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_export_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Export a public key or the public part of a key pair in binary format.
    ///
    /// The output of this function can be passed to psa_import_key() to
    /// create an object that is equivalent to the public key.
    ///
    /// This specification supports a single format for each key type.
    /// Implementations may support other formats as long as the standard
    /// format is supported. Implementations that support other formats
    /// should ensure that the formats are clearly unambiguous so as to
    /// minimize the risk that an invalid input is accidentally interpreted
    /// according to a different format.
    ///
    /// For standard key types, the output format is as follows:
    /// - For RSA public keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY), the DER encoding of
    ///   the representation defined by RFC 3279 &sect;2.3.1 as `RSAPublicKey`.
    ///   ```
    ///   RSAPublicKey ::= SEQUENCE {
    ///      modulus            INTEGER,    -- n
    ///      publicExponent     INTEGER  }  -- e
    ///   ```
    /// - For elliptic curve keys on a twisted Edwards curve (key types for which
    ///   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY
    ///   returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined
    ///   by RFC 8032
    ///   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).
    /// - For other elliptic curve public keys (key types for which
    ///   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed
    ///   representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint.
    ///   Let `m` be the bit size associated with the curve, i.e. the bit size of
    ///   `q` for a curve over `F_q`. The representation consists of:
    ///      - The byte 0x04;
    ///      - `x_P` as a `ceiling(m/8)`-byte string, big-endian;
    ///      - `y_P` as a `ceiling(m/8)`-byte string, big-endian.
    /// - For Diffie-Hellman key exchange public keys (key types for which
    ///   #PSA_KEY_TYPE_IS_DH_PUBLIC_KEY is true),
    ///   the format is the representation of the public key `y = g^x mod p` as a
    ///   big-endian byte string. The length of the byte string is the length of the
    ///   base prime `p` in bytes.
    ///
    /// Exporting a public key object or the public part of a key pair is
    /// always permitted, regardless of the key's usage flags.
    ///
    /// \param key               Identifier of the key to export.
    /// \param[out] data         Buffer where the key data is to be written.
    /// \param data_size         Size of the \p data buffer in bytes.
    /// \param[out] data_length  On success, the number of bytes
    ///                          that make up the key data.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The key is neither a public key nor a key pair.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p data buffer is too small. You can determine a
    ///         sufficient buffer size by calling
    ///         #PSA_EXPORT_KEY_OUTPUT_SIZE(#PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(\c type), \c bits)
    ///         where \c type is the key type
    ///         and \c bits is the key size in bits.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_export_public_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Calculate the hash (digest) of a message.
    ///
    /// \note To verify the hash of a message against an
    ///       expected value, use psa_hash_compare() instead.
    ///
    /// \param alg               The hash algorithm to compute (\c PSA_ALG_XXX value
    ///                          such that #PSA_ALG_IS_HASH(\p alg) is true).
    /// \param[in] input         Buffer containing the message to hash.
    /// \param input_length      Size of the \p input buffer in bytes.
    /// \param[out] hash         Buffer where the hash is to be written.
    /// \param hash_size         Size of the \p hash buffer in bytes.
    /// \param[out] hash_length  On success, the number of bytes
    ///                          that make up the hash value. This is always
    ///                          #PSA_HASH_LENGTH(\p alg).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a hash algorithm.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         \p hash_size is too small
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_compute(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        hash: *mut u8,
        hash_size: usize,
        hash_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Calculate the hash (digest) of a message and compare it with a
    /// reference value.
    ///
    /// \param alg               The hash algorithm to compute (\c PSA_ALG_XXX value
    ///                          such that #PSA_ALG_IS_HASH(\p alg) is true).
    /// \param[in] input         Buffer containing the message to hash.
    /// \param input_length      Size of the \p input buffer in bytes.
    /// \param[out] hash         Buffer containing the expected hash value.
    /// \param hash_length       Size of the \p hash buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         The expected hash is identical to the actual hash of the input.
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The hash of the message was calculated successfully, but it
    ///         differs from the expected hash.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a hash algorithm.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p input_length or \p hash_length do not match the hash size for \p alg
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_compare(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
/// The type of the state data structure for multipart hash operations.
///
/// Before calling any function on a hash operation object, the application must
/// initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_hash_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_hash_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer #PSA_HASH_OPERATION_INIT,
///   for example:
///   \code
///   psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function psa_hash_operation_init()
///   to the structure, for example:
///   \code
///   psa_hash_operation_t operation;
///   operation = psa_hash_operation_init();
///   \endcode
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_hash_operation_t = psa_hash_operation_s;
extern "C" {
    /// Set up a multipart hash operation.
    ///
    /// The sequence of operations to calculate a hash (message digest)
    /// is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_hash_operation_t, e.g. #PSA_HASH_OPERATION_INIT.
    /// -# Call psa_hash_setup() to specify the algorithm.
    /// -# Call psa_hash_update() zero, one or more times, passing a fragment
    ///    of the message each time. The hash that is calculated is the hash
    ///    of the concatenation of these messages in order.
    /// -# To calculate the hash, call psa_hash_finish().
    ///    To compare the hash with an expected value, call psa_hash_verify().
    ///
    /// If an error occurs at any step after a call to psa_hash_setup(), the
    /// operation will need to be reset by a call to psa_hash_abort(). The
    /// application may call psa_hash_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_hash_setup(), the application must
    /// eventually terminate the operation. The following events terminate an
    /// operation:
    /// - A successful call to psa_hash_finish() or psa_hash_verify().
    /// - A call to psa_hash_abort().
    ///
    /// \param[in,out] operation The operation object to set up. It must have
    ///                          been initialized as per the documentation for
    ///                          #psa_hash_operation_t and not yet in use.
    /// \param alg               The hash algorithm to compute (\c PSA_ALG_XXX value
    ///                          such that #PSA_ALG_IS_HASH(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not a supported hash algorithm.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p alg is not a hash algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_setup(
        operation: *mut psa_hash_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Add a message fragment to a multipart hash operation.
    ///
    /// The application must call psa_hash_setup() before calling this function.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_hash_abort().
    ///
    /// \param[in,out] operation Active hash operation.
    /// \param[in] input         Buffer containing the message fragment to hash.
    /// \param input_length      Size of the \p input buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_update(
        operation: *mut psa_hash_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Finish the calculation of the hash of a message.
    ///
    /// The application must call psa_hash_setup() before calling this function.
    /// This function calculates the hash of the message formed by concatenating
    /// the inputs passed to preceding calls to psa_hash_update().
    ///
    /// When this function returns successfully, the operation becomes inactive.
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_hash_abort().
    ///
    /// \warning Applications should not call this function if they expect
    ///          a specific value for the hash. Call psa_hash_verify() instead.
    ///          Beware that comparing integrity or authenticity data such as
    ///          hash values with a function such as \c memcmp is risky
    ///          because the time taken by the comparison may leak information
    ///          about the hashed data which could allow an attacker to guess
    ///          a valid hash and thereby bypass security controls.
    ///
    /// \param[in,out] operation     Active hash operation.
    /// \param[out] hash             Buffer where the hash is to be written.
    /// \param hash_size             Size of the \p hash buffer in bytes.
    /// \param[out] hash_length      On success, the number of bytes
    ///                              that make up the hash value. This is always
    ///                              #PSA_HASH_LENGTH(\c alg) where \c alg is the
    ///                              hash algorithm that is calculated.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p hash buffer is too small. You can determine a
    ///         sufficient buffer size by calling #PSA_HASH_LENGTH(\c alg)
    ///         where \c alg is the hash algorithm that is calculated.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_finish(
        operation: *mut psa_hash_operation_t,
        hash: *mut u8,
        hash_size: usize,
        hash_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Finish the calculation of the hash of a message and compare it with
    /// an expected value.
    ///
    /// The application must call psa_hash_setup() before calling this function.
    /// This function calculates the hash of the message formed by concatenating
    /// the inputs passed to preceding calls to psa_hash_update(). It then
    /// compares the calculated hash with the expected hash passed as a
    /// parameter to this function.
    ///
    /// When this function returns successfully, the operation becomes inactive.
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_hash_abort().
    ///
    /// \note Implementations shall make the best effort to ensure that the
    /// comparison between the actual hash and the expected hash is performed
    /// in constant time.
    ///
    /// \param[in,out] operation     Active hash operation.
    /// \param[in] hash              Buffer containing the expected hash value.
    /// \param hash_length           Size of the \p hash buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         The expected hash is identical to the actual hash of the message.
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The hash of the message was calculated successfully, but it
    ///         differs from the expected hash.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_verify(
        operation: *mut psa_hash_operation_t,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Abort a hash operation.
    ///
    /// Aborting an operation frees all associated resources except for the
    /// \p operation structure itself. Once aborted, the operation object
    /// can be reused for another operation by calling
    /// psa_hash_setup() again.
    ///
    /// You may call this function any time after the operation object has
    /// been initialized by one of the methods described in #psa_hash_operation_t.
    ///
    /// In particular, calling psa_hash_abort() after the operation has been
    /// terminated by a call to psa_hash_abort(), psa_hash_finish() or
    /// psa_hash_verify() is safe and has no effect.
    ///
    /// \param[in,out] operation     Initialized hash operation.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_abort(operation: *mut psa_hash_operation_t) -> psa_status_t;
}
extern "C" {
    /// Clone a hash operation.
    ///
    /// This function copies the state of an ongoing hash operation to
    /// a new operation object. In other words, this function is equivalent
    /// to calling psa_hash_setup() on \p target_operation with the same
    /// algorithm that \p source_operation was set up for, then
    /// psa_hash_update() on \p target_operation with the same input that
    /// that was passed to \p source_operation. After this function returns, the
    /// two objects are independent, i.e. subsequent calls involving one of
    /// the objects do not affect the other object.
    ///
    /// \param[in] source_operation      The active hash operation to clone.
    /// \param[in,out] target_operation  The operation object to set up.
    ///                                  It must be initialized but not active.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The \p source_operation state is not valid (it must be active), or
    ///         the \p target_operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_hash_clone(
        source_operation: *const psa_hash_operation_t,
        target_operation: *mut psa_hash_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Calculate the MAC (message authentication code) of a message.
    ///
    /// \note To verify the MAC of a message against an
    ///       expected value, use psa_mac_verify() instead.
    ///       Beware that comparing integrity or authenticity data such as
    ///       MAC values with a function such as \c memcmp is risky
    ///       because the time taken by the comparison may leak information
    ///       about the MAC value which could allow an attacker to guess
    ///       a valid MAC and thereby bypass security controls.
    ///
    /// \param key               Identifier of the key to use for the operation. It
    ///                          must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.
    /// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
    ///                          such that #PSA_ALG_IS_MAC(\p alg) is true).
    /// \param[in] input         Buffer containing the input message.
    /// \param input_length      Size of the \p input buffer in bytes.
    /// \param[out] mac          Buffer where the MAC value is to be written.
    /// \param mac_size          Size of the \p mac buffer in bytes.
    /// \param[out] mac_length   On success, the number of bytes
    ///                          that make up the MAC value.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a MAC algorithm.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         \p mac_size is too small
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE
    ///         The key could not be retrieved from storage.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_compute(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        mac: *mut u8,
        mac_size: usize,
        mac_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Calculate the MAC of a message and compare it with a reference value.
    ///
    /// \param key               Identifier of the key to use for the operation. It
    ///                          must allow the usage PSA_KEY_USAGE_VERIFY_MESSAGE.
    /// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
    ///                          such that #PSA_ALG_IS_MAC(\p alg) is true).
    /// \param[in] input         Buffer containing the input message.
    /// \param input_length      Size of the \p input buffer in bytes.
    /// \param[out] mac          Buffer containing the expected MAC value.
    /// \param mac_length        Size of the \p mac buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         The expected MAC is identical to the actual MAC of the input.
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The MAC of the message was calculated successfully, but it
    ///         differs from the expected value.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a MAC algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE
    ///         The key could not be retrieved from storage.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_verify(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        mac: *const u8,
        mac_length: usize,
    ) -> psa_status_t;
}
/// The type of the state data structure for multipart MAC operations.
///
/// Before calling any function on a MAC operation object, the application must
/// initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_mac_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_mac_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer #PSA_MAC_OPERATION_INIT,
///   for example:
///   \code
///   psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function psa_mac_operation_init()
///   to the structure, for example:
///   \code
///   psa_mac_operation_t operation;
///   operation = psa_mac_operation_init();
///   \endcode
///
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_mac_operation_t = psa_mac_operation_s;
extern "C" {
    /// Set up a multipart MAC calculation operation.
    ///
    /// This function sets up the calculation of the MAC
    /// (message authentication code) of a byte string.
    /// To verify the MAC of a message against an
    /// expected value, use psa_mac_verify_setup() instead.
    ///
    /// The sequence of operations to calculate a MAC is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.
    /// -# Call psa_mac_sign_setup() to specify the algorithm and key.
    /// -# Call psa_mac_update() zero, one or more times, passing a fragment
    ///    of the message each time. The MAC that is calculated is the MAC
    ///    of the concatenation of these messages in order.
    /// -# At the end of the message, call psa_mac_sign_finish() to finish
    ///    calculating the MAC value and retrieve it.
    ///
    /// If an error occurs at any step after a call to psa_mac_sign_setup(), the
    /// operation will need to be reset by a call to psa_mac_abort(). The
    /// application may call psa_mac_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_mac_sign_setup(), the application must
    /// eventually terminate the operation through one of the following methods:
    /// - A successful call to psa_mac_sign_finish().
    /// - A call to psa_mac_abort().
    ///
    /// \param[in,out] operation The operation object to set up. It must have
    ///                          been initialized as per the documentation for
    ///                          #psa_mac_operation_t and not yet in use.
    /// \param key               Identifier of the key to use for the operation. It
    ///                          must remain valid until the operation terminates.
    ///                          It must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.
    /// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
    ///                          such that #PSA_ALG_IS_MAC(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a MAC algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE
    ///         The key could not be retrieved from storage.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_sign_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Set up a multipart MAC verification operation.
    ///
    /// This function sets up the verification of the MAC
    /// (message authentication code) of a byte string against an expected value.
    ///
    /// The sequence of operations to verify a MAC is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.
    /// -# Call psa_mac_verify_setup() to specify the algorithm and key.
    /// -# Call psa_mac_update() zero, one or more times, passing a fragment
    ///    of the message each time. The MAC that is calculated is the MAC
    ///    of the concatenation of these messages in order.
    /// -# At the end of the message, call psa_mac_verify_finish() to finish
    ///    calculating the actual MAC of the message and verify it against
    ///    the expected value.
    ///
    /// If an error occurs at any step after a call to psa_mac_verify_setup(), the
    /// operation will need to be reset by a call to psa_mac_abort(). The
    /// application may call psa_mac_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_mac_verify_setup(), the application must
    /// eventually terminate the operation through one of the following methods:
    /// - A successful call to psa_mac_verify_finish().
    /// - A call to psa_mac_abort().
    ///
    /// \param[in,out] operation The operation object to set up. It must have
    ///                          been initialized as per the documentation for
    ///                          #psa_mac_operation_t and not yet in use.
    /// \param key               Identifier of the key to use for the operation. It
    ///                          must remain valid until the operation terminates.
    ///                          It must allow the usage
    ///                          PSA_KEY_USAGE_VERIFY_MESSAGE.
    /// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
    ///                          such that #PSA_ALG_IS_MAC(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \c key is not compatible with \c alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \c alg is not supported or is not a MAC algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE
    ///         The key could not be retrieved from storage.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_verify_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Add a message fragment to a multipart MAC operation.
    ///
    /// The application must call psa_mac_sign_setup() or psa_mac_verify_setup()
    /// before calling this function.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_mac_abort().
    ///
    /// \param[in,out] operation Active MAC operation.
    /// \param[in] input         Buffer containing the message fragment to add to
    ///                          the MAC calculation.
    /// \param input_length      Size of the \p input buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_update(
        operation: *mut psa_mac_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Finish the calculation of the MAC of a message.
    ///
    /// The application must call psa_mac_sign_setup() before calling this function.
    /// This function calculates the MAC of the message formed by concatenating
    /// the inputs passed to preceding calls to psa_mac_update().
    ///
    /// When this function returns successfully, the operation becomes inactive.
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_mac_abort().
    ///
    /// \warning Applications should not call this function if they expect
    ///          a specific value for the MAC. Call psa_mac_verify_finish() instead.
    ///          Beware that comparing integrity or authenticity data such as
    ///          MAC values with a function such as \c memcmp is risky
    ///          because the time taken by the comparison may leak information
    ///          about the MAC value which could allow an attacker to guess
    ///          a valid MAC and thereby bypass security controls.
    ///
    /// \param[in,out] operation Active MAC operation.
    /// \param[out] mac          Buffer where the MAC value is to be written.
    /// \param mac_size          Size of the \p mac buffer in bytes.
    /// \param[out] mac_length   On success, the number of bytes
    ///                          that make up the MAC value. This is always
    ///                          #PSA_MAC_LENGTH(\c key_type, \c key_bits, \c alg)
    ///                          where \c key_type and \c key_bits are the type and
    ///                          bit-size respectively of the key and \c alg is the
    ///                          MAC algorithm that is calculated.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p mac buffer is too small. You can determine a
    ///         sufficient buffer size by calling PSA_MAC_LENGTH().
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be an active mac sign
    ///         operation), or the library has not been previously initialized
    ///         by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_sign_finish(
        operation: *mut psa_mac_operation_t,
        mac: *mut u8,
        mac_size: usize,
        mac_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Finish the calculation of the MAC of a message and compare it with
    /// an expected value.
    ///
    /// The application must call psa_mac_verify_setup() before calling this function.
    /// This function calculates the MAC of the message formed by concatenating
    /// the inputs passed to preceding calls to psa_mac_update(). It then
    /// compares the calculated MAC with the expected MAC passed as a
    /// parameter to this function.
    ///
    /// When this function returns successfully, the operation becomes inactive.
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_mac_abort().
    ///
    /// \note Implementations shall make the best effort to ensure that the
    /// comparison between the actual MAC and the expected MAC is performed
    /// in constant time.
    ///
    /// \param[in,out] operation Active MAC operation.
    /// \param[in] mac           Buffer containing the expected MAC value.
    /// \param mac_length        Size of the \p mac buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         The expected MAC is identical to the actual MAC of the message.
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The MAC of the message was calculated successfully, but it
    ///         differs from the expected MAC.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be an active mac verify
    ///         operation), or the library has not been previously initialized
    ///         by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_verify_finish(
        operation: *mut psa_mac_operation_t,
        mac: *const u8,
        mac_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Abort a MAC operation.
    ///
    /// Aborting an operation frees all associated resources except for the
    /// \p operation structure itself. Once aborted, the operation object
    /// can be reused for another operation by calling
    /// psa_mac_sign_setup() or psa_mac_verify_setup() again.
    ///
    /// You may call this function any time after the operation object has
    /// been initialized by one of the methods described in #psa_mac_operation_t.
    ///
    /// In particular, calling psa_mac_abort() after the operation has been
    /// terminated by a call to psa_mac_abort(), psa_mac_sign_finish() or
    /// psa_mac_verify_finish() is safe and has no effect.
    ///
    /// \param[in,out] operation Initialized MAC operation.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_mac_abort(operation: *mut psa_mac_operation_t) -> psa_status_t;
}
extern "C" {
    /// Encrypt a message using a symmetric cipher.
    ///
    /// This function encrypts a message with a random IV (initialization
    /// vector). Use the multipart operation interface with a
    /// #psa_cipher_operation_t object to provide other forms of IV.
    ///
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must allow the usage #PSA_KEY_USAGE_ENCRYPT.
    /// \param alg                   The cipher algorithm to compute
    ///                              (\c PSA_ALG_XXX value such that
    ///                              #PSA_ALG_IS_CIPHER(\p alg) is true).
    /// \param[in] input             Buffer containing the message to encrypt.
    /// \param input_length          Size of the \p input buffer in bytes.
    /// \param[out] output           Buffer where the output is to be written.
    ///                              The output contains the IV followed by
    ///                              the ciphertext proper.
    /// \param output_size           Size of the \p output buffer in bytes.
    /// \param[out] output_length    On success, the number of bytes
    ///                              that make up the output.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a cipher algorithm.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Decrypt a message using a symmetric cipher.
    ///
    /// This function decrypts a message encrypted with a symmetric cipher.
    ///
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must remain valid until the operation
    ///                              terminates. It must allow the usage
    ///                              #PSA_KEY_USAGE_DECRYPT.
    /// \param alg                   The cipher algorithm to compute
    ///                              (\c PSA_ALG_XXX value such that
    ///                              #PSA_ALG_IS_CIPHER(\p alg) is true).
    /// \param[in] input             Buffer containing the message to decrypt.
    ///                              This consists of the IV followed by the
    ///                              ciphertext proper.
    /// \param input_length          Size of the \p input buffer in bytes.
    /// \param[out] output           Buffer where the plaintext is to be written.
    /// \param output_size           Size of the \p output buffer in bytes.
    /// \param[out] output_length    On success, the number of bytes
    ///                              that make up the output.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a cipher algorithm.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
/// The type of the state data structure for multipart cipher operations.
///
/// Before calling any function on a cipher operation object, the application
/// must initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_cipher_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_cipher_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer #PSA_CIPHER_OPERATION_INIT,
///   for example:
///   \code
///   psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function psa_cipher_operation_init()
///   to the structure, for example:
///   \code
///   psa_cipher_operation_t operation;
///   operation = psa_cipher_operation_init();
///   \endcode
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_cipher_operation_t = psa_cipher_operation_s;
extern "C" {
    /// Set the key for a multipart symmetric encryption operation.
    ///
    /// The sequence of operations to encrypt a message with a symmetric cipher
    /// is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_cipher_operation_t, e.g.
    ///    #PSA_CIPHER_OPERATION_INIT.
    /// -# Call psa_cipher_encrypt_setup() to specify the algorithm and key.
    /// -# Call either psa_cipher_generate_iv() or psa_cipher_set_iv() to
    ///    generate or set the IV (initialization vector). You should use
    ///    psa_cipher_generate_iv() unless the protocol you are implementing
    ///    requires a specific IV value.
    /// -# Call psa_cipher_update() zero, one or more times, passing a fragment
    ///    of the message each time.
    /// -# Call psa_cipher_finish().
    ///
    /// If an error occurs at any step after a call to psa_cipher_encrypt_setup(),
    /// the operation will need to be reset by a call to psa_cipher_abort(). The
    /// application may call psa_cipher_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_cipher_encrypt_setup(), the application must
    /// eventually terminate the operation. The following events terminate an
    /// operation:
    /// - A successful call to psa_cipher_finish().
    /// - A call to psa_cipher_abort().
    ///
    /// \param[in,out] operation     The operation object to set up. It must have
    ///                              been initialized as per the documentation for
    ///                              #psa_cipher_operation_t and not yet in use.
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must remain valid until the operation
    ///                              terminates. It must allow the usage
    ///                              #PSA_KEY_USAGE_ENCRYPT.
    /// \param alg                   The cipher algorithm to compute
    ///                              (\c PSA_ALG_XXX value such that
    ///                              #PSA_ALG_IS_CIPHER(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a cipher algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_encrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the key for a multipart symmetric decryption operation.
    ///
    /// The sequence of operations to decrypt a message with a symmetric cipher
    /// is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_cipher_operation_t, e.g.
    ///    #PSA_CIPHER_OPERATION_INIT.
    /// -# Call psa_cipher_decrypt_setup() to specify the algorithm and key.
    /// -# Call psa_cipher_set_iv() with the IV (initialization vector) for the
    ///    decryption. If the IV is prepended to the ciphertext, you can call
    ///    psa_cipher_update() on a buffer containing the IV followed by the
    ///    beginning of the message.
    /// -# Call psa_cipher_update() zero, one or more times, passing a fragment
    ///    of the message each time.
    /// -# Call psa_cipher_finish().
    ///
    /// If an error occurs at any step after a call to psa_cipher_decrypt_setup(),
    /// the operation will need to be reset by a call to psa_cipher_abort(). The
    /// application may call psa_cipher_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_cipher_decrypt_setup(), the application must
    /// eventually terminate the operation. The following events terminate an
    /// operation:
    /// - A successful call to psa_cipher_finish().
    /// - A call to psa_cipher_abort().
    ///
    /// \param[in,out] operation     The operation object to set up. It must have
    ///                              been initialized as per the documentation for
    ///                              #psa_cipher_operation_t and not yet in use.
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must remain valid until the operation
    ///                              terminates. It must allow the usage
    ///                              #PSA_KEY_USAGE_DECRYPT.
    /// \param alg                   The cipher algorithm to compute
    ///                              (\c PSA_ALG_XXX value such that
    ///                              #PSA_ALG_IS_CIPHER(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not a cipher algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_decrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Generate an IV for a symmetric encryption operation.
    ///
    /// This function generates a random IV (initialization vector), nonce
    /// or initial counter value for the encryption operation as appropriate
    /// for the chosen algorithm, key type and key size.
    ///
    /// The application must call psa_cipher_encrypt_setup() before
    /// calling this function.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_cipher_abort().
    ///
    /// \param[in,out] operation     Active cipher operation.
    /// \param[out] iv               Buffer where the generated IV is to be written.
    /// \param iv_size               Size of the \p iv buffer in bytes.
    /// \param[out] iv_length        On success, the number of bytes of the
    ///                              generated IV.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p iv buffer is too small.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, with no IV set),
    ///         or the library has not been previously initialized
    ///         by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_generate_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *mut u8,
        iv_size: usize,
        iv_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the IV for a symmetric encryption or decryption operation.
    ///
    /// This function sets the IV (initialization vector), nonce
    /// or initial counter value for the encryption or decryption operation.
    ///
    /// The application must call psa_cipher_encrypt_setup() before
    /// calling this function.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_cipher_abort().
    ///
    /// \note When encrypting, applications should use psa_cipher_generate_iv()
    /// instead of this function, unless implementing a protocol that requires
    /// a non-random IV.
    ///
    /// \param[in,out] operation     Active cipher operation.
    /// \param[in] iv                Buffer containing the IV to use.
    /// \param iv_length             Size of the IV in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The size of \p iv is not acceptable for the chosen algorithm,
    ///         or the chosen algorithm does not use an IV.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be an active cipher
    ///         encrypt operation, with no IV set), or the library has not been
    ///         previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_set_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *const u8,
        iv_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Encrypt or decrypt a message fragment in an active cipher operation.
    ///
    /// Before calling this function, you must:
    /// 1. Call either psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup().
    ///    The choice of setup function determines whether this function
    ///    encrypts or decrypts its input.
    /// 2. If the algorithm requires an IV, call psa_cipher_generate_iv()
    ///    (recommended when encrypting) or psa_cipher_set_iv().
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_cipher_abort().
    ///
    /// \param[in,out] operation     Active cipher operation.
    /// \param[in] input             Buffer containing the message fragment to
    ///                              encrypt or decrypt.
    /// \param input_length          Size of the \p input buffer in bytes.
    /// \param[out] output           Buffer where the output is to be written.
    /// \param output_size           Size of the \p output buffer in bytes.
    /// \param[out] output_length    On success, the number of bytes
    ///                              that make up the returned output.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p output buffer is too small.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, with an IV set
    ///         if required for the algorithm), or the library has not been
    ///         previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_update(
        operation: *mut psa_cipher_operation_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Finish encrypting or decrypting a message in a cipher operation.
    ///
    /// The application must call psa_cipher_encrypt_setup() or
    /// psa_cipher_decrypt_setup() before calling this function. The choice
    /// of setup function determines whether this function encrypts or
    /// decrypts its input.
    ///
    /// This function finishes the encryption or decryption of the message
    /// formed by concatenating the inputs passed to preceding calls to
    /// psa_cipher_update().
    ///
    /// When this function returns successfully, the operation becomes inactive.
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_cipher_abort().
    ///
    /// \param[in,out] operation     Active cipher operation.
    /// \param[out] output           Buffer where the output is to be written.
    /// \param output_size           Size of the \p output buffer in bytes.
    /// \param[out] output_length    On success, the number of bytes
    ///                              that make up the returned output.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The total input size passed to this operation is not valid for
    ///         this particular algorithm. For example, the algorithm is a based
    ///         on block cipher and requires a whole number of blocks, but the
    ///         total input size is not a multiple of the block size.
    /// \retval #PSA_ERROR_INVALID_PADDING
    ///         This is a decryption operation for an algorithm that includes
    ///         padding, and the ciphertext does not contain valid padding.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p output buffer is too small.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, with an IV set
    ///         if required for the algorithm), or the library has not been
    ///         previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_finish(
        operation: *mut psa_cipher_operation_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Abort a cipher operation.
    ///
    /// Aborting an operation frees all associated resources except for the
    /// \p operation structure itself. Once aborted, the operation object
    /// can be reused for another operation by calling
    /// psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup() again.
    ///
    /// You may call this function any time after the operation object has
    /// been initialized as described in #psa_cipher_operation_t.
    ///
    /// In particular, calling psa_cipher_abort() after the operation has been
    /// terminated by a call to psa_cipher_abort() or psa_cipher_finish()
    /// is safe and has no effect.
    ///
    /// \param[in,out] operation     Initialized cipher operation.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_cipher_abort(operation: *mut psa_cipher_operation_t) -> psa_status_t;
}
extern "C" {
    /// Process an authenticated encryption operation.
    ///
    /// \param key                     Identifier of the key to use for the
    ///                                operation. It must allow the usage
    ///                                #PSA_KEY_USAGE_ENCRYPT.
    /// \param alg                     The AEAD algorithm to compute
    ///                                (\c PSA_ALG_XXX value such that
    ///                                #PSA_ALG_IS_AEAD(\p alg) is true).
    /// \param[in] nonce               Nonce or IV to use.
    /// \param nonce_length            Size of the \p nonce buffer in bytes.
    /// \param[in] additional_data     Additional data that will be authenticated
    ///                                but not encrypted.
    /// \param additional_data_length  Size of \p additional_data in bytes.
    /// \param[in] plaintext           Data that will be authenticated and
    ///                                encrypted.
    /// \param plaintext_length        Size of \p plaintext in bytes.
    /// \param[out] ciphertext         Output buffer for the authenticated and
    ///                                encrypted data. The additional data is not
    ///                                part of this output. For algorithms where the
    ///                                encrypted data and the authentication tag
    ///                                are defined as separate outputs, the
    ///                                authentication tag is appended to the
    ///                                encrypted data.
    /// \param ciphertext_size         Size of the \p ciphertext buffer in bytes.
    ///                                This must be appropriate for the selected
    ///                                algorithm and key:
    ///                                - A sufficient output size is
    ///                                  #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\c key_type,
    ///                                  \p alg, \p plaintext_length) where
    ///                                  \c key_type is the type of \p key.
    ///                                - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\p
    ///                                  plaintext_length) evaluates to the maximum
    ///                                  ciphertext size of any supported AEAD
    ///                                  encryption.
    /// \param[out] ciphertext_length  On success, the size of the output
    ///                                in the \p ciphertext buffer.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not an AEAD algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         \p ciphertext_size is too small.
    ///         #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\c key_type, \p alg,
    ///         \p plaintext_length) or
    ///         #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\p plaintext_length) can be used to
    ///         determine the required buffer size.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: usize,
        additional_data: *const u8,
        additional_data_length: usize,
        plaintext: *const u8,
        plaintext_length: usize,
        ciphertext: *mut u8,
        ciphertext_size: usize,
        ciphertext_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Process an authenticated decryption operation.
    ///
    /// \param key                     Identifier of the key to use for the
    ///                                operation. It must allow the usage
    ///                                #PSA_KEY_USAGE_DECRYPT.
    /// \param alg                     The AEAD algorithm to compute
    ///                                (\c PSA_ALG_XXX value such that
    ///                                #PSA_ALG_IS_AEAD(\p alg) is true).
    /// \param[in] nonce               Nonce or IV to use.
    /// \param nonce_length            Size of the \p nonce buffer in bytes.
    /// \param[in] additional_data     Additional data that has been authenticated
    ///                                but not encrypted.
    /// \param additional_data_length  Size of \p additional_data in bytes.
    /// \param[in] ciphertext          Data that has been authenticated and
    ///                                encrypted. For algorithms where the
    ///                                encrypted data and the authentication tag
    ///                                are defined as separate inputs, the buffer
    ///                                must contain the encrypted data followed
    ///                                by the authentication tag.
    /// \param ciphertext_length       Size of \p ciphertext in bytes.
    /// \param[out] plaintext          Output buffer for the decrypted data.
    /// \param plaintext_size          Size of the \p plaintext buffer in bytes.
    ///                                This must be appropriate for the selected
    ///                                algorithm and key:
    ///                                - A sufficient output size is
    ///                                  #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\c key_type,
    ///                                  \p alg, \p ciphertext_length) where
    ///                                  \c key_type is the type of \p key.
    ///                                - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\p
    ///                                  ciphertext_length) evaluates to the maximum
    ///                                  plaintext size of any supported AEAD
    ///                                  decryption.
    /// \param[out] plaintext_length   On success, the size of the output
    ///                                in the \p plaintext buffer.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The ciphertext is not authentic.
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not an AEAD algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         \p plaintext_size is too small.
    ///         #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\c key_type, \p alg,
    ///         \p ciphertext_length) or
    ///         #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\p ciphertext_length) can be used
    ///         to determine the required buffer size.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: usize,
        additional_data: *const u8,
        additional_data_length: usize,
        ciphertext: *const u8,
        ciphertext_length: usize,
        plaintext: *mut u8,
        plaintext_size: usize,
        plaintext_length: *mut usize,
    ) -> psa_status_t;
}
/// The type of the state data structure for multipart AEAD operations.
///
/// Before calling any function on an AEAD operation object, the application
/// must initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_aead_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_aead_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer #PSA_AEAD_OPERATION_INIT,
///   for example:
///   \code
///   psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function psa_aead_operation_init()
///   to the structure, for example:
///   \code
///   psa_aead_operation_t operation;
///   operation = psa_aead_operation_init();
///   \endcode
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_aead_operation_t = psa_aead_operation_s;
extern "C" {
    /// Set the key for a multipart authenticated encryption operation.
    ///
    /// The sequence of operations to encrypt a message with authentication
    /// is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_aead_operation_t, e.g.
    ///    #PSA_AEAD_OPERATION_INIT.
    /// -# Call psa_aead_encrypt_setup() to specify the algorithm and key.
    /// -# If needed, call psa_aead_set_lengths() to specify the length of the
    ///    inputs to the subsequent calls to psa_aead_update_ad() and
    ///    psa_aead_update(). See the documentation of psa_aead_set_lengths()
    ///    for details.
    /// -# Call either psa_aead_generate_nonce() or psa_aead_set_nonce() to
    ///    generate or set the nonce. You should use
    ///    psa_aead_generate_nonce() unless the protocol you are implementing
    ///    requires a specific nonce value.
    /// -# Call psa_aead_update_ad() zero, one or more times, passing a fragment
    ///    of the non-encrypted additional authenticated data each time.
    /// -# Call psa_aead_update() zero, one or more times, passing a fragment
    ///    of the message to encrypt each time.
    /// -# Call psa_aead_finish().
    ///
    /// If an error occurs at any step after a call to psa_aead_encrypt_setup(),
    /// the operation will need to be reset by a call to psa_aead_abort(). The
    /// application may call psa_aead_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_aead_encrypt_setup(), the application must
    /// eventually terminate the operation. The following events terminate an
    /// operation:
    /// - A successful call to psa_aead_finish().
    /// - A call to psa_aead_abort().
    ///
    /// \param[in,out] operation     The operation object to set up. It must have
    ///                              been initialized as per the documentation for
    ///                              #psa_aead_operation_t and not yet in use.
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must remain valid until the operation
    ///                              terminates. It must allow the usage
    ///                              #PSA_KEY_USAGE_ENCRYPT.
    /// \param alg                   The AEAD algorithm to compute
    ///                              (\c PSA_ALG_XXX value such that
    ///                              #PSA_ALG_IS_AEAD(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not an AEAD algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_encrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the key for a multipart authenticated decryption operation.
    ///
    /// The sequence of operations to decrypt a message with authentication
    /// is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_aead_operation_t, e.g.
    ///    #PSA_AEAD_OPERATION_INIT.
    /// -# Call psa_aead_decrypt_setup() to specify the algorithm and key.
    /// -# If needed, call psa_aead_set_lengths() to specify the length of the
    ///    inputs to the subsequent calls to psa_aead_update_ad() and
    ///    psa_aead_update(). See the documentation of psa_aead_set_lengths()
    ///    for details.
    /// -# Call psa_aead_set_nonce() with the nonce for the decryption.
    /// -# Call psa_aead_update_ad() zero, one or more times, passing a fragment
    ///    of the non-encrypted additional authenticated data each time.
    /// -# Call psa_aead_update() zero, one or more times, passing a fragment
    ///    of the ciphertext to decrypt each time.
    /// -# Call psa_aead_verify().
    ///
    /// If an error occurs at any step after a call to psa_aead_decrypt_setup(),
    /// the operation will need to be reset by a call to psa_aead_abort(). The
    /// application may call psa_aead_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_aead_decrypt_setup(), the application must
    /// eventually terminate the operation. The following events terminate an
    /// operation:
    /// - A successful call to psa_aead_verify().
    /// - A call to psa_aead_abort().
    ///
    /// \param[in,out] operation     The operation object to set up. It must have
    ///                              been initialized as per the documentation for
    ///                              #psa_aead_operation_t and not yet in use.
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must remain valid until the operation
    ///                              terminates. It must allow the usage
    ///                              #PSA_KEY_USAGE_DECRYPT.
    /// \param alg                   The AEAD algorithm to compute
    ///                              (\c PSA_ALG_XXX value such that
    ///                              #PSA_ALG_IS_AEAD(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not compatible with \p alg.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not supported or is not an AEAD algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or the
    ///         library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_decrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Generate a random nonce for an authenticated encryption operation.
    ///
    /// This function generates a random nonce for the authenticated encryption
    /// operation with an appropriate size for the chosen algorithm, key type
    /// and key size.
    ///
    /// The application must call psa_aead_encrypt_setup() before
    /// calling this function.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_aead_abort().
    ///
    /// \param[in,out] operation     Active AEAD operation.
    /// \param[out] nonce            Buffer where the generated nonce is to be
    ///                              written.
    /// \param nonce_size            Size of the \p nonce buffer in bytes.
    /// \param[out] nonce_length     On success, the number of bytes of the
    ///                              generated nonce.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p nonce buffer is too small.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be an active aead encrypt
    ///         operation, with no nonce set), or the library has not been
    ///         previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_generate_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *mut u8,
        nonce_size: usize,
        nonce_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the nonce for an authenticated encryption or decryption operation.
    ///
    /// This function sets the nonce for the authenticated
    /// encryption or decryption operation.
    ///
    /// The application must call psa_aead_encrypt_setup() or
    /// psa_aead_decrypt_setup() before calling this function.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_aead_abort().
    ///
    /// \note When encrypting, applications should use psa_aead_generate_nonce()
    /// instead of this function, unless implementing a protocol that requires
    /// a non-random IV.
    ///
    /// \param[in,out] operation     Active AEAD operation.
    /// \param[in] nonce             Buffer containing the nonce to use.
    /// \param nonce_length          Size of the nonce in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The size of \p nonce is not acceptable for the chosen algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, with no nonce
    ///         set), or the library has not been previously initialized
    ///         by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_set_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *const u8,
        nonce_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Declare the lengths of the message and additional data for AEAD.
    ///
    /// The application must call this function before calling
    /// psa_aead_update_ad() or psa_aead_update() if the algorithm for
    /// the operation requires it. If the algorithm does not require it,
    /// calling this function is optional, but if this function is called
    /// then the implementation must enforce the lengths.
    ///
    /// You may call this function before or after setting the nonce with
    /// psa_aead_set_nonce() or psa_aead_generate_nonce().
    ///
    /// - For #PSA_ALG_CCM, calling this function is required.
    /// - For the other AEAD algorithms defined in this specification, calling
    ///   this function is not required.
    /// - For vendor-defined algorithm, refer to the vendor documentation.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_aead_abort().
    ///
    /// \param[in,out] operation     Active AEAD operation.
    /// \param ad_length             Size of the non-encrypted additional
    ///                              authenticated data in bytes.
    /// \param plaintext_length      Size of the plaintext to encrypt in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         At least one of the lengths is not acceptable for the chosen
    ///         algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, and
    ///         psa_aead_update_ad() and psa_aead_update() must not have been
    ///         called yet), or the library has not been previously initialized
    ///         by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_set_lengths(
        operation: *mut psa_aead_operation_t,
        ad_length: usize,
        plaintext_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Pass additional data to an active AEAD operation.
    ///
    /// Additional data is authenticated, but not encrypted.
    ///
    /// You may call this function multiple times to pass successive fragments
    /// of the additional data. You may not call this function after passing
    /// data to encrypt or decrypt with psa_aead_update().
    ///
    /// Before calling this function, you must:
    /// 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().
    /// 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_aead_abort().
    ///
    /// \warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,
    ///          there is no guarantee that the input is valid. Therefore, until
    ///          you have called psa_aead_verify() and it has returned #PSA_SUCCESS,
    ///          treat the input as untrusted and prepare to undo any action that
    ///          depends on the input if psa_aead_verify() returns an error status.
    ///
    /// \param[in,out] operation     Active AEAD operation.
    /// \param[in] input             Buffer containing the fragment of
    ///                              additional data.
    /// \param input_length          Size of the \p input buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The total input length overflows the additional data length that
    ///         was previously specified with psa_aead_set_lengths().
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, have a nonce
    ///         set, have lengths set if required by the algorithm, and
    ///         psa_aead_update() must not have been called yet), or the library
    ///         has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_update_ad(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Encrypt or decrypt a message fragment in an active AEAD operation.
    ///
    /// Before calling this function, you must:
    /// 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().
    ///    The choice of setup function determines whether this function
    ///    encrypts or decrypts its input.
    /// 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().
    /// 3. Call psa_aead_update_ad() to pass all the additional data.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_aead_abort().
    ///
    /// \warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,
    ///          there is no guarantee that the input is valid. Therefore, until
    ///          you have called psa_aead_verify() and it has returned #PSA_SUCCESS:
    ///          - Do not use the output in any way other than storing it in a
    ///            confidential location. If you take any action that depends
    ///            on the tentative decrypted data, this action will need to be
    ///            undone if the input turns out not to be valid. Furthermore,
    ///            if an adversary can observe that this action took place
    ///            (for example through timing), they may be able to use this
    ///            fact as an oracle to decrypt any message encrypted with the
    ///            same key.
    ///          - In particular, do not copy the output anywhere but to a
    ///            memory or storage space that you have exclusive access to.
    ///
    /// This function does not require the input to be aligned to any
    /// particular block boundary. If the implementation can only process
    /// a whole block at a time, it must consume all the input provided, but
    /// it may delay the end of the corresponding output until a subsequent
    /// call to psa_aead_update(), psa_aead_finish() or psa_aead_verify()
    /// provides sufficient input. The amount of data that can be delayed
    /// in this way is bounded by #PSA_AEAD_UPDATE_OUTPUT_SIZE.
    ///
    /// \param[in,out] operation     Active AEAD operation.
    /// \param[in] input             Buffer containing the message fragment to
    ///                              encrypt or decrypt.
    /// \param input_length          Size of the \p input buffer in bytes.
    /// \param[out] output           Buffer where the output is to be written.
    /// \param output_size           Size of the \p output buffer in bytes.
    ///                              This must be appropriate for the selected
    ///                                algorithm and key:
    ///                                - A sufficient output size is
    ///                                  #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c key_type,
    ///                                  \c alg, \p input_length) where
    ///                                  \c key_type is the type of key and \c alg is
    ///                                  the algorithm that were used to set up the
    ///                                  operation.
    ///                                - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\p
    ///                                  input_length) evaluates to the maximum
    ///                                  output size of any supported AEAD
    ///                                  algorithm.
    /// \param[out] output_length    On success, the number of bytes
    ///                              that make up the returned output.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p output buffer is too small.
    ///         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c key_type, \c alg, \p input_length) or
    ///         #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\p input_length) can be used to
    ///         determine the required buffer size.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The total length of input to psa_aead_update_ad() so far is
    ///         less than the additional data length that was previously
    ///         specified with psa_aead_set_lengths(), or
    ///         the total input length overflows the plaintext length that
    ///         was previously specified with psa_aead_set_lengths().
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, have a nonce
    ///         set, and have lengths set if required by the algorithm), or the
    ///         library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_update(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Finish encrypting a message in an AEAD operation.
    ///
    /// The operation must have been set up with psa_aead_encrypt_setup().
    ///
    /// This function finishes the authentication of the additional data
    /// formed by concatenating the inputs passed to preceding calls to
    /// psa_aead_update_ad() with the plaintext formed by concatenating the
    /// inputs passed to preceding calls to psa_aead_update().
    ///
    /// This function has two output buffers:
    /// - \p ciphertext contains trailing ciphertext that was buffered from
    ///   preceding calls to psa_aead_update().
    /// - \p tag contains the authentication tag.
    ///
    /// When this function returns successfully, the operation becomes inactive.
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_aead_abort().
    ///
    /// \param[in,out] operation     Active AEAD operation.
    /// \param[out] ciphertext       Buffer where the last part of the ciphertext
    ///                              is to be written.
    /// \param ciphertext_size       Size of the \p ciphertext buffer in bytes.
    ///                              This must be appropriate for the selected
    ///                              algorithm and key:
    ///                              - A sufficient output size is
    ///                                #PSA_AEAD_FINISH_OUTPUT_SIZE(\c key_type,
    ///                                \c alg) where \c key_type is the type of key
    ///                                and \c alg is the algorithm that were used to
    ///                                set up the operation.
    ///                              - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to
    ///                                the maximum output size of any supported AEAD
    ///                                algorithm.
    /// \param[out] ciphertext_length On success, the number of bytes of
    ///                              returned ciphertext.
    /// \param[out] tag              Buffer where the authentication tag is
    ///                              to be written.
    /// \param tag_size              Size of the \p tag buffer in bytes.
    ///                              This must be appropriate for the selected
    ///                              algorithm and key:
    ///                              - The exact tag size is #PSA_AEAD_TAG_LENGTH(\c
    ///                                key_type, \c key_bits, \c alg) where
    ///                                \c key_type and \c key_bits are the type and
    ///                                bit-size of the key, and \c alg is the
    ///                                algorithm that were used in the call to
    ///                                psa_aead_encrypt_setup().
    ///                              - #PSA_AEAD_TAG_MAX_SIZE evaluates to the
    ///                                maximum tag size of any supported AEAD
    ///                                algorithm.
    /// \param[out] tag_length       On success, the number of bytes
    ///                              that make up the returned tag.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p ciphertext or \p tag buffer is too small.
    ///         #PSA_AEAD_FINISH_OUTPUT_SIZE(\c key_type, \c alg) or
    ///         #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the
    ///         required \p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\c key_type,
    ///         \c key_bits, \c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to
    ///         determine the required \p tag buffer size.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The total length of input to psa_aead_update_ad() so far is
    ///         less than the additional data length that was previously
    ///         specified with psa_aead_set_lengths(), or
    ///         the total length of input to psa_aead_update() so far is
    ///         less than the plaintext length that was previously
    ///         specified with psa_aead_set_lengths().
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be an active encryption
    ///         operation with a nonce set), or the library has not been previously
    ///         initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_finish(
        operation: *mut psa_aead_operation_t,
        ciphertext: *mut u8,
        ciphertext_size: usize,
        ciphertext_length: *mut usize,
        tag: *mut u8,
        tag_size: usize,
        tag_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Finish authenticating and decrypting a message in an AEAD operation.
    ///
    /// The operation must have been set up with psa_aead_decrypt_setup().
    ///
    /// This function finishes the authenticated decryption of the message
    /// components:
    ///
    /// -  The additional data consisting of the concatenation of the inputs
    ///    passed to preceding calls to psa_aead_update_ad().
    /// -  The ciphertext consisting of the concatenation of the inputs passed to
    ///    preceding calls to psa_aead_update().
    /// -  The tag passed to this function call.
    ///
    /// If the authentication tag is correct, this function outputs any remaining
    /// plaintext and reports success. If the authentication tag is not correct,
    /// this function returns #PSA_ERROR_INVALID_SIGNATURE.
    ///
    /// When this function returns successfully, the operation becomes inactive.
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_aead_abort().
    ///
    /// \note Implementations shall make the best effort to ensure that the
    /// comparison between the actual tag and the expected tag is performed
    /// in constant time.
    ///
    /// \param[in,out] operation     Active AEAD operation.
    /// \param[out] plaintext        Buffer where the last part of the plaintext
    ///                              is to be written. This is the remaining data
    ///                              from previous calls to psa_aead_update()
    ///                              that could not be processed until the end
    ///                              of the input.
    /// \param plaintext_size        Size of the \p plaintext buffer in bytes.
    ///                              This must be appropriate for the selected algorithm and key:
    ///                              - A sufficient output size is
    ///                                #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c key_type,
    ///                                \c alg) where \c key_type is the type of key
    ///                                and \c alg is the algorithm that were used to
    ///                                set up the operation.
    ///                              - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to
    ///                                the maximum output size of any supported AEAD
    ///                                algorithm.
    /// \param[out] plaintext_length On success, the number of bytes of
    ///                              returned plaintext.
    /// \param[in] tag               Buffer containing the authentication tag.
    /// \param tag_length            Size of the \p tag buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The calculations were successful, but the authentication tag is
    ///         not correct.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p plaintext buffer is too small.
    ///         #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c key_type, \c alg) or
    ///         #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the
    ///         required buffer size.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The total length of input to psa_aead_update_ad() so far is
    ///         less than the additional data length that was previously
    ///         specified with psa_aead_set_lengths(), or
    ///         the total length of input to psa_aead_update() so far is
    ///         less than the plaintext length that was previously
    ///         specified with psa_aead_set_lengths().
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be an active decryption
    ///         operation with a nonce set), or the library has not been previously
    ///         initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_verify(
        operation: *mut psa_aead_operation_t,
        plaintext: *mut u8,
        plaintext_size: usize,
        plaintext_length: *mut usize,
        tag: *const u8,
        tag_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Abort an AEAD operation.
    ///
    /// Aborting an operation frees all associated resources except for the
    /// \p operation structure itself. Once aborted, the operation object
    /// can be reused for another operation by calling
    /// psa_aead_encrypt_setup() or psa_aead_decrypt_setup() again.
    ///
    /// You may call this function any time after the operation object has
    /// been initialized as described in #psa_aead_operation_t.
    ///
    /// In particular, calling psa_aead_abort() after the operation has been
    /// terminated by a call to psa_aead_abort(), psa_aead_finish() or
    /// psa_aead_verify() is safe and has no effect.
    ///
    /// \param[in,out] operation     Initialized AEAD operation.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_aead_abort(operation: *mut psa_aead_operation_t) -> psa_status_t;
}
extern "C" {
    /// \brief Sign a message with a private key. For hash-and-sign algorithms,
    ///        this includes the hashing step.
    ///
    /// \note To perform a multi-part hash-and-sign signature algorithm, first use
    ///       a multi-part hash operation and then pass the resulting hash to
    ///       psa_sign_hash(). PSA_ALG_GET_HASH(\p alg) can be used to determine the
    ///       hash algorithm to use.
    ///
    /// \param[in]  key              Identifier of the key to use for the operation.
    ///                              It must be an asymmetric key pair. The key must
    ///                              allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE.
    /// \param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX
    ///                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\p alg)
    ///                              is true), that is compatible with the type of
    ///                              \p key.
    /// \param[in]  input            The input message to sign.
    /// \param[in]  input_length     Size of the \p input buffer in bytes.
    /// \param[out] signature        Buffer where the signature is to be written.
    /// \param[in]  signature_size   Size of the \p signature buffer in bytes. This
    ///                              must be appropriate for the selected
    ///                              algorithm and key:
    ///                              - The required signature size is
    ///                                #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
    ///                                where \c key_type and \c key_bits are the type and
    ///                                bit-size respectively of key.
    ///                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the
    ///                                maximum signature size of any supported
    ///                                signature algorithm.
    /// \param[out] signature_length On success, the number of bytes that make up
    ///                              the returned signature value.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,
    ///         or it does not permit the requested algorithm.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p signature buffer is too small. You can
    ///         determine a sufficient buffer size by calling
    ///         #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
    ///         where \c key_type and \c key_bits are the type and bit-size
    ///         respectively of \p key.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_sign_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Verify the signature of a message with a public key, using
    ///         a hash-and-sign verification algorithm.
    ///
    /// \note To perform a multi-part hash-and-sign signature verification
    ///       algorithm, first use a multi-part hash operation to hash the message
    ///       and then pass the resulting hash to psa_verify_hash().
    ///       PSA_ALG_GET_HASH(\p alg) can be used to determine the hash algorithm
    ///       to use.
    ///
    /// \param[in]  key              Identifier of the key to use for the operation.
    ///                              It must be a public key or an asymmetric key
    ///                              pair. The key must allow the usage
    ///                              #PSA_KEY_USAGE_VERIFY_MESSAGE.
    /// \param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX
    ///                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\p alg)
    ///                              is true), that is compatible with the type of
    ///                              \p key.
    /// \param[in]  input            The message whose signature is to be verified.
    /// \param[in]  input_length     Size of the \p input buffer in bytes.
    /// \param[out] signature        Buffer containing the signature to verify.
    /// \param[in]  signature_length Size of the \p signature buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,
    ///         or it does not permit the requested algorithm.
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The calculation was performed successfully, but the passed signature
    ///         is not a valid signature.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_verify_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Sign a hash or short message with a private key.
    ///
    /// Note that to perform a hash-and-sign signature algorithm, you must
    /// first calculate the hash by calling psa_hash_setup(), psa_hash_update()
    /// and psa_hash_finish(), or alternatively by calling psa_hash_compute().
    /// Then pass the resulting hash as the \p hash
    /// parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\p alg)
    /// to determine the hash algorithm to use.
    ///
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must be an asymmetric key pair. The key must
    ///                              allow the usage #PSA_KEY_USAGE_SIGN_HASH.
    /// \param alg                   A signature algorithm (PSA_ALG_XXX
    ///                              value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
    ///                              is true), that is compatible with
    ///                              the type of \p key.
    /// \param[in] hash              The hash or message to sign.
    /// \param hash_length           Size of the \p hash buffer in bytes.
    /// \param[out] signature        Buffer where the signature is to be written.
    /// \param signature_size        Size of the \p signature buffer in bytes.
    /// \param[out] signature_length On success, the number of bytes
    ///                              that make up the returned signature value.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p signature buffer is too small. You can
    ///         determine a sufficient buffer size by calling
    ///         #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
    ///         where \c key_type and \c key_bits are the type and bit-size
    ///         respectively of \p key.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_sign_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Verify the signature of a hash or short message using a public key.
    ///
    /// Note that to perform a hash-and-sign signature algorithm, you must
    /// first calculate the hash by calling psa_hash_setup(), psa_hash_update()
    /// and psa_hash_finish(), or alternatively by calling psa_hash_compute().
    /// Then pass the resulting hash as the \p hash
    /// parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\p alg)
    /// to determine the hash algorithm to use.
    ///
    /// \param key               Identifier of the key to use for the operation. It
    ///                          must be a public key or an asymmetric key pair. The
    ///                          key must allow the usage
    ///                          #PSA_KEY_USAGE_VERIFY_HASH.
    /// \param alg               A signature algorithm (PSA_ALG_XXX
    ///                          value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
    ///                          is true), that is compatible with
    ///                          the type of \p key.
    /// \param[in] hash          The hash or message whose signature is to be
    ///                          verified.
    /// \param hash_length       Size of the \p hash buffer in bytes.
    /// \param[in] signature     Buffer containing the signature to verify.
    /// \param signature_length  Size of the \p signature buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         The signature is valid.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The calculation was performed successfully, but the passed
    ///         signature is not a valid signature.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_verify_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Encrypt a short message with a public key.
    ///
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must be a public key or an asymmetric key
    ///                              pair. It must allow the usage
    ///                              #PSA_KEY_USAGE_ENCRYPT.
    /// \param alg                   An asymmetric encryption algorithm that is
    ///                              compatible with the type of \p key.
    /// \param[in] input             The message to encrypt.
    /// \param input_length          Size of the \p input buffer in bytes.
    /// \param[in] salt              A salt or label, if supported by the
    ///                              encryption algorithm.
    ///                              If the algorithm does not support a
    ///                              salt, pass \c NULL.
    ///                              If the algorithm supports an optional
    ///                              salt and you do not want to pass a salt,
    ///                              pass \c NULL.
    ///
    ///                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is
    ///                                supported.
    /// \param salt_length           Size of the \p salt buffer in bytes.
    ///                              If \p salt is \c NULL, pass 0.
    /// \param[out] output           Buffer where the encrypted message is to
    ///                              be written.
    /// \param output_size           Size of the \p output buffer in bytes.
    /// \param[out] output_length    On success, the number of bytes
    ///                              that make up the returned output.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p output buffer is too small. You can
    ///         determine a sufficient buffer size by calling
    ///         #PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
    ///         where \c key_type and \c key_bits are the type and bit-size
    ///         respectively of \p key.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_asymmetric_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        salt: *const u8,
        salt_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Decrypt a short message with a private key.
    ///
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must be an asymmetric key pair. It must
    ///                              allow the usage #PSA_KEY_USAGE_DECRYPT.
    /// \param alg                   An asymmetric encryption algorithm that is
    ///                              compatible with the type of \p key.
    /// \param[in] input             The message to decrypt.
    /// \param input_length          Size of the \p input buffer in bytes.
    /// \param[in] salt              A salt or label, if supported by the
    ///                              encryption algorithm.
    ///                              If the algorithm does not support a
    ///                              salt, pass \c NULL.
    ///                              If the algorithm supports an optional
    ///                              salt and you do not want to pass a salt,
    ///                              pass \c NULL.
    ///
    ///                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is
    ///                                supported.
    /// \param salt_length           Size of the \p salt buffer in bytes.
    ///                              If \p salt is \c NULL, pass 0.
    /// \param[out] output           Buffer where the decrypted message is to
    ///                              be written.
    /// \param output_size           Size of the \c output buffer in bytes.
    /// \param[out] output_length    On success, the number of bytes
    ///                              that make up the returned output.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p output buffer is too small. You can
    ///         determine a sufficient buffer size by calling
    ///         #PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
    ///         where \c key_type and \c key_bits are the type and bit-size
    ///         respectively of \p key.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_INVALID_PADDING \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_asymmetric_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        salt: *const u8,
        salt_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
/// The type of the state data structure for key derivation operations.
///
/// Before calling any function on a key derivation operation object, the
/// application must initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_key_derivation_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_key_derivation_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer #PSA_KEY_DERIVATION_OPERATION_INIT,
///   for example:
///   \code
///   psa_key_derivation_operation_t operation = PSA_KEY_DERIVATION_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function psa_key_derivation_operation_init()
///   to the structure, for example:
///   \code
///   psa_key_derivation_operation_t operation;
///   operation = psa_key_derivation_operation_init();
///   \endcode
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_key_derivation_operation_t = psa_key_derivation_s;
extern "C" {
    /// Set up a key derivation operation.
    ///
    /// A key derivation algorithm takes some inputs and uses them to generate
    /// a byte stream in a deterministic way.
    /// This byte stream can be used to produce keys and other
    /// cryptographic material.
    ///
    /// To derive a key:
    /// -# Start with an initialized object of type #psa_key_derivation_operation_t.
    /// -# Call psa_key_derivation_setup() to select the algorithm.
    /// -# Provide the inputs for the key derivation by calling
    ///    psa_key_derivation_input_bytes() or psa_key_derivation_input_key()
    ///    as appropriate. Which inputs are needed, in what order, and whether
    ///    they may be keys and if so of what type depends on the algorithm.
    /// -# Optionally set the operation's maximum capacity with
    ///    psa_key_derivation_set_capacity(). You may do this before, in the middle
    ///    of or after providing inputs. For some algorithms, this step is mandatory
    ///    because the output depends on the maximum capacity.
    /// -# To derive a key, call psa_key_derivation_output_key().
    ///    To derive a byte string for a different purpose, call
    ///    psa_key_derivation_output_bytes().
    ///    Successive calls to these functions use successive output bytes
    ///    calculated by the key derivation algorithm.
    /// -# Clean up the key derivation operation object with
    ///    psa_key_derivation_abort().
    ///
    /// If this function returns an error, the key derivation operation object is
    /// not changed.
    ///
    /// If an error occurs at any step after a call to psa_key_derivation_setup(),
    /// the operation will need to be reset by a call to psa_key_derivation_abort().
    ///
    /// Implementations must reject an attempt to derive a key of size 0.
    ///
    /// \param[in,out] operation       The key derivation operation object
    ///                                to set up. It must
    ///                                have been initialized but not set up yet.
    /// \param alg                     The key derivation algorithm to compute
    ///                                (\c PSA_ALG_XXX value such that
    ///                                #PSA_ALG_IS_KEY_DERIVATION(\p alg) is true).
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \c alg is not a key derivation algorithm.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \c alg is not supported or is not a key derivation algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be inactive), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_setup(
        operation: *mut psa_key_derivation_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Retrieve the current capacity of a key derivation operation.
    ///
    /// The capacity of a key derivation is the maximum number of bytes that it can
    /// return. When you get *N* bytes of output from a key derivation operation,
    /// this reduces its capacity by *N*.
    ///
    /// \param[in] operation     The operation to query.
    /// \param[out] capacity     On success, the capacity of the operation.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_get_capacity(
        operation: *const psa_key_derivation_operation_t,
        capacity: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the maximum capacity of a key derivation operation.
    ///
    /// The capacity of a key derivation operation is the maximum number of bytes
    /// that the key derivation operation can return from this point onwards.
    ///
    /// \param[in,out] operation The key derivation operation object to modify.
    /// \param capacity          The new capacity of the operation.
    ///                          It must be less or equal to the operation's
    ///                          current capacity.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p capacity is larger than the operation's current capacity.
    ///         In this case, the operation object remains valid and its capacity
    ///         remains unchanged.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active), or the
    ///         library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_set_capacity(
        operation: *mut psa_key_derivation_operation_t,
        capacity: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Provide an input for key derivation or key agreement.
    ///
    /// Which inputs are required and in what order depends on the algorithm.
    /// Refer to the documentation of each key derivation or key agreement
    /// algorithm for information.
    ///
    /// This function passes direct inputs, which is usually correct for
    /// non-secret inputs. To pass a secret input, which should be in a key
    /// object, call psa_key_derivation_input_key() instead of this function.
    /// Refer to the documentation of individual step types
    /// (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)
    /// for more information.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_key_derivation_abort().
    ///
    /// \param[in,out] operation       The key derivation operation object to use.
    ///                                It must have been set up with
    ///                                psa_key_derivation_setup() and must not
    ///                                have produced any output yet.
    /// \param step                    Which step the input data is for.
    /// \param[in] data                Input data to use.
    /// \param data_length             Size of the \p data buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \c step is not compatible with the operation's algorithm, or
    ///         \c step does not allow direct inputs.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid for this input \p step, or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_input_bytes(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        data: *const u8,
        data_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Provide a numeric input for key derivation or key agreement.
    ///
    /// Which inputs are required and in what order depends on the algorithm.
    /// However, when an algorithm requires a particular order, numeric inputs
    /// usually come first as they tend to be configuration parameters.
    /// Refer to the documentation of each key derivation or key agreement
    /// algorithm for information.
    ///
    /// This function is used for inputs which are fixed-size non-negative
    /// integers.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_key_derivation_abort().
    ///
    /// \param[in,out] operation       The key derivation operation object to use.
    ///                                It must have been set up with
    ///                                psa_key_derivation_setup() and must not
    ///                                have produced any output yet.
    /// \param step                    Which step the input data is for.
    /// \param[in] value               The value of the numeric input.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \c step is not compatible with the operation's algorithm, or
    ///         \c step does not allow numeric inputs.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid for this input \p step, or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_input_integer(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        value: u64,
    ) -> psa_status_t;
}
extern "C" {
    /// Provide an input for key derivation in the form of a key.
    ///
    /// Which inputs are required and in what order depends on the algorithm.
    /// Refer to the documentation of each key derivation or key agreement
    /// algorithm for information.
    ///
    /// This function obtains input from a key object, which is usually correct for
    /// secret inputs or for non-secret personalization strings kept in the key
    /// store. To pass a non-secret parameter which is not in the key store,
    /// call psa_key_derivation_input_bytes() instead of this function.
    /// Refer to the documentation of individual step types
    /// (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)
    /// for more information.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_key_derivation_abort().
    ///
    /// \param[in,out] operation       The key derivation operation object to use.
    ///                                It must have been set up with
    ///                                psa_key_derivation_setup() and must not
    ///                                have produced any output yet.
    /// \param step                    Which step the input data is for.
    /// \param key                     Identifier of the key. It must have an
    ///                                appropriate type for step and must allow the
    ///                                usage #PSA_KEY_USAGE_DERIVE or
    ///                                #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)
    ///                                and the algorithm used by the operation.
    ///
    /// \note Once all inputs steps are completed, the operations will allow:
    /// - psa_key_derivation_output_bytes() if each input was either a direct input
    ///   or  a key with #PSA_KEY_USAGE_DERIVE set;
    /// - psa_key_derivation_output_key() if the input for step
    ///   #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD
    ///   was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was
    ///   either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;
    /// - psa_key_derivation_verify_bytes() if each input was either a direct input
    ///   or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;
    /// - psa_key_derivation_verify_key() under the same conditions as
    ///   psa_key_derivation_verify_bytes().
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key allows neither #PSA_KEY_USAGE_DERIVE nor
    ///         #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this
    ///         algorithm.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \c step is not compatible with the operation's algorithm, or
    ///         \c step does not allow key inputs of the given type
    ///         or does not allow key inputs at all.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid for this input \p step, or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_input_key(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        key: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Perform a key agreement and use the shared secret as input to a key
    /// derivation.
    ///
    /// A key agreement algorithm takes two inputs: a private key \p private_key
    /// a public key \p peer_key.
    /// The result of this function is passed as input to a key derivation.
    /// The output of this key derivation can be extracted by reading from the
    /// resulting operation to produce keys and other cryptographic material.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_key_derivation_abort().
    ///
    /// \param[in,out] operation       The key derivation operation object to use.
    ///                                It must have been set up with
    ///                                psa_key_derivation_setup() with a
    ///                                key agreement and derivation algorithm
    ///                                \c alg (\c PSA_ALG_XXX value such that
    ///                                #PSA_ALG_IS_KEY_AGREEMENT(\c alg) is true
    ///                                and #PSA_ALG_IS_RAW_KEY_AGREEMENT(\c alg)
    ///                                is false).
    ///                                The operation must be ready for an
    ///                                input of the type given by \p step.
    /// \param step                    Which step the input data is for.
    /// \param private_key             Identifier of the private key to use. It must
    ///                                allow the usage #PSA_KEY_USAGE_DERIVE.
    /// \param[in] peer_key      Public key of the peer. The peer key must be in the
    ///                          same format that psa_import_key() accepts for the
    ///                          public key type corresponding to the type of
    ///                          private_key. That is, this function performs the
    ///                          equivalent of
    ///                          #psa_import_key(...,
    ///                          `peer_key`, `peer_key_length`) where
    ///                          with key attributes indicating the public key
    ///                          type corresponding to the type of `private_key`.
    ///                          For example, for EC keys, this means that peer_key
    ///                          is interpreted as a point on the curve that the
    ///                          private key is on. The standard formats for public
    ///                          keys are documented in the documentation of
    ///                          psa_export_public_key().
    /// \param peer_key_length         Size of \p peer_key in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \c private_key is not compatible with \c alg,
    ///         or \p peer_key is not valid for \c alg or not compatible with
    ///         \c private_key, or \c step does not allow an input resulting
    ///         from a key agreement.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \c alg is not supported or is not a key derivation algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid for this key agreement \p step,
    ///         or the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_key_agreement(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Read some data from a key derivation operation.
    ///
    /// This function calculates output bytes from a key derivation algorithm and
    /// return those bytes.
    /// If you view the key derivation's output as a stream of bytes, this
    /// function destructively reads the requested number of bytes from the
    /// stream.
    /// The operation's capacity decreases by the number of bytes read.
    ///
    /// If this function returns an error status other than
    /// #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error
    /// state and must be aborted by calling psa_key_derivation_abort().
    ///
    /// \param[in,out] operation The key derivation operation object to read from.
    /// \param[out] output       Buffer where the output will be written.
    /// \param output_length     Number of bytes to output.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         One of the inputs was a key whose policy didn't allow
    ///         #PSA_KEY_USAGE_DERIVE.
    /// \retval #PSA_ERROR_INSUFFICIENT_DATA
    ///                          The operation's capacity was less than
    ///                          \p output_length bytes. Note that in this case,
    ///                          no output is written to the output buffer.
    ///                          The operation's capacity is set to 0, thus
    ///                          subsequent calls to this function will not
    ///                          succeed, even with a smaller output buffer.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active and completed
    ///         all required input steps), or the library has not been previously
    ///         initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_output_bytes(
        operation: *mut psa_key_derivation_operation_t,
        output: *mut u8,
        output_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Derive a key from an ongoing key derivation operation.
    ///
    /// This function calculates output bytes from a key derivation algorithm
    /// and uses those bytes to generate a key deterministically.
    /// The key's location, usage policy, type and size are taken from
    /// \p attributes.
    ///
    /// If you view the key derivation's output as a stream of bytes, this
    /// function destructively reads as many bytes as required from the
    /// stream.
    /// The operation's capacity decreases by the number of bytes read.
    ///
    /// If this function returns an error status other than
    /// #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error
    /// state and must be aborted by calling psa_key_derivation_abort().
    ///
    /// How much output is produced and consumed from the operation, and how
    /// the key is derived, depends on the key type and on the key size
    /// (denoted \c bits below):
    ///
    /// - For key types for which the key is an arbitrary sequence of bytes
    ///   of a given size, this function is functionally equivalent to
    ///   calling #psa_key_derivation_output_bytes
    ///   and passing the resulting output to #psa_import_key.
    ///   However, this function has a security benefit:
    ///   if the implementation provides an isolation boundary then
    ///   the key material is not exposed outside the isolation boundary.
    ///   As a consequence, for these key types, this function always consumes
    ///   exactly (\c bits / 8) bytes from the operation.
    ///   The following key types defined in this specification follow this scheme:
    ///
    ///     - #PSA_KEY_TYPE_AES;
    ///     - #PSA_KEY_TYPE_ARIA;
    ///     - #PSA_KEY_TYPE_CAMELLIA;
    ///     - #PSA_KEY_TYPE_DERIVE;
    ///     - #PSA_KEY_TYPE_HMAC;
    ///     - #PSA_KEY_TYPE_PASSWORD_HASH.
    ///
    /// - For ECC keys on a Montgomery elliptic curve
    ///   (#PSA_KEY_TYPE_ECC_KEY_PAIR(\c curve) where \c curve designates a
    ///   Montgomery curve), this function always draws a byte string whose
    ///   length is determined by the curve, and sets the mandatory bits
    ///   accordingly. That is:
    ///
    ///     - Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte
    ///       string and process it as specified in RFC 7748 &sect;5.
    ///     - Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte
    ///       string and process it as specified in RFC 7748 &sect;5.
    ///
    /// - For key types for which the key is represented by a single sequence of
    ///   \c bits bits with constraints as to which bit sequences are acceptable,
    ///   this function draws a byte string of length (\c bits / 8) bytes rounded
    ///   up to the nearest whole number of bytes. If the resulting byte string
    ///   is acceptable, it becomes the key, otherwise the drawn bytes are discarded.
    ///   This process is repeated until an acceptable byte string is drawn.
    ///   The byte string drawn from the operation is interpreted as specified
    ///   for the output produced by psa_export_key().
    ///   The following key types defined in this specification follow this scheme:
    ///
    ///     - #PSA_KEY_TYPE_DES.
    ///       Force-set the parity bits, but discard forbidden weak keys.
    ///       For 2-key and 3-key triple-DES, the three keys are generated
    ///       successively (for example, for 3-key triple-DES,
    ///       if the first 8 bytes specify a weak key and the next 8 bytes do not,
    ///       discard the first 8 bytes, use the next 8 bytes as the first key,
    ///       and continue reading output from the operation to derive the other
    ///       two keys).
    ///     - Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\c group)
    ///       where \c group designates any Diffie-Hellman group) and
    ///       ECC keys on a Weierstrass elliptic curve
    ///       (#PSA_KEY_TYPE_ECC_KEY_PAIR(\c curve) where \c curve designates a
    ///       Weierstrass curve).
    ///       For these key types, interpret the byte string as integer
    ///       in big-endian order. Discard it if it is not in the range
    ///       [0, *N* - 2] where *N* is the boundary of the private key domain
    ///       (the prime *p* for Diffie-Hellman, the subprime *q* for DSA,
    ///       or the order of the curve's base point for ECC).
    ///       Add 1 to the resulting integer and use this as the private key *x*.
    ///       This method allows compliance to NIST standards, specifically
    ///       the methods titled "key-pair generation by testing candidates"
    ///       in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman,
    ///       in FIPS 186-4 &sect;B.1.2 for DSA, and
    ///       in NIST SP 800-56A &sect;5.6.1.2.2 or
    ///       FIPS 186-4 &sect;B.4.2 for elliptic curve keys.
    ///
    /// - For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,
    ///   the way in which the operation output is consumed is
    ///   implementation-defined.
    ///
    /// In all cases, the data that is read is discarded from the operation.
    /// The operation's capacity is decreased by the number of bytes read.
    ///
    /// For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,
    /// the input to that step must be provided with psa_key_derivation_input_key().
    /// Future versions of this specification may include additional restrictions
    /// on the derived key based on the attributes and strength of the secret key.
    ///
    /// \param[in] attributes    The attributes for the new key.
    ///                          If the key type to be created is
    ///                          #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in
    ///                          the policy must be the same as in the current
    ///                          operation.
    /// \param[in,out] operation The key derivation operation object to read from.
    /// \param[out] key          On success, an identifier for the newly created
    ///                          key. For persistent keys, this is the key
    ///                          identifier defined in \p attributes.
    ///                          \c 0 on failure.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    ///         If the key is persistent, the key material and the key's metadata
    ///         have been saved to persistent storage.
    /// \retval #PSA_ERROR_ALREADY_EXISTS
    ///         This is an attempt to create a persistent key, and there is
    ///         already a persistent key with the given identifier.
    /// \retval #PSA_ERROR_INSUFFICIENT_DATA
    ///         There was not enough data to create the desired key.
    ///         Note that in this case, no output is written to the output buffer.
    ///         The operation's capacity is set to 0, thus subsequent calls to
    ///         this function will not succeed, even with a smaller output buffer.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         The key type or key size is not supported, either by the
    ///         implementation in general or in this particular location.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The provided key attributes are not valid for the operation.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The #PSA_KEY_DERIVATION_INPUT_SECRET or
    ///         #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a
    ///         key; or one of the inputs was a key whose policy didn't allow
    ///         #PSA_KEY_USAGE_DERIVE.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active and completed
    ///         all required input steps), or the library has not been previously
    ///         initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_output_key(
        attributes: *const psa_key_attributes_t,
        operation: *mut psa_key_derivation_operation_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Compare output data from a key derivation operation to an expected value.
    ///
    /// This function calculates output bytes from a key derivation algorithm and
    /// compares those bytes to an expected value in constant time.
    /// If you view the key derivation's output as a stream of bytes, this
    /// function destructively reads the expected number of bytes from the
    /// stream before comparing them.
    /// The operation's capacity decreases by the number of bytes read.
    ///
    /// This is functionally equivalent to the following code:
    /// \code
    /// psa_key_derivation_output_bytes(operation, tmp, output_length);
    /// if (memcmp(output, tmp, output_length) != 0)
    ///     return PSA_ERROR_INVALID_SIGNATURE;
    /// \endcode
    /// except (1) it works even if the key's policy does not allow outputting the
    /// bytes, and (2) the comparison will be done in constant time.
    ///
    /// If this function returns an error status other than
    /// #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,
    /// the operation enters an error state and must be aborted by calling
    /// psa_key_derivation_abort().
    ///
    /// \param[in,out] operation The key derivation operation object to read from.
    /// \param[in] expected_output Buffer containing the expected derivation output.
    /// \param output_length     Length of the expected output; this is also the
    ///                          number of bytes that will be read.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The output was read successfully, but it differs from the expected
    ///         output.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         One of the inputs was a key whose policy didn't allow
    ///         #PSA_KEY_USAGE_VERIFY_DERIVATION.
    /// \retval #PSA_ERROR_INSUFFICIENT_DATA
    ///                          The operation's capacity was less than
    ///                          \p output_length bytes. Note that in this case,
    ///                          the operation's capacity is set to 0, thus
    ///                          subsequent calls to this function will not
    ///                          succeed, even with a smaller expected output.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active and completed
    ///         all required input steps), or the library has not been previously
    ///         initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_verify_bytes(
        operation: *mut psa_key_derivation_operation_t,
        expected_output: *const u8,
        output_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Compare output data from a key derivation operation to an expected value
    /// stored in a key object.
    ///
    /// This function calculates output bytes from a key derivation algorithm and
    /// compares those bytes to an expected value, provided as key of type
    /// #PSA_KEY_TYPE_PASSWORD_HASH.
    /// If you view the key derivation's output as a stream of bytes, this
    /// function destructively reads the number of bytes corresponding to the
    /// length of the expected value from the stream before comparing them.
    /// The operation's capacity decreases by the number of bytes read.
    ///
    /// This is functionally equivalent to exporting the key and calling
    /// psa_key_derivation_verify_bytes() on the result, except that it
    /// works even if the key cannot be exported.
    ///
    /// If this function returns an error status other than
    /// #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,
    /// the operation enters an error state and must be aborted by calling
    /// psa_key_derivation_abort().
    ///
    /// \param[in,out] operation The key derivation operation object to read from.
    /// \param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH
    ///                          containing the expected output. Its policy must
    ///                          include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag
    ///                          and the permitted algorithm must match the
    ///                          operation. The value of this key was likely
    ///                          computed by a previous call to
    ///                          psa_key_derivation_output_key().
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The output was read successfully, but if differs from the expected
    ///         output.
    /// \retval #PSA_ERROR_INVALID_HANDLE
    ///         The key passed as the expected value does not exist.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The key passed as the expected value has an invalid type.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key passed as the expected value does not allow this usage or
    ///         this algorithm; or one of the inputs was a key whose policy didn't
    ///         allow #PSA_KEY_USAGE_VERIFY_DERIVATION.
    /// \retval #PSA_ERROR_INSUFFICIENT_DATA
    ///                          The operation's capacity was less than
    ///                          the length of the expected value. In this case,
    ///                          the operation's capacity is set to 0, thus
    ///                          subsequent calls to this function will not
    ///                          succeed, even with a smaller expected output.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active and completed
    ///         all required input steps), or the library has not been previously
    ///         initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_verify_key(
        operation: *mut psa_key_derivation_operation_t,
        expected: psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Abort a key derivation operation.
    ///
    /// Aborting an operation frees all associated resources except for the \c
    /// operation structure itself. Once aborted, the operation object can be reused
    /// for another operation by calling psa_key_derivation_setup() again.
    ///
    /// This function may be called at any time after the operation
    /// object has been initialized as described in #psa_key_derivation_operation_t.
    ///
    /// In particular, it is valid to call psa_key_derivation_abort() twice, or to
    /// call psa_key_derivation_abort() on an operation that has not been set up.
    ///
    /// \param[in,out] operation    The operation to abort.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_key_derivation_abort(operation: *mut psa_key_derivation_operation_t)
        -> psa_status_t;
}
extern "C" {
    /// Perform a key agreement and return the raw shared secret.
    ///
    /// \warning The raw result of a key agreement algorithm such as finite-field
    /// Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should
    /// not be used directly as key material. It should instead be passed as
    /// input to a key derivation algorithm. To chain a key agreement with
    /// a key derivation, use psa_key_derivation_key_agreement() and other
    /// functions from the key derivation interface.
    ///
    /// \param alg                     The key agreement algorithm to compute
    ///                                (\c PSA_ALG_XXX value such that
    ///                                #PSA_ALG_IS_RAW_KEY_AGREEMENT(\p alg)
    ///                                is true).
    /// \param private_key             Identifier of the private key to use. It must
    ///                                allow the usage #PSA_KEY_USAGE_DERIVE.
    /// \param[in] peer_key            Public key of the peer. It must be
    ///                                in the same format that psa_import_key()
    ///                                accepts. The standard formats for public
    ///                                keys are documented in the documentation
    ///                                of psa_export_public_key().
    /// \param peer_key_length         Size of \p peer_key in bytes.
    /// \param[out] output             Buffer where the decrypted message is to
    ///                                be written.
    /// \param output_size             Size of the \c output buffer in bytes.
    /// \param[out] output_length      On success, the number of bytes
    ///                                that make up the returned output.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p alg is not a key agreement algorithm, or
    ///         \p private_key is not compatible with \p alg,
    ///         or \p peer_key is not valid for \p alg or not compatible with
    ///         \p private_key.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         \p output_size is too small
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p alg is not a supported key agreement algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_raw_key_agreement(
        alg: psa_algorithm_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief Generate random bytes.
    ///
    /// \warning This function **can** fail! Callers MUST check the return status
    ///          and MUST NOT use the content of the output buffer if the return
    ///          status is not #PSA_SUCCESS.
    ///
    /// \note    To generate a key, use psa_generate_key() instead.
    ///
    /// \param[out] output       Output buffer for the generated data.
    /// \param output_size       Number of bytes to generate and output.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_generate_random(output: *mut u8, output_size: usize) -> psa_status_t;
}
extern "C" {
    /// \brief Generate a key or key pair.
    ///
    /// The key is generated randomly.
    /// Its location, usage policy, type and size are taken from \p attributes.
    ///
    /// Implementations must reject an attempt to generate a key of size 0.
    ///
    /// The following type-specific considerations apply:
    /// - For RSA keys (#PSA_KEY_TYPE_RSA_KEY_PAIR),
    ///   the public exponent is 65537.
    ///   The modulus is a product of two probabilistic primes
    ///   between 2^{n-1} and 2^n where n is the bit size specified in the
    ///   attributes.
    ///
    /// \param[in] attributes    The attributes for the new key.
    /// \param[out] key          On success, an identifier for the newly created
    ///                          key. For persistent keys, this is the key
    ///                          identifier defined in \p attributes.
    ///                          \c 0 on failure.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    ///         If the key is persistent, the key material and the key's metadata
    ///         have been saved to persistent storage.
    /// \retval #PSA_ERROR_ALREADY_EXISTS
    ///         This is an attempt to create a persistent key, and there is
    ///         already a persistent key with the given identifier.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_generate_key(
        attributes: *const psa_key_attributes_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
/// The type of the state data structure for interruptible hash
///  signing operations.
///
/// Before calling any function on a sign hash operation object, the
/// application must initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_sign_hash_interruptible_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_sign_hash_interruptible_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer
///   #PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:
///   \code
///   psa_sign_hash_interruptible_operation_t operation =
///   PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function
///   psa_sign_hash_interruptible_operation_init() to the structure, for
///   example:
///   \code
///   psa_sign_hash_interruptible_operation_t operation;
///   operation = psa_sign_hash_interruptible_operation_init();
///   \endcode
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_sign_hash_interruptible_operation_t = psa_sign_hash_interruptible_operation_s;
/// The type of the state data structure for interruptible hash
///  verification operations.
///
/// Before calling any function on a sign hash operation object, the
/// application must initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_verify_hash_interruptible_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_verify_hash_interruptible_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer
///   #PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:
///   \code
///   psa_verify_hash_interruptible_operation_t operation =
///   PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function
///   psa_verify_hash_interruptible_operation_init() to the structure, for
///   example:
///   \code
///   psa_verify_hash_interruptible_operation_t operation;
///   operation = psa_verify_hash_interruptible_operation_init();
///   \endcode
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_verify_hash_interruptible_operation_t = psa_verify_hash_interruptible_operation_s;
extern "C" {
    /// \brief                       Set the maximum number of ops allowed to be
    ///                              executed by an interruptible function in a
    ///                              single call.
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    /// \note                        The time taken to execute a single op is
    ///                              implementation specific and depends on
    ///                              software, hardware, the algorithm, key type and
    ///                              curve chosen. Even within a single operation,
    ///                              successive ops can take differing amounts of
    ///                              time. The only guarantee is that lower values
    ///                              for \p max_ops means functions will block for a
    ///                              lesser maximum amount of time. The functions
    ///                              \c psa_sign_interruptible_get_num_ops() and
    ///                              \c psa_verify_interruptible_get_num_ops() are
    ///                              provided to help with tuning this value.
    ///
    /// \note                        This value defaults to
    ///                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, which
    ///                              means the whole operation will be done in one
    ///                              go, regardless of the number of ops required.
    ///
    /// \note                        If more ops are needed to complete a
    ///                              computation, #PSA_OPERATION_INCOMPLETE will be
    ///                              returned by the function performing the
    ///                              computation. It is then the caller's
    ///                              responsibility to either call again with the
    ///                              same operation context until it returns 0 or an
    ///                              error code; or to call the relevant abort
    ///                              function if the answer is no longer required.
    ///
    /// \note                        The interpretation of \p max_ops is also
    ///                              implementation defined. On a hard real time
    ///                              system, this can indicate a hard deadline, as a
    ///                              real-time system needs a guarantee of not
    ///                              spending more than X time, however care must be
    ///                              taken in such an implementation to avoid the
    ///                              situation whereby calls just return, not being
    ///                              able to do any actual work within the allotted
    ///                              time.  On a non-real-time system, the
    ///                              implementation can be more relaxed, but again
    ///                              whether this number should be interpreted as as
    ///                              hard or soft limit or even whether a less than
    ///                              or equals as regards to ops executed in a
    ///                              single call is implementation defined.
    ///
    /// \note                        For keys in local storage when no accelerator
    ///                              driver applies, please see also the
    ///                              documentation for \c mbedtls_ecp_set_max_ops(),
    ///                              which is the internal implementation in these
    ///                              cases.
    ///
    /// \warning                     With implementations that interpret this number
    ///                              as a hard limit, setting this number too small
    ///                              may result in an infinite loop, whereby each
    ///                              call results in immediate return with no ops
    ///                              done (as there is not enough time to execute
    ///                              any), and thus no result will ever be achieved.
    ///
    /// \note                        This only applies to functions whose
    ///                              documentation mentions they may return
    ///                              #PSA_OPERATION_INCOMPLETE.
    ///
    /// \param max_ops               The maximum number of ops to be executed in a
    ///                              single call. This can be a number from 0 to
    ///                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, where 0
    ///                              is the least amount of work done per call.
    pub fn psa_interruptible_set_max_ops(max_ops: u32);
}
extern "C" {
    /// \brief                       Get the maximum number of ops allowed to be
    ///                              executed by an interruptible function in a
    ///                              single call. This will return the last
    ///                              value set by
    ///                              \c psa_interruptible_set_max_ops() or
    ///                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED if
    ///                              that function has never been called.
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    /// \return                      Maximum number of ops allowed to be
    ///                              executed by an interruptible function in a
    ///                              single call.
    pub fn psa_interruptible_get_max_ops() -> u32;
}
extern "C" {
    /// \brief                       Get the number of ops that a hash signing
    ///                              operation has taken so far. If the operation
    ///                              has completed, then this will represent the
    ///                              number of ops required for the entire
    ///                              operation. After initialization or calling
    ///                              \c psa_sign_hash_interruptible_abort() on
    ///                              the operation, a value of 0 will be returned.
    ///
    /// \note                        This interface is guaranteed re-entrant and
    ///                              thus may be called from driver code.
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    ///                              This is a helper provided to help you tune the
    ///                              value passed to \c
    ///                              psa_interruptible_set_max_ops().
    ///
    /// \param operation             The \c psa_sign_hash_interruptible_operation_t
    ///                              to use. This must be initialized first.
    ///
    /// \return                      Number of ops that the operation has taken so
    ///                              far.
    pub fn psa_sign_hash_get_num_ops(
        operation: *const psa_sign_hash_interruptible_operation_t,
    ) -> u32;
}
extern "C" {
    /// \brief                       Get the number of ops that a hash verification
    ///                              operation has taken so far. If the operation
    ///                              has completed, then this will represent the
    ///                              number of ops required for the entire
    ///                              operation. After initialization or calling \c
    ///                              psa_verify_hash_interruptible_abort() on the
    ///                              operation, a value of 0 will be returned.
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    ///                              This is a helper provided to help you tune the
    ///                              value passed to \c
    ///                              psa_interruptible_set_max_ops().
    ///
    /// \param operation             The \c
    ///                              psa_verify_hash_interruptible_operation_t to
    ///                              use. This must be initialized first.
    ///
    /// \return                      Number of ops that the operation has taken so
    ///                              far.
    pub fn psa_verify_hash_get_num_ops(
        operation: *const psa_verify_hash_interruptible_operation_t,
    ) -> u32;
}
extern "C" {
    /// \brief                       Start signing a hash or short message with a
    ///                              private key, in an interruptible manner.
    ///
    /// \see                         \c psa_sign_hash_complete()
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    /// \note                        This function combined with \c
    ///                              psa_sign_hash_complete() is equivalent to
    ///                              \c psa_sign_hash() but
    ///                              \c psa_sign_hash_complete() can return early and
    ///                              resume according to the limit set with \c
    ///                              psa_interruptible_set_max_ops() to reduce the
    ///                              maximum time spent in a function call.
    ///
    /// \note                        Users should call \c psa_sign_hash_complete()
    ///                              repeatedly on the same context after a
    ///                              successful call to this function until \c
    ///                              psa_sign_hash_complete() either returns 0 or an
    ///                              error. \c psa_sign_hash_complete() will return
    ///                              #PSA_OPERATION_INCOMPLETE if there is more work
    ///                              to do. Alternatively users can call
    ///                              \c psa_sign_hash_abort() at any point if they no
    ///                              longer want the result.
    ///
    /// \note                        If this function returns an error status, the
    ///                              operation enters an error state and must be
    ///                              aborted by calling \c psa_sign_hash_abort().
    ///
    /// \param[in, out] operation    The \c psa_sign_hash_interruptible_operation_t
    ///                              to use. This must be initialized first.
    ///
    /// \param key                   Identifier of the key to use for the operation.
    ///                              It must be an asymmetric key pair. The key must
    ///                              allow the usage #PSA_KEY_USAGE_SIGN_HASH.
    /// \param alg                   A signature algorithm (\c PSA_ALG_XXX
    ///                              value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
    ///                              is true), that is compatible with
    ///                              the type of \p key.
    /// \param[in] hash              The hash or message to sign.
    /// \param hash_length           Size of the \p hash buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         The operation started successfully - call \c psa_sign_hash_complete()
    ///         with the same context to complete the operation
    ///
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key does not have the #PSA_KEY_USAGE_SIGN_HASH flag, or it does
    ///         not permit the requested algorithm.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         An operation has previously been started on this context, and is
    ///         still in progress.
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_sign_hash_start(
        operation: *mut psa_sign_hash_interruptible_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief                       Continue and eventually complete the action of
    ///                              signing a hash or short message with a private
    ///                              key, in an interruptible manner.
    ///
    /// \see                         \c psa_sign_hash_start()
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    /// \note                        This function combined with \c
    ///                              psa_sign_hash_start() is equivalent to
    ///                              \c psa_sign_hash() but this function can return
    ///                              early and resume according to the limit set with
    ///                              \c psa_interruptible_set_max_ops() to reduce the
    ///                              maximum time spent in a function call.
    ///
    /// \note                        Users should call this function on the same
    ///                              operation object repeatedly until it either
    ///                              returns 0 or an error. This function will return
    ///                              #PSA_OPERATION_INCOMPLETE if there is more work
    ///                              to do. Alternatively users can call
    ///                              \c psa_sign_hash_abort() at any point if they no
    ///                              longer want the result.
    ///
    /// \note                        When this function returns successfully, the
    ///                              operation becomes inactive. If this function
    ///                              returns an error status, the operation enters an
    ///                              error state and must be aborted by calling
    ///                              \c psa_sign_hash_abort().
    ///
    /// \param[in, out] operation    The \c psa_sign_hash_interruptible_operation_t
    ///                              to use. This must be initialized first, and have
    ///                              had \c psa_sign_hash_start() called with it
    ///                              first.
    ///
    /// \param[out] signature        Buffer where the signature is to be written.
    /// \param signature_size        Size of the \p signature buffer in bytes. This
    ///                              must be appropriate for the selected
    ///                              algorithm and key:
    ///                              - The required signature size is
    ///                                #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c
    ///                                key_bits, \c alg) where \c key_type and \c
    ///                                key_bits are the type and bit-size
    ///                                respectively of key.
    ///                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the
    ///                                maximum signature size of any supported
    ///                                signature algorithm.
    /// \param[out] signature_length On success, the number of bytes that make up
    ///                              the returned signature value.
    ///
    /// \retval #PSA_SUCCESS
    ///         Operation completed successfully
    ///
    /// \retval #PSA_OPERATION_INCOMPLETE
    ///         Operation was interrupted due to the setting of \c
    ///         psa_interruptible_set_max_ops(). There is still work to be done.
    ///         Call this function again with the same operation object.
    ///
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p signature buffer is too small. You can
    ///         determine a sufficient buffer size by calling
    ///         #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
    ///         where \c key_type and \c key_bits are the type and bit-size
    ///         respectively of \p key.
    ///
    /// \retval #PSA_ERROR_BAD_STATE
    ///         An operation was not previously started on this context via
    ///         \c psa_sign_hash_start().
    ///
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has either not been previously initialized by
    ///         psa_crypto_init() or you did not previously call
    ///         psa_sign_hash_start() with this operation object. It is
    ///         implementation-dependent whether a failure to initialize results in
    ///         this error code.
    pub fn psa_sign_hash_complete(
        operation: *mut psa_sign_hash_interruptible_operation_t,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief                       Abort a sign hash operation.
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    /// \note                        This function is the only function that clears
    ///                              the number of ops completed as part of the
    ///                              operation. Please ensure you copy this value via
    ///                              \c psa_sign_hash_get_num_ops() if required
    ///                              before calling.
    ///
    /// \note                        Aborting an operation frees all associated
    ///                              resources except for the \p operation structure
    ///                              itself. Once aborted, the operation object can
    ///                              be reused for another operation by calling \c
    ///                              psa_sign_hash_start() again.
    ///
    /// \note                        You may call this function any time after the
    ///                              operation object has been initialized. In
    ///                              particular, calling \c psa_sign_hash_abort()
    ///                              after the operation has already been terminated
    ///                              by a call to \c psa_sign_hash_abort() or
    ///                              psa_sign_hash_complete() is safe.
    ///
    /// \param[in,out] operation     Initialized sign hash operation.
    ///
    /// \retval #PSA_SUCCESS
    ///         The operation was aborted successfully.
    ///
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_sign_hash_abort(
        operation: *mut psa_sign_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief                       Start reading and verifying a hash or short
    ///                              message, in an interruptible manner.
    ///
    /// \see                         \c psa_verify_hash_complete()
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    /// \note                        This function combined with \c
    ///                              psa_verify_hash_complete() is equivalent to
    ///                              \c psa_verify_hash() but \c
    ///                              psa_verify_hash_complete() can return early and
    ///                              resume according to the limit set with \c
    ///                              psa_interruptible_set_max_ops() to reduce the
    ///                              maximum time spent in a function.
    ///
    /// \note                        Users should call \c psa_verify_hash_complete()
    ///                              repeatedly on the same operation object after a
    ///                              successful call to this function until \c
    ///                              psa_verify_hash_complete() either returns 0 or
    ///                              an error. \c psa_verify_hash_complete() will
    ///                              return #PSA_OPERATION_INCOMPLETE if there is
    ///                              more work to do. Alternatively users can call
    ///                              \c psa_verify_hash_abort() at any point if they
    ///                              no longer want the result.
    ///
    /// \note                        If this function returns an error status, the
    ///                              operation enters an error state and must be
    ///                              aborted by calling \c psa_verify_hash_abort().
    ///
    /// \param[in, out] operation    The \c psa_verify_hash_interruptible_operation_t
    ///                              to use. This must be initialized first.
    ///
    /// \param key                   Identifier of the key to use for the operation.
    ///                              The key must allow the usage
    ///                              #PSA_KEY_USAGE_VERIFY_HASH.
    /// \param alg                   A signature algorithm (\c PSA_ALG_XXX
    ///                              value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
    ///                              is true), that is compatible with
    ///                              the type of \p key.
    /// \param[in] hash              The hash whose signature is to be verified.
    /// \param hash_length           Size of the \p hash buffer in bytes.
    /// \param[in] signature         Buffer containing the signature to verify.
    /// \param signature_length      Size of the \p signature buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         The operation started successfully - please call \c
    ///         psa_verify_hash_complete() with the same context to complete the
    ///         operation.
    ///
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Another operation has already been started on this context, and is
    ///         still in progress.
    ///
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key does not have the #PSA_KEY_USAGE_VERIFY_HASH flag, or it does
    ///         not permit the requested algorithm.
    ///
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_verify_hash_start(
        operation: *mut psa_verify_hash_interruptible_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief                       Continue and eventually complete the action of
    ///                              reading and verifying a hash or short message
    ///                              signed with a private key, in an interruptible
    ///                              manner.
    ///
    /// \see                         \c psa_verify_hash_start()
    ///
    /// \warning                     This is a beta API, and thus subject to change
    ///                              at any point. It is not bound by the usual
    ///                              interface stability promises.
    ///
    /// \note                        This function combined with \c
    ///                              psa_verify_hash_start() is equivalent to
    ///                              \c psa_verify_hash() but this function can
    ///                              return early and resume according to the limit
    ///                              set with \c psa_interruptible_set_max_ops() to
    ///                              reduce the maximum time spent in a function
    ///                              call.
    ///
    /// \note                        Users should call this function on the same
    ///                              operation object repeatedly until it either
    ///                              returns 0 or an error. This function will return
    ///                              #PSA_OPERATION_INCOMPLETE if there is more work
    ///                              to do. Alternatively users can call
    ///                              \c psa_verify_hash_abort() at any point if they
    ///                              no longer want the result.
    ///
    /// \note                        When this function returns successfully, the
    ///                              operation becomes inactive. If this function
    ///                              returns an error status, the operation enters an
    ///                              error state and must be aborted by calling
    ///                              \c psa_verify_hash_abort().
    ///
    /// \param[in, out] operation    The \c psa_verify_hash_interruptible_operation_t
    ///                              to use. This must be initialized first, and have
    ///                              had \c psa_verify_hash_start() called with it
    ///                              first.
    ///
    /// \retval #PSA_SUCCESS
    ///         Operation completed successfully, and the passed signature is valid.
    ///
    /// \retval #PSA_OPERATION_INCOMPLETE
    ///         Operation was interrupted due to the setting of \c
    ///         psa_interruptible_set_max_ops(). There is still work to be done.
    ///         Call this function again with the same operation object.
    ///
    /// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The calculation was performed successfully, but the passed
    ///         signature is not a valid signature.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         An operation was not previously started on this context via
    ///         \c psa_verify_hash_start().
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has either not been previously initialized by
    ///         psa_crypto_init() or you did not previously call
    ///         psa_verify_hash_start() on this object. It is
    ///         implementation-dependent whether a failure to initialize results in
    ///         this error code.
    pub fn psa_verify_hash_complete(
        operation: *mut psa_verify_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    /// \brief                     Abort a verify hash operation.
    ///
    /// \warning                   This is a beta API, and thus subject to change at
    ///                            any point. It is not bound by the usual interface
    ///                            stability promises.
    ///
    /// \note                      This function is the only function that clears the
    ///                            number of ops completed as part of the operation.
    ///                            Please ensure you copy this value via
    ///                            \c psa_verify_hash_get_num_ops() if required
    ///                            before calling.
    ///
    /// \note                      Aborting an operation frees all associated
    ///                            resources except for the operation structure
    ///                            itself. Once aborted, the operation object can be
    ///                            reused for another operation by calling \c
    ///                            psa_verify_hash_start() again.
    ///
    /// \note                      You may call this function any time after the
    ///                            operation object has been initialized.
    ///                            In particular, calling \c psa_verify_hash_abort()
    ///                            after the operation has already been terminated by
    ///                            a call to \c psa_verify_hash_abort() or
    ///                            psa_verify_hash_complete() is safe.
    ///
    /// \param[in,out] operation   Initialized verify hash operation.
    ///
    /// \retval #PSA_SUCCESS
    ///         The operation was aborted successfully.
    ///
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_verify_hash_abort(
        operation: *mut psa_verify_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
/// The CMAC context structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cmac_context_t {
    /// The internal state of the CMAC algorithm.
    pub private_state: [crate::c_types::c_uchar; 16usize],
    /// Unprocessed data - either data that was not block aligned and is still
    ///  pending processing, or the final block.
    pub private_unprocessed_block: [crate::c_types::c_uchar; 16usize],
    /// The length of data pending processing.
    pub private_unprocessed_len: usize,
}
extern "C" {
    /// \brief               This function starts a new CMAC computation
    ///                      by setting the CMAC key, and preparing to authenticate
    ///                      the input data.
    ///                      It must be called with an initialized cipher context.
    ///
    ///                      Once this function has completed, data can be supplied
    ///                      to the CMAC computation by calling
    ///                      mbedtls_cipher_cmac_update().
    ///
    ///                      To start a CMAC computation using the same key as a previous
    ///                      CMAC computation, use mbedtls_cipher_cmac_finish().
    ///
    /// \note                When the CMAC implementation is supplied by an alternate
    ///                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers
    ///                      may not be supported by that implementation, and thus
    ///                      return an error. Alternate implementations must support
    ///                      AES-128 and AES-256, and may support AES-192 and 3DES.
    ///
    /// \param ctx           The cipher context used for the CMAC operation, initialized
    ///                      as one of the following types: MBEDTLS_CIPHER_AES_128_ECB,
    ///                      MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_CIPHER_AES_256_ECB,
    ///                      or MBEDTLS_CIPHER_DES_EDE3_ECB.
    /// \param key           The CMAC key.
    /// \param keybits       The length of the CMAC key in bits.
    ///                      Must be supported by the cipher.
    ///
    /// \return              \c 0 on success.
    /// \return              A cipher-specific error code on failure.
    pub fn mbedtls_cipher_cmac_starts(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const crate::c_types::c_uchar,
        keybits: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function feeds an input buffer into an ongoing CMAC
    ///                      computation.
    ///
    ///                      The CMAC computation must have previously been started
    ///                      by calling mbedtls_cipher_cmac_starts() or
    ///                      mbedtls_cipher_cmac_reset().
    ///
    ///                      Call this function as many times as needed to input the
    ///                      data to be authenticated.
    ///                      Once all of the required data has been input,
    ///                      call mbedtls_cipher_cmac_finish() to obtain the result
    ///                      of the CMAC operation.
    ///
    /// \param ctx           The cipher context used for the CMAC operation.
    /// \param input         The buffer holding the input data.
    /// \param ilen          The length of the input data.
    ///
    /// \return             \c 0 on success.
    /// \return             #MBEDTLS_ERR_MD_BAD_INPUT_DATA
    ///                     if parameter verification fails.
    pub fn mbedtls_cipher_cmac_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function finishes an ongoing CMAC operation, and
    ///                      writes the result to the output buffer.
    ///
    ///                      It should be followed either by
    ///                      mbedtls_cipher_cmac_reset(), which starts another CMAC
    ///                      operation with the same key, or mbedtls_cipher_free(),
    ///                      which clears the cipher context.
    ///
    /// \param ctx           The cipher context used for the CMAC operation.
    /// \param output        The output buffer for the CMAC checksum result.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA
    ///                      if parameter verification fails.
    pub fn mbedtls_cipher_cmac_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function starts a new CMAC operation with the same
    ///                      key as the previous one.
    ///
    ///                      It should be called after finishing the previous CMAC
    ///                      operation with mbedtls_cipher_cmac_finish().
    ///                      After calling this function,
    ///                      call mbedtls_cipher_cmac_update() to supply the new
    ///                      CMAC operation with data.
    ///
    /// \param ctx           The cipher context used for the CMAC operation.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA
    ///                      if parameter verification fails.
    pub fn mbedtls_cipher_cmac_reset(ctx: *mut mbedtls_cipher_context_t) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function calculates the full generic CMAC
    ///                      on the input buffer with the provided key.
    ///
    ///                      The function allocates the context, performs the
    ///                      calculation, and frees the context.
    ///
    ///                      The CMAC result is calculated as
    ///                      output = generic CMAC(cmac key, input buffer).
    ///
    /// \note                When the CMAC implementation is supplied by an alternate
    ///                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers
    ///                      may not be supported by that implementation, and thus
    ///                      return an error. Alternate implementations must support
    ///                      AES-128 and AES-256, and may support AES-192 and 3DES.
    ///
    /// \param cipher_info   The cipher information.
    /// \param key           The CMAC key.
    /// \param keylen        The length of the CMAC key in bits.
    /// \param input         The buffer holding the input data.
    /// \param ilen          The length of the input data.
    /// \param output        The buffer for the generic CMAC result.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA
    ///                      if parameter verification fails.
    pub fn mbedtls_cipher_cmac(
        cipher_info: *const mbedtls_cipher_info_t,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function implements the AES-CMAC-PRF-128 pseudorandom
    ///                  function, as defined in
    ///                  <em>RFC-4615: The Advanced Encryption Standard-Cipher-based
    ///                  Message Authentication Code-Pseudo-Random Function-128
    ///                  (AES-CMAC-PRF-128) Algorithm for the Internet Key
    ///                  Exchange Protocol (IKE).</em>
    ///
    /// \param key       The key to use.
    /// \param key_len   The key length in Bytes.
    /// \param input     The buffer holding the input data.
    /// \param in_len    The length of the input data in Bytes.
    /// \param output    The buffer holding the generated 16 Bytes of
    ///                  pseudorandom output.
    ///
    /// \return          \c 0 on success.
    pub fn mbedtls_aes_cmac_prf_128(
        key: *const crate::c_types::c_uchar,
        key_len: usize,
        input: *const crate::c_types::c_uchar,
        in_len: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The CMAC checkup routine.
    ///
    /// \note           In case the CMAC routines are provided by an alternative
    ///                 implementation (i.e. #MBEDTLS_CMAC_ALT is defined), the
    ///                 checkup routine will succeed even if the implementation does
    ///                 not support the less widely used AES-192 or 3DES primitives.
    ///                 The self-test requires at least AES-128 and AES-256 to be
    ///                 supported by the underlying implementation.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_cmac_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
/// \brief          The GCM context structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_gcm_context {
    ///< The cipher context used.
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    ///< Precalculated HTable low.
    pub private_HL: [u64; 16usize],
    ///< Precalculated HTable high.
    pub private_HH: [u64; 16usize],
    ///< The total length of the encrypted data.
    pub private_len: u64,
    ///< The total length of the additional data.
    pub private_add_len: u64,
    ///< The first ECTR for tag.
    pub private_base_ectr: [crate::c_types::c_uchar; 16usize],
    ///< The Y working value.
    pub private_y: [crate::c_types::c_uchar; 16usize],
    ///< The buf working value.
    pub private_buf: [crate::c_types::c_uchar; 16usize],
    ///< The operation to perform:
    ///#MBEDTLS_GCM_ENCRYPT or
    ///#MBEDTLS_GCM_DECRYPT.
    pub private_mode: crate::c_types::c_int,
}
extern "C" {
    /// \brief           This function initializes the specified GCM context,
    ///                  to make references valid, and prepares the context
    ///                  for mbedtls_gcm_setkey() or mbedtls_gcm_free().
    ///
    ///                  The function does not bind the GCM context to a particular
    ///                  cipher, nor set the key. For this purpose, use
    ///                  mbedtls_gcm_setkey().
    ///
    /// \param ctx       The GCM context to initialize. This must not be \c NULL.
    pub fn mbedtls_gcm_init(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
    /// \brief           This function associates a GCM context with a
    ///                  cipher algorithm and a key.
    ///
    /// \param ctx       The GCM context. This must be initialized.
    /// \param cipher    The 128-bit block cipher to use.
    /// \param key       The encryption key. This must be a readable buffer of at
    ///                  least \p keybits bits.
    /// \param keybits   The key size in bits. Valid options are:
    ///                  <ul><li>128 bits</li>
    ///                  <li>192 bits</li>
    ///                  <li>256 bits</li></ul>
    ///
    /// \return          \c 0 on success.
    /// \return          A cipher-specific error code on failure.
    pub fn mbedtls_gcm_setkey(
        ctx: *mut mbedtls_gcm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs GCM encryption or decryption of a buffer.
    ///
    /// \note            For encryption, the output buffer can be the same as the
    ///                  input buffer. For decryption, the output buffer cannot be
    ///                  the same as input buffer. If the buffers overlap, the output
    ///                  buffer must trail at least 8 Bytes behind the input buffer.
    ///
    /// \warning         When this function performs a decryption, it outputs the
    ///                  authentication tag and does not verify that the data is
    ///                  authentic. You should use this function to perform encryption
    ///                  only. For decryption, use mbedtls_gcm_auth_decrypt() instead.
    ///
    /// \param ctx       The GCM context to use for encryption or decryption. This
    ///                  must be initialized.
    /// \param mode      The operation to perform:
    ///                  - #MBEDTLS_GCM_ENCRYPT to perform authenticated encryption.
    ///                    The ciphertext is written to \p output and the
    ///                    authentication tag is written to \p tag.
    ///                  - #MBEDTLS_GCM_DECRYPT to perform decryption.
    ///                    The plaintext is written to \p output and the
    ///                    authentication tag is written to \p tag.
    ///                    Note that this mode is not recommended, because it does
    ///                    not verify the authenticity of the data. For this reason,
    ///                    you should use mbedtls_gcm_auth_decrypt() instead of
    ///                    calling this function in decryption mode.
    /// \param length    The length of the input data, which is equal to the length
    ///                  of the output data.
    /// \param iv        The initialization vector. This must be a readable buffer of
    ///                  at least \p iv_len Bytes.
    /// \param iv_len    The length of the IV.
    /// \param add       The buffer holding the additional data. This must be of at
    ///                  least that size in Bytes.
    /// \param add_len   The length of the additional data.
    /// \param input     The buffer holding the input data. If \p length is greater
    ///                  than zero, this must be a readable buffer of at least that
    ///                  size in Bytes.
    /// \param output    The buffer for holding the output data. If \p length is greater
    ///                  than zero, this must be a writable buffer of at least that
    ///                  size in Bytes.
    /// \param tag_len   The length of the tag to generate.
    /// \param tag       The buffer for holding the tag. This must be a writable
    ///                  buffer of at least \p tag_len Bytes.
    ///
    /// \return          \c 0 if the encryption or decryption was performed
    ///                  successfully. Note that in #MBEDTLS_GCM_DECRYPT mode,
    ///                  this does not indicate that the data is authentic.
    /// \return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are
    ///                  not valid or a cipher-specific error code if the encryption
    ///                  or decryption failed.
    pub fn mbedtls_gcm_crypt_and_tag(
        ctx: *mut mbedtls_gcm_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        add: *const crate::c_types::c_uchar,
        add_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag_len: usize,
        tag: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs a GCM authenticated decryption of a
    ///                  buffer.
    ///
    /// \note            For decryption, the output buffer cannot be the same as
    ///                  input buffer. If the buffers overlap, the output buffer
    ///                  must trail at least 8 Bytes behind the input buffer.
    ///
    /// \param ctx       The GCM context. This must be initialized.
    /// \param length    The length of the ciphertext to decrypt, which is also
    ///                  the length of the decrypted plaintext.
    /// \param iv        The initialization vector. This must be a readable buffer
    ///                  of at least \p iv_len Bytes.
    /// \param iv_len    The length of the IV.
    /// \param add       The buffer holding the additional data. This must be of at
    ///                  least that size in Bytes.
    /// \param add_len   The length of the additional data.
    /// \param tag       The buffer holding the tag to verify. This must be a
    ///                  readable buffer of at least \p tag_len Bytes.
    /// \param tag_len   The length of the tag to verify.
    /// \param input     The buffer holding the ciphertext. If \p length is greater
    ///                  than zero, this must be a readable buffer of at least that
    ///                  size.
    /// \param output    The buffer for holding the decrypted plaintext. If \p length
    ///                  is greater than zero, this must be a writable buffer of at
    ///                  least that size.
    ///
    /// \return          \c 0 if successful and authenticated.
    /// \return          #MBEDTLS_ERR_GCM_AUTH_FAILED if the tag does not match.
    /// \return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are
    ///                  not valid or a cipher-specific error code if the decryption
    ///                  failed.
    pub fn mbedtls_gcm_auth_decrypt(
        ctx: *mut mbedtls_gcm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        add: *const crate::c_types::c_uchar,
        add_len: usize,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function starts a GCM encryption or decryption
    ///                  operation.
    ///
    /// \param ctx       The GCM context. This must be initialized.
    /// \param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or
    ///                  #MBEDTLS_GCM_DECRYPT.
    /// \param iv        The initialization vector. This must be a readable buffer of
    ///                  at least \p iv_len Bytes.
    /// \param iv_len    The length of the IV.
    ///
    /// \return          \c 0 on success.
    pub fn mbedtls_gcm_starts(
        ctx: *mut mbedtls_gcm_context,
        mode: crate::c_types::c_int,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function feeds an input buffer as associated data
    ///                  (authenticated but not encrypted data) in a GCM
    ///                  encryption or decryption operation.
    ///
    ///                  Call this function after mbedtls_gcm_starts() to pass
    ///                  the associated data. If the associated data is empty,
    ///                  you do not need to call this function. You may not
    ///                  call this function after calling mbedtls_cipher_update().
    ///
    /// \param ctx       The GCM context. This must have been started with
    ///                  mbedtls_gcm_starts() and must not have yet received
    ///                  any input with mbedtls_gcm_update().
    /// \param add       The buffer holding the additional data, or \c NULL
    ///                  if \p add_len is \c 0.
    /// \param add_len   The length of the additional data. If \c 0,
    ///                  \p add may be \c NULL.
    ///
    /// \return          \c 0 on success.
    pub fn mbedtls_gcm_update_ad(
        ctx: *mut mbedtls_gcm_context,
        add: *const crate::c_types::c_uchar,
        add_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function feeds an input buffer into an ongoing GCM
    ///                  encryption or decryption operation.
    ///
    ///                  You may call this function zero, one or more times
    ///                  to pass successive parts of the input: the plaintext to
    ///                  encrypt, or the ciphertext (not including the tag) to
    ///                  decrypt. After the last part of the input, call
    ///                  mbedtls_gcm_finish().
    ///
    ///                  This function may produce output in one of the following
    ///                  ways:
    ///                  - Immediate output: the output length is always equal
    ///                    to the input length.
    ///                  - Buffered output: the output consists of a whole number
    ///                    of 16-byte blocks. If the total input length so far
    ///                    (not including associated data) is 16 \* *B* + *A*
    ///                    with *A* < 16 then the total output length is 16 \* *B*.
    ///
    ///                  In particular:
    ///                  - It is always correct to call this function with
    ///                    \p output_size >= \p input_length + 15.
    ///                  - If \p input_length is a multiple of 16 for all the calls
    ///                    to this function during an operation, then it is
    ///                    correct to use \p output_size = \p input_length.
    ///
    /// \note            For decryption, the output buffer cannot be the same as
    ///                  input buffer. If the buffers overlap, the output buffer
    ///                  must trail at least 8 Bytes behind the input buffer.
    ///
    /// \param ctx           The GCM context. This must be initialized.
    /// \param input         The buffer holding the input data. If \p input_length
    ///                      is greater than zero, this must be a readable buffer
    ///                      of at least \p input_length bytes.
    /// \param input_length  The length of the input data in bytes.
    /// \param output        The buffer for the output data. If \p output_size
    ///                      is greater than zero, this must be a writable buffer of
    ///                      of at least \p output_size bytes.
    /// \param output_size   The size of the output buffer in bytes.
    ///                      See the function description regarding the output size.
    /// \param output_length On success, \p *output_length contains the actual
    ///                      length of the output written in \p output.
    ///                      On failure, the content of \p *output_length is
    ///                      unspecified.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_GCM_BAD_INPUT on failure:
    ///                 total input length too long,
    ///                 unsupported input/output buffer overlap detected,
    ///                 or \p output_size too small.
    pub fn mbedtls_gcm_update(
        ctx: *mut mbedtls_gcm_context,
        input: *const crate::c_types::c_uchar,
        input_length: usize,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        output_length: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function finishes the GCM operation and generates
    ///                  the authentication tag.
    ///
    ///                  It wraps up the GCM stream, and generates the
    ///                  tag. The tag can have a maximum length of 16 Bytes.
    ///
    /// \param ctx       The GCM context. This must be initialized.
    /// \param tag       The buffer for holding the tag. This must be a writable
    ///                  buffer of at least \p tag_len Bytes.
    /// \param tag_len   The length of the tag to generate. This must be at least
    ///                  four.
    /// \param output    The buffer for the final output.
    ///                  If \p output_size is nonzero, this must be a writable
    ///                  buffer of at least \p output_size bytes.
    /// \param output_size  The size of the \p output buffer in bytes.
    ///                  This must be large enough for the output that
    ///                  mbedtls_gcm_update() has not produced. In particular:
    ///                  - If mbedtls_gcm_update() produces immediate output,
    ///                    or if the total input size is a multiple of \c 16,
    ///                    then mbedtls_gcm_finish() never produces any output,
    ///                    so \p output_size can be \c 0.
    ///                  - \p output_size never needs to be more than \c 15.
    /// \param output_length On success, \p *output_length contains the actual
    ///                      length of the output written in \p output.
    ///                      On failure, the content of \p *output_length is
    ///                      unspecified.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_GCM_BAD_INPUT on failure:
    ///                  invalid value of \p tag_len,
    ///                  or \p output_size too small.
    pub fn mbedtls_gcm_finish(
        ctx: *mut mbedtls_gcm_context,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        output_length: *mut usize,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function clears a GCM context and the underlying
    ///                  cipher sub-context.
    ///
    /// \param ctx       The GCM context to clear. If this is \c NULL, the call has
    ///                  no effect. Otherwise, this must be initialized.
    pub fn mbedtls_gcm_free(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
    /// \brief          The GCM checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_gcm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
/// \brief    The CCM context-type definition. The CCM context is passed
///           to the APIs called.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ccm_context {
    ///< The Y working buffer
    pub private_y: [crate::c_types::c_uchar; 16usize],
    ///< The counter buffer
    pub private_ctr: [crate::c_types::c_uchar; 16usize],
    ///< The cipher context used.
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    ///< Total plaintext length
    pub private_plaintext_len: usize,
    ///< Total authentication data length
    pub private_add_len: usize,
    ///< Total tag length
    pub private_tag_len: usize,
    ///< Track how many bytes of input data
    ///were processed (chunked input).
    ///Used independently for both auth data
    ///and plaintext/ciphertext.
    ///This variable is set to zero after
    ///auth data input is finished.
    pub private_processed: usize,
    ///< The Q working value
    pub private_q: crate::c_types::c_uchar,
    ///< The operation to perform:
    ///#MBEDTLS_CCM_ENCRYPT or
    ///#MBEDTLS_CCM_DECRYPT or
    ///#MBEDTLS_CCM_STAR_ENCRYPT or
    ///#MBEDTLS_CCM_STAR_DECRYPT.
    pub private_mode: crate::c_types::c_uchar,
    ///< Working value holding context's
    ///state. Used for chunked data
    ///input
    pub private_state: crate::c_types::c_int,
}
extern "C" {
    /// \brief           This function initializes the specified CCM context,
    ///                  to make references valid, and prepare the context
    ///                  for mbedtls_ccm_setkey() or mbedtls_ccm_free().
    ///
    /// \param ctx       The CCM context to initialize. This must not be \c NULL.
    pub fn mbedtls_ccm_init(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    /// \brief           This function initializes the CCM context set in the
    ///                  \p ctx parameter and sets the encryption key.
    ///
    /// \param ctx       The CCM context to initialize. This must be an initialized
    ///                  context.
    /// \param cipher    The 128-bit block cipher to use.
    /// \param key       The encryption key. This must not be \c NULL.
    /// \param keybits   The key size in bits. This must be acceptable by the cipher.
    ///
    /// \return          \c 0 on success.
    /// \return          A CCM or cipher-specific error code on failure.
    pub fn mbedtls_ccm_setkey(
        ctx: *mut mbedtls_ccm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief   This function releases and clears the specified CCM context
    ///          and underlying cipher sub-context.
    ///
    /// \param ctx       The CCM context to clear. If this is \c NULL, the function
    ///                  has no effect. Otherwise, this must be initialized.
    pub fn mbedtls_ccm_free(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    /// \brief           This function encrypts a buffer using CCM.
    ///
    /// \note            The tag is written to a separate buffer. To concatenate
    ///                  the \p tag with the \p output, as done in <em>RFC-3610:
    ///                  Counter with CBC-MAC (CCM)</em>, use
    ///                  \p tag = \p output + \p length, and make sure that the
    ///                  output buffer is at least \p length + \p tag_len wide.
    ///
    /// \param ctx       The CCM context to use for encryption. This must be
    ///                  initialized and bound to a key.
    /// \param length    The length of the input data in Bytes.
    /// \param iv        The initialization vector (nonce). This must be a readable
    ///                  buffer of at least \p iv_len Bytes.
    /// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
    ///                  or 13. The length L of the message length field is
    ///                  15 - \p iv_len.
    /// \param ad        The additional data field. If \p ad_len is greater than
    ///                  zero, \p ad must be a readable buffer of at least that
    ///                  length.
    /// \param ad_len    The length of additional data in Bytes.
    ///                  This must be less than `2^16 - 2^8`.
    /// \param input     The buffer holding the input data. If \p length is greater
    ///                  than zero, \p input must be a readable buffer of at least
    ///                  that length.
    /// \param output    The buffer holding the output data. If \p length is greater
    ///                  than zero, \p output must be a writable buffer of at least
    ///                  that length.
    /// \param tag       The buffer holding the authentication field. This must be a
    ///                  writable buffer of at least \p tag_len Bytes.
    /// \param tag_len   The length of the authentication field to generate in Bytes:
    ///                  4, 6, 8, 10, 12, 14 or 16.
    ///
    /// \return          \c 0 on success.
    /// \return          A CCM or cipher-specific error code on failure.
    pub fn mbedtls_ccm_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function encrypts a buffer using CCM*.
    ///
    /// \note            The tag is written to a separate buffer. To concatenate
    ///                  the \p tag with the \p output, as done in <em>RFC-3610:
    ///                  Counter with CBC-MAC (CCM)</em>, use
    ///                  \p tag = \p output + \p length, and make sure that the
    ///                  output buffer is at least \p length + \p tag_len wide.
    ///
    /// \note            When using this function in a variable tag length context,
    ///                  the tag length has to be encoded into the \p iv passed to
    ///                  this function.
    ///
    /// \param ctx       The CCM context to use for encryption. This must be
    ///                  initialized and bound to a key.
    /// \param length    The length of the input data in Bytes.
    ///                  For tag length = 0, input length is ignored.
    /// \param iv        The initialization vector (nonce). This must be a readable
    ///                  buffer of at least \p iv_len Bytes.
    /// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
    ///                  or 13. The length L of the message length field is
    ///                  15 - \p iv_len.
    /// \param ad        The additional data field. This must be a readable buffer of
    ///                  at least \p ad_len Bytes.
    /// \param ad_len    The length of additional data in Bytes.
    ///                  This must be less than 2^16 - 2^8.
    /// \param input     The buffer holding the input data. If \p length is greater
    ///                  than zero, \p input must be a readable buffer of at least
    ///                  that length.
    /// \param output    The buffer holding the output data. If \p length is greater
    ///                  than zero, \p output must be a writable buffer of at least
    ///                  that length.
    /// \param tag       The buffer holding the authentication field. This must be a
    ///                  writable buffer of at least \p tag_len Bytes.
    /// \param tag_len   The length of the authentication field to generate in Bytes:
    ///                  0, 4, 6, 8, 10, 12, 14 or 16.
    ///
    /// \warning         Passing \c 0 as \p tag_len means that the message is no
    ///                  longer authenticated.
    ///
    /// \return          \c 0 on success.
    /// \return          A CCM or cipher-specific error code on failure.
    pub fn mbedtls_ccm_star_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs a CCM authenticated decryption of a
    ///                  buffer.
    ///
    /// \param ctx       The CCM context to use for decryption. This must be
    ///                  initialized and bound to a key.
    /// \param length    The length of the input data in Bytes.
    /// \param iv        The initialization vector (nonce). This must be a readable
    ///                  buffer of at least \p iv_len Bytes.
    /// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
    ///                  or 13. The length L of the message length field is
    ///                  15 - \p iv_len.
    /// \param ad        The additional data field. This must be a readable buffer
    ///                  of at least that \p ad_len Bytes..
    /// \param ad_len    The length of additional data in Bytes.
    ///                  This must be less than 2^16 - 2^8.
    /// \param input     The buffer holding the input data. If \p length is greater
    ///                  than zero, \p input must be a readable buffer of at least
    ///                  that length.
    /// \param output    The buffer holding the output data. If \p length is greater
    ///                  than zero, \p output must be a writable buffer of at least
    ///                  that length.
    /// \param tag       The buffer holding the authentication field. This must be a
    ///                  readable buffer of at least \p tag_len Bytes.
    /// \param tag_len   The length of the authentication field to generate in Bytes:
    ///                  4, 6, 8, 10, 12, 14 or 16.
    ///
    /// \return          \c 0 on success. This indicates that the message is authentic.
    /// \return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.
    /// \return          A cipher-specific error code on calculation failure.
    pub fn mbedtls_ccm_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs a CCM* authenticated decryption of a
    ///                  buffer.
    ///
    /// \note            When using this function in a variable tag length context,
    ///                  the tag length has to be decoded from \p iv and passed to
    ///                  this function as \p tag_len. (\p tag needs to be adjusted
    ///                  accordingly.)
    ///
    /// \param ctx       The CCM context to use for decryption. This must be
    ///                  initialized and bound to a key.
    /// \param length    The length of the input data in Bytes.
    ///                  For tag length = 0, input length is ignored.
    /// \param iv        The initialization vector (nonce). This must be a readable
    ///                  buffer of at least \p iv_len Bytes.
    /// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
    ///                  or 13. The length L of the message length field is
    ///                  15 - \p iv_len.
    /// \param ad        The additional data field. This must be a readable buffer of
    ///                  at least that \p ad_len Bytes.
    /// \param ad_len    The length of additional data in Bytes.
    ///                  This must be less than 2^16 - 2^8.
    /// \param input     The buffer holding the input data. If \p length is greater
    ///                  than zero, \p input must be a readable buffer of at least
    ///                  that length.
    /// \param output    The buffer holding the output data. If \p length is greater
    ///                  than zero, \p output must be a writable buffer of at least
    ///                  that length.
    /// \param tag       The buffer holding the authentication field. This must be a
    ///                  readable buffer of at least \p tag_len Bytes.
    /// \param tag_len   The length of the authentication field in Bytes.
    ///                  0, 4, 6, 8, 10, 12, 14 or 16.
    ///
    /// \warning         Passing \c 0 as \p tag_len means that the message is nos
    ///                  longer authenticated.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.
    /// \return          A cipher-specific error code on calculation failure.
    pub fn mbedtls_ccm_star_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function starts a CCM encryption or decryption
    ///                  operation.
    ///
    ///                  This function and mbedtls_ccm_set_lengths() must be called
    ///                  before calling mbedtls_ccm_update_ad() or
    ///                  mbedtls_ccm_update(). This function can be called before
    ///                  or after mbedtls_ccm_set_lengths().
    ///
    /// \note            This function is not implemented in Mbed TLS yet.
    ///
    /// \param ctx       The CCM context. This must be initialized.
    /// \param mode      The operation to perform: #MBEDTLS_CCM_ENCRYPT or
    ///                  #MBEDTLS_CCM_DECRYPT or #MBEDTLS_CCM_STAR_ENCRYPT or
    ///                  #MBEDTLS_CCM_STAR_DECRYPT.
    /// \param iv        The initialization vector. This must be a readable buffer
    ///                  of at least \p iv_len Bytes.
    /// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
    ///                  or 13. The length L of the message length field is
    ///                  15 - \p iv_len.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
    ///                  \p ctx is in an invalid state,
    ///                  \p mode is invalid,
    ///                  \p iv_len is invalid (lower than \c 7 or greater than
    ///                  \c 13).
    pub fn mbedtls_ccm_starts(
        ctx: *mut mbedtls_ccm_context,
        mode: crate::c_types::c_int,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function declares the lengths of the message
    ///                  and additional data for a CCM encryption or decryption
    ///                  operation.
    ///
    ///                  This function and mbedtls_ccm_starts() must be called
    ///                  before calling mbedtls_ccm_update_ad() or
    ///                  mbedtls_ccm_update(). This function can be called before
    ///                  or after mbedtls_ccm_starts().
    ///
    /// \note            This function is not implemented in Mbed TLS yet.
    ///
    /// \param ctx       The CCM context. This must be initialized.
    /// \param total_ad_len   The total length of additional data in bytes.
    ///                       This must be less than `2^16 - 2^8`.
    /// \param plaintext_len  The length in bytes of the plaintext to encrypt or
    ///                       result of the decryption (thus not encompassing the
    ///                       additional data that are not encrypted).
    /// \param tag_len   The length of the tag to generate in Bytes:
    ///                  4, 6, 8, 10, 12, 14 or 16.
    ///                  For CCM*, zero is also valid.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
    ///                  \p ctx is in an invalid state,
    ///                  \p total_ad_len is greater than \c 0xFF00.
    pub fn mbedtls_ccm_set_lengths(
        ctx: *mut mbedtls_ccm_context,
        total_ad_len: usize,
        plaintext_len: usize,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function feeds an input buffer as associated data
    ///                  (authenticated but not encrypted data) in a CCM
    ///                  encryption or decryption operation.
    ///
    ///                  You may call this function zero, one or more times
    ///                  to pass successive parts of the additional data. The
    ///                  lengths \p ad_len of the data parts should eventually add
    ///                  up exactly to the total length of additional data
    ///                  \c total_ad_len passed to mbedtls_ccm_set_lengths(). You
    ///                  may not call this function after calling
    ///                  mbedtls_ccm_update().
    ///
    /// \note            This function is not implemented in Mbed TLS yet.
    ///
    /// \param ctx       The CCM context. This must have been started with
    ///                  mbedtls_ccm_starts(), the lengths of the message and
    ///                  additional data must have been declared with
    ///                  mbedtls_ccm_set_lengths() and this must not have yet
    ///                  received any input with mbedtls_ccm_update().
    /// \param ad        The buffer holding the additional data, or \c NULL
    ///                  if \p ad_len is \c 0.
    /// \param ad_len    The length of the additional data. If \c 0,
    ///                  \p ad may be \c NULL.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
    ///                  \p ctx is in an invalid state,
    ///                  total input length too long.
    pub fn mbedtls_ccm_update_ad(
        ctx: *mut mbedtls_ccm_context,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function feeds an input buffer into an ongoing CCM
    ///                  encryption or decryption operation.
    ///
    ///                  You may call this function zero, one or more times
    ///                  to pass successive parts of the input: the plaintext to
    ///                  encrypt, or the ciphertext (not including the tag) to
    ///                  decrypt. After the last part of the input, call
    ///                  mbedtls_ccm_finish(). The lengths \p input_len of the
    ///                  data parts should eventually add up exactly to the
    ///                  plaintext length \c plaintext_len passed to
    ///                  mbedtls_ccm_set_lengths().
    ///
    ///                  This function may produce output in one of the following
    ///                  ways:
    ///                  - Immediate output: the output length is always equal
    ///                    to the input length.
    ///                  - Buffered output: except for the last part of input data,
    ///                    the output consists of a whole number of 16-byte blocks.
    ///                    If the total input length so far (not including
    ///                    associated data) is 16 \* *B* + *A* with *A* < 16 then
    ///                    the total output length is 16 \* *B*.
    ///                    For the last part of input data, the output length is
    ///                    equal to the input length plus the number of bytes (*A*)
    ///                    buffered in the previous call to the function (if any).
    ///                    The function uses the plaintext length
    ///                    \c plaintext_len passed to mbedtls_ccm_set_lengths()
    ///                    to detect the last part of input data.
    ///
    ///                  In particular:
    ///                  - It is always correct to call this function with
    ///                    \p output_size >= \p input_len + 15.
    ///                  - If \p input_len is a multiple of 16 for all the calls
    ///                    to this function during an operation (not necessary for
    ///                    the last one) then it is correct to use \p output_size
    ///                    =\p input_len.
    ///
    /// \note            This function is not implemented in Mbed TLS yet.
    ///
    /// \param ctx           The CCM context. This must have been started with
    ///                      mbedtls_ccm_starts() and the lengths of the message and
    ///                      additional data must have been declared with
    ///                      mbedtls_ccm_set_lengths().
    /// \param input         The buffer holding the input data. If \p input_len
    ///                      is greater than zero, this must be a readable buffer
    ///                      of at least \p input_len bytes.
    /// \param input_len     The length of the input data in bytes.
    /// \param output        The buffer for the output data. If \p output_size
    ///                      is greater than zero, this must be a writable buffer of
    ///                      at least \p output_size bytes.
    /// \param output_size   The size of the output buffer in bytes.
    ///                      See the function description regarding the output size.
    /// \param output_len    On success, \p *output_len contains the actual
    ///                      length of the output written in \p output.
    ///                      On failure, the content of \p *output_len is
    ///                      unspecified.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
    ///                 \p ctx is in an invalid state,
    ///                 total input length too long,
    ///                 or \p output_size too small.
    pub fn mbedtls_ccm_update(
        ctx: *mut mbedtls_ccm_context,
        input: *const crate::c_types::c_uchar,
        input_len: usize,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        output_len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function finishes the CCM operation and generates
    ///                  the authentication tag.
    ///
    ///                  It wraps up the CCM stream, and generates the
    ///                  tag. The tag can have a maximum length of 16 Bytes.
    ///
    /// \note            This function is not implemented in Mbed TLS yet.
    ///
    /// \param ctx       The CCM context. This must have been started with
    ///                  mbedtls_ccm_starts() and the lengths of the message and
    ///                  additional data must have been declared with
    ///                  mbedtls_ccm_set_lengths().
    /// \param tag       The buffer for holding the tag. If \p tag_len is greater
    ///                  than zero, this must be a writable buffer of at least \p
    ///                  tag_len Bytes.
    /// \param tag_len   The length of the tag. Must match the tag length passed to
    ///                  mbedtls_ccm_set_lengths() function.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
    ///                  \p ctx is in an invalid state,
    ///                  invalid value of \p tag_len,
    ///                  the total amount of additional data passed to
    ///                  mbedtls_ccm_update_ad() was lower than the total length of
    ///                  additional data \c total_ad_len passed to
    ///                  mbedtls_ccm_set_lengths(),
    ///                  the total amount of input data passed to
    ///                  mbedtls_ccm_update() was lower than the plaintext length
    ///                  \c plaintext_len passed to mbedtls_ccm_set_lengths().
    pub fn mbedtls_ccm_finish(
        ctx: *mut mbedtls_ccm_context,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The CCM checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_ccm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_poly1305_context {
    pub private_r: [u32; 4usize],
    /// The value for 'r' (low 128 bits of the key).
    pub private_s: [u32; 4usize],
    /// The value for 's' (high 128 bits of the key).
    pub private_acc: [u32; 5usize],
    /// The accumulator number.
    pub private_queue: [u8; 16usize],
    /// The current partial block of data.
    pub private_queue_len: usize,
}
extern "C" {
    /// \brief           This function initializes the specified Poly1305 context.
    ///
    ///                  It must be the first API called before using
    ///                  the context.
    ///
    ///                  It is usually followed by a call to
    ///                  \c mbedtls_poly1305_starts(), then one or more calls to
    ///                  \c mbedtls_poly1305_update(), then one call to
    ///                  \c mbedtls_poly1305_finish(), then finally
    ///                  \c mbedtls_poly1305_free().
    ///
    /// \param ctx       The Poly1305 context to initialize. This must
    ///                  not be \c NULL.
    pub fn mbedtls_poly1305_init(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    /// \brief           This function releases and clears the specified
    ///                  Poly1305 context.
    ///
    /// \param ctx       The Poly1305 context to clear. This may be \c NULL, in which
    ///                  case this function is a no-op. If it is not \c NULL, it must
    ///                  point to an initialized Poly1305 context.
    pub fn mbedtls_poly1305_free(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    /// \brief           This function sets the one-time authentication key.
    ///
    /// \warning         The key must be unique and unpredictable for each
    ///                  invocation of Poly1305.
    ///
    /// \param ctx       The Poly1305 context to which the key should be bound.
    ///                  This must be initialized.
    /// \param key       The buffer containing the \c 32 Byte (\c 256 Bit) key.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_poly1305_starts(
        ctx: *mut mbedtls_poly1305_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This functions feeds an input buffer into an ongoing
    ///                  Poly1305 computation.
    ///
    ///                  It is called between \c mbedtls_cipher_poly1305_starts() and
    ///                  \c mbedtls_cipher_poly1305_finish().
    ///                  It can be called repeatedly to process a stream of data.
    ///
    /// \param ctx       The Poly1305 context to use for the Poly1305 operation.
    ///                  This must be initialized and bound to a key.
    /// \param ilen      The length of the input data in Bytes.
    ///                  Any value is accepted.
    /// \param input     The buffer holding the input data.
    ///                  This pointer can be \c NULL if `ilen == 0`.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_poly1305_update(
        ctx: *mut mbedtls_poly1305_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function generates the Poly1305 Message
    ///                  Authentication Code (MAC).
    ///
    /// \param ctx       The Poly1305 context to use for the Poly1305 operation.
    ///                  This must be initialized and bound to a key.
    /// \param mac       The buffer to where the MAC is written. This must
    ///                  be a writable buffer of length \c 16 Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_poly1305_finish(
        ctx: *mut mbedtls_poly1305_context,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function calculates the Poly1305 MAC of the input
    ///                  buffer with the provided key.
    ///
    /// \warning         The key must be unique and unpredictable for each
    ///                  invocation of Poly1305.
    ///
    /// \param key       The buffer containing the \c 32 Byte (\c 256 Bit) key.
    /// \param ilen      The length of the input data in Bytes.
    ///                  Any value is accepted.
    /// \param input     The buffer holding the input data.
    ///                  This pointer can be \c NULL if `ilen == 0`.
    /// \param mac       The buffer to where the MAC is written. This must be
    ///                  a writable buffer of length \c 16 Bytes.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_poly1305_mac(
        key: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           The Poly1305 checkup routine.
    ///
    /// \return          \c 0 on success.
    /// \return          \c 1 on failure.
    pub fn mbedtls_poly1305_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
///< The mode value for performing encryption.
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_ENCRYPT: mbedtls_chachapoly_mode_t = 0;
///< The mode value for performing decryption.
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_DECRYPT: mbedtls_chachapoly_mode_t = 1;
pub type mbedtls_chachapoly_mode_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_chacha20_context {
    pub private_state: [u32; 16usize],
    /// The state (before round operations).
    pub private_keystream8: [u8; 64usize],
    /// Leftover keystream bytes.
    pub private_keystream_bytes_used: usize,
}
extern "C" {
    /// \brief           This function initializes the specified ChaCha20 context.
    ///
    ///                  It must be the first API called before using
    ///                  the context.
    ///
    ///                  It is usually followed by calls to
    ///                  \c mbedtls_chacha20_setkey() and
    ///                  \c mbedtls_chacha20_starts(), then one or more calls to
    ///                  to \c mbedtls_chacha20_update(), and finally to
    ///                  \c mbedtls_chacha20_free().
    ///
    /// \param ctx       The ChaCha20 context to initialize.
    ///                  This must not be \c NULL.
    pub fn mbedtls_chacha20_init(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    /// \brief           This function releases and clears the specified
    ///                  ChaCha20 context.
    ///
    /// \param ctx       The ChaCha20 context to clear. This may be \c NULL,
    ///                  in which case this function is a no-op. If it is not
    ///                  \c NULL, it must point to an initialized context.
    pub fn mbedtls_chacha20_free(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    /// \brief           This function sets the encryption/decryption key.
    ///
    /// \note            After using this function, you must also call
    ///                  \c mbedtls_chacha20_starts() to set a nonce before you
    ///                  start encrypting/decrypting data with
    ///                  \c mbedtls_chacha_update().
    ///
    /// \param ctx       The ChaCha20 context to which the key should be bound.
    ///                  It must be initialized.
    /// \param key       The encryption/decryption key. This must be \c 32 Bytes
    ///                  in length.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or key is NULL.
    pub fn mbedtls_chacha20_setkey(
        ctx: *mut mbedtls_chacha20_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function sets the nonce and initial counter value.
    ///
    /// \note            A ChaCha20 context can be re-used with the same key by
    ///                  calling this function to change the nonce.
    ///
    /// \warning         You must never use the same nonce twice with the same key.
    ///                  This would void any confidentiality guarantees for the
    ///                  messages encrypted with the same nonce and key.
    ///
    /// \param ctx       The ChaCha20 context to which the nonce should be bound.
    ///                  It must be initialized and bound to a key.
    /// \param nonce     The nonce. This must be \c 12 Bytes in size.
    /// \param counter   The initial counter value. This is usually \c 0.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or nonce is
    ///                  NULL.
    pub fn mbedtls_chacha20_starts(
        ctx: *mut mbedtls_chacha20_context,
        nonce: *const crate::c_types::c_uchar,
        counter: u32,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function encrypts or decrypts data.
    ///
    ///                  Since ChaCha20 is a stream cipher, the same operation is
    ///                  used for encrypting and decrypting data.
    ///
    /// \note            The \p input and \p output pointers must either be equal or
    ///                  point to non-overlapping buffers.
    ///
    /// \note            \c mbedtls_chacha20_setkey() and
    ///                  \c mbedtls_chacha20_starts() must be called at least once
    ///                  to setup the context before this function can be called.
    ///
    /// \note            This function can be called multiple times in a row in
    ///                  order to encrypt of decrypt data piecewise with the same
    ///                  key and nonce.
    ///
    /// \param ctx       The ChaCha20 context to use for encryption or decryption.
    ///                  It must be initialized and bound to a key and nonce.
    /// \param size      The length of the input data in Bytes.
    /// \param input     The buffer holding the input data.
    ///                  This pointer can be \c NULL if `size == 0`.
    /// \param output    The buffer holding the output data.
    ///                  This must be able to hold \p size Bytes.
    ///                  This pointer can be \c NULL if `size == 0`.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_chacha20_update(
        ctx: *mut mbedtls_chacha20_context,
        size: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function encrypts or decrypts data with ChaCha20 and
    ///                  the given key and nonce.
    ///
    ///                  Since ChaCha20 is a stream cipher, the same operation is
    ///                  used for encrypting and decrypting data.
    ///
    /// \warning         You must never use the same (key, nonce) pair more than
    ///                  once. This would void any confidentiality guarantees for
    ///                  the messages encrypted with the same nonce and key.
    ///
    /// \note            The \p input and \p output pointers must either be equal or
    ///                  point to non-overlapping buffers.
    ///
    /// \param key       The encryption/decryption key.
    ///                  This must be \c 32 Bytes in length.
    /// \param nonce     The nonce. This must be \c 12 Bytes in size.
    /// \param counter   The initial counter value. This is usually \c 0.
    /// \param size      The length of the input data in Bytes.
    /// \param input     The buffer holding the input data.
    ///                  This pointer can be \c NULL if `size == 0`.
    /// \param output    The buffer holding the output data.
    ///                  This must be able to hold \p size Bytes.
    ///                  This pointer can be \c NULL if `size == 0`.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_chacha20_crypt(
        key: *const crate::c_types::c_uchar,
        nonce: *const crate::c_types::c_uchar,
        counter: u32,
        size: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           The ChaCha20 checkup routine.
    ///
    /// \return          \c 0 on success.
    /// \return          \c 1 on failure.
    pub fn mbedtls_chacha20_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_chachapoly_context {
    ///< The ChaCha20 context.
    pub private_chacha20_ctx: mbedtls_chacha20_context,
    ///< The Poly1305 context.
    pub private_poly1305_ctx: mbedtls_poly1305_context,
    ///< The length (bytes) of the Additional Authenticated Data.
    pub private_aad_len: u64,
    ///< The length (bytes) of the ciphertext.
    pub private_ciphertext_len: u64,
    ///< The current state of the context.
    pub private_state: crate::c_types::c_int,
    ///< Cipher mode (encrypt or decrypt).
    pub private_mode: mbedtls_chachapoly_mode_t,
}
extern "C" {
    /// \brief           This function initializes the specified ChaCha20-Poly1305 context.
    ///
    ///                  It must be the first API called before using
    ///                  the context. It must be followed by a call to
    ///                  \c mbedtls_chachapoly_setkey() before any operation can be
    ///                  done, and to \c mbedtls_chachapoly_free() once all
    ///                  operations with that context have been finished.
    ///
    ///                  In order to encrypt or decrypt full messages at once, for
    ///                  each message you should make a single call to
    ///                  \c mbedtls_chachapoly_crypt_and_tag() or
    ///                  \c mbedtls_chachapoly_auth_decrypt().
    ///
    ///                  In order to encrypt messages piecewise, for each
    ///                  message you should make a call to
    ///                  \c mbedtls_chachapoly_starts(), then 0 or more calls to
    ///                  \c mbedtls_chachapoly_update_aad(), then 0 or more calls to
    ///                  \c mbedtls_chachapoly_update(), then one call to
    ///                  \c mbedtls_chachapoly_finish().
    ///
    /// \warning         Decryption with the piecewise API is discouraged! Always
    ///                  use \c mbedtls_chachapoly_auth_decrypt() when possible!
    ///
    ///                  If however this is not possible because the data is too
    ///                  large to fit in memory, you need to:
    ///
    ///                  - call \c mbedtls_chachapoly_starts() and (if needed)
    ///                  \c mbedtls_chachapoly_update_aad() as above,
    ///                  - call \c mbedtls_chachapoly_update() multiple times and
    ///                  ensure its output (the plaintext) is NOT used in any other
    ///                  way than placing it in temporary storage at this point,
    ///                  - call \c mbedtls_chachapoly_finish() to compute the
    ///                  authentication tag and compared it in constant time to the
    ///                  tag received with the ciphertext.
    ///
    ///                  If the tags are not equal, you must immediately discard
    ///                  all previous outputs of \c mbedtls_chachapoly_update(),
    ///                  otherwise you can now safely use the plaintext.
    ///
    /// \param ctx       The ChachaPoly context to initialize. Must not be \c NULL.
    pub fn mbedtls_chachapoly_init(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    /// \brief           This function releases and clears the specified
    ///                  ChaCha20-Poly1305 context.
    ///
    /// \param ctx       The ChachaPoly context to clear. This may be \c NULL, in which
    ///                  case this function is a no-op.
    pub fn mbedtls_chachapoly_free(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    /// \brief           This function sets the ChaCha20-Poly1305
    ///                  symmetric encryption key.
    ///
    /// \param ctx       The ChaCha20-Poly1305 context to which the key should be
    ///                  bound. This must be initialized.
    /// \param key       The \c 256 Bit (\c 32 Bytes) key.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_chachapoly_setkey(
        ctx: *mut mbedtls_chachapoly_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function starts a ChaCha20-Poly1305 encryption or
    ///                  decryption operation.
    ///
    /// \warning         You must never use the same nonce twice with the same key.
    ///                  This would void any confidentiality and authenticity
    ///                  guarantees for the messages encrypted with the same nonce
    ///                  and key.
    ///
    /// \note            If the context is being used for AAD only (no data to
    ///                  encrypt or decrypt) then \p mode can be set to any value.
    ///
    /// \warning         Decryption with the piecewise API is discouraged, see the
    ///                  warning on \c mbedtls_chachapoly_init().
    ///
    /// \param ctx       The ChaCha20-Poly1305 context. This must be initialized
    ///                  and bound to a key.
    /// \param nonce     The nonce/IV to use for the message.
    ///                  This must be a readable buffer of length \c 12 Bytes.
    /// \param mode      The operation to perform: #MBEDTLS_CHACHAPOLY_ENCRYPT or
    ///                  #MBEDTLS_CHACHAPOLY_DECRYPT (discouraged, see warning).
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_chachapoly_starts(
        ctx: *mut mbedtls_chachapoly_context,
        nonce: *const crate::c_types::c_uchar,
        mode: mbedtls_chachapoly_mode_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function feeds additional data to be authenticated
    ///                  into an ongoing ChaCha20-Poly1305 operation.
    ///
    ///                  The Additional Authenticated Data (AAD), also called
    ///                  Associated Data (AD) is only authenticated but not
    ///                  encrypted nor included in the encrypted output. It is
    ///                  usually transmitted separately from the ciphertext or
    ///                  computed locally by each party.
    ///
    /// \note            This function is called before data is encrypted/decrypted.
    ///                  I.e. call this function to process the AAD before calling
    ///                  \c mbedtls_chachapoly_update().
    ///
    ///                  You may call this function multiple times to process
    ///                  an arbitrary amount of AAD. It is permitted to call
    ///                  this function 0 times, if no AAD is used.
    ///
    ///                  This function cannot be called any more if data has
    ///                  been processed by \c mbedtls_chachapoly_update(),
    ///                  or if the context has been finished.
    ///
    /// \warning         Decryption with the piecewise API is discouraged, see the
    ///                  warning on \c mbedtls_chachapoly_init().
    ///
    /// \param ctx       The ChaCha20-Poly1305 context. This must be initialized
    ///                  and bound to a key.
    /// \param aad_len   The length in Bytes of the AAD. The length has no
    ///                  restrictions.
    /// \param aad       Buffer containing the AAD.
    ///                  This pointer can be \c NULL if `aad_len == 0`.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA
    ///                  if \p ctx or \p aad are NULL.
    /// \return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE
    ///                  if the operations has not been started or has been
    ///                  finished, or if the AAD has been finished.
    pub fn mbedtls_chachapoly_update_aad(
        ctx: *mut mbedtls_chachapoly_context,
        aad: *const crate::c_types::c_uchar,
        aad_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Thus function feeds data to be encrypted or decrypted
    ///                  into an on-going ChaCha20-Poly1305
    ///                  operation.
    ///
    ///                  The direction (encryption or decryption) depends on the
    ///                  mode that was given when calling
    ///                  \c mbedtls_chachapoly_starts().
    ///
    ///                  You may call this function multiple times to process
    ///                  an arbitrary amount of data. It is permitted to call
    ///                  this function 0 times, if no data is to be encrypted
    ///                  or decrypted.
    ///
    /// \warning         Decryption with the piecewise API is discouraged, see the
    ///                  warning on \c mbedtls_chachapoly_init().
    ///
    /// \param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.
    /// \param len       The length (in bytes) of the data to encrypt or decrypt.
    /// \param input     The buffer containing the data to encrypt or decrypt.
    ///                  This pointer can be \c NULL if `len == 0`.
    /// \param output    The buffer to where the encrypted or decrypted data is
    ///                  written. This must be able to hold \p len bytes.
    ///                  This pointer can be \c NULL if `len == 0`.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE
    ///                  if the operation has not been started or has been
    ///                  finished.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_chachapoly_update(
        ctx: *mut mbedtls_chachapoly_context,
        len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function finished the ChaCha20-Poly1305 operation and
    ///                  generates the MAC (authentication tag).
    ///
    /// \param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.
    /// \param mac       The buffer to where the 128-bit (16 bytes) MAC is written.
    ///
    /// \warning         Decryption with the piecewise API is discouraged, see the
    ///                  warning on \c mbedtls_chachapoly_init().
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE
    ///                  if the operation has not been started or has been
    ///                  finished.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_chachapoly_finish(
        ctx: *mut mbedtls_chachapoly_context,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs a complete ChaCha20-Poly1305
    ///                  authenticated encryption with the previously-set key.
    ///
    /// \note            Before using this function, you must set the key with
    ///                  \c mbedtls_chachapoly_setkey().
    ///
    /// \warning         You must never use the same nonce twice with the same key.
    ///                  This would void any confidentiality and authenticity
    ///                  guarantees for the messages encrypted with the same nonce
    ///                  and key.
    ///
    /// \param ctx       The ChaCha20-Poly1305 context to use (holds the key).
    ///                  This must be initialized.
    /// \param length    The length (in bytes) of the data to encrypt or decrypt.
    /// \param nonce     The 96-bit (12 bytes) nonce/IV to use.
    /// \param aad       The buffer containing the additional authenticated
    ///                  data (AAD). This pointer can be \c NULL if `aad_len == 0`.
    /// \param aad_len   The length (in bytes) of the AAD data to process.
    /// \param input     The buffer containing the data to encrypt or decrypt.
    ///                  This pointer can be \c NULL if `ilen == 0`.
    /// \param output    The buffer to where the encrypted or decrypted data
    ///                  is written. This pointer can be \c NULL if `ilen == 0`.
    /// \param tag       The buffer to where the computed 128-bit (16 bytes) MAC
    ///                  is written. This must not be \c NULL.
    ///
    /// \return          \c 0 on success.
    /// \return          A negative error code on failure.
    pub fn mbedtls_chachapoly_encrypt_and_tag(
        ctx: *mut mbedtls_chachapoly_context,
        length: usize,
        nonce: *const crate::c_types::c_uchar,
        aad: *const crate::c_types::c_uchar,
        aad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function performs a complete ChaCha20-Poly1305
    ///                  authenticated decryption with the previously-set key.
    ///
    /// \note            Before using this function, you must set the key with
    ///                  \c mbedtls_chachapoly_setkey().
    ///
    /// \param ctx       The ChaCha20-Poly1305 context to use (holds the key).
    /// \param length    The length (in Bytes) of the data to decrypt.
    /// \param nonce     The \c 96 Bit (\c 12 bytes) nonce/IV to use.
    /// \param aad       The buffer containing the additional authenticated data (AAD).
    ///                  This pointer can be \c NULL if `aad_len == 0`.
    /// \param aad_len   The length (in bytes) of the AAD data to process.
    /// \param tag       The buffer holding the authentication tag.
    ///                  This must be a readable buffer of length \c 16 Bytes.
    /// \param input     The buffer containing the data to decrypt.
    ///                  This pointer can be \c NULL if `ilen == 0`.
    /// \param output    The buffer to where the decrypted data is written.
    ///                  This pointer can be \c NULL if `ilen == 0`.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED
    ///                  if the data was not authentic.
    /// \return          Another negative error code on other kinds of failure.
    pub fn mbedtls_chachapoly_auth_decrypt(
        ctx: *mut mbedtls_chachapoly_context,
        length: usize,
        nonce: *const crate::c_types::c_uchar,
        aad: *const crate::c_types::c_uchar,
        aad_len: usize,
        tag: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           The ChaCha20-Poly1305 checkup routine.
    ///
    /// \return          \c 0 on success.
    /// \return          \c 1 on failure.
    pub fn mbedtls_chachapoly_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_DECRYPT: psa_encrypt_or_decrypt_t = 0;
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_ENCRYPT: psa_encrypt_or_decrypt_t = 1;
/// For encrypt-decrypt functions, whether the operation is an encryption
/// or a decryption.
pub type psa_encrypt_or_decrypt_t = crate::c_types::c_uint;
/// \brief          MD5 context structure
///
/// \warning        MD5 is considered a weak message digest and its use
///                 constitutes a security risk. We recommend considering
///                 stronger message digests instead.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md5_context {
    ///< number of bytes processed
    pub private_total: [u32; 2usize],
    ///< intermediate digest state
    pub private_state: [u32; 4usize],
    ///< data block being processed
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    /// \brief          Initialize MD5 context
    ///
    /// \param ctx      MD5 context to be initialized
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5_init(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    /// \brief          Clear MD5 context
    ///
    /// \param ctx      MD5 context to be cleared
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5_free(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    /// \brief          Clone (the state of) an MD5 context
    ///
    /// \param dst      The destination context
    /// \param src      The context to be cloned
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5_clone(dst: *mut mbedtls_md5_context, src: *const mbedtls_md5_context);
}
extern "C" {
    /// \brief          MD5 context setup
    ///
    /// \param ctx      context to be initialized
    ///
    /// \return         0 if successful
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5_starts(ctx: *mut mbedtls_md5_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          MD5 process buffer
    ///
    /// \param ctx      MD5 context
    /// \param input    buffer holding the data
    /// \param ilen     length of the input data
    ///
    /// \return         0 if successful
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5_update(
        ctx: *mut mbedtls_md5_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          MD5 final digest
    ///
    /// \param ctx      MD5 context
    /// \param output   MD5 checksum result
    ///
    /// \return         0 if successful
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5_finish(
        ctx: *mut mbedtls_md5_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          MD5 process data block (internal use only)
    ///
    /// \param ctx      MD5 context
    /// \param data     buffer holding one block of data
    ///
    /// \return         0 if successful
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_internal_md5_process(
        ctx: *mut mbedtls_md5_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Output = MD5( input buffer )
    ///
    /// \param input    buffer holding the data
    /// \param ilen     length of the input data
    /// \param output   MD5 checksum result
    ///
    /// \return         0 if successful
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Checkup routine
    ///
    /// \return         0 if successful, or 1 if the test failed
    ///
    /// \warning        MD5 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    pub fn mbedtls_md5_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
/// \brief          RIPEMD-160 context structure
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ripemd160_context {
    ///< number of bytes processed
    pub private_total: [u32; 2usize],
    ///< intermediate digest state
    pub private_state: [u32; 5usize],
    ///< data block being processed
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    /// \brief          Initialize RIPEMD-160 context
    ///
    /// \param ctx      RIPEMD-160 context to be initialized
    pub fn mbedtls_ripemd160_init(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    /// \brief          Clear RIPEMD-160 context
    ///
    /// \param ctx      RIPEMD-160 context to be cleared
    pub fn mbedtls_ripemd160_free(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    /// \brief          Clone (the state of) a RIPEMD-160 context
    ///
    /// \param dst      The destination context
    /// \param src      The context to be cloned
    pub fn mbedtls_ripemd160_clone(
        dst: *mut mbedtls_ripemd160_context,
        src: *const mbedtls_ripemd160_context,
    );
}
extern "C" {
    /// \brief          RIPEMD-160 context setup
    ///
    /// \param ctx      context to be initialized
    ///
    /// \return         0 if successful
    pub fn mbedtls_ripemd160_starts(ctx: *mut mbedtls_ripemd160_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          RIPEMD-160 process buffer
    ///
    /// \param ctx      RIPEMD-160 context
    /// \param input    buffer holding the data
    /// \param ilen     length of the input data
    ///
    /// \return         0 if successful
    pub fn mbedtls_ripemd160_update(
        ctx: *mut mbedtls_ripemd160_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          RIPEMD-160 final digest
    ///
    /// \param ctx      RIPEMD-160 context
    /// \param output   RIPEMD-160 checksum result
    ///
    /// \return         0 if successful
    pub fn mbedtls_ripemd160_finish(
        ctx: *mut mbedtls_ripemd160_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          RIPEMD-160 process data block (internal use only)
    ///
    /// \param ctx      RIPEMD-160 context
    /// \param data     buffer holding one block of data
    ///
    /// \return         0 if successful
    pub fn mbedtls_internal_ripemd160_process(
        ctx: *mut mbedtls_ripemd160_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Output = RIPEMD-160( input buffer )
    ///
    /// \param input    buffer holding the data
    /// \param ilen     length of the input data
    /// \param output   RIPEMD-160 checksum result
    ///
    /// \return         0 if successful
    pub fn mbedtls_ripemd160(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Checkup routine
    ///
    /// \return         0 if successful, or 1 if the test failed
    pub fn mbedtls_ripemd160_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha1_context {
    pub hasher: *mut crate::c_types::c_void,
}
extern "C" {
    /// \brief          This function initializes a SHA-1 context.
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param ctx      The SHA-1 context to initialize.
    ///                 This must not be \c NULL.
    pub fn mbedtls_sha1_init(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    /// \brief          This function clears a SHA-1 context.
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param ctx      The SHA-1 context to clear. This may be \c NULL,
    ///                 in which case this function does nothing. If it is
    ///                 not \c NULL, it must point to an initialized
    ///                 SHA-1 context.
    pub fn mbedtls_sha1_free(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    /// \brief          This function clones the state of a SHA-1 context.
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param dst      The SHA-1 context to clone to. This must be initialized.
    /// \param src      The SHA-1 context to clone from. This must be initialized.
    pub fn mbedtls_sha1_clone(dst: *mut mbedtls_sha1_context, src: *const mbedtls_sha1_context);
}
extern "C" {
    /// \brief          This function starts a SHA-1 checksum calculation.
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param ctx      The SHA-1 context to initialize. This must be initialized.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha1_starts(ctx: *mut mbedtls_sha1_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function feeds an input buffer into an ongoing SHA-1
    ///                 checksum calculation.
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param ctx      The SHA-1 context. This must be initialized
    ///                 and have a hash operation started.
    /// \param input    The buffer holding the input data.
    ///                 This must be a readable buffer of length \p ilen Bytes.
    /// \param ilen     The length of the input data \p input in Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha1_update(
        ctx: *mut mbedtls_sha1_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function finishes the SHA-1 operation, and writes
    ///                 the result to the output buffer.
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param ctx      The SHA-1 context to use. This must be initialized and
    ///                 have a hash operation started.
    /// \param output   The SHA-1 checksum result. This must be a writable
    ///                 buffer of length \c 20 Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha1_finish(
        ctx: *mut mbedtls_sha1_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          SHA-1 process data block (internal use only).
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param ctx      The SHA-1 context to use. This must be initialized.
    /// \param data     The data block being processed. This must be a
    ///                 readable buffer of length \c 64 Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_internal_sha1_process(
        ctx: *mut mbedtls_sha1_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function calculates the SHA-1 checksum of a buffer.
    ///
    ///                 The function allocates the context, performs the
    ///                 calculation, and frees the context.
    ///
    ///                 The SHA-1 result is calculated as
    ///                 output = SHA-1(input buffer).
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \param input    The buffer holding the input data.
    ///                 This must be a readable buffer of length \p ilen Bytes.
    /// \param ilen     The length of the input data \p input in Bytes.
    /// \param output   The SHA-1 checksum result.
    ///                 This must be a writable buffer of length \c 20 Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha1(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The SHA-1 checkup routine.
    ///
    /// \warning        SHA-1 is considered a weak message digest and its use
    ///                 constitutes a security risk. We recommend considering
    ///                 stronger message digests instead.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_sha1_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
/// \brief          The SHA-256 context structure.
///
///                 The structure is used both for SHA-256 and for SHA-224
///                 checksum calculations. The choice between these two is
///                 made in the call to mbedtls_sha256_starts().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha256_context {
    ///< The number of Bytes processed.
    pub private_total: [u32; 2usize],
    ///< The intermediate digest state.
    pub private_state: [u32; 8usize],
    ///< The data block being processed.
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
    ///< Determines which function to use:
    ///0: Use SHA-256, or 1: Use SHA-224.
    pub private_is224: crate::c_types::c_int,
}
extern "C" {
    /// \brief          This function initializes a SHA-256 context.
    ///
    /// \param ctx      The SHA-256 context to initialize. This must not be \c NULL.
    pub fn mbedtls_sha256_init(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    /// \brief          This function clears a SHA-256 context.
    ///
    /// \param ctx      The SHA-256 context to clear. This may be \c NULL, in which
    ///                 case this function returns immediately. If it is not \c NULL,
    ///                 it must point to an initialized SHA-256 context.
    pub fn mbedtls_sha256_free(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    /// \brief          This function clones the state of a SHA-256 context.
    ///
    /// \param dst      The destination context. This must be initialized.
    /// \param src      The context to clone. This must be initialized.
    pub fn mbedtls_sha256_clone(
        dst: *mut mbedtls_sha256_context,
        src: *const mbedtls_sha256_context,
    );
}
extern "C" {
    /// \brief          This function starts a SHA-224 or SHA-256 checksum
    ///                 calculation.
    ///
    /// \param ctx      The context to use. This must be initialized.
    /// \param is224    This determines which function to use. This must be
    ///                 either \c 0 for SHA-256, or \c 1 for SHA-224.
    ///
    /// \note           is224 must be defined accordingly to the enabled
    ///                 MBEDTLS_SHA224_C/MBEDTLS_SHA256_C symbols otherwise the
    ///                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha256_starts(
        ctx: *mut mbedtls_sha256_context,
        is224: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function feeds an input buffer into an ongoing
    ///                 SHA-256 checksum calculation.
    ///
    /// \param ctx      The SHA-256 context. This must be initialized
    ///                 and have a hash operation started.
    /// \param input    The buffer holding the data. This must be a readable
    ///                 buffer of length \p ilen Bytes.
    /// \param ilen     The length of the input data in Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha256_update(
        ctx: *mut mbedtls_sha256_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function finishes the SHA-256 operation, and writes
    ///                 the result to the output buffer.
    ///
    /// \param ctx      The SHA-256 context. This must be initialized
    ///                 and have a hash operation started.
    /// \param output   The SHA-224 or SHA-256 checksum result.
    ///                 This must be a writable buffer of length \c 32 bytes
    ///                 for SHA-256, \c 28 bytes for SHA-224.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha256_finish(
        ctx: *mut mbedtls_sha256_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function processes a single data block within
    ///                 the ongoing SHA-256 computation. This function is for
    ///                 internal use only.
    ///
    /// \param ctx      The SHA-256 context. This must be initialized.
    /// \param data     The buffer holding one block of data. This must
    ///                 be a readable buffer of length \c 64 Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_internal_sha256_process(
        ctx: *mut mbedtls_sha256_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function calculates the SHA-224 or SHA-256
    ///                 checksum of a buffer.
    ///
    ///                 The function allocates the context, performs the
    ///                 calculation, and frees the context.
    ///
    ///                 The SHA-256 result is calculated as
    ///                 output = SHA-256(input buffer).
    ///
    /// \param input    The buffer holding the data. This must be a readable
    ///                 buffer of length \p ilen Bytes.
    /// \param ilen     The length of the input data in Bytes.
    /// \param output   The SHA-224 or SHA-256 checksum result.
    ///                 This must be a writable buffer of length \c 32 bytes
    ///                 for SHA-256, \c 28 bytes for SHA-224.
    /// \param is224    Determines which function to use. This must be
    ///                 either \c 0 for SHA-256, or \c 1 for SHA-224.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha256(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        is224: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The SHA-224 checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_sha224_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The SHA-256 checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_sha256_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
/// \brief          The SHA-512 context structure.
///
///                 The structure is used both for SHA-384 and for SHA-512
///                 checksum calculations. The choice between these two is
///                 made in the call to mbedtls_sha512_starts().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha512_context {
    ///< The number of Bytes processed.
    pub private_total: [u64; 2usize],
    ///< The intermediate digest state.
    pub private_state: [u64; 8usize],
    ///< The data block being processed.
    pub private_buffer: [crate::c_types::c_uchar; 128usize],
    ///< Determines which function to use:
    ///0: Use SHA-512, or 1: Use SHA-384.
    pub private_is384: crate::c_types::c_int,
}
extern "C" {
    /// \brief          This function initializes a SHA-512 context.
    ///
    /// \param ctx      The SHA-512 context to initialize. This must
    ///                 not be \c NULL.
    pub fn mbedtls_sha512_init(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    /// \brief          This function clears a SHA-512 context.
    ///
    /// \param ctx      The SHA-512 context to clear. This may be \c NULL,
    ///                 in which case this function does nothing. If it
    ///                 is not \c NULL, it must point to an initialized
    ///                 SHA-512 context.
    pub fn mbedtls_sha512_free(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    /// \brief          This function clones the state of a SHA-512 context.
    ///
    /// \param dst      The destination context. This must be initialized.
    /// \param src      The context to clone. This must be initialized.
    pub fn mbedtls_sha512_clone(
        dst: *mut mbedtls_sha512_context,
        src: *const mbedtls_sha512_context,
    );
}
extern "C" {
    /// \brief          This function starts a SHA-384 or SHA-512 checksum
    ///                 calculation.
    ///
    /// \param ctx      The SHA-512 context to use. This must be initialized.
    /// \param is384    Determines which function to use. This must be
    ///                 either \c 0 for SHA-512, or \c 1 for SHA-384.
    ///
    /// \note           is384 must be defined accordingly to the enabled
    ///                 MBEDTLS_SHA384_C/MBEDTLS_SHA512_C symbols otherwise the
    ///                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha512_starts(
        ctx: *mut mbedtls_sha512_context,
        is384: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function feeds an input buffer into an ongoing
    ///                 SHA-512 checksum calculation.
    ///
    /// \param ctx      The SHA-512 context. This must be initialized
    ///                 and have a hash operation started.
    /// \param input    The buffer holding the input data. This must
    ///                 be a readable buffer of length \p ilen Bytes.
    /// \param ilen     The length of the input data in Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha512_update(
        ctx: *mut mbedtls_sha512_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function finishes the SHA-512 operation, and writes
    ///                 the result to the output buffer.
    ///
    /// \param ctx      The SHA-512 context. This must be initialized
    ///                 and have a hash operation started.
    /// \param output   The SHA-384 or SHA-512 checksum result.
    ///                 This must be a writable buffer of length \c 64 bytes
    ///                 for SHA-512, \c 48 bytes for SHA-384.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha512_finish(
        ctx: *mut mbedtls_sha512_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function processes a single data block within
    ///                 the ongoing SHA-512 computation.
    ///                 This function is for internal use only.
    ///
    /// \param ctx      The SHA-512 context. This must be initialized.
    /// \param data     The buffer holding one block of data. This
    ///                 must be a readable buffer of length \c 128 Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_internal_sha512_process(
        ctx: *mut mbedtls_sha512_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function calculates the SHA-512 or SHA-384
    ///                 checksum of a buffer.
    ///
    ///                 The function allocates the context, performs the
    ///                 calculation, and frees the context.
    ///
    ///                 The SHA-512 result is calculated as
    ///                 output = SHA-512(input buffer).
    ///
    /// \param input    The buffer holding the input data. This must be
    ///                 a readable buffer of length \p ilen Bytes.
    /// \param ilen     The length of the input data in Bytes.
    /// \param output   The SHA-384 or SHA-512 checksum result.
    ///                 This must be a writable buffer of length \c 64 bytes
    ///                 for SHA-512, \c 48 bytes for SHA-384.
    /// \param is384    Determines which function to use. This must be either
    ///                 \c 0 for SHA-512, or \c 1 for SHA-384.
    ///
    /// \note           is384 must be defined accordingly with the supported
    ///                 symbols in the config file. If:
    ///                 - is384 is 0, but \c MBEDTLS_SHA384_C is not defined, or
    ///                 - is384 is 1, but \c MBEDTLS_SHA512_C is not defined
    ///                 then the function will return
    ///                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.
    ///
    /// \return         \c 0 on success.
    /// \return         A negative error code on failure.
    pub fn mbedtls_sha512(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        is384: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The SHA-384 checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_sha384_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The SHA-512 checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_sha512_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hash_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_hash_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_hash_operation_t__bindgen_ty_1 {
    pub dummy: crate::c_types::c_uint,
    pub md5: mbedtls_md5_context,
    pub ripemd160: mbedtls_ripemd160_context,
    pub sha1: mbedtls_sha1_context,
    pub sha256: mbedtls_sha256_context,
    pub sha512: mbedtls_sha512_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_cipher_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_iv_length: u8,
    pub private_block_length: u8,
    pub private_ctx: mbedtls_psa_cipher_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_cipher_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_cipher: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_hash_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_hash_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_cipher_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_cipher_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hash_operation_s {
    /// Unique ID indicating which driver got assigned to do the
    /// operation. Since driver contexts are driver-specific, swapping
    /// drivers halfway through the operation is not supported.
    /// ID values are auto-generated in psa_driver_wrappers.h.
    /// ID value zero means the context is not valid or not assigned to
    /// any driver (i.e. the driver context is not active, in use).
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_hash_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_cipher_operation_s {
    /// Unique ID indicating which driver got assigned to do the
    /// operation. Since driver contexts are driver-specific, swapping
    /// drivers halfway through the operation is not supported.
    /// ID values are auto-generated in psa_crypto_driver_wrappers.h
    /// ID value zero means the context is not valid or not assigned to
    /// any driver (i.e. none of the driver contexts are active).
    pub private_id: crate::c_types::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_default_iv_length: u8,
    pub private_ctx: psa_driver_cipher_context_t,
}
impl psa_cipher_operation_s {
    #[inline]
    pub fn private_iv_required(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_required(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_iv_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_iv_required: crate::c_types::c_uint,
        private_iv_set: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_iv_required: u32 = unsafe { ::core::mem::transmute(private_iv_required) };
            private_iv_required as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_iv_set: u32 = unsafe { ::core::mem::transmute(private_iv_set) };
            private_iv_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hmac_operation_t {
    /// The HMAC algorithm in use
    pub private_alg: psa_algorithm_t,
    /// The hash context.
    pub hash_ctx: psa_hash_operation_s,
    /// The HMAC part of the context.
    pub private_opad: [u8; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_mac_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_mac_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_mac_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_hmac: mbedtls_psa_hmac_operation_t,
    pub private_cmac: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_aead_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_tag_length: u8,
    pub ctx: mbedtls_psa_aead_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_aead_operation_t__bindgen_ty_1 {
    pub dummy: crate::c_types::c_uint,
    pub private_ccm: mbedtls_ccm_context,
    pub private_gcm: mbedtls_gcm_context,
    pub private_chachapoly: mbedtls_chachapoly_context,
}
impl mbedtls_psa_aead_operation_t {
    #[inline]
    pub fn private_is_encrypt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_encrypt: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_sign_hash_interruptible_operation_t {
    pub private_dummy: crate::c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_verify_hash_interruptible_operation_t {
    pub private_dummy: crate::c_types::c_uint,
}
///< Client
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_CLIENT: mbedtls_ecjpake_role = 0;
///< Server
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_SERVER: mbedtls_ecjpake_role = 1;
/// Roles in the EC J-PAKE exchange
pub type mbedtls_ecjpake_role = crate::c_types::c_uint;
/// EC J-PAKE context structure.
///
/// J-PAKE is a symmetric protocol, except for the identifiers used in
/// Zero-Knowledge Proofs, and the serialization of the second message
/// (KeyExchange) as defined by the Thread spec.
///
/// In order to benefit from this symmetry, we choose a different naming
/// convention from the Thread v1.0 spec. Correspondence is indicated in the
/// description as a pair C: client name, S: server name
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecjpake_context {
    ///< Hash to use
    pub private_md_type: mbedtls_md_type_t,
    ///< Elliptic curve
    pub private_grp: mbedtls_ecp_group,
    ///< Are we client or server?
    pub private_role: mbedtls_ecjpake_role,
    ///< Format for point export
    pub private_point_format: crate::c_types::c_int,
    ///< My public key 1   C: X1, S: X3
    pub private_Xm1: mbedtls_ecp_point,
    ///< My public key 2   C: X2, S: X4
    pub private_Xm2: mbedtls_ecp_point,
    ///< Peer public key 1 C: X3, S: X1
    pub private_Xp1: mbedtls_ecp_point,
    ///< Peer public key 2 C: X4, S: X2
    pub private_Xp2: mbedtls_ecp_point,
    ///< Peer public key   C: Xs, S: Xc
    pub private_Xp: mbedtls_ecp_point,
    ///< My private key 1  C: x1, S: x3
    pub private_xm1: mbedtls_mpi,
    ///< My private key 2  C: x2, S: x4
    pub private_xm2: mbedtls_mpi,
    ///< Pre-shared secret (passphrase)
    pub private_s: mbedtls_mpi,
}
extern "C" {
    /// \brief           Initialize an ECJPAKE context.
    ///
    /// \param ctx       The ECJPAKE context to initialize.
    ///                  This must not be \c NULL.
    pub fn mbedtls_ecjpake_init(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
    /// \brief           Set up an ECJPAKE context for use.
    ///
    /// \note            Currently the only values for hash/curve allowed by the
    ///                  standard are #MBEDTLS_MD_SHA256/#MBEDTLS_ECP_DP_SECP256R1.
    ///
    /// \param ctx       The ECJPAKE context to set up. This must be initialized.
    /// \param role      The role of the caller. This must be either
    ///                  #MBEDTLS_ECJPAKE_CLIENT or #MBEDTLS_ECJPAKE_SERVER.
    /// \param hash      The identifier of the hash function to use,
    ///                  for example #MBEDTLS_MD_SHA256.
    /// \param curve     The identifier of the elliptic curve to use,
    ///                  for example #MBEDTLS_ECP_DP_SECP256R1.
    /// \param secret    The pre-shared secret (passphrase). This must be
    ///                  a readable not empty buffer of length \p len Bytes. It need
    ///                  only be valid for the duration of this call.
    /// \param len       The length of the pre-shared secret \p secret.
    ///
    /// \return          \c 0 if successful.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecjpake_setup(
        ctx: *mut mbedtls_ecjpake_context,
        role: mbedtls_ecjpake_role,
        hash: mbedtls_md_type_t,
        curve: mbedtls_ecp_group_id,
        secret: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               Set the point format for future reads and writes.
    ///
    /// \param ctx           The ECJPAKE context to configure.
    /// \param point_format  The point format to use:
    ///                      #MBEDTLS_ECP_PF_UNCOMPRESSED (default)
    ///                      or #MBEDTLS_ECP_PF_COMPRESSED.
    ///
    /// \return              \c 0 if successful.
    /// \return              #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if \p point_format
    ///                      is invalid.
    pub fn mbedtls_ecjpake_set_point_format(
        ctx: *mut mbedtls_ecjpake_context,
        point_format: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Check if an ECJPAKE context is ready for use.
    ///
    /// \param ctx       The ECJPAKE context to check. This must be
    ///                  initialized.
    ///
    /// \return          \c 0 if the context is ready for use.
    /// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA otherwise.
    pub fn mbedtls_ecjpake_check(ctx: *const mbedtls_ecjpake_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Generate and write the first round message
    ///                  (TLS: contents of the Client/ServerHello extension,
    ///                  excluding extension type and length bytes).
    ///
    /// \param ctx       The ECJPAKE context to use. This must be
    ///                  initialized and set up.
    /// \param buf       The buffer to write the contents to. This must be a
    ///                  writable buffer of length \p len Bytes.
    /// \param len       The length of \p buf in Bytes.
    /// \param olen      The address at which to store the total number
    ///                  of Bytes written to \p buf. This must not be \c NULL.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG parameter to be passed to \p f_rng. This
    ///                  may be \c NULL if \p f_rng doesn't use a context.
    ///
    /// \return          \c 0 if successful.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecjpake_write_round_one(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Read and process the first round message
    ///                  (TLS: contents of the Client/ServerHello extension,
    ///                  excluding extension type and length bytes).
    ///
    /// \param ctx       The ECJPAKE context to use. This must be initialized
    ///                  and set up.
    /// \param buf       The buffer holding the first round message. This must
    ///                  be a readable buffer of length \p len Bytes.
    /// \param len       The length in Bytes of \p buf.
    ///
    /// \return          \c 0 if successful.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecjpake_read_round_one(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Generate and write the second round message
    ///                  (TLS: contents of the Client/ServerKeyExchange).
    ///
    /// \param ctx       The ECJPAKE context to use. This must be initialized,
    ///                  set up, and already have performed round one.
    /// \param buf       The buffer to write the round two contents to.
    ///                  This must be a writable buffer of length \p len Bytes.
    /// \param len       The size of \p buf in Bytes.
    /// \param olen      The address at which to store the total number of Bytes
    ///                  written to \p buf. This must not be \c NULL.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG parameter to be passed to \p f_rng. This
    ///                  may be \c NULL if \p f_rng doesn't use a context.
    ///
    /// \return          \c 0 if successful.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecjpake_write_round_two(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Read and process the second round message
    ///                  (TLS: contents of the Client/ServerKeyExchange).
    ///
    /// \param ctx       The ECJPAKE context to use. This must be initialized
    ///                  and set up and already have performed round one.
    /// \param buf       The buffer holding the second round message. This must
    ///                  be a readable buffer of length \p len Bytes.
    /// \param len       The length in Bytes of \p buf.
    ///
    /// \return          \c 0 if successful.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecjpake_read_round_two(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Derive the shared secret
    ///                  (TLS: Pre-Master Secret).
    ///
    /// \param ctx       The ECJPAKE context to use. This must be initialized,
    ///                  set up and have performed both round one and two.
    /// \param buf       The buffer to write the derived secret to. This must
    ///                  be a writable buffer of length \p len Bytes.
    /// \param len       The length of \p buf in Bytes.
    /// \param olen      The address at which to store the total number of Bytes
    ///                  written to \p buf. This must not be \c NULL.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG parameter to be passed to \p f_rng. This
    ///                  may be \c NULL if \p f_rng doesn't use a context.
    ///
    /// \return          \c 0 if successful.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecjpake_derive_secret(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Write the shared key material to be passed to a Key
    ///                  Derivation Function as described in RFC8236.
    ///
    /// \param ctx       The ECJPAKE context to use. This must be initialized,
    ///                  set up and have performed both round one and two.
    /// \param buf       The buffer to write the derived secret to. This must
    ///                  be a writable buffer of length \p len Bytes.
    /// \param len       The length of \p buf in Bytes.
    /// \param olen      The address at which to store the total number of bytes
    ///                  written to \p buf. This must not be \c NULL.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG parameter to be passed to \p f_rng. This
    ///                  may be \c NULL if \p f_rng doesn't use a context.
    ///
    /// \return          \c 0 if successful.
    /// \return          A negative error code on failure.
    pub fn mbedtls_ecjpake_write_shared_key(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This clears an ECJPAKE context and frees any
    ///                  embedded data structure.
    ///
    /// \param ctx       The ECJPAKE context to free. This may be \c NULL,
    ///                  in which case this function does nothing. If it is not
    ///                  \c NULL, it must point to an initialized ECJPAKE context.
    pub fn mbedtls_ecjpake_free(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
    /// \brief          Checkup routine
    ///
    /// \return         0 if successful, or 1 if a test failed
    pub fn mbedtls_ecjpake_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_pake_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_password: *mut u8,
    pub private_password_len: usize,
    pub private_role: u8,
    pub private_buffer: [u8; 336usize],
    pub private_buffer_length: usize,
    pub private_buffer_offset: usize,
    pub private_ctx: mbedtls_psa_pake_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_pake_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_jpake: mbedtls_ecjpake_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_mac_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_mac_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_aead_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_aead_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_sign_hash_interruptible_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_sign_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_verify_hash_interruptible_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_verify_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_pake_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_pake_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_mac_operation_s {
    /// Unique ID indicating which driver got assigned to do the
    /// operation. Since driver contexts are driver-specific, swapping
    /// drivers halfway through the operation is not supported.
    /// ID values are auto-generated in psa_driver_wrappers.h
    /// ID value zero means the context is not valid or not assigned to
    /// any driver (i.e. none of the driver contexts are active).
    pub private_id: crate::c_types::c_uint,
    pub private_mac_size: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_mac_context_t,
}
impl psa_mac_operation_s {
    #[inline]
    pub fn private_is_sign(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_sign(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_sign: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_sign: u32 = unsafe { ::core::mem::transmute(private_is_sign) };
            private_is_sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_aead_operation_s {
    /// Unique ID indicating which driver got assigned to do the
    /// operation. Since driver contexts are driver-specific, swapping
    /// drivers halfway through the operation is not supported.
    /// ID values are auto-generated in psa_crypto_driver_wrappers.h
    /// ID value zero means the context is not valid or not assigned to
    /// any driver (i.e. none of the driver contexts are active).
    pub private_id: crate::c_types::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub private_ad_remaining: usize,
    pub private_body_remaining: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_aead_context_t,
}
impl psa_aead_operation_s {
    #[inline]
    pub fn private_nonce_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_nonce_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_lengths_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_lengths_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_ad_started(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_ad_started(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_body_started(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_body_started(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_is_encrypt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_nonce_set: crate::c_types::c_uint,
        private_lengths_set: crate::c_types::c_uint,
        private_ad_started: crate::c_types::c_uint,
        private_body_started: crate::c_types::c_uint,
        private_is_encrypt: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_nonce_set: u32 = unsafe { ::core::mem::transmute(private_nonce_set) };
            private_nonce_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_lengths_set: u32 = unsafe { ::core::mem::transmute(private_lengths_set) };
            private_lengths_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_ad_started: u32 = unsafe { ::core::mem::transmute(private_ad_started) };
            private_ad_started as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let private_body_started: u32 = unsafe { ::core::mem::transmute(private_body_started) };
            private_body_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hkdf_key_derivation_t {
    pub private_info: *mut u8,
    pub private_info_length: usize,
    pub private_offset_in_block: u8,
    pub private_block_number: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_output_block: [u8; 64usize],
    pub private_prk: [u8; 64usize],
    pub private_hmac: psa_mac_operation_s,
}
impl psa_hkdf_key_derivation_t {
    #[inline]
    pub fn private_state(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_private_state(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn private_info_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_info_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_state: crate::c_types::c_uint,
        private_info_set: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let private_state: u32 = unsafe { ::core::mem::transmute(private_state) };
            private_state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_info_set: u32 = unsafe { ::core::mem::transmute(private_info_set) };
            private_info_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_tls12_ecjpake_to_pms_t {
    pub private_data: [u8; 32usize],
}
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_INIT:
    psa_tls12_prf_key_derivation_state_t = 0;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_SEED_SET:
    psa_tls12_prf_key_derivation_state_t = 1;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OTHER_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 2;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 3;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_LABEL_SET:
    psa_tls12_prf_key_derivation_state_t = 4;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OUTPUT:
    psa_tls12_prf_key_derivation_state_t = 5;
pub type psa_tls12_prf_key_derivation_state_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_tls12_prf_key_derivation_s {
    pub private_left_in_block: u8,
    pub private_block_number: u8,
    pub private_state: psa_tls12_prf_key_derivation_state_t,
    pub private_secret: *mut u8,
    pub private_secret_length: usize,
    pub private_seed: *mut u8,
    pub private_seed_length: usize,
    pub private_label: *mut u8,
    pub private_label_length: usize,
    pub private_other_secret: *mut u8,
    pub private_other_secret_length: usize,
    pub private_Ai: [u8; 64usize],
    pub private_output_block: [u8; 64usize],
}
pub type psa_tls12_prf_key_derivation_t = psa_tls12_prf_key_derivation_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_derivation_s {
    pub private_alg: psa_algorithm_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_capacity: usize,
    pub private_ctx: psa_key_derivation_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_key_derivation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_hkdf: psa_hkdf_key_derivation_t,
    pub private_tls12_prf: psa_tls12_prf_key_derivation_t,
    pub private_tls12_ecjpake_to_pms: psa_tls12_ecjpake_to_pms_t,
}
impl psa_key_derivation_s {
    #[inline]
    pub fn private_can_output_key(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_can_output_key(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_can_output_key: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_can_output_key: u32 =
                unsafe { ::core::mem::transmute(private_can_output_key) };
            private_can_output_key as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_policy_s {
    pub private_usage: psa_key_usage_t,
    pub private_alg: psa_algorithm_t,
    pub private_alg2: psa_algorithm_t,
}
pub type psa_key_policy_t = psa_key_policy_s;
pub type psa_key_bits_t = u16;
/// A mask of flags that can be stored in key attributes.
///
/// This type is also used internally to store flags in slots. Internal
/// flags are defined in library/psa_crypto_core.h. Internal flags may have
/// the same value as external flags if they are properly handled during
/// key creation and in psa_get_key_attributes.
pub type psa_key_attributes_flag_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_core_key_attributes_t {
    pub private_type: psa_key_type_t,
    pub private_bits: psa_key_bits_t,
    pub private_lifetime: psa_key_lifetime_t,
    pub private_id: mbedtls_svc_key_id_t,
    pub private_policy: psa_key_policy_t,
    pub private_flags: psa_key_attributes_flag_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_attributes_s {
    pub private_core: psa_core_key_attributes_t,
    pub private_domain_parameters: *mut crate::c_types::c_void,
    pub private_domain_parameters_size: usize,
}
extern "C" {
    /// \brief Set domain parameters for a key.
    ///
    /// Some key types require additional domain parameters in addition to
    /// the key type identifier and the key size. Use this function instead
    /// of psa_set_key_type() when you need to specify domain parameters.
    ///
    /// The format for the required domain parameters varies based on the key type.
    ///
    /// - For RSA keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY or #PSA_KEY_TYPE_RSA_KEY_PAIR),
    ///   the domain parameter data consists of the public exponent,
    ///   represented as a big-endian integer with no leading zeros.
    ///   This information is used when generating an RSA key pair.
    ///   When importing a key, the public exponent is read from the imported
    ///   key data and the exponent recorded in the attribute structure is ignored.
    ///   As an exception, the public exponent 65537 is represented by an empty
    ///   byte string.
    /// - For DSA keys (#PSA_KEY_TYPE_DSA_PUBLIC_KEY or #PSA_KEY_TYPE_DSA_KEY_PAIR),
    ///   the `Dss-Params` format as defined by RFC 3279 &sect;2.3.2.
    ///   ```
    ///   Dss-Params ::= SEQUENCE  {
    ///      p       INTEGER,
    ///      q       INTEGER,
    ///      g       INTEGER
    ///   }
    ///   ```
    /// - For Diffie-Hellman key exchange keys
    ///   (#PSA_KEY_TYPE_DH_PUBLIC_KEY(#PSA_DH_FAMILY_CUSTOM) or
    ///   #PSA_KEY_TYPE_DH_KEY_PAIR(#PSA_DH_FAMILY_CUSTOM)), the
    ///   `DomainParameters` format as defined by RFC 3279 &sect;2.3.3.
    ///   ```
    ///   DomainParameters ::= SEQUENCE {
    ///      p               INTEGER,                    -- odd prime, p=jq +1
    ///      g               INTEGER,                    -- generator, g
    ///      q               INTEGER,                    -- factor of p-1
    ///      j               INTEGER OPTIONAL,           -- subgroup factor
    ///      validationParams ValidationParams OPTIONAL
    ///   }
    ///   ValidationParams ::= SEQUENCE {
    ///      seed            BIT STRING,
    ///      pgenCounter     INTEGER
    ///   }
    ///   ```
    ///
    /// \note This function may allocate memory or other resources.
    ///       Once you have called this function on an attribute structure,
    ///       you must call psa_reset_key_attributes() to free these resources.
    ///
    /// \note This is an experimental extension to the interface. It may change
    ///       in future versions of the library.
    ///
    /// \param[in,out] attributes    Attribute structure where the specified domain
    ///                              parameters will be stored.
    ///                              If this function fails, the content of
    ///                              \p attributes is not modified.
    /// \param type                  Key type (a \c PSA_KEY_TYPE_XXX value).
    /// \param[in] data              Buffer containing the key domain parameters.
    ///                              The content of this buffer is interpreted
    ///                              according to \p type as described above.
    /// \param data_length           Size of the \p data buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
    /// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    pub fn psa_set_key_domain_parameters(
        attributes: *mut psa_key_attributes_t,
        type_: psa_key_type_t,
        data: *const u8,
        data_length: usize,
    ) -> psa_status_t;
}
/// \brief The context for PSA interruptible hash signing.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_sign_hash_interruptible_operation_s {
    /// Unique ID indicating which driver got assigned to do the
    /// operation. Since driver contexts are driver-specific, swapping
    /// drivers halfway through the operation is not supported.
    /// ID values are auto-generated in psa_crypto_driver_wrappers.h
    /// ID value zero means the context is not valid or not assigned to
    /// any driver (i.e. none of the driver contexts are active).
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_sign_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_sign_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
/// \brief The context for PSA interruptible hash verification.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_verify_hash_interruptible_operation_s {
    /// Unique ID indicating which driver got assigned to do the
    /// operation. Since driver contexts are driver-specific, swapping
    /// drivers halfway through the operation is not supported.
    /// ID values are auto-generated in psa_crypto_driver_wrappers.h
    /// ID value zero means the context is not valid or not assigned to
    /// any driver (i.e. none of the driver contexts are active).
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_verify_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_verify_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type psa_key_handle_t = mbedtls_svc_key_id_t;
extern "C" {
    /// Open a handle to an existing persistent key.
    ///
    /// Open a handle to a persistent key. A key is persistent if it was created
    /// with a lifetime other than #PSA_KEY_LIFETIME_VOLATILE. A persistent key
    /// always has a nonzero key identifier, set with psa_set_key_id() when
    /// creating the key. Implementations may provide additional pre-provisioned
    /// keys that can be opened with psa_open_key(). Such keys have an application
    /// key identifier in the vendor range, as documented in the description of
    /// #psa_key_id_t.
    ///
    /// The application must eventually close the handle with psa_close_key() or
    /// psa_destroy_key() to release associated resources. If the application dies
    /// without calling one of these functions, the implementation should perform
    /// the equivalent of a call to psa_close_key().
    ///
    /// Some implementations permit an application to open the same key multiple
    /// times. If this is successful, each call to psa_open_key() will return a
    /// different key handle.
    ///
    /// \note This API is not part of the PSA Cryptography API Release 1.0.0
    /// specification. It was defined in the 1.0 Beta 3 version of the
    /// specification but was removed in the 1.0.0 released version. This API is
    /// kept for the time being to not break applications relying on it. It is not
    /// deprecated yet but will be in the near future.
    ///
    /// \note Applications that rely on opening a key multiple times will not be
    /// portable to implementations that only permit a single key handle to be
    /// opened. See also :ref:\`key-handles\`.
    ///
    ///
    /// \param key           The persistent identifier of the key.
    /// \param[out] handle   On success, a handle to the key.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success. The application can now use the value of `*handle`
    ///         to access the key.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY
    ///         The implementation does not have sufficient resources to open the
    ///         key. This can be due to reaching an implementation limit on the
    ///         number of open keys, the number of open key handles, or available
    ///         memory.
    /// \retval #PSA_ERROR_DOES_NOT_EXIST
    ///         There is no persistent key with key identifier \p key.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p key is not a valid persistent key identifier.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The specified key exists, but the application does not have the
    ///         permission to access it. Note that this specification does not
    ///         define any way to create such a key, but it may be possible
    ///         through implementation-specific means.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_open_key(key: mbedtls_svc_key_id_t, handle: *mut psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    /// Close a key handle.
    ///
    /// If the handle designates a volatile key, this will destroy the key material
    /// and free all associated resources, just like psa_destroy_key().
    ///
    /// If this is the last open handle to a persistent key, then closing the handle
    /// will free all resources associated with the key in volatile memory. The key
    /// data in persistent storage is not affected and can be opened again later
    /// with a call to psa_open_key().
    ///
    /// Closing the key handle makes the handle invalid, and the key handle
    /// must not be used again by the application.
    ///
    /// \note This API is not part of the PSA Cryptography API Release 1.0.0
    /// specification. It was defined in the 1.0 Beta 3 version of the
    /// specification but was removed in the 1.0.0 released version. This API is
    /// kept for the time being to not break applications relying on it. It is not
    /// deprecated yet but will be in the near future.
    ///
    /// \note If the key handle was used to set up an active
    /// :ref:\`multipart operation <multipart-operations>\`, then closing the
    /// key handle can cause the multipart operation to fail. Applications should
    /// maintain the key handle until after the multipart operation has finished.
    ///
    /// \param handle        The key handle to close.
    ///                      If this is \c 0, do nothing and return \c PSA_SUCCESS.
    ///
    /// \retval #PSA_SUCCESS
    ///         \p handle was a valid handle or \c 0. It is now closed.
    /// \retval #PSA_ERROR_INVALID_HANDLE
    ///         \p handle is not a valid handle nor \c 0.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_close_key(handle: psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    /// \brief Library deinitialization.
    ///
    /// This function clears all data associated with the PSA layer,
    /// including the whole key store.
    ///
    /// This is an Mbed TLS extension.
    pub fn mbedtls_psa_crypto_free();
}
/// \brief Statistics about
/// resource consumption related to the PSA keystore.
///
/// \note The content of this structure is not part of the stable API and ABI
///       of Mbed Crypto and may change arbitrarily from version to version.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_stats_s {
    /// Number of slots containing key material for a volatile key.
    pub private_volatile_slots: usize,
    /// Number of slots containing key material for a key which is in
    /// internal persistent storage.
    pub private_persistent_slots: usize,
    /// Number of slots containing a reference to a key in a
    /// secure element.
    pub private_external_slots: usize,
    /// Number of slots which are occupied, but do not contain
    /// key material yet.
    pub private_half_filled_slots: usize,
    /// Number of slots that contain cache data.
    pub private_cache_slots: usize,
    /// Number of slots that are not used for anything.
    pub private_empty_slots: usize,
    /// Number of slots that are locked.
    pub private_locked_slots: usize,
    /// Largest key id value among open keys in internal persistent storage.
    pub private_max_open_internal_key_id: psa_key_id_t,
    /// Largest key id value among open keys in secure elements.
    pub private_max_open_external_key_id: psa_key_id_t,
}
/// \brief Statistics about
/// resource consumption related to the PSA keystore.
///
/// \note The content of this structure is not part of the stable API and ABI
///       of Mbed Crypto and may change arbitrarily from version to version.
pub type mbedtls_psa_stats_t = mbedtls_psa_stats_s;
extern "C" {
    /// \brief Get statistics about
    /// resource consumption related to the PSA keystore.
    ///
    /// \note When Mbed Crypto is built as part of a service, with isolation
    ///       between the application and the keystore, the service may or
    ///       may not expose this function.
    pub fn mbedtls_psa_get_stats(stats: *mut mbedtls_psa_stats_t);
}
extern "C" {
    /// \brief Inject an initial entropy seed for the random generator into
    ///        secure storage.
    ///
    /// This function injects data to be used as a seed for the random generator
    /// used by the PSA Crypto implementation. On devices that lack a trusted
    /// entropy source (preferably a hardware random number generator),
    /// the Mbed PSA Crypto implementation uses this value to seed its
    /// random generator.
    ///
    /// On devices without a trusted entropy source, this function must be
    /// called exactly once in the lifetime of the device. On devices with
    /// a trusted entropy source, calling this function is optional.
    /// In all cases, this function may only be called before calling any
    /// other function in the PSA Crypto API, including psa_crypto_init().
    ///
    /// When this function returns successfully, it populates a file in
    /// persistent storage. Once the file has been created, this function
    /// can no longer succeed.
    ///
    /// If any error occurs, this function does not change the system state.
    /// You can call this function again after correcting the reason for the
    /// error if possible.
    ///
    /// \warning This function **can** fail! Callers MUST check the return status.
    ///
    /// \warning If you use this function, you should use it as part of a
    ///          factory provisioning process. The value of the injected seed
    ///          is critical to the security of the device. It must be
    ///          *secret*, *unpredictable* and (statistically) *unique per device*.
    ///          You should be generate it randomly using a cryptographically
    ///          secure random generator seeded from trusted entropy sources.
    ///          You should transmit it securely to the device and ensure
    ///          that its value is not leaked or stored anywhere beyond the
    ///          needs of transmitting it from the point of generation to
    ///          the call of this function, and erase all copies of the value
    ///          once this function returns.
    ///
    /// This is an Mbed TLS extension.
    ///
    /// \note This function is only available on the following platforms:
    /// * If the compile-time option MBEDTLS_PSA_INJECT_ENTROPY is enabled.
    ///   Note that you must provide compatible implementations of
    ///   mbedtls_nv_seed_read and mbedtls_nv_seed_write.
    /// * In a client-server integration of PSA Cryptography, on the client side,
    ///   if the server supports this feature.
    /// \param[in] seed          Buffer containing the seed value to inject.
    /// \param[in] seed_size     Size of the \p seed buffer.
    ///                          The size of the seed in bytes must be greater
    ///                          or equal to both #MBEDTLS_ENTROPY_BLOCK_SIZE
    ///                          and the value of \c MBEDTLS_ENTROPY_MIN_PLATFORM
    ///                          in `library/entropy_poll.h` in the Mbed TLS source
    ///                          code.
    ///                          It must be less or equal to
    ///                          #MBEDTLS_ENTROPY_MAX_SEED_SIZE.
    ///
    /// \retval #PSA_SUCCESS
    ///         The seed value was injected successfully. The random generator
    ///         of the PSA Crypto implementation is now ready for use.
    ///         You may now call psa_crypto_init() and use the PSA Crypto
    ///         implementation.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p seed_size is out of range.
    /// \retval #PSA_ERROR_STORAGE_FAILURE
    ///         There was a failure reading or writing from storage.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The library has already been initialized. It is no longer
    ///         possible to call this function.
    pub fn mbedtls_psa_inject_entropy(seed: *const u8, seed_size: usize) -> psa_status_t;
}
extern "C" {
    /// \brief Get domain parameters for a key.
    ///
    /// Get the domain parameters for a key with this function, if any. The format
    /// of the domain parameters written to \p data is specified in the
    /// documentation for psa_set_key_domain_parameters().
    ///
    /// \note This is an experimental extension to the interface. It may change
    ///       in future versions of the library.
    ///
    /// \param[in] attributes        The key attribute structure to query.
    /// \param[out] data             On success, the key domain parameters.
    /// \param data_size             Size of the \p data buffer in bytes.
    ///                              The buffer is guaranteed to be large
    ///                              enough if its size in bytes is at least
    ///                              the value given by
    ///                              PSA_KEY_DOMAIN_PARAMETERS_SIZE().
    /// \param[out] data_length      On success, the number of bytes
    ///                              that make up the key domain parameters data.
    ///
    /// \retval #PSA_SUCCESS \emptydescription
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL \emptydescription
    pub fn psa_get_key_domain_parameters(
        attributes: *const psa_key_attributes_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Convert an ECC curve identifier from the PSA encoding to Mbed TLS.
    ///
    /// \note This function is provided solely for the convenience of
    ///       Mbed TLS and may be removed at any time without notice.
    ///
    /// \param curve         A PSA elliptic curve identifier
    ///                      (`PSA_ECC_FAMILY_xxx`).
    /// \param bits          The bit-length of a private key on \p curve.
    /// \param bits_is_sloppy If true, \p bits may be the bit-length rounded up
    ///                      to the nearest multiple of 8. This allows the caller
    ///                      to infer the exact curve from the length of a key
    ///                      which is supplied as a byte string.
    ///
    /// \return              The corresponding Mbed TLS elliptic curve identifier
    ///                      (`MBEDTLS_ECP_DP_xxx`).
    /// \return              #MBEDTLS_ECP_DP_NONE if \c curve is not recognized.
    /// \return              #MBEDTLS_ECP_DP_NONE if \p bits is not
    ///                      correct for \p curve.
    pub fn mbedtls_ecc_group_of_psa(
        curve: psa_ecc_family_t,
        bits: usize,
        bits_is_sloppy: crate::c_types::c_int,
    ) -> mbedtls_ecp_group_id;
}
extern "C" {
    /// External random generator function, implemented by the platform.
    ///
    /// When the compile-time option #MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG is enabled,
    /// this function replaces Mbed TLS's entropy and DRBG modules for all
    /// random generation triggered via PSA crypto interfaces.
    ///
    /// \note This random generator must deliver random numbers with cryptographic
    ///       quality and high performance. It must supply unpredictable numbers
    ///       with a uniform distribution. The implementation of this function
    ///       is responsible for ensuring that the random generator is seeded
    ///       with sufficient entropy. If you have a hardware TRNG which is slow
    ///       or delivers non-uniform output, declare it as an entropy source
    ///       with mbedtls_entropy_add_source() instead of enabling this option.
    ///
    /// \param[in,out] context       Pointer to the random generator context.
    ///                              This is all-bits-zero on the first call
    ///                              and preserved between successive calls.
    /// \param[out] output           Output buffer. On success, this buffer
    ///                              contains random data with a uniform
    ///                              distribution.
    /// \param output_size           The size of the \p output buffer in bytes.
    /// \param[out] output_length    On success, set this value to \p output_size.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success. The output buffer contains \p output_size bytes of
    ///         cryptographic-quality random data, and \c *output_length is
    ///         set to \p output_size.
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY
    ///         The random generator requires extra entropy and there is no
    ///         way to obtain entropy under current environment conditions.
    ///         This error should not happen under normal circumstances since
    ///         this function is responsible for obtaining as much entropy as
    ///         it needs. However implementations of this function may return
    ///         #PSA_ERROR_INSUFFICIENT_ENTROPY if there is no way to obtain
    ///         entropy without blocking indefinitely.
    /// \retval #PSA_ERROR_HARDWARE_FAILURE
    ///         A failure of the random generator hardware that isn't covered
    ///         by #PSA_ERROR_INSUFFICIENT_ENTROPY.
    pub fn mbedtls_psa_external_get_random(
        context: *mut mbedtls_psa_external_random_context_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
/// A slot number identifying a key in a driver.
///
/// Values of this type are used to identify built-in keys.
pub type psa_drv_slot_number_t = u64;
/// \brief Encoding of the application role of PAKE
///
/// Encodes the application's role in the algorithm is being executed. For more
/// information see the documentation of individual \c PSA_PAKE_ROLE_XXX
/// constants.
pub type psa_pake_role_t = u8;
/// Encoding of input and output indicators for PAKE.
///
/// Some PAKE algorithms need to exchange more data than just a single key share.
/// This type is for encoding additional input and output data for such
/// algorithms.
pub type psa_pake_step_t = u8;
/// Encoding of the type of the PAKE's primitive.
///
/// Values defined by this standard will never be in the range 0x80-0xff.
/// Vendors who define additional types must use an encoding in this range.
///
/// For more information see the documentation of individual
/// \c PSA_PAKE_PRIMITIVE_TYPE_XXX constants.
pub type psa_pake_primitive_type_t = u8;
/// \brief Encoding of the family of the primitive associated with the PAKE.
///
/// For more information see the documentation of individual
/// \c PSA_PAKE_PRIMITIVE_TYPE_XXX constants.
pub type psa_pake_family_t = u8;
/// \brief Encoding of the primitive associated with the PAKE.
///
/// For more information see the documentation of the #PSA_PAKE_PRIMITIVE macro.
pub type psa_pake_primitive_t = u32;
/// The type of the data structure for PAKE cipher suites.
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_pake_cipher_suite_t = psa_pake_cipher_suite_s;
/// The type of the state data structure for PAKE operations.
///
/// Before calling any function on a PAKE operation object, the application
/// must initialize it by any of the following means:
/// - Set the structure to all-bits-zero, for example:
///   \code
///   psa_pake_operation_t operation;
///   memset(&operation, 0, sizeof(operation));
///   \endcode
/// - Initialize the structure to logical zero values, for example:
///   \code
///   psa_pake_operation_t operation = {0};
///   \endcode
/// - Initialize the structure to the initializer #PSA_PAKE_OPERATION_INIT,
///   for example:
///   \code
///   psa_pake_operation_t operation = PSA_PAKE_OPERATION_INIT;
///   \endcode
/// - Assign the result of the function psa_pake_operation_init()
///   to the structure, for example:
///   \code
///   psa_pake_operation_t operation;
///   operation = psa_pake_operation_init();
///   \endcode
///
/// This is an implementation-defined \c struct. Applications should not
/// make any assumptions about the content of this structure.
/// Implementation details can change in future versions without notice.
pub type psa_pake_operation_t = psa_pake_operation_s;
/// The type of input values for PAKE operations.
pub type psa_crypto_driver_pake_inputs_t = psa_crypto_driver_pake_inputs_s;
/// The type of computation stage for J-PAKE operations.
pub type psa_jpake_computation_stage_t = psa_jpake_computation_stage_s;
extern "C" {
    /// Get the length of the password in bytes from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] password_len     Password length.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Password hasn't been set yet.
    pub fn psa_crypto_driver_pake_get_password_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        password_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Get the password from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] buffer           Return buffer for password.
    /// \param      buffer_size      Size of the return buffer in bytes.
    /// \param[out] buffer_length    Actual size of the password in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Password hasn't been set yet.
    pub fn psa_crypto_driver_pake_get_password(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        buffer: *mut u8,
        buffer_size: usize,
        buffer_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Get the role from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] role             Return buffer for role.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Role hasn't been set yet.
    pub fn psa_crypto_driver_pake_get_role(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        role: *mut psa_pake_role_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Get the length of the user id in bytes from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] user_len         User id length.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         User id hasn't been set yet.
    pub fn psa_crypto_driver_pake_get_user_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        user_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Get the length of the peer id in bytes from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] peer_len         Peer id length.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Peer id hasn't been set yet.
    pub fn psa_crypto_driver_pake_get_peer_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        peer_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Get the user id from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] user_id          User id.
    /// \param      user_id_size     Size of \p user_id in bytes.
    /// \param[out] user_id_len      Size of the user id in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         User id hasn't been set yet.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p user_id is too small.
    pub fn psa_crypto_driver_pake_get_user(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        user_id: *mut u8,
        user_id_size: usize,
        user_id_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Get the peer id from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] peer_id          Peer id.
    /// \param      peer_id_size     Size of \p peer_id in bytes.
    /// \param[out] peer_id_length   Size of the peer id in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Peer id hasn't been set yet.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p peer_id is too small.
    pub fn psa_crypto_driver_pake_get_peer(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        peer_id: *mut u8,
        peer_id_size: usize,
        peer_id_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Get the cipher suite from given inputs.
    ///
    /// \param[in]  inputs           Operation inputs.
    /// \param[out] cipher_suite     Return buffer for role.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Cipher_suite hasn't been set yet.
    pub fn psa_crypto_driver_pake_get_cipher_suite(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        cipher_suite: *mut psa_pake_cipher_suite_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the session information for a password-authenticated key exchange.
    ///
    /// The sequence of operations to set up a password-authenticated key exchange
    /// is as follows:
    /// -# Allocate an operation object which will be passed to all the functions
    ///    listed here.
    /// -# Initialize the operation object with one of the methods described in the
    ///    documentation for #psa_pake_operation_t, e.g.
    ///    #PSA_PAKE_OPERATION_INIT.
    /// -# Call psa_pake_setup() to specify the cipher suite.
    /// -# Call \c psa_pake_set_xxx() functions on the operation to complete the
    ///    setup. The exact sequence of \c psa_pake_set_xxx() functions that needs
    ///    to be called depends on the algorithm in use.
    ///
    /// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
    /// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
    /// for more information.
    ///
    /// A typical sequence of calls to perform a password-authenticated key
    /// exchange:
    /// -# Call psa_pake_output(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to get the
    ///    key share that needs to be sent to the peer.
    /// -# Call psa_pake_input(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to provide
    ///    the key share that was received from the peer.
    /// -# Depending on the algorithm additional calls to psa_pake_output() and
    ///    psa_pake_input() might be necessary.
    /// -# Call psa_pake_get_implicit_key() for accessing the shared secret.
    ///
    /// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
    /// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
    /// for more information.
    ///
    /// If an error occurs at any step after a call to psa_pake_setup(),
    /// the operation will need to be reset by a call to psa_pake_abort(). The
    /// application may call psa_pake_abort() at any time after the operation
    /// has been initialized.
    ///
    /// After a successful call to psa_pake_setup(), the application must
    /// eventually terminate the operation. The following events terminate an
    /// operation:
    /// - A call to psa_pake_abort().
    /// - A successful call to psa_pake_get_implicit_key().
    ///
    /// \param[in,out] operation     The operation object to set up. It must have
    ///                              been initialized but not set up yet.
    /// \param[in] cipher_suite      The cipher suite to use. (A cipher suite fully
    ///                              characterizes a PAKE algorithm and determines
    ///                              the algorithm as well.)
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The algorithm in \p cipher_suite is not a PAKE algorithm, or the
    ///         PAKE primitive in \p cipher_suite is not compatible with the
    ///         PAKE algorithm, or the hash algorithm in \p cipher_suite is invalid
    ///         or not compatible with the PAKE algorithm and primitive.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         The algorithm in \p cipher_suite is not a supported PAKE algorithm,
    ///         or the PAKE primitive in \p cipher_suite is not supported or not
    ///         compatible with the PAKE algorithm, or the hash algorithm in
    ///         \p cipher_suite is not supported or not compatible with the PAKE
    ///         algorithm and primitive.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid, or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_setup(
        operation: *mut psa_pake_operation_t,
        cipher_suite: *const psa_pake_cipher_suite_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the password for a password-authenticated key exchange from key ID.
    ///
    /// Call this function when the password, or a value derived from the password,
    /// is already present in the key store.
    ///
    /// \param[in,out] operation     The operation object to set the password for. It
    ///                              must have been set up by psa_pake_setup() and
    ///                              not yet in use (neither psa_pake_output() nor
    ///                              psa_pake_input() has been called yet). It must
    ///                              be on operation for which the password hasn't
    ///                              been set yet (psa_pake_set_password_key()
    ///                              hasn't been called yet).
    /// \param password              Identifier of the key holding the password or a
    ///                              value derived from the password (eg. by a
    ///                              memory-hard function).  It must remain valid
    ///                              until the operation terminates. It must be of
    ///                              type #PSA_KEY_TYPE_PASSWORD or
    ///                              #PSA_KEY_TYPE_PASSWORD_HASH. It has to allow
    ///                              the usage #PSA_KEY_USAGE_DERIVE.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_HANDLE
    ///         \p password is not a valid key identifier.
    /// \retval #PSA_ERROR_NOT_PERMITTED
    ///         The key does not have the #PSA_KEY_USAGE_DERIVE flag, or it does not
    ///         permit the \p operation's algorithm.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The key type for \p password is not #PSA_KEY_TYPE_PASSWORD or
    ///         #PSA_KEY_TYPE_PASSWORD_HASH, or \p password is not compatible with
    ///         the \p operation's cipher suite.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         The key type or key size of \p password is not supported with the
    ///         \p operation's cipher suite.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must have been set up.), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_set_password_key(
        operation: *mut psa_pake_operation_t,
        password: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the user ID for a password-authenticated key exchange.
    ///
    /// Call this function to set the user ID. For PAKE algorithms that associate a
    /// user identifier with each side of the session you need to call
    /// psa_pake_set_peer() as well. For PAKE algorithms that associate a single
    /// user identifier with the session, call psa_pake_set_user() only.
    ///
    /// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
    /// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
    /// for more information.
    ///
    /// \param[in,out] operation     The operation object to set the user ID for. It
    ///                              must have been set up by psa_pake_setup() and
    ///                              not yet in use (neither psa_pake_output() nor
    ///                              psa_pake_input() has been called yet). It must
    ///                              be on operation for which the user ID hasn't
    ///                              been set (psa_pake_set_user() hasn't been
    ///                              called yet).
    /// \param[in] user_id           The user ID to authenticate with.
    ///                              (temporary limitation: "client" or "server" only)
    /// \param user_id_len           Size of the \p user_id buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p user_id is not valid for the \p operation's algorithm and cipher
    ///         suite.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         The value of \p user_id is not supported by the implementation.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid, or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_set_user(
        operation: *mut psa_pake_operation_t,
        user_id: *const u8,
        user_id_len: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the peer ID for a password-authenticated key exchange.
    ///
    /// Call this function in addition to psa_pake_set_user() for PAKE algorithms
    /// that associate a user identifier with each side of the session. For PAKE
    /// algorithms that associate a single user identifier with the session, call
    /// psa_pake_set_user() only.
    ///
    /// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
    /// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
    /// for more information.
    ///
    /// \param[in,out] operation     The operation object to set the peer ID for. It
    ///                              must have been set up by psa_pake_setup() and
    ///                              not yet in use (neither psa_pake_output() nor
    ///                              psa_pake_input() has been called yet). It must
    ///                              be on operation for which the peer ID hasn't
    ///                              been set (psa_pake_set_peer() hasn't been
    ///                              called yet).
    /// \param[in] peer_id           The peer's ID to authenticate.
    ///                              (temporary limitation: "client" or "server" only)
    /// \param peer_id_len           Size of the \p peer_id buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p user_id is not valid for the \p operation's algorithm and cipher
    ///         suite.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         The algorithm doesn't associate a second identity with the session.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         Calling psa_pake_set_peer() is invalid with the \p operation's
    ///         algorithm, the operation state is not valid, or the library has not
    ///         been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_set_peer(
        operation: *mut psa_pake_operation_t,
        peer_id: *const u8,
        peer_id_len: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Set the application role for a password-authenticated key exchange.
    ///
    /// Not all PAKE algorithms need to differentiate the communicating entities.
    /// It is optional to call this function for PAKEs that don't require a role
    /// to be specified. For such PAKEs the application role parameter is ignored,
    /// or #PSA_PAKE_ROLE_NONE can be passed as \c role.
    ///
    /// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
    /// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
    /// for more information.
    ///
    /// \param[in,out] operation     The operation object to specify the
    ///                              application's role for. It must have been set up
    ///                              by psa_pake_setup() and not yet in use (neither
    ///                              psa_pake_output() nor psa_pake_input() has been
    ///                              called yet). It must be on operation for which
    ///                              the application's role hasn't been specified
    ///                              (psa_pake_set_role() hasn't been called yet).
    /// \param role                  A value of type ::psa_pake_role_t indicating the
    ///                              application's role in the PAKE the algorithm
    ///                              that is being set up. For more information see
    ///                              the documentation of \c PSA_PAKE_ROLE_XXX
    ///                              constants.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         The \p role is not a valid PAKE role in the \p operation’s algorithm.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         The \p role for this algorithm is not supported or is not valid.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid, or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_set_role(
        operation: *mut psa_pake_operation_t,
        role: psa_pake_role_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Get output for a step of a password-authenticated key exchange.
    ///
    /// Depending on the algorithm being executed, you might need to call this
    /// function several times or you might not need to call this at all.
    ///
    /// The exact sequence of calls to perform a password-authenticated key
    /// exchange depends on the algorithm in use.  Refer to the documentation of
    /// individual PAKE algorithm types (`PSA_ALG_XXX` values of type
    /// ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true) for more
    /// information.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_pake_abort().
    ///
    /// \param[in,out] operation    Active PAKE operation.
    /// \param step                 The step of the algorithm for which the output is
    ///                             requested.
    /// \param[out] output          Buffer where the output is to be written in the
    ///                             format appropriate for this \p step. Refer to
    ///                             the documentation of the individual
    ///                             \c PSA_PAKE_STEP_XXX constants for more
    ///                             information.
    /// \param output_size          Size of the \p output buffer in bytes. This must
    ///                             be at least #PSA_PAKE_OUTPUT_SIZE(\p alg, \p
    ///                             primitive, \p step) where \p alg and
    ///                             \p primitive are the PAKE algorithm and primitive
    ///                             in the operation's cipher suite, and \p step is
    ///                             the output step.
    ///
    /// \param[out] output_length   On success, the number of bytes of the returned
    ///                             output.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_BUFFER_TOO_SMALL
    ///         The size of the \p output buffer is too small.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p step is not compatible with the operation's algorithm.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p step is not supported with the operation's algorithm.
    /// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, and fully set
    ///         up, and this call must conform to the algorithm's requirements
    ///         for ordering of input and output steps), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_output(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Provide input for a step of a password-authenticated key exchange.
    ///
    /// Depending on the algorithm being executed, you might need to call this
    /// function several times or you might not need to call this at all.
    ///
    /// The exact sequence of calls to perform a password-authenticated key
    /// exchange depends on the algorithm in use.  Refer to the documentation of
    /// individual PAKE algorithm types (`PSA_ALG_XXX` values of type
    /// ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true) for more
    /// information.
    ///
    /// If this function returns an error status, the operation enters an error
    /// state and must be aborted by calling psa_pake_abort().
    ///
    /// \param[in,out] operation    Active PAKE operation.
    /// \param step                 The step for which the input is provided.
    /// \param[in] input            Buffer containing the input in the format
    ///                             appropriate for this \p step. Refer to the
    ///                             documentation of the individual
    ///                             \c PSA_PAKE_STEP_XXX constants for more
    ///                             information.
    /// \param input_length         Size of the \p input buffer in bytes.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_SIGNATURE
    ///         The verification fails for a #PSA_PAKE_STEP_ZK_PROOF input step.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         \p is not compatible with the \p operation’s algorithm, or the
    ///         \p input is not valid for the \p operation's algorithm, cipher suite
    ///         or \p step.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         \p step p is not supported with the \p operation's algorithm, or the
    ///         \p input is not supported for the \p operation's algorithm, cipher
    ///         suite or \p step.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The operation state is not valid (it must be active, and fully set
    ///         up, and this call must conform to the algorithm's requirements
    ///         for ordering of input and output steps), or
    ///         the library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_input(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    /// Get implicitly confirmed shared secret from a PAKE.
    ///
    /// At this point there is a cryptographic guarantee that only the authenticated
    /// party who used the same password is able to compute the key. But there is no
    /// guarantee that the peer is the party it claims to be and was able to do so.
    ///
    /// That is, the authentication is only implicit. Since the peer is not
    /// authenticated yet, no action should be taken yet that assumes that the peer
    /// is who it claims to be. For example, do not access restricted files on the
    /// peer's behalf until an explicit authentication has succeeded.
    ///
    /// This function can be called after the key exchange phase of the operation
    /// has completed. It imports the shared secret output of the PAKE into the
    /// provided derivation operation. The input step
    /// #PSA_KEY_DERIVATION_INPUT_SECRET is used when placing the shared key
    /// material in the key derivation operation.
    ///
    /// The exact sequence of calls to perform a password-authenticated key
    /// exchange depends on the algorithm in use.  Refer to the documentation of
    /// individual PAKE algorithm types (`PSA_ALG_XXX` values of type
    /// ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true) for more
    /// information.
    ///
    /// When this function returns successfully, \p operation becomes inactive.
    /// If this function returns an error status, both \p operation
    /// and \p key_derivation operations enter an error state and must be aborted by
    /// calling psa_pake_abort() and psa_key_derivation_abort() respectively.
    ///
    /// \param[in,out] operation    Active PAKE operation.
    /// \param[out] output          A key derivation operation that is ready
    ///                             for an input step of type
    ///                             #PSA_KEY_DERIVATION_INPUT_SECRET.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_INVALID_ARGUMENT
    ///         #PSA_KEY_DERIVATION_INPUT_SECRET is not compatible with the
    ///         algorithm in the \p output key derivation operation.
    /// \retval #PSA_ERROR_NOT_SUPPORTED
    ///         Input from a PAKE is not supported by the algorithm in the \p output
    ///         key derivation operation.
    /// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    /// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    /// \retval #PSA_ERROR_DATA_INVALID \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The PAKE operation state is not valid (it must be active, but beyond
    ///         that validity is specific to the algorithm), or
    ///         the library has not been previously initialized by psa_crypto_init(),
    ///         or the state of \p output is not valid for
    ///         the #PSA_KEY_DERIVATION_INPUT_SECRET step. This can happen if the
    ///         step is out of order or the application has done this step already
    ///         and it may not be repeated.
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_get_implicit_key(
        operation: *mut psa_pake_operation_t,
        output: *mut psa_key_derivation_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    /// Abort a PAKE operation.
    ///
    /// Aborting an operation frees all associated resources except for the \c
    /// operation structure itself. Once aborted, the operation object can be reused
    /// for another operation by calling psa_pake_setup() again.
    ///
    /// This function may be called at any time after the operation
    /// object has been initialized as described in #psa_pake_operation_t.
    ///
    /// In particular, calling psa_pake_abort() after the operation has been
    /// terminated by a call to psa_pake_abort() or psa_pake_get_implicit_key()
    /// is safe and has no effect.
    ///
    /// \param[in,out] operation    The operation to abort.
    ///
    /// \retval #PSA_SUCCESS
    ///         Success.
    /// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
    /// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
    /// \retval #PSA_ERROR_BAD_STATE
    ///         The library has not been previously initialized by psa_crypto_init().
    ///         It is implementation-dependent whether a failure to initialize
    ///         results in this error code.
    pub fn psa_pake_abort(operation: *mut psa_pake_operation_t) -> psa_status_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_cipher_suite_s {
    pub algorithm: psa_algorithm_t,
    pub type_: psa_pake_primitive_type_t,
    pub family: psa_pake_family_t,
    pub bits: u16,
    pub hash: psa_algorithm_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_crypto_driver_pake_inputs_s {
    pub private_password: *mut u8,
    pub private_password_len: usize,
    pub private_role: psa_pake_role_t,
    pub private_user: *mut u8,
    pub private_user_len: usize,
    pub private_peer: *mut u8,
    pub private_peer_len: usize,
    pub private_attributes: psa_key_attributes_t,
    pub private_cipher_suite: psa_pake_cipher_suite_t,
}
pub const psa_jpake_step_PSA_PAKE_STEP_INVALID: psa_jpake_step = 0;
pub const psa_jpake_step_PSA_PAKE_STEP_X1_X2: psa_jpake_step = 1;
pub const psa_jpake_step_PSA_PAKE_STEP_X2S: psa_jpake_step = 2;
pub const psa_jpake_step_PSA_PAKE_STEP_DERIVE: psa_jpake_step = 3;
pub type psa_jpake_step = crate::c_types::c_uint;
pub use self::psa_jpake_step as psa_jpake_step_t;
pub const psa_jpake_state_PSA_PAKE_STATE_INVALID: psa_jpake_state = 0;
pub const psa_jpake_state_PSA_PAKE_STATE_SETUP: psa_jpake_state = 1;
pub const psa_jpake_state_PSA_PAKE_STATE_READY: psa_jpake_state = 2;
pub const psa_jpake_state_PSA_PAKE_OUTPUT_X1_X2: psa_jpake_state = 3;
pub const psa_jpake_state_PSA_PAKE_OUTPUT_X2S: psa_jpake_state = 4;
pub const psa_jpake_state_PSA_PAKE_INPUT_X1_X2: psa_jpake_state = 5;
pub const psa_jpake_state_PSA_PAKE_INPUT_X4S: psa_jpake_state = 6;
pub type psa_jpake_state = crate::c_types::c_uint;
pub use self::psa_jpake_state as psa_jpake_state_t;
pub const psa_jpake_sequence_PSA_PAKE_SEQ_INVALID: psa_jpake_sequence = 0;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_KEY_SHARE: psa_jpake_sequence = 1;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_ZK_PUBLIC: psa_jpake_sequence = 2;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_ZK_PROOF: psa_jpake_sequence = 3;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_KEY_SHARE: psa_jpake_sequence = 4;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_ZK_PUBLIC: psa_jpake_sequence = 5;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_ZK_PROOF: psa_jpake_sequence = 6;
pub const psa_jpake_sequence_PSA_PAKE_SEQ_END: psa_jpake_sequence = 7;
pub type psa_jpake_sequence = crate::c_types::c_uint;
pub use self::psa_jpake_sequence as psa_jpake_sequence_t;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_STEP_INVALID: psa_crypto_driver_pake_step = 0;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 1;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 2;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 3;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 4;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 5;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 6;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 7;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 8;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 9;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_KEY_SHARE: psa_crypto_driver_pake_step =
    10;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step =
    11;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 12;
pub type psa_crypto_driver_pake_step = crate::c_types::c_uint;
pub use self::psa_crypto_driver_pake_step as psa_crypto_driver_pake_step_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_jpake_computation_stage_s {
    pub private_state: psa_jpake_state_t,
    pub private_sequence: psa_jpake_sequence_t,
    pub private_input_step: psa_jpake_step_t,
    pub private_output_step: psa_jpake_step_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_operation_s {
    /// Unique ID indicating which driver got assigned to do the
    /// operation. Since driver contexts are driver-specific, swapping
    /// drivers halfway through the operation is not supported.
    /// ID values are auto-generated in psa_crypto_driver_wrappers.h
    /// ID value zero means the context is not valid or not assigned to
    /// any driver (i.e. none of the driver contexts are active).
    pub private_id: crate::c_types::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_stage: u8,
    pub private_computation_stage: psa_pake_operation_s__bindgen_ty_1,
    pub private_data: psa_pake_operation_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_jpake: psa_jpake_computation_stage_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_2 {
    pub private_ctx: psa_driver_pake_context_t,
    pub private_inputs: psa_crypto_driver_pake_inputs_t,
}
/// Type-length-value structure that allows for ASN1 using DER.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_buf {
    ///< ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING.
    pub tag: crate::c_types::c_int,
    ///< ASN1 length, in octets.
    pub len: usize,
    ///< ASN1 data, e.g. in ASCII.
    pub p: *mut crate::c_types::c_uchar,
}
/// Container for ASN1 bit strings.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_bitstring {
    ///< ASN1 length, in octets.
    pub len: usize,
    ///< Number of unused bits at the end of the string
    pub unused_bits: crate::c_types::c_uchar,
    ///< Raw ASN1 data for the bit string
    pub p: *mut crate::c_types::c_uchar,
}
/// Container for a sequence of ASN.1 items
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_sequence {
    ///< Buffer containing the given ASN.1 item.
    pub buf: mbedtls_asn1_buf,
    /// The next entry in the sequence.
    ///
    /// The details of memory management for sequences are not documented and
    /// may change in future versions. Set this field to \p NULL when
    /// initializing a structure, and do not modify it except via Mbed TLS
    /// library functions.
    pub next: *mut mbedtls_asn1_sequence,
}
/// Container for a sequence or list of 'named' ASN.1 data items
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_named_data {
    ///< The object identifier.
    pub oid: mbedtls_asn1_buf,
    ///< The named value.
    pub val: mbedtls_asn1_buf,
    /// The next entry in the sequence.
    ///
    /// The details of memory management for named data sequences are not
    /// documented and may change in future versions. Set this field to \p NULL
    /// when initializing a structure, and do not modify it except via Mbed TLS
    /// library functions.
    pub next: *mut mbedtls_asn1_named_data,
    /// Merge next item into the current one?
    ///
    /// This field exists for the sake of Mbed TLS's X.509 certificate parsing
    /// code and may change in future versions of the library.
    pub private_next_merged: crate::c_types::c_uchar,
}
extern "C" {
    /// \brief       Get the length of an ASN.1 element.
    ///              Updates the pointer to immediately behind the length.
    ///
    /// \param p     On entry, \c *p points to the first byte of the length,
    ///              i.e. immediately after the tag.
    ///              On successful completion, \c *p points to the first byte
    ///              after the length, i.e. the first byte of the content.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param len   On successful completion, \c *len contains the length
    ///              read from the ASN.1 input.
    ///
    /// \return      0 if successful.
    /// \return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element
    ///              would end beyond \p end.
    /// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable.
    pub fn mbedtls_asn1_get_len(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Get the tag and length of the element.
    ///              Check for the requested tag.
    ///              Updates the pointer to immediately behind the tag and length.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              after the length, i.e. the first byte of the content.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param len   On successful completion, \c *len contains the length
    ///              read from the ASN.1 input.
    /// \param tag   The expected tag.
    ///
    /// \return      0 if successful.
    /// \return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the data does not start
    ///              with the requested tag.
    /// \return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element
    ///              would end beyond \p end.
    /// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable.
    pub fn mbedtls_asn1_get_tag(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut usize,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve a boolean ASN.1 tag and its value.
    ///              Updates the pointer to immediately behind the full tag.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              beyond the ASN.1 element.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param val   On success, the parsed value (\c 0 or \c 1).
    ///
    /// \return      0 if successful.
    /// \return      An ASN.1 error code if the input does not start with
    ///              a valid ASN.1 BOOLEAN.
    pub fn mbedtls_asn1_get_bool(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve an integer ASN.1 tag and its value.
    ///              Updates the pointer to immediately behind the full tag.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              beyond the ASN.1 element.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param val   On success, the parsed value.
    ///
    /// \return      0 if successful.
    /// \return      An ASN.1 error code if the input does not start with
    ///              a valid ASN.1 INTEGER.
    /// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does
    ///              not fit in an \c int.
    pub fn mbedtls_asn1_get_int(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve an enumerated ASN.1 tag and its value.
    ///              Updates the pointer to immediately behind the full tag.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              beyond the ASN.1 element.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param val   On success, the parsed value.
    ///
    /// \return      0 if successful.
    /// \return      An ASN.1 error code if the input does not start with
    ///              a valid ASN.1 ENUMERATED.
    /// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does
    ///              not fit in an \c int.
    pub fn mbedtls_asn1_get_enum(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve a bitstring ASN.1 tag and its value.
    ///              Updates the pointer to immediately behind the full tag.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p is equal to \p end.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param bs    On success, ::mbedtls_asn1_bitstring information about
    ///              the parsed value.
    ///
    /// \return      0 if successful.
    /// \return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains
    ///              extra data after a valid BIT STRING.
    /// \return      An ASN.1 error code if the input does not start with
    ///              a valid ASN.1 BIT STRING.
    pub fn mbedtls_asn1_get_bitstring(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        bs: *mut mbedtls_asn1_bitstring,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve a bitstring ASN.1 tag without unused bits and its
    ///              value.
    ///              Updates the pointer to the beginning of the bit/octet string.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              of the content of the BIT STRING.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param len   On success, \c *len is the length of the content in bytes.
    ///
    /// \return      0 if successful.
    /// \return      #MBEDTLS_ERR_ASN1_INVALID_DATA if the input starts with
    ///              a valid BIT STRING with a nonzero number of unused bits.
    /// \return      An ASN.1 error code if the input does not start with
    ///              a valid ASN.1 BIT STRING.
    pub fn mbedtls_asn1_get_bitstring_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Parses and splits an ASN.1 "SEQUENCE OF <tag>".
    ///              Updates the pointer to immediately behind the full sequence tag.
    ///
    /// This function allocates memory for the sequence elements. You can free
    /// the allocated memory with mbedtls_asn1_sequence_free().
    ///
    /// \note        On error, this function may return a partial list in \p cur.
    ///              You must set `cur->next = NULL` before calling this function!
    ///              Otherwise it is impossible to distinguish a previously non-null
    ///              pointer from a pointer to an object allocated by this function.
    ///
    /// \note        If the sequence is empty, this function does not modify
    ///              \c *cur. If the sequence is valid and non-empty, this
    ///              function sets `cur->buf.tag` to \p tag. This allows
    ///              callers to distinguish between an empty sequence and
    ///              a one-element sequence.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p is equal to \p end.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param cur   A ::mbedtls_asn1_sequence which this function fills.
    ///              When this function returns, \c *cur is the head of a linked
    ///              list. Each node in this list is allocated with
    ///              mbedtls_calloc() apart from \p cur itself, and should
    ///              therefore be freed with mbedtls_free().
    ///              The list describes the content of the sequence.
    ///              The head of the list (i.e. \c *cur itself) describes the
    ///              first element, `*cur->next` describes the second element, etc.
    ///              For each element, `buf.tag == tag`, `buf.len` is the length
    ///              of the content of the content of the element, and `buf.p`
    ///              points to the first byte of the content (i.e. immediately
    ///              past the length of the element).
    ///              Note that list elements may be allocated even on error.
    /// \param tag   Each element of the sequence must have this tag.
    ///
    /// \return      0 if successful.
    /// \return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains
    ///              extra data after a valid SEQUENCE OF \p tag.
    /// \return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts with
    ///              an ASN.1 SEQUENCE in which an element has a tag that
    ///              is different from \p tag.
    /// \return      #MBEDTLS_ERR_ASN1_ALLOC_FAILED if a memory allocation failed.
    /// \return      An ASN.1 error code if the input does not start with
    ///              a valid ASN.1 SEQUENCE.
    pub fn mbedtls_asn1_get_sequence_of(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        cur: *mut mbedtls_asn1_sequence,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Free a heap-allocated linked list presentation of
    ///                 an ASN.1 sequence, including the first element.
    ///
    /// There are two common ways to manage the memory used for the representation
    /// of a parsed ASN.1 sequence:
    /// - Allocate a head node `mbedtls_asn1_sequence *head` with mbedtls_calloc().
    ///   Pass this node as the `cur` argument to mbedtls_asn1_get_sequence_of().
    ///   When you have finished processing the sequence,
    ///   call mbedtls_asn1_sequence_free() on `head`.
    /// - Allocate a head node `mbedtls_asn1_sequence *head` in any manner,
    ///   for example on the stack. Make sure that `head->next == NULL`.
    ///   Pass `head` as the `cur` argument to mbedtls_asn1_get_sequence_of().
    ///   When you have finished processing the sequence,
    ///   call mbedtls_asn1_sequence_free() on `head->cur`,
    ///   then free `head` itself in the appropriate manner.
    ///
    /// \param seq      The address of the first sequence component. This may
    ///                 be \c NULL, in which case this functions returns
    ///                 immediately.
    pub fn mbedtls_asn1_sequence_free(seq: *mut mbedtls_asn1_sequence);
}
extern "C" {
    /// \brief                Traverse an ASN.1 SEQUENCE container and
    ///                       call a callback for each entry.
    ///
    /// This function checks that the input is a SEQUENCE of elements that
    /// each have a "must" tag, and calls a callback function on the elements
    /// that have a "may" tag.
    ///
    /// For example, to validate that the input is a SEQUENCE of `tag1` and call
    /// `cb` on each element, use
    /// ```
    /// mbedtls_asn1_traverse_sequence_of(&p, end, 0xff, tag1, 0, 0, cb, ctx);
    /// ```
    ///
    /// To validate that the input is a SEQUENCE of ANY and call `cb` on
    /// each element, use
    /// ```
    /// mbedtls_asn1_traverse_sequence_of(&p, end, 0, 0, 0, 0, cb, ctx);
    /// ```
    ///
    /// To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING}
    /// and call `cb` on each element that is an OCTET STRING, use
    /// ```
    /// mbedtls_asn1_traverse_sequence_of(&p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);
    /// ```
    ///
    /// The callback is called on the elements with a "may" tag from left to
    /// right. If the input is not a valid SEQUENCE of elements with a "must" tag,
    /// the callback is called on the elements up to the leftmost point where
    /// the input is invalid.
    ///
    /// \warning              This function is still experimental and may change
    ///                       at any time.
    ///
    /// \param p              The address of the pointer to the beginning of
    ///                       the ASN.1 SEQUENCE header. This is updated to
    ///                       point to the end of the ASN.1 SEQUENCE container
    ///                       on a successful invocation.
    /// \param end            The end of the ASN.1 SEQUENCE container.
    /// \param tag_must_mask  A mask to be applied to the ASN.1 tags found within
    ///                       the SEQUENCE before comparing to \p tag_must_value.
    /// \param tag_must_val   The required value of each ASN.1 tag found in the
    ///                       SEQUENCE, after masking with \p tag_must_mask.
    ///                       Mismatching tags lead to an error.
    ///                       For example, a value of \c 0 for both \p tag_must_mask
    ///                       and \p tag_must_val means that every tag is allowed,
    ///                       while a value of \c 0xFF for \p tag_must_mask means
    ///                       that \p tag_must_val is the only allowed tag.
    /// \param tag_may_mask   A mask to be applied to the ASN.1 tags found within
    ///                       the SEQUENCE before comparing to \p tag_may_value.
    /// \param tag_may_val    The desired value of each ASN.1 tag found in the
    ///                       SEQUENCE, after masking with \p tag_may_mask.
    ///                       Mismatching tags will be silently ignored.
    ///                       For example, a value of \c 0 for \p tag_may_mask and
    ///                       \p tag_may_val means that any tag will be considered,
    ///                       while a value of \c 0xFF for \p tag_may_mask means
    ///                       that all tags with value different from \p tag_may_val
    ///                       will be ignored.
    /// \param cb             The callback to trigger for each component
    ///                       in the ASN.1 SEQUENCE that matches \p tag_may_val.
    ///                       The callback function is called with the following
    ///                       parameters:
    ///                       - \p ctx.
    ///                       - The tag of the current element.
    ///                       - A pointer to the start of the current element's
    ///                         content inside the input.
    ///                       - The length of the content of the current element.
    ///                       If the callback returns a non-zero value,
    ///                       the function stops immediately,
    ///                       forwarding the callback's return value.
    /// \param ctx            The context to be passed to the callback \p cb.
    ///
    /// \return               \c 0 if successful the entire ASN.1 SEQUENCE
    ///                       was traversed without parsing or callback errors.
    /// \return               #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input
    ///                       contains extra data after a valid SEQUENCE
    ///                       of elements with an accepted tag.
    /// \return               #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts
    ///                       with an ASN.1 SEQUENCE in which an element has a tag
    ///                       that is not accepted.
    /// \return               An ASN.1 error code if the input does not start with
    ///                       a valid ASN.1 SEQUENCE.
    /// \return               A non-zero error code forwarded from the callback
    ///                       \p cb in case the latter returns a non-zero value.
    pub fn mbedtls_asn1_traverse_sequence_of(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        tag_must_mask: crate::c_types::c_uchar,
        tag_must_val: crate::c_types::c_uchar,
        tag_may_mask: crate::c_types::c_uchar,
        tag_may_val: crate::c_types::c_uchar,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut crate::c_types::c_void,
                tag: crate::c_types::c_int,
                start: *mut crate::c_types::c_uchar,
                len: usize,
            ) -> crate::c_types::c_int,
        >,
        ctx: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve an integer ASN.1 tag and its value.
    ///              Updates the pointer to immediately behind the full tag.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              beyond the ASN.1 element.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param X     On success, the parsed value.
    ///
    /// \return      0 if successful.
    /// \return      An ASN.1 error code if the input does not start with
    ///              a valid ASN.1 INTEGER.
    /// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does
    ///              not fit in an \c int.
    /// \return      An MPI error code if the parsed value is too large.
    pub fn mbedtls_asn1_get_mpi(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        X: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve an AlgorithmIdentifier ASN.1 sequence.
    ///              Updates the pointer to immediately behind the full
    ///              AlgorithmIdentifier.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              beyond the AlgorithmIdentifier element.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param alg   The buffer to receive the OID.
    /// \param params The buffer to receive the parameters.
    ///              This is zeroized if there are no parameters.
    ///
    /// \return      0 if successful or a specific ASN.1 or MPI error code.
    pub fn mbedtls_asn1_get_alg(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_asn1_buf,
        params: *mut mbedtls_asn1_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no
    ///              params.
    ///              Updates the pointer to immediately behind the full
    ///              AlgorithmIdentifier.
    ///
    /// \param p     On entry, \c *p points to the start of the ASN.1 element.
    ///              On successful completion, \c *p points to the first byte
    ///              beyond the AlgorithmIdentifier element.
    ///              On error, the value of \c *p is undefined.
    /// \param end   End of data.
    /// \param alg   The buffer to receive the OID.
    ///
    /// \return      0 if successful or a specific ASN.1 or MPI error code.
    pub fn mbedtls_asn1_get_alg_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_asn1_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       Find a specific named_data entry in a sequence or list based on
    ///              the OID.
    ///
    /// \param list  The list to seek through
    /// \param oid   The OID to look for
    /// \param len   Size of the OID
    ///
    /// \return      NULL if not found, or a pointer to the existing entry.
    pub fn mbedtls_asn1_find_named_data(
        list: *const mbedtls_asn1_named_data,
        oid: *const crate::c_types::c_char,
        len: usize,
    ) -> *const mbedtls_asn1_named_data;
}
extern "C" {
    /// \brief       Free a mbedtls_asn1_named_data entry
    ///
    /// \deprecated  This function is deprecated and will be removed in a
    ///              future version of the library.
    ///              Please use mbedtls_asn1_free_named_data_list()
    ///              or mbedtls_asn1_free_named_data_list_shallow().
    ///
    /// \param entry The named data entry to free.
    ///              This function calls mbedtls_free() on
    ///              `entry->oid.p` and `entry->val.p`.
    pub fn mbedtls_asn1_free_named_data(entry: *mut mbedtls_asn1_named_data);
}
extern "C" {
    /// \brief       Free all entries in a mbedtls_asn1_named_data list.
    ///
    /// \param head  Pointer to the head of the list of named data entries to free.
    ///              This function calls mbedtls_free() on
    ///              `entry->oid.p` and `entry->val.p` and then on `entry`
    ///              for each list entry, and sets \c *head to \c NULL.
    pub fn mbedtls_asn1_free_named_data_list(head: *mut *mut mbedtls_asn1_named_data);
}
extern "C" {
    /// \brief       Free all shallow entries in a mbedtls_asn1_named_data list,
    ///              but do not free internal pointer targets.
    ///
    /// \param name  Head of the list of named data entries to free.
    ///              This function calls mbedtls_free() on each list element.
    pub fn mbedtls_asn1_free_named_data_list_shallow(name: *mut mbedtls_asn1_named_data);
}
/// Type-length-value structure that allows for ASN1 using DER.
pub type mbedtls_x509_buf = mbedtls_asn1_buf;
/// Container for ASN1 bit strings.
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
/// Container for ASN1 named information objects.
/// It allows for Relative Distinguished Names (e.g. cn=localhost,ou=code,etc.).
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
/// Container for a sequence of ASN.1 items
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
/// Container for date and time (precision in seconds).
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_time {
    ///< Date.
    pub year: crate::c_types::c_int,
    ///< Date.
    pub mon: crate::c_types::c_int,
    ///< Date.
    pub day: crate::c_types::c_int,
    ///< Time.
    pub hour: crate::c_types::c_int,
    ///< Time.
    pub min: crate::c_types::c_int,
    ///< Time.
    pub sec: crate::c_types::c_int,
}
/// From RFC 5280 section 4.2.1.6:
/// OtherName ::= SEQUENCE {
///      type-id    OBJECT IDENTIFIER,
///      value      [0] EXPLICIT ANY DEFINED BY type-id }
///
/// Future versions of the library may add new fields to this structure or
/// to its embedded union and structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name {
    ///< The type id.
    pub type_id: mbedtls_x509_buf,
    pub value: mbedtls_x509_san_other_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_san_other_name__bindgen_ty_1 {
    pub hardware_module_name: mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1,
}
/// From RFC 4108 section 5:
/// HardwareModuleName ::= SEQUENCE {
///                         hwType OBJECT IDENTIFIER,
///                         hwSerialNum OCTET STRING }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    ///< The object identifier.
    pub oid: mbedtls_x509_buf,
    ///< The named value.
    pub val: mbedtls_x509_buf,
}
/// A structure for holding the parsed Subject Alternative Name,
/// according to type.
///
/// Future versions of the library may add new fields to this structure or
/// to its embedded union and structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_subject_alternative_name {
    ///< The SAN type, value of MBEDTLS_X509_SAN_XXX.
    pub type_: crate::c_types::c_int,
    ///< A union of the supported SAN types
    pub san: mbedtls_x509_subject_alternative_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_subject_alternative_name__bindgen_ty_1 {
    ///< The otherName supported type.
    pub other_name: mbedtls_x509_san_other_name,
    ///< The buffer for the unconstructed types. Only rfc822Name, dnsName and uniformResourceIdentifier are currently supported
    pub unstructured_name: mbedtls_x509_buf,
}
extern "C" {
    /// \brief          Store the certificate DN in printable form into buf;
    ///                 no more than size characters will be written.
    ///
    /// \param buf      Buffer to write to
    /// \param size     Maximum size of buffer
    /// \param dn       The X509 name to represent
    ///
    /// \return         The length of the string written (not including the
    ///                 terminated nul byte), or a negative error code.
    pub fn mbedtls_x509_dn_gets(
        buf: *mut crate::c_types::c_char,
        size: usize,
        dn: *const mbedtls_x509_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Store the certificate serial in printable form into buf;
    ///                 no more than size characters will be written.
    ///
    /// \param buf      Buffer to write to
    /// \param size     Maximum size of buffer
    /// \param serial   The X509 serial to represent
    ///
    /// \return         The length of the string written (not including the
    ///                 terminated nul byte), or a negative error code.
    pub fn mbedtls_x509_serial_gets(
        buf: *mut crate::c_types::c_char,
        size: usize,
        serial: *const mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Check a given mbedtls_x509_time against the system time
    ///                 and tell if it's in the past.
    ///
    /// \note           Intended usage is "if( is_past( valid_to ) ) ERROR".
    ///                 Hence the return value of 1 if on internal errors.
    ///
    /// \param to       mbedtls_x509_time to check
    ///
    /// \return         1 if the given time is in the past or an error occurred,
    ///                 0 otherwise.
    pub fn mbedtls_x509_time_is_past(to: *const mbedtls_x509_time) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Check a given mbedtls_x509_time against the system time
    ///                 and tell if it's in the future.
    ///
    /// \note           Intended usage is "if( is_future( valid_from ) ) ERROR".
    ///                 Hence the return value of 1 if on internal errors.
    ///
    /// \param from     mbedtls_x509_time to check
    ///
    /// \return         1 if the given time is in the future or an error occurred,
    ///                 0 otherwise.
    pub fn mbedtls_x509_time_is_future(from: *const mbedtls_x509_time) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function parses an item in the SubjectAlternativeNames
    ///                 extension.
    ///
    /// \param san_buf  The buffer holding the raw data item of the subject
    ///                 alternative name.
    /// \param san      The target structure to populate with the parsed presentation
    ///                 of the subject alternative name encoded in \p san_raw.
    ///
    /// \note           Supported GeneralName types, as defined in RFC 5280:
    ///                 "rfc822Name", "dnsName", "uniformResourceIdentifier" and "hardware_module_name"
    ///                 of type "otherName", as defined in RFC 4108.
    ///
    /// \note           This function should be called on a single raw data of
    ///                 subject alternative name. For example, after successful
    ///                 certificate parsing, one must iterate on every item in the
    ///                 \p crt->subject_alt_names sequence, and pass it to
    ///                 this function.
    ///
    /// \warning        The target structure contains pointers to the raw data of the
    ///                 parsed certificate, and its lifetime is restricted by the
    ///                 lifetime of the certificate.
    ///
    /// \return         \c 0 on success
    /// \return         #MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE for an unsupported
    ///                 SAN type.
    /// \return         Another negative value for any other failure.
    pub fn mbedtls_x509_parse_subject_alt_name(
        san_buf: *const mbedtls_x509_buf,
        san: *mut mbedtls_x509_subject_alternative_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \} addtogroup x509_module
    pub fn mbedtls_x509_get_name(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        cur: *mut mbedtls_x509_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_x509_buf,
        params: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_rsassa_pss_params(
        params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        mgf_md: *mut mbedtls_md_type_t,
        salt_len: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        sig: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig_alg(
        sig_oid: *const mbedtls_x509_buf,
        sig_params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        pk_alg: *mut mbedtls_pk_type_t,
        sig_opts: *mut *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_time(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        t: *mut mbedtls_x509_time,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_serial(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        serial: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ext(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        ext: *mut mbedtls_x509_buf,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_sig_alg_gets(
        buf: *mut crate::c_types::c_char,
        size: usize,
        sig_oid: *const mbedtls_x509_buf,
        pk_alg: mbedtls_pk_type_t,
        md_alg: mbedtls_md_type_t,
        sig_opts: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_key_size_helper(
        buf: *mut crate::c_types::c_char,
        buf_size: usize,
        name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_string_to_names(
        head: *mut *mut mbedtls_asn1_named_data,
        name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_set_extension(
        head: *mut *mut mbedtls_asn1_named_data,
        oid: *const crate::c_types::c_char,
        oid_len: usize,
        critical: crate::c_types::c_int,
        val: *const crate::c_types::c_uchar,
        val_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_extensions(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_names(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_sig(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        oid: *const crate::c_types::c_char,
        oid_len: usize,
        sig: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ns_cert_type(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        ns_cert_type: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_key_usage(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        key_usage: *mut crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_subject_alt_name(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        subject_alt_name: *mut mbedtls_x509_sequence,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_subject_alt_name(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut usize,
        subject_alt_name: *const mbedtls_x509_sequence,
        prefix: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_cert_type(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut usize,
        ns_cert_type: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_key_usage(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut usize,
        key_usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
/// Certificate revocation list entry.
/// Contains the CA-specific serial numbers and revocation dates.
///
/// Some fields of this structure are publicly readable. Do not modify
/// them except via Mbed TLS library functions: the effect of modifying
/// those fields or the data that those fields points to is unspecified.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crl_entry {
    /// Direct access to the whole entry inside the containing buffer.
    pub raw: mbedtls_x509_buf,
    /// The serial number of the revoked certificate.
    pub serial: mbedtls_x509_buf,
    /// The revocation date of this entry.
    pub revocation_date: mbedtls_x509_time,
    /// Direct access to the list of CRL entry extensions
    /// (an ASN.1 constructed sequence).
    ///
    /// If there are no extensions, `entry_ext.len == 0` and
    /// `entry_ext.p == NULL`.
    pub entry_ext: mbedtls_x509_buf,
    /// Next element in the linked list of entries.
    /// \p NULL indicates the end of the list.
    /// Do not modify this field directly.
    pub next: *mut mbedtls_x509_crl_entry,
}
/// Certificate revocation list structure.
/// Every CRL may have multiple entries.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crl {
    ///< The raw certificate data (DER).
    pub raw: mbedtls_x509_buf,
    ///< The raw certificate body (DER). The part that is To Be Signed.
    pub tbs: mbedtls_x509_buf,
    ///< CRL version (1=v1, 2=v2)
    pub version: crate::c_types::c_int,
    ///< CRL signature type identifier
    pub sig_oid: mbedtls_x509_buf,
    ///< The raw issuer data (DER).
    pub issuer_raw: mbedtls_x509_buf,
    ///< The parsed issuer data (named information object).
    pub issuer: mbedtls_x509_name,
    pub this_update: mbedtls_x509_time,
    pub next_update: mbedtls_x509_time,
    ///< The CRL entries containing the certificate revocation times for this CA.
    pub entry: mbedtls_x509_crl_entry,
    pub crl_ext: mbedtls_x509_buf,
    pub private_sig_oid2: mbedtls_x509_buf,
    pub private_sig: mbedtls_x509_buf,
    ///< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256
    pub private_sig_md: mbedtls_md_type_t,
    ///< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA
    pub private_sig_pk: mbedtls_pk_type_t,
    ///< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS
    pub private_sig_opts: *mut crate::c_types::c_void,
    /// Next element in the linked list of CRL.
    /// \p NULL indicates the end of the list.
    /// Do not modify this field directly.
    pub next: *mut mbedtls_x509_crl,
}
extern "C" {
    /// \brief          Parse a DER-encoded CRL and append it to the chained list
    ///
    /// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                 subsystem must have been initialized by calling
    ///                 psa_crypto_init() before calling this function.
    ///
    /// \param chain    points to the start of the chain
    /// \param buf      buffer holding the CRL data in DER format
    /// \param buflen   size of the buffer
    ///                 (including the terminating null byte for PEM data)
    ///
    /// \return         0 if successful, or a specific X509 or PEM error code
    pub fn mbedtls_x509_crl_parse_der(
        chain: *mut mbedtls_x509_crl,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Parse one or more CRLs and append them to the chained list
    ///
    /// \note           Multiple CRLs are accepted only if using PEM format
    ///
    /// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                 subsystem must have been initialized by calling
    ///                 psa_crypto_init() before calling this function.
    ///
    /// \param chain    points to the start of the chain
    /// \param buf      buffer holding the CRL data in PEM or DER format
    /// \param buflen   size of the buffer
    ///                 (including the terminating null byte for PEM data)
    ///
    /// \return         0 if successful, or a specific X509 or PEM error code
    pub fn mbedtls_x509_crl_parse(
        chain: *mut mbedtls_x509_crl,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Returns an informational string about the CRL.
    ///
    /// \param buf      Buffer to write to
    /// \param size     Maximum size of buffer
    /// \param prefix   A line prefix
    /// \param crl      The X509 CRL to represent
    ///
    /// \return         The length of the string written (not including the
    ///                 terminated nul byte), or a negative error code.
    pub fn mbedtls_x509_crl_info(
        buf: *mut crate::c_types::c_char,
        size: usize,
        prefix: *const crate::c_types::c_char,
        crl: *const mbedtls_x509_crl,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Initialize a CRL (chain)
    ///
    /// \param crl      CRL chain to initialize
    pub fn mbedtls_x509_crl_init(crl: *mut mbedtls_x509_crl);
}
extern "C" {
    /// \brief          Unallocate all CRL data
    ///
    /// \param crl      CRL chain to free
    pub fn mbedtls_x509_crl_free(crl: *mut mbedtls_x509_crl);
}
/// Container for an X.509 certificate. The certificate may be chained.
///
/// Some fields of this structure are publicly readable. Do not modify
/// them except via Mbed TLS library functions: the effect of modifying
/// those fields or the data that those fields points to is unspecified.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt {
    ///< Indicates if \c raw is owned
    ///   by the structure or not.
    pub private_own_buffer: crate::c_types::c_int,
    ///< The raw certificate data (DER).
    pub raw: mbedtls_x509_buf,
    ///< The raw certificate body (DER). The part that is To Be Signed.
    pub tbs: mbedtls_x509_buf,
    ///< The X.509 version. (1=v1, 2=v2, 3=v3)
    pub version: crate::c_types::c_int,
    ///< Unique id for certificate issued by a specific CA.
    pub serial: mbedtls_x509_buf,
    ///< Signature algorithm, e.g. sha1RSA
    pub sig_oid: mbedtls_x509_buf,
    ///< The raw issuer data (DER). Used for quick comparison.
    pub issuer_raw: mbedtls_x509_buf,
    ///< The raw subject data (DER). Used for quick comparison.
    pub subject_raw: mbedtls_x509_buf,
    ///< The parsed issuer data (named information object).
    pub issuer: mbedtls_x509_name,
    ///< The parsed subject data (named information object).
    pub subject: mbedtls_x509_name,
    ///< Start time of certificate validity.
    pub valid_from: mbedtls_x509_time,
    ///< End time of certificate validity.
    pub valid_to: mbedtls_x509_time,
    pub pk_raw: mbedtls_x509_buf,
    ///< Container for the public key context.
    pub pk: mbedtls_pk_context,
    ///< Optional X.509 v2/v3 issuer unique identifier.
    pub issuer_id: mbedtls_x509_buf,
    ///< Optional X.509 v2/v3 subject unique identifier.
    pub subject_id: mbedtls_x509_buf,
    ///< Optional X.509 v3 extensions.
    pub v3_ext: mbedtls_x509_buf,
    ///< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName, uniformResourceIdentifier and OtherName are listed).
    pub subject_alt_names: mbedtls_x509_sequence,
    ///< Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed).
    pub certificate_policies: mbedtls_x509_sequence,
    ///< Bit string containing detected and parsed extensions
    pub private_ext_types: crate::c_types::c_int,
    ///< Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise.
    pub private_ca_istrue: crate::c_types::c_int,
    ///< Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+
    pub private_max_pathlen: crate::c_types::c_int,
    ///< Optional key usage extension value: See the values in x509.h
    pub private_key_usage: crate::c_types::c_uint,
    ///< Optional list of extended key usage OIDs.
    pub ext_key_usage: mbedtls_x509_sequence,
    ///< Optional Netscape certificate type extension value: See the values in x509.h
    pub private_ns_cert_type: crate::c_types::c_uchar,
    ///< Signature: hash of the tbs part signed with the private key.
    pub private_sig: mbedtls_x509_buf,
    ///< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256
    pub private_sig_md: mbedtls_md_type_t,
    ///< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA
    pub private_sig_pk: mbedtls_pk_type_t,
    ///< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS
    pub private_sig_opts: *mut crate::c_types::c_void,
    /// Next certificate in the linked list that constitutes the CA chain.
    /// \p NULL indicates the end of the list.
    /// Do not modify this field directly.
    pub next: *mut mbedtls_x509_crt,
}
/// Security profile for certificate verification.
///
/// All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG().
///
/// The fields of this structure are part of the public API and can be
/// manipulated directly by applications. Future versions of the library may
/// add extra fields or reorder existing fields.
///
/// You can create custom profiles by starting from a copy of
/// an existing profile, such as mbedtls_x509_crt_profile_default or
/// mbedtls_x509_ctr_profile_none and then tune it to your needs.
///
/// For example to allow SHA-224 in addition to the default:
///
///  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_default;
///  my_profile.allowed_mds |= MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 );
///
/// Or to allow only RSA-3072+ with SHA-256:
///
///  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_none;
///  my_profile.allowed_mds = MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 );
///  my_profile.allowed_pks = MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_RSA );
///  my_profile.rsa_min_bitlen = 3072;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_profile {
    ///< MDs for signatures
    pub allowed_mds: u32,
    ///< PK algs for public keys;
    ///   this applies to all certificates
    ///   in the provided chain.
    pub allowed_pks: u32,
    ///< Elliptic curves for ECDSA
    pub allowed_curves: u32,
    ///< Minimum size for RSA keys
    pub rsa_min_bitlen: u32,
}
/// Container for writing a certificate (CRT)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509write_cert {
    pub private_version: crate::c_types::c_int,
    pub private_serial: [crate::c_types::c_uchar; 20usize],
    pub private_serial_len: usize,
    pub private_subject_key: *mut mbedtls_pk_context,
    pub private_issuer_key: *mut mbedtls_pk_context,
    pub private_subject: *mut mbedtls_asn1_named_data,
    pub private_issuer: *mut mbedtls_asn1_named_data,
    pub private_md_alg: mbedtls_md_type_t,
    pub private_not_before: [crate::c_types::c_char; 16usize],
    pub private_not_after: [crate::c_types::c_char; 16usize],
    pub private_extensions: *mut mbedtls_asn1_named_data,
}
/// Item in a verification chain: cert and flags for it
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain_item {
    pub private_crt: *mut mbedtls_x509_crt,
    pub private_flags: u32,
}
/// Verification chain as built by \c mbedtls_crt_verify_chain()
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain {
    pub private_items: [mbedtls_x509_crt_verify_chain_item; 10usize],
    pub private_len: crate::c_types::c_uint,
}
pub type mbedtls_x509_crt_restart_ctx = crate::c_types::c_void;
extern "C" {
    /// Default security profile. Should provide a good balance between security
    /// and compatibility with current deployments.
    ///
    /// This profile permits:
    /// - SHA2 hashes with at least 256 bits: SHA-256, SHA-384, SHA-512.
    /// - Elliptic curves with 255 bits and above except secp256k1.
    /// - RSA with 2048 bits and above.
    ///
    /// New minor versions of Mbed TLS may extend this profile, for example if
    /// new algorithms are added to the library. New minor versions of Mbed TLS will
    /// not reduce this profile unless serious security concerns require it.
    pub static mbedtls_x509_crt_profile_default: mbedtls_x509_crt_profile;
}
extern "C" {
    /// Expected next default profile. Recommended for new deployments.
    /// Currently targets a 128-bit security level, except for allowing RSA-2048.
    /// This profile may change at any time.
    pub static mbedtls_x509_crt_profile_next: mbedtls_x509_crt_profile;
}
extern "C" {
    /// NSA Suite B profile.
    pub static mbedtls_x509_crt_profile_suiteb: mbedtls_x509_crt_profile;
}
extern "C" {
    /// Empty profile that allows nothing. Useful as a basis for constructing
    /// custom profiles.
    pub static mbedtls_x509_crt_profile_none: mbedtls_x509_crt_profile;
}
extern "C" {
    /// \brief          Parse a single DER formatted certificate and add it
    ///                 to the end of the provided chained list.
    ///
    /// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                 subsystem must have been initialized by calling
    ///                 psa_crypto_init() before calling this function.
    ///
    /// \param chain    The pointer to the start of the CRT chain to attach to.
    ///                 When parsing the first CRT in a chain, this should point
    ///                 to an instance of ::mbedtls_x509_crt initialized through
    ///                 mbedtls_x509_crt_init().
    /// \param buf      The buffer holding the DER encoded certificate.
    /// \param buflen   The size in Bytes of \p buf.
    ///
    /// \note           This function makes an internal copy of the CRT buffer
    ///                 \p buf. In particular, \p buf may be destroyed or reused
    ///                 after this call returns. To avoid duplicating the CRT
    ///                 buffer (at the cost of stricter lifetime constraints),
    ///                 use mbedtls_x509_crt_parse_der_nocopy() instead.
    ///
    /// \return         \c 0 if successful.
    /// \return         A negative error code on failure.
    pub fn mbedtls_x509_crt_parse_der(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
/// \brief          The type of certificate extension callbacks.
///
///                 Callbacks of this type are passed to and used by the
///                 mbedtls_x509_crt_parse_der_with_ext_cb() routine when
///                 it encounters either an unsupported extension or a
///                 "certificate policies" extension containing any
///                 unsupported certificate policies.
///                 Future versions of the library may invoke the callback
///                 in other cases, if and when the need arises.
///
/// \param p_ctx    An opaque context passed to the callback.
/// \param crt      The certificate being parsed.
/// \param oid      The OID of the extension.
/// \param critical Whether the extension is critical.
/// \param p        Pointer to the start of the extension value
///                 (the content of the OCTET STRING).
/// \param end      End of extension value.
///
/// \note           The callback must fail and return a negative error code
///                 if it can not parse or does not support the extension.
///                 When the callback fails to parse a critical extension
///                 mbedtls_x509_crt_parse_der_with_ext_cb() also fails.
///                 When the callback fails to parse a non critical extension
///                 mbedtls_x509_crt_parse_der_with_ext_cb() simply skips
///                 the extension and continues parsing.
///
/// \return         \c 0 on success.
/// \return         A negative error code on failure.
pub type mbedtls_x509_crt_ext_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::c_types::c_void,
        crt: *const mbedtls_x509_crt,
        oid: *const mbedtls_x509_buf,
        critical: crate::c_types::c_int,
        p: *const crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    /// \brief            Parse a single DER formatted certificate and add it
    ///                   to the end of the provided chained list.
    ///
    /// \note             If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                   subsystem must have been initialized by calling
    ///                   psa_crypto_init() before calling this function.
    ///
    /// \param chain      The pointer to the start of the CRT chain to attach to.
    ///                   When parsing the first CRT in a chain, this should point
    ///                   to an instance of ::mbedtls_x509_crt initialized through
    ///                   mbedtls_x509_crt_init().
    /// \param buf        The buffer holding the DER encoded certificate.
    /// \param buflen     The size in Bytes of \p buf.
    /// \param make_copy  When not zero this function makes an internal copy of the
    ///                   CRT buffer \p buf. In particular, \p buf may be destroyed
    ///                   or reused after this call returns.
    ///                   When zero this function avoids duplicating the CRT buffer
    ///                   by taking temporary ownership thereof until the CRT
    ///                   is destroyed (like mbedtls_x509_crt_parse_der_nocopy())
    /// \param cb         A callback invoked for every unsupported certificate
    ///                   extension.
    /// \param p_ctx      An opaque context passed to the callback.
    ///
    /// \note             This call is functionally equivalent to
    ///                   mbedtls_x509_crt_parse_der(), and/or
    ///                   mbedtls_x509_crt_parse_der_nocopy()
    ///                   but it calls the callback with every unsupported
    ///                   certificate extension and additionally the
    ///                   "certificate policies" extension if it contains any
    ///                   unsupported certificate policies.
    ///                   The callback must return a negative error code if it
    ///                   does not know how to handle such an extension.
    ///                   When the callback fails to parse a critical extension
    ///                   mbedtls_x509_crt_parse_der_with_ext_cb() also fails.
    ///                   When the callback fails to parse a non critical extension
    ///                   mbedtls_x509_crt_parse_der_with_ext_cb() simply skips
    ///                   the extension and continues parsing.
    ///                   Future versions of the library may invoke the callback
    ///                   in other cases, if and when the need arises.
    ///
    /// \return           \c 0 if successful.
    /// \return           A negative error code on failure.
    pub fn mbedtls_x509_crt_parse_der_with_ext_cb(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
        make_copy: crate::c_types::c_int,
        cb: mbedtls_x509_crt_ext_cb_t,
        p_ctx: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Parse a single DER formatted certificate and add it
    ///                 to the end of the provided chained list. This is a
    ///                 variant of mbedtls_x509_crt_parse_der() which takes
    ///                 temporary ownership of the CRT buffer until the CRT
    ///                 is destroyed.
    ///
    /// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                 subsystem must have been initialized by calling
    ///                 psa_crypto_init() before calling this function.
    ///
    /// \param chain    The pointer to the start of the CRT chain to attach to.
    ///                 When parsing the first CRT in a chain, this should point
    ///                 to an instance of ::mbedtls_x509_crt initialized through
    ///                 mbedtls_x509_crt_init().
    /// \param buf      The address of the readable buffer holding the DER encoded
    ///                 certificate to use. On success, this buffer must be
    ///                 retained and not be changed for the lifetime of the
    ///                 CRT chain \p chain, that is, until \p chain is destroyed
    ///                 through a call to mbedtls_x509_crt_free().
    /// \param buflen   The size in Bytes of \p buf.
    ///
    /// \note           This call is functionally equivalent to
    ///                 mbedtls_x509_crt_parse_der(), but it avoids creating a
    ///                 copy of the input buffer at the cost of stronger lifetime
    ///                 constraints. This is useful in constrained environments
    ///                 where duplication of the CRT cannot be tolerated.
    ///
    /// \return         \c 0 if successful.
    /// \return         A negative error code on failure.
    pub fn mbedtls_x509_crt_parse_der_nocopy(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Parse one DER-encoded or one or more concatenated PEM-encoded
    ///                 certificates and add them to the chained list.
    ///
    ///                 For CRTs in PEM encoding, the function parses permissively:
    ///                 if at least one certificate can be parsed, the function
    ///                 returns the number of certificates for which parsing failed
    ///                 (hence \c 0 if all certificates were parsed successfully).
    ///                 If no certificate could be parsed, the function returns
    ///                 the first (negative) error encountered during parsing.
    ///
    ///                 PEM encoded certificates may be interleaved by other data
    ///                 such as human readable descriptions of their content, as
    ///                 long as the certificates are enclosed in the PEM specific
    ///                 '-----{BEGIN/END} CERTIFICATE-----' delimiters.
    ///
    /// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                 subsystem must have been initialized by calling
    ///                 psa_crypto_init() before calling this function.
    ///
    /// \param chain    The chain to which to add the parsed certificates.
    /// \param buf      The buffer holding the certificate data in PEM or DER format.
    ///                 For certificates in PEM encoding, this may be a concatenation
    ///                 of multiple certificates; for DER encoding, the buffer must
    ///                 comprise exactly one certificate.
    /// \param buflen   The size of \p buf, including the terminating \c NULL byte
    ///                 in case of PEM encoded data.
    ///
    /// \return         \c 0 if all certificates were parsed successfully.
    /// \return         The (positive) number of certificates that couldn't
    ///                 be parsed if parsing was partly successful (see above).
    /// \return         A negative X509 or PEM error code otherwise.
    pub fn mbedtls_x509_crt_parse(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Returns an informational string about the
    ///                 certificate.
    ///
    /// \param buf      Buffer to write to
    /// \param size     Maximum size of buffer
    /// \param prefix   A line prefix
    /// \param crt      The X509 certificate to represent
    ///
    /// \return         The length of the string written (not including the
    ///                 terminated nul byte), or a negative error code.
    pub fn mbedtls_x509_crt_info(
        buf: *mut crate::c_types::c_char,
        size: usize,
        prefix: *const crate::c_types::c_char,
        crt: *const mbedtls_x509_crt,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Returns an informational string about the
    ///                 verification status of a certificate.
    ///
    /// \param buf      Buffer to write to
    /// \param size     Maximum size of buffer
    /// \param prefix   A line prefix
    /// \param flags    Verification flags created by mbedtls_x509_crt_verify()
    ///
    /// \return         The length of the string written (not including the
    ///                 terminated nul byte), or a negative error code.
    pub fn mbedtls_x509_crt_verify_info(
        buf: *mut crate::c_types::c_char,
        size: usize,
        prefix: *const crate::c_types::c_char,
        flags: u32,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Verify a chain of certificates.
    ///
    ///                 The verify callback is a user-supplied callback that
    ///                 can clear / modify / add flags for a certificate. If set,
    ///                 the verification callback is called for each
    ///                 certificate in the chain (from the trust-ca down to the
    ///                 presented crt). The parameters for the callback are:
    ///                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,
    ///                 int *flags). With the flags representing current flags for
    ///                 that specific certificate and the certificate depth from
    ///                 the bottom (Peer cert depth = 0).
    ///
    ///                 All flags left after returning from the callback
    ///                 are also returned to the application. The function should
    ///                 return 0 for anything (including invalid certificates)
    ///                 other than fatal error, as a non-zero return code
    ///                 immediately aborts the verification process. For fatal
    ///                 errors, a specific error code should be used (different
    ///                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not
    ///                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR
    ///                 can be used if no better code is available.
    ///
    /// \note           In case verification failed, the results can be displayed
    ///                 using \c mbedtls_x509_crt_verify_info()
    ///
    /// \note           Same as \c mbedtls_x509_crt_verify_with_profile() with the
    ///                 default security profile.
    ///
    /// \note           It is your responsibility to provide up-to-date CRLs for
    ///                 all trusted CAs. If no CRL is provided for the CA that was
    ///                 used to sign the certificate, CRL verification is skipped
    ///                 silently, that is *without* setting any flag.
    ///
    /// \note           The \c trust_ca list can contain two types of certificates:
    ///                 (1) those of trusted root CAs, so that certificates
    ///                 chaining up to those CAs will be trusted, and (2)
    ///                 self-signed end-entity certificates to be trusted (for
    ///                 specific peers you know) - in that case, the self-signed
    ///                 certificate doesn't need to have the CA bit set.
    ///
    /// \param crt      The certificate chain to be verified.
    /// \param trust_ca The list of trusted CAs.
    /// \param ca_crl   The list of CRLs for trusted CAs.
    /// \param cn       The expected Common Name. This will be checked to be
    ///                 present in the certificate's subjectAltNames extension or,
    ///                 if this extension is absent, as a CN component in its
    ///                 Subject name. Currently only DNS names are supported. This
    ///                 may be \c NULL if the CN need not be verified.
    /// \param flags    The address at which to store the result of the verification.
    ///                 If the verification couldn't be completed, the flag value is
    ///                 set to (uint32_t) -1.
    /// \param f_vrfy   The verification callback to use. See the documentation
    ///                 of mbedtls_x509_crt_verify() for more information.
    /// \param p_vrfy   The context to be passed to \p f_vrfy.
    ///
    /// \return         \c 0 if the chain is valid with respect to the
    ///                 passed CN, CAs, CRLs and security profile.
    /// \return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the
    ///                 certificate chain verification failed. In this case,
    ///                 \c *flags will have one or more
    ///                 \c MBEDTLS_X509_BADCERT_XXX or \c MBEDTLS_X509_BADCRL_XXX
    ///                 flags set.
    /// \return         Another negative error code in case of a fatal error
    ///                 encountered during the verification process.
    pub fn mbedtls_x509_crt_verify(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Verify a chain of certificates with respect to
    ///                 a configurable security profile.
    ///
    /// \note           Same as \c mbedtls_x509_crt_verify(), but with explicit
    ///                 security profile.
    ///
    /// \note           The restrictions on keys (RSA minimum size, allowed curves
    ///                 for ECDSA) apply to all certificates: trusted root,
    ///                 intermediate CAs if any, and end entity certificate.
    ///
    /// \param crt      The certificate chain to be verified.
    /// \param trust_ca The list of trusted CAs.
    /// \param ca_crl   The list of CRLs for trusted CAs.
    /// \param profile  The security profile to use for the verification.
    /// \param cn       The expected Common Name. This may be \c NULL if the
    ///                 CN need not be verified.
    /// \param flags    The address at which to store the result of the verification.
    ///                 If the verification couldn't be completed, the flag value is
    ///                 set to (uint32_t) -1.
    /// \param f_vrfy   The verification callback to use. See the documentation
    ///                 of mbedtls_x509_crt_verify() for more information.
    /// \param p_vrfy   The context to be passed to \p f_vrfy.
    ///
    /// \return         \c 0 if the chain is valid with respect to the
    ///                 passed CN, CAs, CRLs and security profile.
    /// \return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the
    ///                 certificate chain verification failed. In this case,
    ///                 \c *flags will have one or more
    ///                 \c MBEDTLS_X509_BADCERT_XXX or \c MBEDTLS_X509_BADCRL_XXX
    ///                 flags set.
    /// \return         Another negative error code in case of a fatal error
    ///                 encountered during the verification process.
    pub fn mbedtls_x509_crt_verify_with_profile(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Restartable version of \c mbedtls_crt_verify_with_profile()
    ///
    /// \note           Performs the same job as \c mbedtls_crt_verify_with_profile()
    ///                 but can return early and restart according to the limit
    ///                 set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
    ///
    /// \param crt      The certificate chain to be verified.
    /// \param trust_ca The list of trusted CAs.
    /// \param ca_crl   The list of CRLs for trusted CAs.
    /// \param profile  The security profile to use for the verification.
    /// \param cn       The expected Common Name. This may be \c NULL if the
    ///                 CN need not be verified.
    /// \param flags    The address at which to store the result of the verification.
    ///                 If the verification couldn't be completed, the flag value is
    ///                 set to (uint32_t) -1.
    /// \param f_vrfy   The verification callback to use. See the documentation
    ///                 of mbedtls_x509_crt_verify() for more information.
    /// \param p_vrfy   The context to be passed to \p f_vrfy.
    /// \param rs_ctx   The restart context to use. This may be set to \c NULL
    ///                 to disable restartable ECC.
    ///
    /// \return         See \c mbedtls_crt_verify_with_profile(), or
    /// \return         #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                 operations was reached: see \c mbedtls_ecp_set_max_ops().
    pub fn mbedtls_x509_crt_verify_restartable(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_x509_crt_restart_ctx,
    ) -> crate::c_types::c_int;
}
/// \brief               The type of trusted certificate callbacks.
///
///                      Callbacks of this type are passed to and used by the CRT
///                      verification routine mbedtls_x509_crt_verify_with_ca_cb()
///                      when looking for trusted signers of a given certificate.
///
///                      On success, the callback returns a list of trusted
///                      certificates to be considered as potential signers
///                      for the input certificate.
///
/// \param p_ctx         An opaque context passed to the callback.
/// \param child         The certificate for which to search a potential signer.
///                      This will point to a readable certificate.
/// \param candidate_cas The address at which to store the address of the first
///                      entry in the generated linked list of candidate signers.
///                      This will not be \c NULL.
///
/// \note                The callback must only return a non-zero value on a
///                      fatal error. If, in contrast, the search for a potential
///                      signer completes without a single candidate, the
///                      callback must return \c 0 and set \c *candidate_cas
///                      to \c NULL.
///
/// \return              \c 0 on success. In this case, \c *candidate_cas points
///                      to a heap-allocated linked list of instances of
///                      ::mbedtls_x509_crt, and ownership of this list is passed
///                      to the caller.
/// \return              A negative error code on failure.
pub type mbedtls_x509_crt_ca_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::c_types::c_void,
        child: *const mbedtls_x509_crt,
        candidate_cas: *mut *mut mbedtls_x509_crt,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    /// \brief          Check usage of certificate against keyUsage extension.
    ///
    /// \param crt      Leaf certificate used.
    /// \param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT
    ///                 before using the certificate to perform an RSA key
    ///                 exchange).
    ///
    /// \note           Except for decipherOnly and encipherOnly, a bit set in the
    ///                 usage argument means this bit MUST be set in the
    ///                 certificate. For decipherOnly and encipherOnly, it means
    ///                 that bit MAY be set.
    ///
    /// \return         0 is these uses of the certificate are allowed,
    ///                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension
    ///                 is present but does not match the usage argument.
    ///
    /// \note           You should only call this function on leaf certificates, on
    ///                 (intermediate) CAs the keyUsage extension is automatically
    ///                 checked by \c mbedtls_x509_crt_verify().
    pub fn mbedtls_x509_crt_check_key_usage(
        crt: *const mbedtls_x509_crt,
        usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Check usage of certificate against extendedKeyUsage.
    ///
    /// \param crt       Leaf certificate used.
    /// \param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or
    ///                  MBEDTLS_OID_CLIENT_AUTH).
    /// \param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE()).
    ///
    /// \return          0 if this use of the certificate is allowed,
    ///                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if not.
    ///
    /// \note            Usually only makes sense on leaf certificates.
    pub fn mbedtls_x509_crt_check_extended_key_usage(
        crt: *const mbedtls_x509_crt,
        usage_oid: *const crate::c_types::c_char,
        usage_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Verify the certificate revocation status
    ///
    /// \param crt      a certificate to be verified
    /// \param crl      the CRL to verify against
    ///
    /// \return         1 if the certificate is revoked, 0 otherwise
    pub fn mbedtls_x509_crt_is_revoked(
        crt: *const mbedtls_x509_crt,
        crl: *const mbedtls_x509_crl,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Initialize a certificate (chain)
    ///
    /// \param crt      Certificate chain to initialize
    pub fn mbedtls_x509_crt_init(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    /// \brief          Unallocate all certificate data
    ///
    /// \param crt      Certificate chain to free
    pub fn mbedtls_x509_crt_free(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    /// \brief           Initialize a CRT writing context
    ///
    /// \param ctx       CRT context to initialize
    pub fn mbedtls_x509write_crt_init(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    /// \brief           Set the version for a Certificate
    ///                  Default: MBEDTLS_X509_CRT_VERSION_3
    ///
    /// \param ctx       CRT context to use
    /// \param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or
    ///                                  MBEDTLS_X509_CRT_VERSION_3)
    pub fn mbedtls_x509write_crt_set_version(
        ctx: *mut mbedtls_x509write_cert,
        version: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief           Set the serial number for a Certificate.
    ///
    /// \deprecated      This function is deprecated and will be removed in a
    ///                  future version of the library. Please use
    ///                  mbedtls_x509write_crt_set_serial_raw() instead.
    ///
    /// \note            Even though the MBEDTLS_BIGNUM_C guard looks redundant since
    ///                  X509 depends on PK and PK depends on BIGNUM, this emphasizes
    ///                  a direct dependency between X509 and BIGNUM which is going
    ///                  to be deprecated in the future.
    ///
    /// \param ctx       CRT context to use
    /// \param serial    serial number to set
    ///
    /// \return          0 if successful
    pub fn mbedtls_x509write_crt_set_serial(
        ctx: *mut mbedtls_x509write_cert,
        serial: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the serial number for a Certificate.
    ///
    /// \param ctx          CRT context to use
    /// \param serial       A raw array of bytes containing the serial number in big
    ///                     endian format
    /// \param serial_len   Length of valid bytes (expressed in bytes) in \p serial
    ///                     input buffer
    ///
    /// \return          0 if successful, or
    ///                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if the provided input buffer
    ///                  is too big (longer than MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN)
    pub fn mbedtls_x509write_crt_set_serial_raw(
        ctx: *mut mbedtls_x509write_cert,
        serial: *mut crate::c_types::c_uchar,
        serial_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the validity period for a Certificate
    ///                  Timestamps should be in string format for UTC timezone
    ///                  i.e. "YYYYMMDDhhmmss"
    ///                  e.g. "20131231235959" for December 31st 2013
    ///                       at 23:59:59
    ///
    /// \param ctx       CRT context to use
    /// \param not_before    not_before timestamp
    /// \param not_after     not_after timestamp
    ///
    /// \return          0 if timestamp was parsed successfully, or
    ///                  a specific error code
    pub fn mbedtls_x509write_crt_set_validity(
        ctx: *mut mbedtls_x509write_cert,
        not_before: *const crate::c_types::c_char,
        not_after: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the issuer name for a Certificate
    ///                  Issuer names should contain a comma-separated list
    ///                  of OID types and values:
    ///                  e.g. "C=UK,O=ARM,CN=mbed TLS CA"
    ///
    /// \param ctx           CRT context to use
    /// \param issuer_name   issuer name to set
    ///
    /// \return          0 if issuer name was parsed successfully, or
    ///                  a specific error code
    pub fn mbedtls_x509write_crt_set_issuer_name(
        ctx: *mut mbedtls_x509write_cert,
        issuer_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the subject name for a Certificate
    ///                  Subject names should contain a comma-separated list
    ///                  of OID types and values:
    ///                  e.g. "C=UK,O=ARM,CN=mbed TLS Server 1"
    ///
    /// \param ctx           CRT context to use
    /// \param subject_name  subject name to set
    ///
    /// \return          0 if subject name was parsed successfully, or
    ///                  a specific error code
    pub fn mbedtls_x509write_crt_set_subject_name(
        ctx: *mut mbedtls_x509write_cert,
        subject_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the subject public key for the certificate
    ///
    /// \param ctx       CRT context to use
    /// \param key       public key to include
    pub fn mbedtls_x509write_crt_set_subject_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    /// \brief           Set the issuer key used for signing the certificate
    ///
    /// \param ctx       CRT context to use
    /// \param key       private key to sign with
    pub fn mbedtls_x509write_crt_set_issuer_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    /// \brief           Set the MD algorithm to use for the signature
    ///                  (e.g. MBEDTLS_MD_SHA1)
    ///
    /// \param ctx       CRT context to use
    /// \param md_alg    MD algorithm to use
    pub fn mbedtls_x509write_crt_set_md_alg(
        ctx: *mut mbedtls_x509write_cert,
        md_alg: mbedtls_md_type_t,
    );
}
extern "C" {
    /// \brief           Generic function to add to or replace an extension in the
    ///                  CRT
    ///
    /// \param ctx       CRT context to use
    /// \param oid       OID of the extension
    /// \param oid_len   length of the OID
    /// \param critical  if the extension is critical (per the RFC's definition)
    /// \param val       value of the extension OCTET STRING
    /// \param val_len   length of the value data
    ///
    /// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
    pub fn mbedtls_x509write_crt_set_extension(
        ctx: *mut mbedtls_x509write_cert,
        oid: *const crate::c_types::c_char,
        oid_len: usize,
        critical: crate::c_types::c_int,
        val: *const crate::c_types::c_uchar,
        val_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the basicConstraints extension for a CRT
    ///
    /// \param ctx       CRT context to use
    /// \param is_ca     is this a CA certificate
    /// \param max_pathlen   maximum length of certificate chains below this
    ///                      certificate (only for CA certificates, -1 is
    ///                      unlimited)
    ///
    /// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
    pub fn mbedtls_x509write_crt_set_basic_constraints(
        ctx: *mut mbedtls_x509write_cert,
        is_ca: crate::c_types::c_int,
        max_pathlen: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the subjectKeyIdentifier extension for a CRT
    ///                  Requires that mbedtls_x509write_crt_set_subject_key() has been
    ///                  called before
    ///
    /// \param ctx       CRT context to use
    ///
    /// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
    pub fn mbedtls_x509write_crt_set_subject_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the authorityKeyIdentifier extension for a CRT
    ///                  Requires that mbedtls_x509write_crt_set_issuer_key() has been
    ///                  called before
    ///
    /// \param ctx       CRT context to use
    ///
    /// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
    pub fn mbedtls_x509write_crt_set_authority_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the Key Usage Extension flags
    ///                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)
    ///
    /// \param ctx       CRT context to use
    /// \param key_usage key usage flags to set
    ///
    /// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
    pub fn mbedtls_x509write_crt_set_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        key_usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the Extended Key Usage Extension
    ///                  (e.g. MBEDTLS_OID_SERVER_AUTH)
    ///
    /// \param ctx       CRT context to use
    /// \param exts      extended key usage extensions to set, a sequence of
    ///                  MBEDTLS_ASN1_OID objects
    ///
    /// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
    pub fn mbedtls_x509write_crt_set_ext_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        exts: *const mbedtls_asn1_sequence,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Set the Netscape Cert Type flags
    ///                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)
    ///
    /// \param ctx           CRT context to use
    /// \param ns_cert_type  Netscape Cert Type flags to set
    ///
    /// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
    pub fn mbedtls_x509write_crt_set_ns_cert_type(
        ctx: *mut mbedtls_x509write_cert,
        ns_cert_type: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Free the contents of a CRT write context
    ///
    /// \param ctx       CRT context to free
    pub fn mbedtls_x509write_crt_free(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    /// \brief           Write a built up certificate to a X509 DER structure
    ///                  Note: data is written at the end of the buffer! Use the
    ///                        return value to determine where you should start
    ///                        using the buffer
    ///
    /// \param ctx       certificate to write away
    /// \param buf       buffer to write to
    /// \param size      size of the buffer
    /// \param f_rng     RNG function. This must not be \c NULL.
    /// \param p_rng     RNG parameter
    ///
    /// \return          length of data written if successful, or a specific
    ///                  error code
    ///
    /// \note            \p f_rng is used for the signature operation.
    pub fn mbedtls_x509write_crt_der(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Write a built up certificate to a X509 PEM string
    ///
    /// \param ctx       certificate to write away
    /// \param buf       buffer to write to
    /// \param size      size of the buffer
    /// \param f_rng     RNG function. This must not be \c NULL.
    /// \param p_rng     RNG parameter
    ///
    /// \return          0 if successful, or a specific error code
    ///
    /// \note            \p f_rng is used for the signature operation.
    pub fn mbedtls_x509write_crt_pem(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
///<  The prime modulus.
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_P: mbedtls_dhm_parameter = 0;
///<  The generator.
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_G: mbedtls_dhm_parameter = 1;
///<  Our secret value.
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_X: mbedtls_dhm_parameter = 2;
///<  Our public key = \c G^X mod \c P.
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_GX: mbedtls_dhm_parameter = 3;
///<  The public key of the peer = \c G^Y mod \c P.
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_GY: mbedtls_dhm_parameter = 4;
///<  The shared secret = \c G^(XY) mod \c P.
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_K: mbedtls_dhm_parameter = 5;
/// Which parameter to access in mbedtls_dhm_get_value().
pub type mbedtls_dhm_parameter = crate::c_types::c_uint;
/// \brief          The DHM context structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_dhm_context {
    ///<  The prime modulus.
    pub private_P: mbedtls_mpi,
    ///<  The generator.
    pub private_G: mbedtls_mpi,
    ///<  Our secret value.
    pub private_X: mbedtls_mpi,
    ///<  Our public key = \c G^X mod \c P.
    pub private_GX: mbedtls_mpi,
    ///<  The public key of the peer = \c G^Y mod \c P.
    pub private_GY: mbedtls_mpi,
    ///<  The shared secret = \c G^(XY) mod \c P.
    pub private_K: mbedtls_mpi,
    ///<  The cached value = \c R^2 mod \c P.
    pub private_RP: mbedtls_mpi,
    ///<  The blinding value.
    pub private_Vi: mbedtls_mpi,
    ///<  The unblinding value.
    pub private_Vf: mbedtls_mpi,
    ///<  The previous \c X.
    pub private_pX: mbedtls_mpi,
}
extern "C" {
    /// \brief          This function initializes the DHM context.
    ///
    /// \param ctx      The DHM context to initialize.
    pub fn mbedtls_dhm_init(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    /// \brief          This function parses the DHM parameters in a
    ///                 TLS ServerKeyExchange handshake message
    ///                 (DHM modulus, generator, and public key).
    ///
    /// \note           In a TLS handshake, this is the how the client
    ///                 sets up its DHM context from the server's public
    ///                 DHM key material.
    ///
    /// \param ctx      The DHM context to use. This must be initialized.
    /// \param p        On input, *p must be the start of the input buffer.
    ///                 On output, *p is updated to point to the end of the data
    ///                 that has been read. On success, this is the first byte
    ///                 past the end of the ServerKeyExchange parameters.
    ///                 On error, this is the point at which an error has been
    ///                 detected, which is usually not useful except to debug
    ///                 failures.
    /// \param end      The end of the input buffer.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
    pub fn mbedtls_dhm_read_params(
        ctx: *mut mbedtls_dhm_context,
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function generates a DHM key pair and exports its
    ///                 public part together with the DHM parameters in the format
    ///                 used in a TLS ServerKeyExchange handshake message.
    ///
    /// \note           This function assumes that the DHM parameters \c ctx->P
    ///                 and \c ctx->G have already been properly set. For that, use
    ///                 mbedtls_dhm_set_group() below in conjunction with
    ///                 mbedtls_mpi_read_binary() and mbedtls_mpi_read_string().
    ///
    /// \note           In a TLS handshake, this is the how the server generates
    ///                 and exports its DHM key material.
    ///
    /// \param ctx      The DHM context to use. This must be initialized
    ///                 and have the DHM parameters set. It may or may not
    ///                 already have imported the peer's public key.
    /// \param x_size   The private key size in Bytes.
    /// \param olen     The address at which to store the number of Bytes
    ///                 written on success. This must not be \c NULL.
    /// \param output   The destination buffer. This must be a writable buffer of
    ///                 sufficient size to hold the reduced binary presentation of
    ///                 the modulus, the generator and the public key, each wrapped
    ///                 with a 2-byte length field. It is the responsibility of the
    ///                 caller to ensure that enough space is available. Refer to
    ///                 mbedtls_mpi_size() to computing the byte-size of an MPI.
    /// \param f_rng    The RNG function. Must not be \c NULL.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be
    ///                 \c NULL if \p f_rng doesn't need a context parameter.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
    pub fn mbedtls_dhm_make_params(
        ctx: *mut mbedtls_dhm_context,
        x_size: crate::c_types::c_int,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function sets the prime modulus and generator.
    ///
    /// \note           This function can be used to set \c ctx->P, \c ctx->G
    ///                 in preparation for mbedtls_dhm_make_params().
    ///
    /// \param ctx      The DHM context to configure. This must be initialized.
    /// \param P        The MPI holding the DHM prime modulus. This must be
    ///                 an initialized MPI.
    /// \param G        The MPI holding the DHM generator. This must be an
    ///                 initialized MPI.
    ///
    /// \return         \c 0 if successful.
    /// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
    pub fn mbedtls_dhm_set_group(
        ctx: *mut mbedtls_dhm_context,
        P: *const mbedtls_mpi,
        G: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function imports the raw public value of the peer.
    ///
    /// \note           In a TLS handshake, this is the how the server imports
    ///                 the Client's public DHM key.
    ///
    /// \param ctx      The DHM context to use. This must be initialized and have
    ///                 its DHM parameters set, e.g. via mbedtls_dhm_set_group().
    ///                 It may or may not already have generated its own private key.
    /// \param input    The input buffer containing the \c G^Y value of the peer.
    ///                 This must be a readable buffer of size \p ilen Bytes.
    /// \param ilen     The size of the input buffer \p input in Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
    pub fn mbedtls_dhm_read_public(
        ctx: *mut mbedtls_dhm_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function creates a DHM key pair and exports
    ///                 the raw public key in big-endian format.
    ///
    /// \note           The destination buffer is always fully written
    ///                 so as to contain a big-endian representation of G^X mod P.
    ///                 If it is larger than \c ctx->len, it is padded accordingly
    ///                 with zero-bytes at the beginning.
    ///
    /// \param ctx      The DHM context to use. This must be initialized and
    ///                 have the DHM parameters set. It may or may not already
    ///                 have imported the peer's public key.
    /// \param x_size   The private key size in Bytes.
    /// \param output   The destination buffer. This must be a writable buffer of
    ///                 size \p olen Bytes.
    /// \param olen     The length of the destination buffer. This must be at least
    ///                 equal to `ctx->len` (the size of \c P).
    /// \param f_rng    The RNG function. This must not be \c NULL.
    /// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
    ///                 if \p f_rng doesn't need a context argument.
    ///
    /// \return         \c 0 on success.
    /// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
    pub fn mbedtls_dhm_make_public(
        ctx: *mut mbedtls_dhm_context,
        x_size: crate::c_types::c_int,
        output: *mut crate::c_types::c_uchar,
        olen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function derives and exports the shared secret
    ///                 \c (G^Y)^X mod \c P.
    ///
    /// \note           If \p f_rng is not \c NULL, it is used to blind the input as
    ///                 a countermeasure against timing attacks. Blinding is used
    ///                 only if our private key \c X is re-used, and not used
    ///                 otherwise. We recommend always passing a non-NULL
    ///                 \p f_rng argument.
    ///
    /// \param ctx           The DHM context to use. This must be initialized
    ///                      and have its own private key generated and the peer's
    ///                      public key imported.
    /// \param output        The buffer to write the generated shared key to. This
    ///                      must be a writable buffer of size \p output_size Bytes.
    /// \param output_size   The size of the destination buffer. This must be at
    ///                      least the size of \c ctx->len (the size of \c P).
    /// \param olen          On exit, holds the actual number of Bytes written.
    /// \param f_rng         The RNG function. Must not be \c NULL. Used for
    ///                      blinding.
    /// \param p_rng         The RNG context to be passed to \p f_rng. This may be
    ///                      \c NULL if \p f_rng doesn't need a context parameter.
    ///
    /// \return              \c 0 on success.
    /// \return              An \c MBEDTLS_ERR_DHM_XXX error code on failure.
    pub fn mbedtls_dhm_calc_secret(
        ctx: *mut mbedtls_dhm_context,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function returns the size of the prime modulus in bits.
    ///
    /// \param ctx      The DHM context to query.
    ///
    /// \return         The size of the prime modulus in bits,
    ///                 i.e. the number n such that 2^(n-1) <= P < 2^n.
    pub fn mbedtls_dhm_get_bitlen(ctx: *const mbedtls_dhm_context) -> usize;
}
extern "C" {
    /// \brief          This function returns the size of the prime modulus in bytes.
    ///
    /// \param ctx      The DHM context to query.
    ///
    /// \return         The size of the prime modulus in bytes,
    ///                 i.e. the number n such that 2^(8*(n-1)) <= P < 2^(8*n).
    pub fn mbedtls_dhm_get_len(ctx: *const mbedtls_dhm_context) -> usize;
}
extern "C" {
    /// \brief          This function copies a parameter of a DHM key.
    ///
    /// \param ctx      The DHM context to query.
    /// \param param    The parameter to copy.
    /// \param dest     The MPI object to copy the value into. It must be
    ///                 initialized.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_DHM_BAD_INPUT_DATA if \p field is invalid.
    /// \return         An \c MBEDTLS_ERR_MPI_XXX error code if the copy fails.
    pub fn mbedtls_dhm_get_value(
        ctx: *const mbedtls_dhm_context,
        param: mbedtls_dhm_parameter,
        dest: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function frees and clears the components
    ///                 of a DHM context.
    ///
    /// \param ctx      The DHM context to free and clear. This may be \c NULL,
    ///                 in which case this function is a no-op. If it is not \c NULL,
    ///                 it must point to an initialized DHM context.
    pub fn mbedtls_dhm_free(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    /// \brief             This function parses DHM parameters in PEM or DER format.
    ///
    /// \param dhm         The DHM context to import the DHM parameters into.
    ///                    This must be initialized.
    /// \param dhmin       The input buffer. This must be a readable buffer of
    ///                    length \p dhminlen Bytes.
    /// \param dhminlen    The size of the input buffer \p dhmin, including the
    ///                    terminating \c NULL Byte for PEM data.
    ///
    /// \return            \c 0 on success.
    /// \return            An \c MBEDTLS_ERR_DHM_XXX or \c MBEDTLS_ERR_PEM_XXX error
    ///                    code on failure.
    pub fn mbedtls_dhm_parse_dhm(
        dhm: *mut mbedtls_dhm_context,
        dhmin: *const crate::c_types::c_uchar,
        dhminlen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          The DMH checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_dhm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
///< Our key.
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_OURS: mbedtls_ecdh_side = 0;
///< The key of the peer.
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_THEIRS: mbedtls_ecdh_side = 1;
/// Defines the source of the imported EC key.
pub type mbedtls_ecdh_side = crate::c_types::c_uint;
///< Implementation not defined.
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_NONE: mbedtls_ecdh_variant = 0;
///< The default Mbed TLS implementation
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0: mbedtls_ecdh_variant = 1;
/// Defines the ECDH implementation used.
///
/// Later versions of the library may add new variants, therefore users should
/// not make any assumptions about them.
pub type mbedtls_ecdh_variant = crate::c_types::c_uint;
/// The context used by the default ECDH implementation.
///
/// Later versions might change the structure of this context, therefore users
/// should not make any assumptions about the structure of
/// mbedtls_ecdh_context_mbed.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecdh_context_mbed {
    ///< The elliptic curve used.
    pub private_grp: mbedtls_ecp_group,
    ///< The private key.
    pub private_d: mbedtls_mpi,
    ///< The public key.
    pub private_Q: mbedtls_ecp_point,
    ///< The value of the public key of the peer.
    pub private_Qp: mbedtls_ecp_point,
    ///< The shared secret.
    pub private_z: mbedtls_mpi,
}
/// \warning         Performing multiple operations concurrently on the same
///                  ECDSA context is not supported; objects of this type
///                  should not be shared between multiple threads.
/// \brief           The ECDH context structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecdh_context {
    ///< The format of point export in TLS messages
    ///as defined in RFC 4492.
    pub private_point_format: u8,
    ///< The elliptic curve used.
    pub private_grp_id: mbedtls_ecp_group_id,
    ///< The ECDH implementation/structure used.
    pub private_var: mbedtls_ecdh_variant,
    ///< Implementation-specific context. The
    ///context in use is specified by the \c var
    ///field.
    pub private_ctx: mbedtls_ecdh_context__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ecdh_context__bindgen_ty_1 {
    pub private_mbed_ecdh: mbedtls_ecdh_context_mbed,
}
extern "C" {
    /// \brief          Check whether a given group can be used for ECDH.
    ///
    /// \param gid      The ECP group ID to check.
    ///
    /// \return         \c 1 if the group can be used, \c 0 otherwise
    pub fn mbedtls_ecdh_can_do(gid: mbedtls_ecp_group_id) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function generates an ECDH keypair on an elliptic
    ///                  curve.
    ///
    ///                  This function performs the first of two core computations
    ///                  implemented during the ECDH key exchange. The second core
    ///                  computation is performed by mbedtls_ecdh_compute_shared().
    ///
    /// \see             ecp.h
    ///
    /// \param grp       The ECP group to use. This must be initialized and have
    ///                  domain parameters loaded, for example through
    ///                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().
    /// \param d         The destination MPI (private key).
    ///                  This must be initialized.
    /// \param Q         The destination point (public key).
    ///                  This must be initialized.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be
    ///                  \c NULL in case \p f_rng doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX or
    ///                  \c MBEDTLS_MPI_XXX error code on failure.
    pub fn mbedtls_ecdh_gen_public(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function computes the shared secret.
    ///
    ///                  This function performs the second of two core computations
    ///                  implemented during the ECDH key exchange. The first core
    ///                  computation is performed by mbedtls_ecdh_gen_public().
    ///
    /// \see             ecp.h
    ///
    /// \note            If \p f_rng is not NULL, it is used to implement
    ///                  countermeasures against side-channel attacks.
    ///                  For more information, see mbedtls_ecp_mul().
    ///
    /// \param grp       The ECP group to use. This must be initialized and have
    ///                  domain parameters loaded, for example through
    ///                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().
    /// \param z         The destination MPI (shared secret).
    ///                  This must be initialized.
    /// \param Q         The public key from another party.
    ///                  This must be initialized.
    /// \param d         Our secret exponent (private key).
    ///                  This must be initialized.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be
    ///                  \c NULL if \p f_rng is \c NULL or doesn't need a
    ///                  context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX or
    ///                  \c MBEDTLS_MPI_XXX error code on failure.
    pub fn mbedtls_ecdh_compute_shared(
        grp: *mut mbedtls_ecp_group,
        z: *mut mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        d: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function initializes an ECDH context.
    ///
    /// \param ctx       The ECDH context to initialize. This must not be \c NULL.
    pub fn mbedtls_ecdh_init(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    /// \brief           This function sets up the ECDH context with the information
    ///                  given.
    ///
    ///                  This function should be called after mbedtls_ecdh_init() but
    ///                  before mbedtls_ecdh_make_params(). There is no need to call
    ///                  this function before mbedtls_ecdh_read_params().
    ///
    ///                  This is the first function used by a TLS server for ECDHE
    ///                  ciphersuites.
    ///
    /// \param ctx       The ECDH context to set up. This must be initialized.
    /// \param grp_id    The group id of the group to set up the context for.
    ///
    /// \return          \c 0 on success.
    pub fn mbedtls_ecdh_setup(
        ctx: *mut mbedtls_ecdh_context,
        grp_id: mbedtls_ecp_group_id,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function frees a context.
    ///
    /// \param ctx       The context to free. This may be \c NULL, in which
    ///                  case this function does nothing. If it is not \c NULL,
    ///                  it must point to an initialized ECDH context.
    pub fn mbedtls_ecdh_free(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    /// \brief           This function generates an EC key pair and exports its
    ///                  in the format used in a TLS ServerKeyExchange handshake
    ///                  message.
    ///
    ///                  This is the second function used by a TLS server for ECDHE
    ///                  ciphersuites. (It is called after mbedtls_ecdh_setup().)
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDH context to use. This must be initialized
    ///                  and bound to a group, for example via mbedtls_ecdh_setup().
    /// \param olen      The address at which to store the number of Bytes written.
    /// \param buf       The destination buffer. This must be a writable buffer of
    ///                  length \p blen Bytes.
    /// \param blen      The length of the destination buffer \p buf in Bytes.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be
    ///                  \c NULL in case \p f_rng doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
    pub fn mbedtls_ecdh_make_params(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function parses the ECDHE parameters in a
    ///                  TLS ServerKeyExchange handshake message.
    ///
    /// \note            In a TLS handshake, this is the how the client
    ///                  sets up its ECDHE context from the server's public
    ///                  ECDHE key material.
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDHE context to use. This must be initialized.
    /// \param buf       On input, \c *buf must be the start of the input buffer.
    ///                  On output, \c *buf is updated to point to the end of the
    ///                  data that has been read. On success, this is the first byte
    ///                  past the end of the ServerKeyExchange parameters.
    ///                  On error, this is the point at which an error has been
    ///                  detected, which is usually not useful except to debug
    ///                  failures.
    /// \param end       The end of the input buffer.
    ///
    /// \return          \c 0 on success.
    /// \return          An \c MBEDTLS_ERR_ECP_XXX error code on failure.
    pub fn mbedtls_ecdh_read_params(
        ctx: *mut mbedtls_ecdh_context,
        buf: *mut *const crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function sets up an ECDH context from an EC key.
    ///
    ///                  It is used by clients and servers in place of the
    ///                  ServerKeyEchange for static ECDH, and imports ECDH
    ///                  parameters from the EC key information of a certificate.
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDH context to set up. This must be initialized.
    /// \param key       The EC key to use. This must be initialized.
    /// \param side      Defines the source of the key. Possible values are:
    ///                  - #MBEDTLS_ECDH_OURS: The key is ours.
    ///                  - #MBEDTLS_ECDH_THEIRS: The key is that of the peer.
    ///
    /// \return          \c 0 on success.
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
    pub fn mbedtls_ecdh_get_params(
        ctx: *mut mbedtls_ecdh_context,
        key: *const mbedtls_ecp_keypair,
        side: mbedtls_ecdh_side,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function generates a public key and exports it
    ///                  as a TLS ClientKeyExchange payload.
    ///
    ///                  This is the second function used by a TLS client for ECDH(E)
    ///                  ciphersuites.
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDH context to use. This must be initialized
    ///                  and bound to a group, the latter usually by
    ///                  mbedtls_ecdh_read_params().
    /// \param olen      The address at which to store the number of Bytes written.
    ///                  This must not be \c NULL.
    /// \param buf       The destination buffer. This must be a writable buffer
    ///                  of length \p blen Bytes.
    /// \param blen      The size of the destination buffer \p buf in Bytes.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG context to be passed to \p f_rng. This may be
    ///                  \c NULL in case \p f_rng doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
    pub fn mbedtls_ecdh_make_public(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       This function parses and processes the ECDHE payload of a
    ///              TLS ClientKeyExchange message.
    ///
    ///              This is the third function used by a TLS server for ECDH(E)
    ///              ciphersuites. (It is called after mbedtls_ecdh_setup() and
    ///              mbedtls_ecdh_make_params().)
    ///
    /// \see         ecp.h
    ///
    /// \param ctx   The ECDH context to use. This must be initialized
    ///              and bound to a group, for example via mbedtls_ecdh_setup().
    /// \param buf   The pointer to the ClientKeyExchange payload. This must
    ///              be a readable buffer of length \p blen Bytes.
    /// \param blen  The length of the input buffer \p buf in Bytes.
    ///
    /// \return      \c 0 on success.
    /// \return      An \c MBEDTLS_ERR_ECP_XXX error code on failure.
    pub fn mbedtls_ecdh_read_public(
        ctx: *mut mbedtls_ecdh_context,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           This function derives and exports the shared secret.
    ///
    ///                  This is the last function used by both TLS client
    ///                  and servers.
    ///
    /// \note            If \p f_rng is not NULL, it is used to implement
    ///                  countermeasures against side-channel attacks.
    ///                  For more information, see mbedtls_ecp_mul().
    ///
    /// \see             ecp.h
    ///
    /// \param ctx       The ECDH context to use. This must be initialized
    ///                  and have its own private key generated and the peer's
    ///                  public key imported.
    /// \param olen      The address at which to store the total number of
    ///                  Bytes written on success. This must not be \c NULL.
    /// \param buf       The buffer to write the generated shared key to. This
    ///                  must be a writable buffer of size \p blen Bytes.
    /// \param blen      The length of the destination buffer \p buf in Bytes.
    /// \param f_rng     The RNG function to use. This must not be \c NULL.
    /// \param p_rng     The RNG context. This may be \c NULL if \p f_rng
    ///                  doesn't need a context argument.
    ///
    /// \return          \c 0 on success.
    /// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
    ///                  operations was reached: see \c mbedtls_ecp_set_max_ops().
    /// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
    pub fn mbedtls_ecdh_calc_secret(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_premaster_secret {
    pub _pms_rsa: [crate::c_types::c_uchar; 48usize],
    pub _pms_dhm: [crate::c_types::c_uchar; 1024usize],
    pub _pms_ecdh: [crate::c_types::c_uchar; 66usize],
    pub _pms_psk: [crate::c_types::c_uchar; 100usize],
    pub _pms_dhe_psk: [crate::c_types::c_uchar; 1076usize],
    pub _pms_rsa_psk: [crate::c_types::c_uchar; 100usize],
    pub _pms_ecdhe_psk: [crate::c_types::c_uchar; 118usize],
}
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_REQUEST: mbedtls_ssl_states = 0;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_HELLO: mbedtls_ssl_states = 1;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO: mbedtls_ssl_states = 2;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CERTIFICATE: mbedtls_ssl_states = 3;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_KEY_EXCHANGE: mbedtls_ssl_states = 4;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_REQUEST: mbedtls_ssl_states = 5;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_DONE: mbedtls_ssl_states = 6;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE: mbedtls_ssl_states = 7;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_KEY_EXCHANGE: mbedtls_ssl_states = 8;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_VERIFY: mbedtls_ssl_states = 9;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 10;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_FINISHED: mbedtls_ssl_states = 11;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 12;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_FINISHED: mbedtls_ssl_states = 13;
pub const mbedtls_ssl_states_MBEDTLS_SSL_FLUSH_BUFFERS: mbedtls_ssl_states = 14;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_WRAPUP: mbedtls_ssl_states = 15;
pub const mbedtls_ssl_states_MBEDTLS_SSL_NEW_SESSION_TICKET: mbedtls_ssl_states = 16;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: mbedtls_ssl_states = 17;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_RETRY_REQUEST: mbedtls_ssl_states = 18;
pub const mbedtls_ssl_states_MBEDTLS_SSL_ENCRYPTED_EXTENSIONS: mbedtls_ssl_states = 19;
pub const mbedtls_ssl_states_MBEDTLS_SSL_END_OF_EARLY_DATA: mbedtls_ssl_states = 20;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY: mbedtls_ssl_states = 21;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED: mbedtls_ssl_states = 22;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO: mbedtls_ssl_states =
    23;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO: mbedtls_ssl_states = 24;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO: mbedtls_ssl_states = 25;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST: mbedtls_ssl_states =
    26;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_OVER: mbedtls_ssl_states = 27;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET: mbedtls_ssl_states = 28;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH: mbedtls_ssl_states = 29;
pub type mbedtls_ssl_states = crate::c_types::c_uint;
/// \brief          Callback type: send data on the network.
///
/// \note           That callback may be either blocking or non-blocking.
///
/// \param ctx      Context for the send callback (typically a file descriptor)
/// \param buf      Buffer holding the data to send
/// \param len      Length of the data to send
///
/// \return         The callback must return the number of bytes sent if any,
///                 or a non-zero error code.
///                 If performing non-blocking I/O, \c MBEDTLS_ERR_SSL_WANT_WRITE
///                 must be returned when the operation would block.
///
/// \note           The callback is allowed to send fewer bytes than requested.
///                 It must always return the number of bytes actually sent.
pub type mbedtls_ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int,
>;
/// \brief          Callback type: receive data from the network.
///
/// \note           That callback may be either blocking or non-blocking.
///
/// \param ctx      Context for the receive callback (typically a file
///                 descriptor)
/// \param buf      Buffer to write the received data to
/// \param len      Length of the receive buffer
///
/// \returns        If data has been received, the positive number of bytes received.
/// \returns        \c 0 if the connection has been closed.
/// \returns        If performing non-blocking I/O, \c MBEDTLS_ERR_SSL_WANT_READ
///                 must be returned when the operation would block.
/// \returns        Another negative error code on other kinds of failures.
///
/// \note           The callback may receive fewer bytes than the length of the
///                 buffer. It must always return the number of bytes actually
///                 received and written to the buffer.
pub type mbedtls_ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int,
>;
/// \brief          Callback type: receive data from the network, with timeout
///
/// \note           That callback must block until data is received, or the
///                 timeout delay expires, or the operation is interrupted by a
///                 signal.
///
/// \param ctx      Context for the receive callback (typically a file descriptor)
/// \param buf      Buffer to write the received data to
/// \param len      Length of the receive buffer
/// \param timeout  Maximum number of milliseconds to wait for data
///                 0 means no timeout (potentially waiting forever)
///
/// \return         The callback must return the number of bytes received,
///                 or a non-zero error code:
///                 \c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,
///                 \c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal.
///
/// \note           The callback may receive fewer bytes than the length of the
///                 buffer. It must always return the number of bytes actually
///                 received and written to the buffer.
pub type mbedtls_ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        timeout: u32,
    ) -> crate::c_types::c_int,
>;
/// \brief          Callback type: set a pair of timers/delays to watch
///
/// \param ctx      Context pointer
/// \param int_ms   Intermediate delay in milliseconds
/// \param fin_ms   Final delay in milliseconds
///                 0 cancels the current timer.
///
/// \note           This callback must at least store the necessary information
///                 for the associated \c mbedtls_ssl_get_timer_t callback to
///                 return correct information.
///
/// \note           If using an event-driven style of programming, an event must
///                 be generated when the final delay is passed. The event must
///                 cause a call to \c mbedtls_ssl_handshake() with the proper
///                 SSL context to be scheduled. Care must be taken to ensure
///                 that at most one such call happens at a time.
///
/// \note           Only one timer at a time must be running. Calling this
///                 function while a timer is running must cancel it. Cancelled
///                 timers must not generate any event.
pub type mbedtls_ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void, int_ms: u32, fin_ms: u32),
>;
/// \brief          Callback type: get status of timers/delays
///
/// \param ctx      Context pointer
///
/// \return         This callback must return:
///                 -1 if cancelled (fin_ms == 0),
///                  0 if none of the delays have passed,
///                  1 if only the intermediate delay has passed,
///                  2 if the final delay has passed.
pub type mbedtls_ssl_get_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_transform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_handshake_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_sig_hash_set_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_key_cert {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_flight_item {
    _unused: [u8; 0],
}
/// \brief          Callback type: server-side session cache getter
///
///                 The session cache is logically a key value store, with
///                 keys being session IDs and values being instances of
///                 mbedtls_ssl_session.
///
///                 This callback retrieves an entry in this key-value store.
///
/// \param data            The address of the session cache structure to query.
/// \param session_id      The buffer holding the session ID to query.
/// \param session_id_len  The length of \p session_id in Bytes.
/// \param session         The address of the session structure to populate.
///                        It is initialized with mbdtls_ssl_session_init(),
///                        and the callback must always leave it in a state
///                        where it can safely be freed via
///                        mbedtls_ssl_session_free() independent of the
///                        return code of this function.
///
/// \return                \c 0 on success
/// \return                A non-zero return value on failure.
pub type mbedtls_ssl_cache_get_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        session_id: *const crate::c_types::c_uchar,
        session_id_len: usize,
        session: *mut mbedtls_ssl_session,
    ) -> crate::c_types::c_int,
>;
/// \brief          Callback type: server-side session cache setter
///
///                 The session cache is logically a key value store, with
///                 keys being session IDs and values being instances of
///                 mbedtls_ssl_session.
///
///                 This callback sets an entry in this key-value store.
///
/// \param data            The address of the session cache structure to modify.
/// \param session_id      The buffer holding the session ID to query.
/// \param session_id_len  The length of \p session_id in Bytes.
/// \param session         The address of the session to be stored in the
///                        session cache.
///
/// \return                \c 0 on success
/// \return                A non-zero return value on failure.
pub type mbedtls_ssl_cache_set_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        session_id: *const crate::c_types::c_uchar,
        session_id_len: usize,
        session: *const mbedtls_ssl_session,
    ) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_tls13_application_secrets {
    pub client_application_traffic_secret_N: [crate::c_types::c_uchar; 64usize],
    pub server_application_traffic_secret_N: [crate::c_types::c_uchar; 64usize],
    pub exporter_master_secret: [crate::c_types::c_uchar; 64usize],
    pub resumption_master_secret: [crate::c_types::c_uchar; 64usize],
}
///< Context not in use or version not yet negotiated.
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_UNKNOWN: mbedtls_ssl_protocol_version =
    0;
///< (D)TLS 1.2
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_2: mbedtls_ssl_protocol_version =
    771;
///< (D)TLS 1.3
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_3: mbedtls_ssl_protocol_version =
    772;
/// Human-friendly representation of the (D)TLS protocol version.
pub type mbedtls_ssl_protocol_version = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_session {
    ///< MaxFragmentLength negotiated by peer
    pub private_mfl_code: crate::c_types::c_uchar,
    pub private_exported: crate::c_types::c_uchar,
    /// TLS version negotiated in the session. Used if and when renegotiating
    ///  or resuming a session instead of the configured minor TLS version.
    pub private_tls_version: mbedtls_ssl_protocol_version,
    ///< chosen ciphersuite
    pub private_ciphersuite: crate::c_types::c_int,
    ///< session id length
    pub private_id_len: usize,
    ///< session identifier
    pub private_id: [crate::c_types::c_uchar; 32usize],
    ///< the master secret
    pub private_master: [crate::c_types::c_uchar; 48usize],
    ///< peer X.509 cert chain
    pub private_peer_cert: *mut mbedtls_x509_crt,
    ///<  verification result
    pub private_verify_result: u32,
    ///< RFC 5077 session ticket
    pub private_ticket: *mut crate::c_types::c_uchar,
    ///< session ticket length
    pub private_ticket_len: usize,
    ///< ticket lifetime hint
    pub private_ticket_lifetime: u32,
    ///< 0: client, 1: server
    pub private_endpoint: u8,
    ///< Ticket flags
    pub private_ticket_flags: u8,
    ///< Randomly generated value used to obscure the age of the ticket
    pub private_ticket_age_add: u32,
    ///< resumption_key length
    pub private_resumption_key_len: u8,
    pub private_resumption_key: [crate::c_types::c_uchar; 48usize],
    ///< host name binded with tickets
    pub private_hostname: *mut crate::c_types::c_char,
    ///< flag for EtM activation
    pub private_encrypt_then_mac: crate::c_types::c_int,
    pub private_app_secrets: mbedtls_ssl_tls13_application_secrets,
}
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_NONE: mbedtls_tls_prf_types = 0;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA384: mbedtls_tls_prf_types = 1;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA256: mbedtls_tls_prf_types = 2;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA384: mbedtls_tls_prf_types = 3;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA256: mbedtls_tls_prf_types = 4;
pub type mbedtls_tls_prf_types = crate::c_types::c_uint;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET:
    mbedtls_ssl_key_export_type = 0;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_EARLY_SECRET:
    mbedtls_ssl_key_export_type = 1;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_EARLY_EXPORTER_SECRET:
    mbedtls_ssl_key_export_type = 2;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_HANDSHAKE_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 3 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_HANDSHAKE_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 4 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_APPLICATION_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 5 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_APPLICATION_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 6 ;
pub type mbedtls_ssl_key_export_type = crate::c_types::c_uint;
/// \brief           Callback type: Export key alongside random values for
///                                 session identification, and PRF for
///                                 implementation of TLS key exporters.
///
/// \param p_expkey   Context for the callback.
/// \param type       The type of the key that is being exported.
/// \param secret     The address of the buffer holding the secret
///                   that's being exporterd.
/// \param secret_len The length of \p secret in bytes.
/// \param client_random The client random bytes.
/// \param server_random The server random bytes.
/// \param tls_prf_type The identifier for the PRF used in the handshake
///                     to which the key belongs.
pub type mbedtls_ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut crate::c_types::c_void,
        type_: mbedtls_ssl_key_export_type,
        secret: *const crate::c_types::c_uchar,
        secret_len: usize,
        client_random: *const crate::c_types::c_uchar,
        server_random: *const crate::c_types::c_uchar,
        tls_prf_type: mbedtls_tls_prf_types,
    ),
>;
/// \brief           Callback type: generic handshake callback
///
/// \note            Callbacks may use user_data funcs to set/get app user data.
///                  See \c mbedtls_ssl_get_user_data_p()
///                      \c mbedtls_ssl_get_user_data_n()
///                      \c mbedtls_ssl_conf_get_user_data_p()
///                      \c mbedtls_ssl_conf_get_user_data_n()
///
/// \param ssl       \c mbedtls_ssl_context on which the callback is run
///
/// \return          The return value of the callback is 0 if successful,
///                  or a specific MBEDTLS_ERR_XXX code, which will cause
///                  the handshake to be aborted.
pub type mbedtls_ssl_hs_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_user_data_t {
    pub n: usize,
    pub p: *mut crate::c_types::c_void,
}
/// SSL/TLS configuration to be shared between mbedtls_ssl_context structures.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_config {
    ///< max. TLS version used
    pub private_max_tls_version: mbedtls_ssl_protocol_version,
    ///< min. TLS version used
    pub private_min_tls_version: mbedtls_ssl_protocol_version,
    ///< 0: client, 1: server
    pub private_endpoint: u8,
    ///< 0: stream (TLS), 1: datagram (DTLS)
    pub private_transport: u8,
    ///< MBEDTLS_SSL_VERIFY_XXX
    pub private_authmode: u8,
    ///< MBEDTLS_LEGACY_XXX
    pub private_allow_legacy_renegotiation: u8,
    ///< desired fragment length indicator
    ///(MBEDTLS_SSL_MAX_FRAG_LEN_XXX)
    pub private_mfl_code: u8,
    ///< negotiate encrypt-then-mac?
    pub private_encrypt_then_mac: u8,
    ///< negotiate extended master secret?
    pub private_extended_ms: u8,
    ///< detect and prevent replay?
    pub private_anti_replay: u8,
    ///< disable renegotiation?
    pub private_disable_renegotiation: u8,
    ///< use session tickets?
    pub private_session_tickets: u8,
    ///< number of NewSessionTicket
    pub private_new_session_tickets_count: u16,
    ///< enable sending CA list in
    ///Certificate Request messages?
    pub private_cert_req_ca_list: u8,
    ///< pick the ciphersuite according to
    ///the client's preferences rather
    ///than ours?
    pub private_respect_cli_pref: u8,
    ///< Should DTLS record with
    ///   unexpected CID
    ///   lead to failure?
    pub private_ignore_unexpected_cid: u8,
    /// Allowed ciphersuites for (D)TLS 1.2 (0-terminated)
    pub private_ciphersuite_list: *const crate::c_types::c_int,
    /// Allowed TLS 1.3 key exchange modes.
    pub private_tls13_kex_modes: crate::c_types::c_int,
    /// Callback for printing debug output
    pub private_f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: crate::c_types::c_int,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
            arg5: *const crate::c_types::c_char,
        ),
    >,
    ///< context for the debug function
    pub private_p_dbg: *mut crate::c_types::c_void,
    /// Callback for getting (pseudo-)random numbers
    pub private_f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut crate::c_types::c_uchar,
            arg3: usize,
        ) -> crate::c_types::c_int,
    >,
    ///< context for the RNG function
    pub private_p_rng: *mut crate::c_types::c_void,
    /// Callback to retrieve a session from the cache
    pub private_f_get_cache: mbedtls_ssl_cache_get_t,
    /// Callback to store a session into the cache
    pub private_f_set_cache: mbedtls_ssl_cache_set_t,
    ///< context for cache callbacks
    pub private_p_cache: *mut crate::c_types::c_void,
    /// Callback for setting cert according to SNI extension
    pub private_f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const crate::c_types::c_uchar,
            arg4: usize,
        ) -> crate::c_types::c_int,
    >,
    ///< context for SNI callback
    pub private_p_sni: *mut crate::c_types::c_void,
    /// Callback to customize X.509 certificate chain verification
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: crate::c_types::c_int,
            arg4: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    ///< context for X.509 verify calllback
    pub private_p_vrfy: *mut crate::c_types::c_void,
    /// Callback to retrieve PSK key from identity
    pub private_f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const crate::c_types::c_uchar,
            arg4: usize,
        ) -> crate::c_types::c_int,
    >,
    ///< context for PSK callback
    pub private_p_psk: *mut crate::c_types::c_void,
    /// Callback to create & write a cookie for ClientHello verification
    pub private_f_cookie_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut *mut crate::c_types::c_uchar,
            arg3: *mut crate::c_types::c_uchar,
            arg4: *const crate::c_types::c_uchar,
            arg5: usize,
        ) -> crate::c_types::c_int,
    >,
    /// Callback to verify validity of a ClientHello cookie
    pub private_f_cookie_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *const crate::c_types::c_uchar,
            arg3: usize,
            arg4: *const crate::c_types::c_uchar,
            arg5: usize,
        ) -> crate::c_types::c_int,
    >,
    ///< context for the cookie callbacks
    pub private_p_cookie: *mut crate::c_types::c_void,
    /// Callback to create & write a session ticket
    pub private_f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *const mbedtls_ssl_session,
            arg3: *mut crate::c_types::c_uchar,
            arg4: *const crate::c_types::c_uchar,
            arg5: *mut usize,
            arg6: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    /// Callback to parse a session ticket into a session structure
    pub private_f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_session,
            arg3: *mut crate::c_types::c_uchar,
            arg4: usize,
        ) -> crate::c_types::c_int,
    >,
    ///< context for the ticket callbacks
    pub private_p_ticket: *mut crate::c_types::c_void,
    ///< The length of CIDs for incoming DTLS records.
    pub private_cid_len: usize,
    ///< verification profile
    pub private_cert_profile: *const mbedtls_x509_crt_profile,
    ///< own certificate/key pair(s)
    pub private_key_cert: *mut mbedtls_ssl_key_cert,
    ///< trusted CAs
    pub private_ca_chain: *mut mbedtls_x509_crt,
    ///< trusted CAs CRLs
    pub private_ca_crl: *mut mbedtls_x509_crl,
    ///< allowed signature hashes
    pub private_sig_hashes: *const crate::c_types::c_int,
    ///< allowed signature algorithms
    pub private_sig_algs: *const u16,
    ///< allowed curves
    pub private_curve_list: *const mbedtls_ecp_group_id,
    ///< allowed IANA NamedGroups
    pub private_group_list: *const u16,
    ///< prime modulus for DHM
    pub private_dhm_P: mbedtls_mpi,
    ///< generator for DHM
    pub private_dhm_G: mbedtls_mpi,
    ///< The raw pre-shared key. This field should
    ///   only be set via mbedtls_ssl_conf_psk().
    ///   If either no PSK or an opaque PSK
    ///   have been configured, this has value NULL.
    pub private_psk: *mut crate::c_types::c_uchar,
    ///< The length of the raw pre-shared key.
    ///   This field should only be set via
    ///   mbedtls_ssl_conf_psk().
    ///   Its value is non-zero if and only if
    ///   \c psk is not \c NULL.
    pub private_psk_len: usize,
    ///< The PSK identity for PSK negotiation.
    ///   This field should only be set via
    ///   mbedtls_ssl_conf_psk().
    ///   This is set if and only if either
    ///   \c psk or \c psk_opaque are set.
    pub private_psk_identity: *mut crate::c_types::c_uchar,
    ///< The length of PSK identity.
    ///   This field should only be set via
    ///   mbedtls_ssl_conf_psk().
    ///   Its value is non-zero if and only if
    ///   \c psk is not \c NULL or \c psk_opaque
    ///   is not \c 0.
    pub private_psk_identity_len: usize,
    ///< ordered list of protocols
    pub private_alpn_list: *mut *const crate::c_types::c_char,
    ///< timeout for mbedtls_ssl_read (ms)
    pub private_read_timeout: u32,
    ///< initial value of the handshake
    ///retransmission timeout (ms)
    pub private_hs_timeout_min: u32,
    ///< maximum value of the handshake
    ///retransmission timeout (ms)
    pub private_hs_timeout_max: u32,
    ///< grace period for renegotiation
    pub private_renego_max_records: crate::c_types::c_int,
    ///< value of the record counters
    ///that triggers renegotiation
    pub private_renego_period: [crate::c_types::c_uchar; 8usize],
    ///< limit of records with a bad MAC
    pub private_badmac_limit: crate::c_types::c_uint,
    ///< min. bit length of the DHM prime
    pub private_dhm_min_bitlen: crate::c_types::c_uint,
    /// User data pointer or handle.
    ///
    /// The library sets this to \p 0 when creating a context and does not
    /// access it afterwards.
    pub private_user_data: mbedtls_ssl_user_data_t,
    ///< certificate selection callback
    pub private_f_cert_cb: mbedtls_ssl_hs_cb_t,
    ///< acceptable client cert issuers
    pub private_dn_hints: *const mbedtls_x509_crt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_context {
    ///< configuration information
    pub private_conf: *const mbedtls_ssl_config,
    ///< SSL handshake: current state
    pub private_state: crate::c_types::c_int,
    ///< Initial, in progress, pending?
    pub private_renego_status: crate::c_types::c_int,
    ///< Records since renego request, or with DTLS,
    ///number of retransmissions of request if
    ///renego_max_records is < 0
    pub private_renego_records_seen: crate::c_types::c_int,
    /// Server: Negotiated TLS protocol version.
    ///  Client: Maximum TLS version to be negotiated, then negotiated TLS
    ///          version.
    ///
    ///  It is initialized as the maximum TLS version to be negotiated in the
    ///  ClientHello writing preparation stage and used throughout the
    ///  ClientHello writing. For a fresh handshake not linked to any previous
    ///  handshake, it is initialized to the configured maximum TLS version
    ///  to be negotiated. When renegotiating or resuming a session, it is
    ///  initialized to the previously negotiated TLS version.
    ///
    ///  Updated to the negotiated TLS version as soon as the ServerHello is
    ///  received.
    pub private_tls_version: mbedtls_ssl_protocol_version,
    ///< records with a bad MAC received
    pub private_badmac_seen: crate::c_types::c_uint,
    /// Callback to customize X.509 certificate chain verification
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: crate::c_types::c_int,
            arg4: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    ///< context for X.509 verify callback
    pub private_p_vrfy: *mut crate::c_types::c_void,
    ///< Callback for network send
    pub private_f_send: mbedtls_ssl_send_t,
    ///< Callback for network receive
    pub private_f_recv: mbedtls_ssl_recv_t,
    pub private_f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    ///< context for I/O operations
    pub private_p_bio: *mut crate::c_types::c_void,
    ///<  current session data (in)
    pub private_session_in: *mut mbedtls_ssl_session,
    ///<  current session data (out)
    pub private_session_out: *mut mbedtls_ssl_session,
    ///<  negotiated session data
    pub private_session: *mut mbedtls_ssl_session,
    ///<  session data in negotiation
    pub private_session_negotiate: *mut mbedtls_ssl_session,
    ///<  params required only during
    ///the handshake process
    pub private_handshake: *mut mbedtls_ssl_handshake_params,
    ///<  current transform params (in)
    ///    This is always a reference,
    ///    never an owning pointer.
    pub private_transform_in: *mut mbedtls_ssl_transform,
    ///<  current transform params (out)
    ///    This is always a reference,
    ///    never an owning pointer.
    pub private_transform_out: *mut mbedtls_ssl_transform,
    ///<  negotiated transform params
    ///    This pointer owns the transform
    ///    it references.
    pub private_transform: *mut mbedtls_ssl_transform,
    ///<  transform params in negotiation
    ///    This pointer owns the transform
    ///    it references.
    pub private_transform_negotiate: *mut mbedtls_ssl_transform,
    /// The application data transform in TLS 1.3.
    ///  This pointer owns the transform it references.
    pub private_transform_application: *mut mbedtls_ssl_transform,
    ///< context for the timer callbacks
    pub private_p_timer: *mut crate::c_types::c_void,
    ///< set timer callback
    pub private_f_set_timer: mbedtls_ssl_set_timer_t,
    ///< get timer callback
    pub private_f_get_timer: mbedtls_ssl_get_timer_t,
    ///< input buffer
    pub private_in_buf: *mut crate::c_types::c_uchar,
    ///< 64-bit incoming message counter
    ///TLS: maintained by us
    ///DTLS: read from peer
    pub private_in_ctr: *mut crate::c_types::c_uchar,
    ///< start of record header
    pub private_in_hdr: *mut crate::c_types::c_uchar,
    ///< The start of the CID;
    ///   (the end is marked by in_len).
    pub private_in_cid: *mut crate::c_types::c_uchar,
    ///< two-bytes message length field
    pub private_in_len: *mut crate::c_types::c_uchar,
    ///< ivlen-byte IV
    pub private_in_iv: *mut crate::c_types::c_uchar,
    ///< message contents (in_iv+ivlen)
    pub private_in_msg: *mut crate::c_types::c_uchar,
    ///< read offset in application data
    pub private_in_offt: *mut crate::c_types::c_uchar,
    ///< record header: message type
    pub private_in_msgtype: crate::c_types::c_int,
    ///< record header: message length
    pub private_in_msglen: usize,
    ///< amount of data read so far
    pub private_in_left: usize,
    ///< DTLS epoch for incoming records
    pub private_in_epoch: u16,
    ///< offset of the next record in datagram
    ///(equal to in_left if none)
    pub private_next_record_offset: usize,
    ///< last validated record seq_num
    pub private_in_window_top: u64,
    ///< bitmask for replay detection
    pub private_in_window: u64,
    ///< current handshake message length,
    ///including the handshake header
    pub private_in_hslen: usize,
    ///< # of 0-length encrypted messages
    pub private_nb_zero: crate::c_types::c_int,
    ///< drop or reuse current message
    ///on next call to record layer?
    pub private_keep_current_message: crate::c_types::c_int,
    ///< Determines if a fatal alert
    ///should be sent. Values:
    ///- \c 0 , no alert is to be sent.
    ///- \c 1 , alert is to be sent.
    pub private_send_alert: crate::c_types::c_uchar,
    ///< Type of alert if send_alert
    ///= 0
    pub private_alert_type: crate::c_types::c_uchar,
    ///< The error code to be returned
    ///to the user once the fatal alert
    ///has been sent.
    pub private_alert_reason: crate::c_types::c_int,
    ///< Disable packing multiple records
    ///   within a single datagram.
    pub private_disable_datagram_packing: u8,
    ///< output buffer
    pub private_out_buf: *mut crate::c_types::c_uchar,
    ///< 64-bit outgoing message counter
    pub private_out_ctr: *mut crate::c_types::c_uchar,
    ///< start of record header
    pub private_out_hdr: *mut crate::c_types::c_uchar,
    ///< The start of the CID;
    ///   (the end is marked by in_len).
    pub private_out_cid: *mut crate::c_types::c_uchar,
    ///< two-bytes message length field
    pub private_out_len: *mut crate::c_types::c_uchar,
    ///< ivlen-byte IV
    pub private_out_iv: *mut crate::c_types::c_uchar,
    ///< message contents (out_iv+ivlen)
    pub private_out_msg: *mut crate::c_types::c_uchar,
    ///< record header: message type
    pub private_out_msgtype: crate::c_types::c_int,
    ///< record header: message length
    pub private_out_msglen: usize,
    ///< amount of data not yet written
    pub private_out_left: usize,
    ///<  Outgoing record sequence  number.
    pub private_cur_out_ctr: [crate::c_types::c_uchar; 8usize],
    ///< path mtu, used to fragment outgoing messages
    pub private_mtu: u16,
    ///< expected peer CN for verification
    ///(and SNI if available)
    pub private_hostname: *mut crate::c_types::c_char,
    ///<  negotiated protocol
    pub private_alpn_chosen: *const crate::c_types::c_char,
    ///<  transport-level ID of the client
    pub private_cli_id: *mut crate::c_types::c_uchar,
    ///<  length of cli_id
    pub private_cli_id_len: usize,
    ///<  does peer support legacy or
    ///secure renegotiation
    pub private_secure_renegotiation: crate::c_types::c_int,
    ///<  length of verify data stored
    pub private_verify_data_len: usize,
    ///<  previous handshake verify data
    pub private_own_verify_data: [crate::c_types::c_char; 12usize],
    ///<  previous handshake verify data
    pub private_peer_verify_data: [crate::c_types::c_char; 12usize],
    /// The next incoming CID, chosen by the user and applying to
    ///  all subsequent handshakes. This may be different from the
    ///  CID currently used in case the user has re-configured the CID
    ///  after an initial handshake.
    pub private_own_cid: [crate::c_types::c_uchar; 32usize],
    ///< The length of \c own_cid.
    pub private_own_cid_len: u8,
    ///< This indicates whether the CID extension should
    ///   be negotiated in the next handshake or not.
    ///   Possible values are #MBEDTLS_SSL_CID_ENABLED
    ///   and #MBEDTLS_SSL_CID_DISABLED.
    pub private_negotiate_cid: u8,
    /// Callback to export key block and master secret
    pub private_f_export_keys: mbedtls_ssl_export_keys_t,
    ///< context for key export callback
    pub private_p_export_keys: *mut crate::c_types::c_void,
    /// User data pointer or handle.
    ///
    /// The library sets this to \p 0 when creating a context and does not
    /// access it afterwards.
    ///
    /// \warning Serializing and restoring an SSL context with
    ///          mbedtls_ssl_context_save() and mbedtls_ssl_context_load()
    ///          does not currently restore the user data.
    pub private_user_data: mbedtls_ssl_user_data_t,
}
extern "C" {
    /// \brief               Return the name of the ciphersuite associated with the
    ///                      given ID
    ///
    /// \param ciphersuite_id SSL ciphersuite ID
    ///
    /// \return              a string containing the ciphersuite name
    pub fn mbedtls_ssl_get_ciphersuite_name(
        ciphersuite_id: crate::c_types::c_int,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    /// \brief               Return the ID of the ciphersuite associated with the
    ///                      given name
    ///
    /// \param ciphersuite_name SSL ciphersuite name
    ///
    /// \return              the ID with the ciphersuite or 0 if not found
    pub fn mbedtls_ssl_get_ciphersuite_id(
        ciphersuite_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Initialize an SSL context
    ///                 Just makes the context ready for mbedtls_ssl_setup() or
    ///                 mbedtls_ssl_free()
    ///
    /// \param ssl      SSL context
    pub fn mbedtls_ssl_init(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    /// \brief          Set up an SSL context for use
    ///
    /// \note           No copy of the configuration context is made, it can be
    ///                 shared by many mbedtls_ssl_context structures.
    ///
    /// \warning        The conf structure will be accessed during the session.
    ///                 It must not be modified or freed as long as the session
    ///                 is active.
    ///
    /// \warning        This function must be called exactly once per context.
    ///                 Calling mbedtls_ssl_setup again is not supported, even
    ///                 if no session is active.
    ///
    /// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                 subsystem must have been initialized by calling
    ///                 psa_crypto_init() before calling this function.
    ///
    /// \param ssl      SSL context
    /// \param conf     SSL configuration to use
    ///
    /// \return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if
    ///                 memory allocation failed
    pub fn mbedtls_ssl_setup(
        ssl: *mut mbedtls_ssl_context,
        conf: *const mbedtls_ssl_config,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Reset an already initialized SSL context for re-use
    ///                 while retaining application-set variables, function
    ///                 pointers and data.
    ///
    /// \param ssl      SSL context
    /// \return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED or
    ///MBEDTLS_ERR_SSL_HW_ACCEL_FAILED
    pub fn mbedtls_ssl_session_reset(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the current endpoint type
    ///
    /// \param conf     SSL configuration
    /// \param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER
    pub fn mbedtls_ssl_conf_endpoint(
        conf: *mut mbedtls_ssl_config,
        endpoint: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief           Set the transport type (TLS or DTLS).
    ///                  Default: TLS
    ///
    /// \note            For DTLS, you must either provide a recv callback that
    ///                  doesn't block, or one that handles timeouts, see
    ///                  \c mbedtls_ssl_set_bio(). You also need to provide timer
    ///                  callbacks with \c mbedtls_ssl_set_timer_cb().
    ///
    /// \param conf      SSL configuration
    /// \param transport transport type:
    ///                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,
    ///                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS.
    pub fn mbedtls_ssl_conf_transport(
        conf: *mut mbedtls_ssl_config,
        transport: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Set the certificate verification mode
    ///                 Default: NONE on server, REQUIRED on client
    ///
    /// \param conf     SSL configuration
    /// \param authmode can be:
    ///
    ///  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked
    ///                        (default on server)
    ///                        (insecure on client)
    ///
    ///  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the
    ///                        handshake continues even if verification failed;
    ///                        mbedtls_ssl_get_verify_result() can be called after the
    ///                        handshake is complete.
    ///
    ///  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,
    ///                        handshake is aborted if verification failed.
    ///                        (default on client)
    ///
    /// \note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode.
    /// With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at
    /// the right time(s), which may not be obvious, while REQUIRED always perform
    /// the verification as soon as possible. For example, REQUIRED was protecting
    /// against the "triple handshake" attack even before it was found.
    pub fn mbedtls_ssl_conf_authmode(
        conf: *mut mbedtls_ssl_config,
        authmode: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Set the verification callback (Optional).
    ///
    ///                 If set, the provided verify callback is called for each
    ///                 certificate in the peer's CRT chain, including the trusted
    ///                 root. For more information, please see the documentation of
    ///                 \c mbedtls_x509_crt_verify().
    ///
    /// \note           For per context callbacks and contexts, please use
    ///                 mbedtls_ssl_set_verify() instead.
    ///
    /// \param conf     The SSL configuration to use.
    /// \param f_vrfy   The verification callback to use during CRT verification.
    /// \param p_vrfy   The opaque context to be passed to the callback.
    pub fn mbedtls_ssl_conf_verify(
        conf: *mut mbedtls_ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief          Set the random number generator callback
    ///
    /// \param conf     SSL configuration
    /// \param f_rng    RNG function (mandatory)
    /// \param p_rng    RNG parameter
    pub fn mbedtls_ssl_conf_rng(
        conf: *mut mbedtls_ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief          Set the debug callback
    ///
    ///                 The callback has the following argument:
    ///                 void *           opaque context for the callback
    ///                 int              debug level
    ///                 const char *     file name
    ///                 int              line number
    ///                 const char *     message
    ///
    /// \param conf     SSL configuration
    /// \param f_dbg    debug function
    /// \param p_dbg    debug parameter
    pub fn mbedtls_ssl_conf_dbg(
        conf: *mut mbedtls_ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: crate::c_types::c_int,
                arg3: *const crate::c_types::c_char,
                arg4: crate::c_types::c_int,
                arg5: *const crate::c_types::c_char,
            ),
        >,
        p_dbg: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief          Set the underlying BIO callbacks for write, read and
    ///                 read-with-timeout.
    ///
    /// \param ssl      SSL context
    /// \param p_bio    parameter (context) shared by BIO callbacks
    /// \param f_send   write callback
    /// \param f_recv   read callback
    /// \param f_recv_timeout blocking read callback with timeout.
    ///
    /// \note           One of f_recv or f_recv_timeout can be NULL, in which case
    ///                 the other is used. If both are non-NULL, f_recv_timeout is
    ///                 used and f_recv is ignored (as if it were NULL).
    ///
    /// \note           The two most common use cases are:
    ///                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL
    ///                 - blocking I/O, f_recv == NULL, f_recv_timeout != NULL
    ///
    /// \note           For DTLS, you need to provide either a non-NULL
    ///                 f_recv_timeout callback, or a f_recv that doesn't block.
    ///
    /// \note           See the documentations of \c mbedtls_ssl_send_t,
    ///                 \c mbedtls_ssl_recv_t and \c mbedtls_ssl_recv_timeout_t for
    ///                 the conventions those callbacks must follow.
    ///
    /// \note           On some platforms, net_sockets.c provides
    ///                 \c mbedtls_net_send(), \c mbedtls_net_recv() and
    ///                 \c mbedtls_net_recv_timeout() that are suitable to be used
    ///                 here.
    pub fn mbedtls_ssl_set_bio(
        ssl: *mut mbedtls_ssl_context,
        p_bio: *mut crate::c_types::c_void,
        f_send: mbedtls_ssl_send_t,
        f_recv: mbedtls_ssl_recv_t,
        f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    );
}
extern "C" {
    /// \brief             Configure the use of the Connection ID (CID)
    ///                    extension in the next handshake.
    ///
    ///                    Reference: RFC 9146 (or draft-ietf-tls-dtls-connection-id-05
    ///                    https://tools.ietf.org/html/draft-ietf-tls-dtls-connection-id-05
    ///                    for legacy version)
    ///
    ///                    The DTLS CID extension allows the reliable association of
    ///                    DTLS records to DTLS connections across changes in the
    ///                    underlying transport (changed IP and Port metadata) by
    ///                    adding explicit connection identifiers (CIDs) to the
    ///                    headers of encrypted DTLS records. The desired CIDs are
    ///                    configured by the application layer and are exchanged in
    ///                    new `ClientHello` / `ServerHello` extensions during the
    ///                    handshake, where each side indicates the CID it wants the
    ///                    peer to use when writing encrypted messages. The CIDs are
    ///                    put to use once records get encrypted: the stack discards
    ///                    any incoming records that don't include the configured CID
    ///                    in their header, and adds the peer's requested CID to the
    ///                    headers of outgoing messages.
    ///
    ///                    This API enables or disables the use of the CID extension
    ///                    in the next handshake and sets the value of the CID to
    ///                    be used for incoming messages.
    ///
    /// \param ssl         The SSL context to configure. This must be initialized.
    /// \param enable      This value determines whether the CID extension should
    ///                    be used or not. Possible values are:
    ///                    - MBEDTLS_SSL_CID_ENABLED to enable the use of the CID.
    ///                    - MBEDTLS_SSL_CID_DISABLED (default) to disable the use
    ///                      of the CID.
    /// \param own_cid     The address of the readable buffer holding the CID we want
    ///                    the peer to use when sending encrypted messages to us.
    ///                    This may be \c NULL if \p own_cid_len is \c 0.
    ///                    This parameter is unused if \p enabled is set to
    ///                    MBEDTLS_SSL_CID_DISABLED.
    /// \param own_cid_len The length of \p own_cid.
    ///                    This parameter is unused if \p enabled is set to
    ///                    MBEDTLS_SSL_CID_DISABLED.
    ///
    /// \note              The value of \p own_cid_len must match the value of the
    ///                    \c len parameter passed to mbedtls_ssl_conf_cid()
    ///                    when configuring the ::mbedtls_ssl_config that \p ssl
    ///                    is bound to.
    ///
    /// \note              This CID configuration applies to subsequent handshakes
    ///                    performed on the SSL context \p ssl, but does not trigger
    ///                    one. You still have to call `mbedtls_ssl_handshake()`
    ///                    (for the initial handshake) or `mbedtls_ssl_renegotiate()`
    ///                    (for a renegotiation handshake) explicitly after a
    ///                    successful call to this function to run the handshake.
    ///
    /// \note              This call cannot guarantee that the use of the CID
    ///                    will be successfully negotiated in the next handshake,
    ///                    because the peer might not support it. Specifically:
    ///                    - On the Client, enabling the use of the CID through
    ///                      this call implies that the `ClientHello` in the next
    ///                      handshake will include the CID extension, thereby
    ///                      offering the use of the CID to the server. Only if
    ///                      the `ServerHello` contains the CID extension, too,
    ///                      the CID extension will actually be put to use.
    ///                    - On the Server, enabling the use of the CID through
    ///                      this call implies that the server will look for
    ///                      the CID extension in a `ClientHello` from the client,
    ///                      and, if present, reply with a CID extension in its
    ///                      `ServerHello`.
    ///
    /// \note              To check whether the use of the CID was negotiated
    ///                    after the subsequent handshake has completed, please
    ///                    use the API mbedtls_ssl_get_peer_cid().
    ///
    /// \warning           If the use of the CID extension is enabled in this call
    ///                    and the subsequent handshake negotiates its use, Mbed TLS
    ///                    will silently drop every packet whose CID does not match
    ///                    the CID configured in \p own_cid. It is the responsibility
    ///                    of the user to adapt the underlying transport to take care
    ///                    of CID-based demultiplexing before handing datagrams to
    ///                    Mbed TLS.
    ///
    /// \return            \c 0 on success. In this case, the CID configuration
    ///                    applies to the next handshake.
    /// \return            A negative error code on failure.
    pub fn mbedtls_ssl_set_cid(
        ssl: *mut mbedtls_ssl_context,
        enable: crate::c_types::c_int,
        own_cid: *const crate::c_types::c_uchar,
        own_cid_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief              Get information about our request for usage of the CID
    ///                     extension in the current connection.
    ///
    /// \param ssl          The SSL context to query.
    /// \param enabled      The address at which to store whether the CID extension
    ///                     is requested to be used or not. If the CID is
    ///                     requested, `*enabled` is set to
    ///                     MBEDTLS_SSL_CID_ENABLED; otherwise, it is set to
    ///                     MBEDTLS_SSL_CID_DISABLED.
    /// \param own_cid      The address of the buffer in which to store our own
    ///                     CID (if the CID extension is requested). This may be
    ///                     \c NULL in case the value of our CID isn't needed. If
    ///                     it is not \c NULL, \p own_cid_len must not be \c NULL.
    /// \param own_cid_len  The address at which to store the size of our own CID
    ///                     (if the CID extension is requested). This is also the
    ///                     number of Bytes in \p own_cid that have been written.
    ///                     This may be \c NULL in case the length of our own CID
    ///                     isn't needed. If it is \c NULL, \p own_cid must be
    ///                     \c NULL, too.
    ///
    ///\note                If we are requesting an empty CID this function sets
    ///                     `*enabled` to #MBEDTLS_SSL_CID_DISABLED (the rationale
    ///                     for this is that the resulting outcome is the
    ///                     same as if the CID extensions wasn't requested).
    ///
    /// \return            \c 0 on success.
    /// \return            A negative error code on failure.
    pub fn mbedtls_ssl_get_own_cid(
        ssl: *mut mbedtls_ssl_context,
        enabled: *mut crate::c_types::c_int,
        own_cid: *mut crate::c_types::c_uchar,
        own_cid_len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief              Get information about the use of the CID extension
    ///                     in the current connection.
    ///
    /// \param ssl          The SSL context to query.
    /// \param enabled      The address at which to store whether the CID extension
    ///                     is currently in use or not. If the CID is in use,
    ///                     `*enabled` is set to MBEDTLS_SSL_CID_ENABLED;
    ///                     otherwise, it is set to MBEDTLS_SSL_CID_DISABLED.
    /// \param peer_cid     The address of the buffer in which to store the CID
    ///                     chosen by the peer (if the CID extension is used).
    ///                     This may be \c NULL in case the value of peer CID
    ///                     isn't needed. If it is not \c NULL, \p peer_cid_len
    ///                     must not be \c NULL.
    /// \param peer_cid_len The address at which to store the size of the CID
    ///                     chosen by the peer (if the CID extension is used).
    ///                     This is also the number of Bytes in \p peer_cid that
    ///                     have been written.
    ///                     This may be \c NULL in case the length of the peer CID
    ///                     isn't needed. If it is \c NULL, \p peer_cid must be
    ///                     \c NULL, too.
    ///
    /// \note               This applies to the state of the CID negotiated in
    ///                     the last complete handshake. If a handshake is in
    ///                     progress, this function will attempt to complete
    ///                     the handshake first.
    ///
    /// \note               If CID extensions have been exchanged but both client
    ///                     and server chose to use an empty CID, this function
    ///                     sets `*enabled` to #MBEDTLS_SSL_CID_DISABLED
    ///                     (the rationale for this is that the resulting
    ///                     communication is the same as if the CID extensions
    ///                     hadn't been used).
    ///
    /// \return            \c 0 on success.
    /// \return            A negative error code on failure.
    pub fn mbedtls_ssl_get_peer_cid(
        ssl: *mut mbedtls_ssl_context,
        enabled: *mut crate::c_types::c_int,
        peer_cid: *mut crate::c_types::c_uchar,
        peer_cid_len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the Maximum Transport Unit (MTU).
    ///                 Special value: 0 means unset (no limit).
    ///                 This represents the maximum size of a datagram payload
    ///                 handled by the transport layer (usually UDP) as determined
    ///                 by the network link and stack. In practice, this controls
    ///                 the maximum size datagram the DTLS layer will pass to the
    ///                 \c f_send() callback set using \c mbedtls_ssl_set_bio().
    ///
    /// \note           The limit on datagram size is converted to a limit on
    ///                 record payload by subtracting the current overhead of
    ///                 encapsulation and encryption/authentication if any.
    ///
    /// \note           This can be called at any point during the connection, for
    ///                 example when a Path Maximum Transfer Unit (PMTU)
    ///                 estimate becomes available from other sources,
    ///                 such as lower (or higher) protocol layers.
    ///
    /// \note           This setting only controls the size of the packets we send,
    ///                 and does not restrict the size of the datagrams we're
    ///                 willing to receive. Client-side, you can request the
    ///                 server to use smaller records with \c
    ///                 mbedtls_ssl_conf_max_frag_len().
    ///
    /// \note           If both a MTU and a maximum fragment length have been
    ///                 configured (or negotiated with the peer), the resulting
    ///                 lower limit on record payload (see first note) is used.
    ///
    /// \note           This can only be used to decrease the maximum size
    ///                 of datagrams (hence records, see first note) sent. It
    ///                 cannot be used to increase the maximum size of records over
    ///                 the limit set by #MBEDTLS_SSL_OUT_CONTENT_LEN.
    ///
    /// \note           Values lower than the current record layer expansion will
    ///                 result in an error when trying to send data.
    ///
    /// \param ssl      SSL context
    /// \param mtu      Value of the path MTU in bytes
    pub fn mbedtls_ssl_set_mtu(ssl: *mut mbedtls_ssl_context, mtu: u16);
}
extern "C" {
    /// \brief          Set a connection-specific verification callback (optional).
    ///
    ///                 If set, the provided verify callback is called for each
    ///                 certificate in the peer's CRT chain, including the trusted
    ///                 root. For more information, please see the documentation of
    ///                 \c mbedtls_x509_crt_verify().
    ///
    /// \note           This call is analogous to mbedtls_ssl_conf_verify() but
    ///                 binds the verification callback and context to an SSL context
    ///                 as opposed to an SSL configuration.
    ///                 If mbedtls_ssl_conf_verify() and mbedtls_ssl_set_verify()
    ///                 are both used, mbedtls_ssl_set_verify() takes precedence.
    ///
    /// \param ssl      The SSL context to use.
    /// \param f_vrfy   The verification callback to use during CRT verification.
    /// \param p_vrfy   The opaque context to be passed to the callback.
    pub fn mbedtls_ssl_set_verify(
        ssl: *mut mbedtls_ssl_context,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief          Set the timeout period for mbedtls_ssl_read()
    ///                 (Default: no timeout.)
    ///
    /// \param conf     SSL configuration context
    /// \param timeout  Timeout value in milliseconds.
    ///                 Use 0 for no timeout (default).
    ///
    /// \note           With blocking I/O, this will only work if a non-NULL
    ///                 \c f_recv_timeout was set with \c mbedtls_ssl_set_bio().
    ///                 With non-blocking I/O, this will only work if timer
    ///                 callbacks were set with \c mbedtls_ssl_set_timer_cb().
    ///
    /// \note           With non-blocking I/O, you may also skip this function
    ///                 altogether and handle timeouts at the application layer.
    pub fn mbedtls_ssl_conf_read_timeout(conf: *mut mbedtls_ssl_config, timeout: u32);
}
extern "C" {
    /// \brief          Check whether a buffer contains a valid and authentic record
    ///                 that has not been seen before. (DTLS only).
    ///
    ///                 This function does not change the user-visible state
    ///                 of the SSL context. Its sole purpose is to provide
    ///                 an indication of the legitimacy of an incoming record.
    ///
    ///                 This can be useful e.g. in distributed server environments
    ///                 using the DTLS Connection ID feature, in which connections
    ///                 might need to be passed between service instances on a change
    ///                 of peer address, but where such disruptive operations should
    ///                 only happen after the validity of incoming records has been
    ///                 confirmed.
    ///
    /// \param ssl      The SSL context to use.
    /// \param buf      The address of the buffer holding the record to be checked.
    ///                 This must be a read/write buffer of length \p buflen Bytes.
    /// \param buflen   The length of \p buf in Bytes.
    ///
    /// \note           This routine only checks whether the provided buffer begins
    ///                 with a valid and authentic record that has not been seen
    ///                 before, but does not check potential data following the
    ///                 initial record. In particular, it is possible to pass DTLS
    ///                 datagrams containing multiple records, in which case only
    ///                 the first record is checked.
    ///
    /// \note           This function modifies the input buffer \p buf. If you need
    ///                 to preserve the original record, you have to maintain a copy.
    ///
    /// \return         \c 0 if the record is valid and authentic and has not been
    ///                 seen before.
    /// \return         MBEDTLS_ERR_SSL_INVALID_MAC if the check completed
    ///                 successfully but the record was found to be not authentic.
    /// \return         MBEDTLS_ERR_SSL_INVALID_RECORD if the check completed
    ///                 successfully but the record was found to be invalid for
    ///                 a reason different from authenticity checking.
    /// \return         MBEDTLS_ERR_SSL_UNEXPECTED_RECORD if the check completed
    ///                 successfully but the record was found to be unexpected
    ///                 in the state of the SSL context, including replayed records.
    /// \return         Another negative error code on different kinds of failure.
    ///                 In this case, the SSL context becomes unusable and needs
    ///                 to be freed or reset before reuse.
    pub fn mbedtls_ssl_check_record(
        ssl: *const mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the timer callbacks (Mandatory for DTLS.)
    ///
    /// \param ssl      SSL context
    /// \param p_timer  parameter (context) shared by timer callbacks
    /// \param f_set_timer   set timer callback
    /// \param f_get_timer   get timer callback. Must return:
    ///
    /// \note           See the documentation of \c mbedtls_ssl_set_timer_t and
    ///                 \c mbedtls_ssl_get_timer_t for the conventions this pair of
    ///                 callbacks must follow.
    ///
    /// \note           On some platforms, timing.c provides
    ///                 \c mbedtls_timing_set_delay() and
    ///                 \c mbedtls_timing_get_delay() that are suitable for using
    ///                 here, except if using an event-driven style.
    ///
    /// \note           See also the "DTLS tutorial" article in our knowledge base.
    ///                 https://mbed-tls.readthedocs.io/en/latest/kb/how-to/dtls-tutorial
    pub fn mbedtls_ssl_set_timer_cb(
        ssl: *mut mbedtls_ssl_context,
        p_timer: *mut crate::c_types::c_void,
        f_set_timer: mbedtls_ssl_set_timer_t,
        f_get_timer: mbedtls_ssl_get_timer_t,
    );
}
/// \brief           Callback type: generate and write session ticket
///
/// \note            This describes what a callback implementation should do.
///                  This callback should generate an encrypted and
///                  authenticated ticket for the session and write it to the
///                  output buffer. Here, ticket means the opaque ticket part
///                  of the NewSessionTicket structure of RFC 5077.
///
/// \param p_ticket  Context for the callback
/// \param session   SSL session to be written in the ticket
/// \param start     Start of the output buffer
/// \param end       End of the output buffer
/// \param tlen      On exit, holds the length written
/// \param lifetime  On exit, holds the lifetime of the ticket in seconds
///
/// \return          0 if successful, or
///                  a specific MBEDTLS_ERR_XXX code.
pub type mbedtls_ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::c_types::c_void,
        session: *const mbedtls_ssl_session,
        start: *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> crate::c_types::c_int,
>;
/// \brief           Callback type: parse and load session ticket
///
/// \note            This describes what a callback implementation should do.
///                  This callback should parse a session ticket as generated
///                  by the corresponding mbedtls_ssl_ticket_write_t function,
///                  and, if the ticket is authentic and valid, load the
///                  session.
///
/// \note            The implementation is allowed to modify the first len
///                  bytes of the input buffer, eg to use it as a temporary
///                  area for the decrypted ticket contents.
///
/// \param p_ticket  Context for the callback
/// \param session   SSL session to be loaded
/// \param buf       Start of the buffer containing the ticket
/// \param len       Length of the ticket.
///
/// \return          0 if successful, or
///                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or
///                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or
///                  any other non-zero code for other failures.
pub type mbedtls_ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::c_types::c_void,
        session: *mut mbedtls_ssl_session,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    /// \brief           Configure SSL session ticket callbacks (server only).
    ///                  (Default: none.)
    ///
    /// \note            On server, session tickets are enabled by providing
    ///                  non-NULL callbacks.
    ///
    /// \note            On client, use \c mbedtls_ssl_conf_session_tickets().
    ///
    /// \param conf      SSL configuration context
    /// \param f_ticket_write    Callback for writing a ticket
    /// \param f_ticket_parse    Callback for parsing a ticket
    /// \param p_ticket          Context shared by the two callbacks
    pub fn mbedtls_ssl_conf_session_tickets_cb(
        conf: *mut mbedtls_ssl_config,
        f_ticket_write: mbedtls_ssl_ticket_write_t,
        f_ticket_parse: mbedtls_ssl_ticket_parse_t,
        p_ticket: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief   Configure a key export callback.
    ///          (Default: none.)
    ///
    ///          This API can be used for two purposes:
    ///          - Debugging: Use this API to e.g. generate an NSSKeylog
    ///            file and use it to inspect encrypted traffic in tools
    ///            such as Wireshark.
    ///          - Application-specific export: Use this API to implement
    ///            key exporters, e.g. for EAP-TLS or DTLS-SRTP.
    ///
    ///
    /// \param ssl            The SSL context to which the export
    ///                       callback should be attached.
    /// \param f_export_keys  The callback for the key export.
    /// \param p_export_keys  The opaque context pointer to be passed to the
    ///                       callback \p f_export_keys.
    pub fn mbedtls_ssl_set_export_keys_cb(
        ssl: *mut mbedtls_ssl_context,
        f_export_keys: mbedtls_ssl_export_keys_t,
        p_export_keys: *mut crate::c_types::c_void,
    );
}
/// \brief          Callback type: generate a cookie
///
/// \param ctx      Context for the callback
/// \param p        Buffer to write to,
///                 must be updated to point right after the cookie
/// \param end      Pointer to one past the end of the output buffer
/// \param info     Client ID info that was passed to
///                 \c mbedtls_ssl_set_client_transport_id()
/// \param ilen     Length of info in bytes
///
/// \return         The callback must return 0 on success,
///                 or a negative error code.
pub type mbedtls_ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        p: *mut *mut crate::c_types::c_uchar,
        end: *mut crate::c_types::c_uchar,
        info: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int,
>;
/// \brief          Callback type: verify a cookie
///
/// \param ctx      Context for the callback
/// \param cookie   Cookie to verify
/// \param clen     Length of cookie
/// \param info     Client ID info that was passed to
///                 \c mbedtls_ssl_set_client_transport_id()
/// \param ilen     Length of info in bytes
///
/// \return         The callback must return 0 if cookie is valid,
///                 or a negative error code.
pub type mbedtls_ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        cookie: *const crate::c_types::c_uchar,
        clen: usize,
        info: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    /// \brief           Register callbacks for DTLS cookies
    ///                  (Server only. DTLS only.)
    ///
    ///                  Default: dummy callbacks that fail, in order to force you to
    ///                  register working callbacks (and initialize their context).
    ///
    ///                  To disable HelloVerifyRequest, register NULL callbacks.
    ///
    /// \warning         Disabling hello verification allows your server to be used
    ///                  for amplification in DoS attacks against other hosts.
    ///                  Only disable if you known this can't happen in your
    ///                  particular environment.
    ///
    /// \note            See comments on \c mbedtls_ssl_handshake() about handling
    ///                  the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected
    ///                  on the first handshake attempt when this is enabled.
    ///
    /// \note            This is also necessary to handle client reconnection from
    ///                  the same port as described in RFC 6347 section 4.2.8 (only
    ///                  the variant with cookies is supported currently). See
    ///                  comments on \c mbedtls_ssl_read() for details.
    ///
    /// \param conf              SSL configuration
    /// \param f_cookie_write    Cookie write callback
    /// \param f_cookie_check    Cookie check callback
    /// \param p_cookie          Context for both callbacks
    pub fn mbedtls_ssl_conf_dtls_cookies(
        conf: *mut mbedtls_ssl_config,
        f_cookie_write: mbedtls_ssl_cookie_write_t,
        f_cookie_check: mbedtls_ssl_cookie_check_t,
        p_cookie: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief          Set client's transport-level identification info.
    ///                 (Server only. DTLS only.)
    ///
    ///                 This is usually the IP address (and port), but could be
    ///                 anything identify the client depending on the underlying
    ///                 network stack. Used for HelloVerifyRequest with DTLS.
    ///                 This is *not* used to route the actual packets.
    ///
    /// \param ssl      SSL context
    /// \param info     Transport-level info identifying the client (eg IP + port)
    /// \param ilen     Length of info in bytes
    ///
    /// \note           An internal copy is made, so the info buffer can be reused.
    ///
    /// \return         0 on success,
    ///                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,
    ///                 MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory.
    pub fn mbedtls_ssl_set_client_transport_id(
        ssl: *mut mbedtls_ssl_context,
        info: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Enable or disable anti-replay protection for DTLS.
    ///                 (DTLS only, no effect on TLS.)
    ///                 Default: enabled.
    ///
    /// \param conf     SSL configuration
    /// \param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED.
    ///
    /// \warning        Disabling this is a security risk unless the application
    ///                 protocol handles duplicated packets in a safe way. You
    ///                 should not disable this without careful consideration.
    ///                 However, if your application already detects duplicated
    ///                 packets and needs information about them to adjust its
    ///                 transmission strategy, then you'll want to disable this.
    pub fn mbedtls_ssl_conf_dtls_anti_replay(
        conf: *mut mbedtls_ssl_config,
        mode: crate::c_types::c_char,
    );
}
extern "C" {
    /// \brief          Set a limit on the number of records with a bad MAC
    ///                 before terminating the connection.
    ///                 (DTLS only, no effect on TLS.)
    ///                 Default: 0 (disabled).
    ///
    /// \param conf     SSL configuration
    /// \param limit    Limit, or 0 to disable.
    ///
    /// \note           If the limit is N, then the connection is terminated when
    ///                 the Nth non-authentic record is seen.
    ///
    /// \note           Records with an invalid header are not counted, only the
    ///                 ones going through the authentication-decryption phase.
    ///
    /// \note           This is a security trade-off related to the fact that it's
    ///                 often relatively easy for an active attacker to inject UDP
    ///                 datagrams. On one hand, setting a low limit here makes it
    ///                 easier for such an attacker to forcibly terminated a
    ///                 connection. On the other hand, a high limit or no limit
    ///                 might make us waste resources checking authentication on
    ///                 many bogus packets.
    pub fn mbedtls_ssl_conf_dtls_badmac_limit(
        conf: *mut mbedtls_ssl_config,
        limit: crate::c_types::c_uint,
    );
}
extern "C" {
    /// \brief          Allow or disallow packing of multiple handshake records
    ///                 within a single datagram.
    ///
    /// \param ssl           The SSL context to configure.
    /// \param allow_packing This determines whether datagram packing may
    ///                      be used or not. A value of \c 0 means that every
    ///                      record will be sent in a separate datagram; a
    ///                      value of \c 1 means that, if space permits,
    ///                      multiple handshake messages (including CCS) belonging to
    ///                      a single flight may be packed within a single datagram.
    ///
    /// \note           This is enabled by default and should only be disabled
    ///                 for test purposes, or if datagram packing causes
    ///                 interoperability issues with peers that don't support it.
    ///
    /// \note           Allowing datagram packing reduces the network load since
    ///                 there's less overhead if multiple messages share the same
    ///                 datagram. Also, it increases the handshake efficiency
    ///                 since messages belonging to a single datagram will not
    ///                 be reordered in transit, and so future message buffering
    ///                 or flight retransmission (if no buffering is used) as
    ///                 means to deal with reordering are needed less frequently.
    ///
    /// \note           Application records are not affected by this option and
    ///                 are currently always sent in separate datagrams.
    pub fn mbedtls_ssl_set_datagram_packing(
        ssl: *mut mbedtls_ssl_context,
        allow_packing: crate::c_types::c_uint,
    );
}
extern "C" {
    /// \brief          Set retransmit timeout values for the DTLS handshake.
    ///                 (DTLS only, no effect on TLS.)
    ///
    /// \param conf     SSL configuration
    /// \param min      Initial timeout value in milliseconds.
    ///                 Default: 1000 (1 second).
    /// \param max      Maximum timeout value in milliseconds.
    ///                 Default: 60000 (60 seconds).
    ///
    /// \note           Default values are from RFC 6347 section 4.2.4.1.
    ///
    /// \note           The 'min' value should typically be slightly above the
    ///                 expected round-trip time to your peer, plus whatever time
    ///                 it takes for the peer to process the message. For example,
    ///                 if your RTT is about 600ms and you peer needs up to 1s to
    ///                 do the cryptographic operations in the handshake, then you
    ///                 should set 'min' slightly above 1600. Lower values of 'min'
    ///                 might cause spurious resends which waste network resources,
    ///                 while larger value of 'min' will increase overall latency
    ///                 on unreliable network links.
    ///
    /// \note           The more unreliable your network connection is, the larger
    ///                 your max / min ratio needs to be in order to achieve
    ///                 reliable handshakes.
    ///
    /// \note           Messages are retransmitted up to log2(ceil(max/min)) times.
    ///                 For example, if min = 1s and max = 5s, the retransmit plan
    ///                 goes: send ... 1s -> resend ... 2s -> resend ... 4s ->
    ///                 resend ... 5s -> give up and return a timeout error.
    pub fn mbedtls_ssl_conf_handshake_timeout(conf: *mut mbedtls_ssl_config, min: u32, max: u32);
}
extern "C" {
    /// \brief          Set the session cache callbacks (server-side only)
    ///                 If not set, no session resuming is done (except if session
    ///                 tickets are enabled too).
    ///
    ///                 The session cache has the responsibility to check for stale
    ///                 entries based on timeout. See RFC 5246 for recommendations.
    ///
    ///                 Warning: session.peer_cert is cleared by the SSL/TLS layer on
    ///                 connection shutdown, so do not cache the pointer! Either set
    ///                 it to NULL or make a full copy of the certificate.
    ///
    ///                 The get callback is called once during the initial handshake
    ///                 to enable session resuming. The get function has the
    ///                 following parameters: (void *parameter, mbedtls_ssl_session *session)
    ///                 If a valid entry is found, it should fill the master of
    ///                 the session object with the cached values and return 0,
    ///                 return 1 otherwise. Optionally peer_cert can be set as well
    ///                 if it is properly present in cache entry.
    ///
    ///                 The set callback is called once during the initial handshake
    ///                 to enable session resuming after the entire handshake has
    ///                 been finished. The set function has the following parameters:
    ///                 (void *parameter, const mbedtls_ssl_session *session). The function
    ///                 should create a cache entry for future retrieval based on
    ///                 the data in the session structure and should keep in mind
    ///                 that the mbedtls_ssl_session object presented (and all its referenced
    ///                 data) is cleared by the SSL/TLS layer when the connection is
    ///                 terminated. It is recommended to add metadata to determine if
    ///                 an entry is still valid in the future. Return 0 if
    ///                 successfully cached, return 1 otherwise.
    ///
    /// \param conf           SSL configuration
    /// \param p_cache        parameter (context) for both callbacks
    /// \param f_get_cache    session get callback
    /// \param f_set_cache    session set callback
    pub fn mbedtls_ssl_conf_session_cache(
        conf: *mut mbedtls_ssl_config,
        p_cache: *mut crate::c_types::c_void,
        f_get_cache: mbedtls_ssl_cache_get_t,
        f_set_cache: mbedtls_ssl_cache_set_t,
    );
}
extern "C" {
    /// \brief          Load a session for session resumption.
    ///
    ///                 Sessions loaded through this call will be considered
    ///                 for session resumption in the next handshake.
    ///
    /// \note           Even if this call succeeds, it is not guaranteed that
    ///                 the next handshake will indeed be shortened through the
    ///                 use of session resumption: The server is always free
    ///                 to reject any attempt for resumption and fall back to
    ///                 a full handshake.
    ///
    /// \note           This function can handle a variety of mechanisms for session
    ///                 resumption: For TLS 1.2, both session ID-based resumption and
    ///                 ticket-based resumption will be considered. For TLS 1.3,
    ///                 once implemented, sessions equate to tickets, and loading
    ///                 one or more sessions via this call will lead to their
    ///                 corresponding tickets being advertised as resumption PSKs
    ///                 by the client.
    ///
    /// \note           Calling this function multiple times will only be useful
    ///                 once TLS 1.3 is supported. For TLS 1.2 connections, this
    ///                 function should be called at most once.
    ///
    /// \param ssl      The SSL context representing the connection which should
    ///                 be attempted to be setup using session resumption. This
    ///                 must be initialized via mbedtls_ssl_init() and bound to
    ///                 an SSL configuration via mbedtls_ssl_setup(), but
    ///                 the handshake must not yet have been started.
    /// \param session  The session to be considered for session resumption.
    ///                 This must be a session previously exported via
    ///                 mbedtls_ssl_get_session(), and potentially serialized and
    ///                 deserialized through mbedtls_ssl_session_save() and
    ///                 mbedtls_ssl_session_load() in the meantime.
    ///
    /// \return         \c 0 if successful.
    /// \return         \c MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if the session
    ///                 could not be loaded because of an implementation limitation.
    ///                 This error is non-fatal, and has no observable effect on
    ///                 the SSL context or the session that was attempted to be loaded.
    /// \return         Another negative error code on other kinds of failure.
    ///
    /// \sa             mbedtls_ssl_get_session()
    /// \sa             mbedtls_ssl_session_load()
    pub fn mbedtls_ssl_set_session(
        ssl: *mut mbedtls_ssl_context,
        session: *const mbedtls_ssl_session,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Load serialized session data into a session structure.
    ///                 On client, this can be used for loading saved sessions
    ///                 before resuming them with mbedtls_ssl_set_session().
    ///                 On server, this can be used for alternative implementations
    ///                 of session cache or session tickets.
    ///
    /// \warning        If a peer certificate chain is associated with the session,
    ///                 the serialized state will only contain the peer's
    ///                 end-entity certificate and the result of the chain
    ///                 verification (unless verification was disabled), but not
    ///                 the rest of the chain.
    ///
    /// \see            mbedtls_ssl_session_save()
    /// \see            mbedtls_ssl_set_session()
    ///
    /// \param session  The session structure to be populated. It must have been
    ///                 initialised with mbedtls_ssl_session_init() but not
    ///                 populated yet.
    /// \param buf      The buffer holding the serialized session data. It must be a
    ///                 readable buffer of at least \p len bytes.
    /// \param len      The size of the serialized data in bytes.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed.
    /// \return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid.
    /// \return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data
    ///                 was generated in a different version or configuration of
    ///                 Mbed TLS.
    /// \return         Another negative value for other kinds of errors (for
    ///                 example, unsupported features in the embedded certificate).
    pub fn mbedtls_ssl_session_load(
        session: *mut mbedtls_ssl_session,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Save session structure as serialized data in a buffer.
    ///                 On client, this can be used for saving session data,
    ///                 potentially in non-volatile storage, for resuming later.
    ///                 On server, this can be used for alternative implementations
    ///                 of session cache or session tickets.
    ///
    /// \see            mbedtls_ssl_session_load()
    ///
    /// \param session  The session structure to be saved.
    /// \param buf      The buffer to write the serialized data to. It must be a
    ///                 writeable buffer of at least \p len bytes, or may be \c
    ///                 NULL if \p len is \c 0.
    /// \param buf_len  The number of bytes available for writing in \p buf.
    /// \param olen     The size in bytes of the data that has been or would have
    ///                 been written. It must point to a valid \c size_t.
    ///
    /// \note           \p olen is updated to the correct value regardless of
    ///                 whether \p buf_len was large enough. This makes it possible
    ///                 to determine the necessary size by calling this function
    ///                 with \p buf set to \c NULL and \p buf_len to \c 0.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \p buf is too small.
    pub fn mbedtls_ssl_session_save(
        session: *const mbedtls_ssl_session,
        buf: *mut crate::c_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               Set the list of allowed ciphersuites and the preference
    ///                      order. First in the list has the highest preference.
    ///
    ///                      For TLS 1.2, the notion of ciphersuite determines both
    ///                      the key exchange mechanism and the suite of symmetric
    ///                      algorithms to be used during and after the handshake.
    ///
    ///                      For TLS 1.3 (in development), the notion of ciphersuite
    ///                      only determines the suite of symmetric algorithms to be
    ///                      used during and after the handshake, while key exchange
    ///                      mechanisms are configured separately.
    ///
    ///                      In Mbed TLS, ciphersuites for both TLS 1.2 and TLS 1.3
    ///                      are configured via this function. For users of TLS 1.3,
    ///                      there will be separate API for the configuration of key
    ///                      exchange mechanisms.
    ///
    ///                      The list of ciphersuites passed to this function may
    ///                      contain a mixture of TLS 1.2 and TLS 1.3 ciphersuite
    ///                      identifiers. This is useful if negotiation of TLS 1.3
    ///                      should be attempted, but a fallback to TLS 1.2 would
    ///                      be tolerated.
    ///
    /// \note                By default, the server chooses its preferred
    ///                      ciphersuite among those that the client supports. If
    ///                      mbedtls_ssl_conf_preference_order() is called to prefer
    ///                      the client's preferences, the server instead chooses
    ///                      the client's preferred ciphersuite among those that
    ///                      the server supports.
    ///
    /// \warning             The ciphersuites array \p ciphersuites is not copied.
    ///                      It must remain valid for the lifetime of the SSL
    ///                      configuration \p conf.
    ///
    /// \param conf          The SSL configuration to modify.
    /// \param ciphersuites  A 0-terminated list of IANA identifiers of supported
    ///                      ciphersuites, accessible through \c MBEDTLS_TLS_XXX
    ///                      and \c MBEDTLS_TLS1_3_XXX macros defined in
    ///                      ssl_ciphersuites.h.
    pub fn mbedtls_ssl_conf_ciphersuites(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief Set the supported key exchange modes for TLS 1.3 connections.
    ///
    ///        In contrast to TLS 1.2, the ciphersuite concept in TLS 1.3 does not
    ///        include the choice of key exchange mechanism. It is therefore not
    ///        covered by the API mbedtls_ssl_conf_ciphersuites(). See the
    ///        documentation of mbedtls_ssl_conf_ciphersuites() for more
    ///        information on the ciphersuite concept in TLS 1.2 and TLS 1.3.
    ///
    ///        The present function is specific to TLS 1.3 and allows users to
    ///        configure the set of supported key exchange mechanisms in TLS 1.3.
    ///
    /// \param conf       The SSL configuration the change should apply to.
    /// \param kex_modes  A bitwise combination of one or more of the following:
    ///                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK
    ///                     This flag enables pure-PSK key exchanges.
    ///                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL
    ///                     This flag enables combined PSK-ephemeral key exchanges.
    ///                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL
    ///                     This flag enables pure-ephemeral key exchanges.
    ///                   For convenience, the following pre-defined macros are
    ///                   available for combinations of the above:
    ///                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL
    ///                     Includes all of pure-PSK, PSK-ephemeral and pure-ephemeral.
    ///                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL
    ///                     Includes both pure-PSK and combined PSK-ephemeral
    ///                     key exchanges, but excludes pure-ephemeral key exchanges.
    ///                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL
    ///                     Includes both pure-ephemeral and combined PSK-ephemeral
    ///                     key exchanges.
    ///
    /// \note  If a PSK-based key exchange mode shall be supported, applications
    ///        must also use the APIs mbedtls_ssl_conf_psk() or
    ///        mbedtls_ssl_conf_psk_cb() or mbedtls_ssl_conf_psk_opaque()
    ///        to configure the PSKs to be used.
    ///
    /// \note  If a pure-ephemeral key exchange mode shall be supported,
    ///        server-side applications must also provide a certificate via
    ///        mbedtls_ssl_conf_own_cert().
    pub fn mbedtls_ssl_conf_tls13_key_exchange_modes(
        conf: *mut mbedtls_ssl_config,
        kex_modes: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief               Specify the length of Connection IDs for incoming
    ///                      encrypted DTLS records, as well as the behaviour
    ///                      on unexpected CIDs.
    ///
    ///                      By default, the CID length is set to \c 0,
    ///                      and unexpected CIDs are silently ignored.
    ///
    /// \param conf          The SSL configuration to modify.
    /// \param len           The length in Bytes of the CID fields in encrypted
    ///                      DTLS records using the CID mechanism. This must
    ///                      not be larger than #MBEDTLS_SSL_CID_OUT_LEN_MAX.
    /// \param ignore_other_cids This determines the stack's behaviour when
    ///                          receiving a record with an unexpected CID.
    ///                          Possible values are:
    ///                          - #MBEDTLS_SSL_UNEXPECTED_CID_IGNORE
    ///                            In this case, the record is silently ignored.
    ///                          - #MBEDTLS_SSL_UNEXPECTED_CID_FAIL
    ///                            In this case, the stack fails with the specific
    ///                            error code #MBEDTLS_ERR_SSL_UNEXPECTED_CID.
    ///
    /// \note                The CID specification allows implementations to either
    ///                      use a common length for all incoming connection IDs or
    ///                      allow variable-length incoming IDs. Mbed TLS currently
    ///                      requires a common length for all connections sharing the
    ///                      same SSL configuration; this allows simpler parsing of
    ///                      record headers.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if \p own_cid_len
    ///                      is too large.
    pub fn mbedtls_ssl_conf_cid(
        conf: *mut mbedtls_ssl_config,
        len: usize,
        ignore_other_cids: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the X.509 security profile used for verification
    ///
    /// \note           The restrictions are enforced for all certificates in the
    ///                 chain. However, signatures in the handshake are not covered
    ///                 by this setting but by \b mbedtls_ssl_conf_sig_hashes().
    ///
    /// \param conf     SSL configuration
    /// \param profile  Profile to use
    pub fn mbedtls_ssl_conf_cert_profile(
        conf: *mut mbedtls_ssl_config,
        profile: *const mbedtls_x509_crt_profile,
    );
}
extern "C" {
    /// \brief          Set the data required to verify peer certificate
    ///
    /// \note           See \c mbedtls_x509_crt_verify() for notes regarding the
    ///                 parameters ca_chain (maps to trust_ca for that function)
    ///                 and ca_crl.
    ///
    /// \param conf     SSL configuration
    /// \param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)
    /// \param ca_crl   trusted CA CRLs
    pub fn mbedtls_ssl_conf_ca_chain(
        conf: *mut mbedtls_ssl_config,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    /// \brief          Set own certificate chain and private key
    ///
    /// \note           own_cert should contain in order from the bottom up your
    ///                 certificate chain. The top certificate (self-signed)
    ///                 can be omitted.
    ///
    /// \note           On server, this function can be called multiple times to
    ///                 provision more than one cert/key pair (eg one ECDSA, one
    ///                 RSA with SHA-256, one RSA with SHA-1). An adequate
    ///                 certificate will be selected according to the client's
    ///                 advertised capabilities. In case multiple certificates are
    ///                 adequate, preference is given to the one set by the first
    ///                 call to this function, then second, etc.
    ///
    /// \note           On client, only the first call has any effect. That is,
    ///                 only one client certificate can be provisioned. The
    ///                 server's preferences in its CertificateRequest message will
    ///                 be ignored and our only cert will be sent regardless of
    ///                 whether it matches those preferences - the server can then
    ///                 decide what it wants to do with it.
    ///
    /// \note           The provided \p pk_key needs to match the public key in the
    ///                 first certificate in \p own_cert, or all handshakes using
    ///                 that certificate will fail. It is your responsibility
    ///                 to ensure that; this function will not perform any check.
    ///                 You may use mbedtls_pk_check_pair() in order to perform
    ///                 this check yourself, but be aware that this function can
    ///                 be computationally expensive on some key types.
    ///
    /// \param conf     SSL configuration
    /// \param own_cert own public certificate chain
    /// \param pk_key   own private key
    ///
    /// \return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED
    pub fn mbedtls_ssl_conf_own_cert(
        conf: *mut mbedtls_ssl_config,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Configure pre-shared keys (PSKs) and their
    ///                 identities to be used in PSK-based ciphersuites.
    ///
    ///                 Only one PSK can be registered, through either
    ///                 mbedtls_ssl_conf_psk() or mbedtls_ssl_conf_psk_opaque().
    ///                 If you attempt to register more than one PSK, this function
    ///                 fails, though this may change in future versions, which
    ///                 may add support for multiple PSKs.
    ///
    /// \note           This is mainly useful for clients. Servers will usually
    ///                 want to use \c mbedtls_ssl_conf_psk_cb() instead.
    ///
    /// \note           A PSK set by \c mbedtls_ssl_set_hs_psk() in the PSK callback
    ///                 takes precedence over a PSK configured by this function.
    ///
    /// \param conf     The SSL configuration to register the PSK with.
    /// \param psk      The pointer to the pre-shared key to use.
    /// \param psk_len  The length of the pre-shared key in bytes.
    /// \param psk_identity      The pointer to the pre-shared key identity.
    /// \param psk_identity_len  The length of the pre-shared key identity
    ///                          in bytes.
    ///
    /// \note           The PSK and its identity are copied internally and
    ///                 hence need not be preserved by the caller for the lifetime
    ///                 of the SSL configuration.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no more PSKs
    ///                 can be configured. In this case, the old PSK(s) remain intact.
    /// \return         Another negative error code on other kinds of failure.
    pub fn mbedtls_ssl_conf_psk(
        conf: *mut mbedtls_ssl_config,
        psk: *const crate::c_types::c_uchar,
        psk_len: usize,
        psk_identity: *const crate::c_types::c_uchar,
        psk_identity_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the pre-shared Key (PSK) for the current handshake.
    ///
    /// \note           This should only be called inside the PSK callback,
    ///                 i.e. the function passed to \c mbedtls_ssl_conf_psk_cb().
    ///
    /// \note           A PSK set by this function takes precedence over a PSK
    ///                 configured by \c mbedtls_ssl_conf_psk().
    ///
    /// \param ssl      The SSL context to configure a PSK for.
    /// \param psk      The pointer to the pre-shared key.
    /// \param psk_len  The length of the pre-shared key in bytes.
    ///
    /// \return         \c 0 if successful.
    /// \return         An \c MBEDTLS_ERR_SSL_XXX error code on failure.
    pub fn mbedtls_ssl_set_hs_psk(
        ssl: *mut mbedtls_ssl_context,
        psk: *const crate::c_types::c_uchar,
        psk_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the PSK callback (server-side only).
    ///
    ///                 If set, the PSK callback is called for each
    ///                 handshake where a PSK-based ciphersuite was negotiated.
    ///                 The caller provides the identity received and wants to
    ///                 receive the actual PSK data and length.
    ///
    ///                 The callback has the following parameters:
    ///                 - \c void*: The opaque pointer \p p_psk.
    ///                 - \c mbedtls_ssl_context*: The SSL context to which
    ///                                            the operation applies.
    ///                 - \c const unsigned char*: The PSK identity
    ///                                            selected by the client.
    ///                 - \c size_t: The length of the PSK identity
    ///                              selected by the client.
    ///
    ///                 If a valid PSK identity is found, the callback should use
    ///                 \c mbedtls_ssl_set_hs_psk() or
    ///                 \c mbedtls_ssl_set_hs_psk_opaque()
    ///                 on the SSL context to set the correct PSK and return \c 0.
    ///                 Any other return value will result in a denied PSK identity.
    ///
    /// \note           A dynamic PSK (i.e. set by the PSK callback) takes
    ///                 precedence over a static PSK (i.e. set by
    ///                 \c mbedtls_ssl_conf_psk() or
    ///                 \c mbedtls_ssl_conf_psk_opaque()).
    ///                 This means that if you set a PSK callback using this
    ///                 function, you don't need to set a PSK using
    ///                 \c mbedtls_ssl_conf_psk() or
    ///                 \c mbedtls_ssl_conf_psk_opaque()).
    ///
    /// \param conf     The SSL configuration to register the callback with.
    /// \param f_psk    The callback for selecting and setting the PSK based
    ///                 in the PSK identity chosen by the client.
    /// \param p_psk    A pointer to an opaque structure to be passed to
    ///                 the callback, for example a PSK store.
    pub fn mbedtls_ssl_conf_psk_cb(
        conf: *mut mbedtls_ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const crate::c_types::c_uchar,
                arg4: usize,
            ) -> crate::c_types::c_int,
        >,
        p_psk: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief          Set the Diffie-Hellman public P and G values
    ///                 from big-endian binary presentations.
    ///                 (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN)
    ///
    /// \param conf     SSL configuration
    /// \param dhm_P    Diffie-Hellman-Merkle modulus in big-endian binary form
    /// \param P_len    Length of DHM modulus
    /// \param dhm_G    Diffie-Hellman-Merkle generator in big-endian binary form
    /// \param G_len    Length of DHM generator
    ///
    /// \return         0 if successful
    pub fn mbedtls_ssl_conf_dh_param_bin(
        conf: *mut mbedtls_ssl_config,
        dhm_P: *const crate::c_types::c_uchar,
        P_len: usize,
        dhm_G: *const crate::c_types::c_uchar,
        G_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the Diffie-Hellman public P and G values,
    ///                 read from existing context (server-side only)
    ///
    /// \param conf     SSL configuration
    /// \param dhm_ctx  Diffie-Hellman-Merkle context
    ///
    /// \return         0 if successful
    pub fn mbedtls_ssl_conf_dh_param_ctx(
        conf: *mut mbedtls_ssl_config,
        dhm_ctx: *mut mbedtls_dhm_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the minimum length for Diffie-Hellman parameters.
    ///                 (Client-side only.)
    ///                 (Default: 1024 bits.)
    ///
    /// \param conf     SSL configuration
    /// \param bitlen   Minimum bit length of the DHM prime
    pub fn mbedtls_ssl_conf_dhm_min_bitlen(
        conf: *mut mbedtls_ssl_config,
        bitlen: crate::c_types::c_uint,
    );
}
extern "C" {
    /// \brief          Set the allowed curves in order of preference.
    ///
    ///                 On server: this only affects selection of the ECDHE curve;
    ///                 the curves used for ECDH and ECDSA are determined by the
    ///                 list of available certificates instead.
    ///
    ///                 On client: this affects the list of curves offered for any
    ///                 use. The server can override our preference order.
    ///
    ///                 Both sides: limits the set of curves accepted for use in
    ///                 ECDHE and in the peer's end-entity certificate.
    ///
    /// \deprecated     Superseded by mbedtls_ssl_conf_groups().
    ///
    /// \note           This has no influence on which curves are allowed inside the
    ///                 certificate chains, see \c mbedtls_ssl_conf_cert_profile()
    ///                 for that. For the end-entity certificate however, the key
    ///                 will be accepted only if it is allowed both by this list
    ///                 and by the cert profile.
    ///
    /// \note           This list should be ordered by decreasing preference
    ///                 (preferred curve first).
    ///
    /// \note           The default list is the same set of curves that
    ///                 #mbedtls_x509_crt_profile_default allows, plus
    ///                 ECDHE-only curves selected according to the same criteria.
    ///                 The order favors curves with the lowest resource usage.
    ///
    /// \note           New minor versions of Mbed TLS may extend this list,
    ///                 for example if new curves are added to the library.
    ///                 New minor versions of Mbed TLS will not remove items
    ///                 from this list unless serious security concerns require it.
    ///                 New minor versions of Mbed TLS may change the order in
    ///                 keeping with the general principle of favoring the lowest
    ///                 resource usage.
    ///
    /// \param conf     SSL configuration
    /// \param curves   Ordered list of allowed curves,
    ///                 terminated by MBEDTLS_ECP_DP_NONE.
    pub fn mbedtls_ssl_conf_curves(
        conf: *mut mbedtls_ssl_config,
        curves: *const mbedtls_ecp_group_id,
    );
}
extern "C" {
    /// \brief          Set the allowed groups in order of preference.
    ///
    ///                 On server: This only affects the choice of key agreement mechanism
    ///
    ///                 On client: this affects the list of groups offered for any
    ///                 use. The server can override our preference order.
    ///
    ///                 Both sides: limits the set of groups accepted for use in
    ///                 key sharing.
    ///
    /// \note           This function replaces the deprecated mbedtls_ssl_conf_curves(),
    ///                 which only allows ECP curves to be configured.
    ///
    /// \note           The most recent invocation of either mbedtls_ssl_conf_curves()
    ///                 or mbedtls_ssl_conf_groups() nullifies all previous invocations
    ///                 of both.
    ///
    /// \note           This list should be ordered by decreasing preference
    ///                 (preferred group first).
    ///
    /// \note           When this function is not called, a default list is used,
    ///                 consisting of all supported curves at 255 bits and above,
    ///                 and all supported finite fields at 2048 bits and above.
    ///                 The order favors groups with the lowest resource usage.
    ///
    /// \note           New minor versions of Mbed TLS will not remove items
    ///                 from the default list unless serious security concerns require it.
    ///                 New minor versions of Mbed TLS may change the order in
    ///                 keeping with the general principle of favoring the lowest
    ///                 resource usage.
    ///
    /// \param conf     SSL configuration
    /// \param groups   List of allowed groups ordered by preference, terminated by 0.
    ///                 Must contain valid IANA NamedGroup IDs (provided via either an integer
    ///                 or using MBEDTLS_TLS1_3_NAMED_GROUP_XXX macros).
    pub fn mbedtls_ssl_conf_groups(conf: *mut mbedtls_ssl_config, groups: *const u16);
}
extern "C" {
    /// \brief          Set the allowed hashes for signatures during the handshake.
    ///
    /// \note           This only affects which hashes are offered and can be used
    ///                 for signatures during the handshake. Hashes for message
    ///                 authentication and the TLS PRF are controlled by the
    ///                 ciphersuite, see \c mbedtls_ssl_conf_ciphersuites(). Hashes
    ///                 used for certificate signature are controlled by the
    ///                 verification profile, see \c mbedtls_ssl_conf_cert_profile().
    ///
    /// \note           This list should be ordered by decreasing preference
    ///                 (preferred hash first).
    ///
    /// \note           By default, all supported hashes whose length is at least
    ///                 256 bits are allowed. This is the same set as the default
    ///                 for certificate verification
    ///                 (#mbedtls_x509_crt_profile_default).
    ///                 The preference order is currently unspecified and may
    ///                 change in future versions.
    ///
    /// \note           New minor versions of Mbed TLS may extend this list,
    ///                 for example if new curves are added to the library.
    ///                 New minor versions of Mbed TLS will not remove items
    ///                 from this list unless serious security concerns require it.
    ///
    /// \param conf     SSL configuration
    /// \param hashes   Ordered list of allowed signature hashes,
    ///                 terminated by \c MBEDTLS_MD_NONE.
    pub fn mbedtls_ssl_conf_sig_hashes(
        conf: *mut mbedtls_ssl_config,
        hashes: *const crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Configure allowed signature algorithms for use in TLS 1.3
    ///
    /// \param conf     The SSL configuration to use.
    /// \param sig_algs List of allowed IANA values for TLS 1.3 signature algorithms,
    ///                 terminated by \c MBEDTLS_TLS1_3_SIG_NONE. The list must remain
    ///                 available throughout the lifetime of the conf object. Supported
    ///                 values are available as \c MBEDTLS_TLS1_3_SIG_XXXX
    pub fn mbedtls_ssl_conf_sig_algs(conf: *mut mbedtls_ssl_config, sig_algs: *const u16);
}
extern "C" {
    /// \brief          Set or reset the hostname to check against the received
    ///                 server certificate. It sets the ServerName TLS extension,
    ///                 too, if that extension is enabled. (client-side only)
    ///
    /// \param ssl      SSL context
    /// \param hostname the server hostname, may be NULL to clear hostname
    ///
    /// \note           Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN.
    ///
    /// \return         0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on
    ///                 allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on
    ///                 too long input hostname.
    ///
    ///                 Hostname set to the one provided on success (cleared
    ///                 when NULL). On allocation failure hostname is cleared.
    ///                 On too long input failure, old hostname is unchanged.
    pub fn mbedtls_ssl_set_hostname(
        ssl: *mut mbedtls_ssl_context,
        hostname: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Retrieve SNI extension value for the current handshake.
    ///                 Available in \p f_cert_cb of \c mbedtls_ssl_conf_cert_cb(),
    ///                 this is the same value passed to \p f_sni callback of
    ///                 \c mbedtls_ssl_conf_sni() and may be used instead of
    ///                 \c mbedtls_ssl_conf_sni().
    ///
    /// \param ssl      SSL context
    /// \param name_len pointer into which to store length of returned value.
    ///                 0 if SNI extension is not present or not yet processed.
    ///
    /// \return         const pointer to SNI extension value.
    ///                 - value is valid only when called in \p f_cert_cb
    ///                   registered with \c mbedtls_ssl_conf_cert_cb().
    ///                 - value is NULL if SNI extension is not present.
    ///                 - value is not '\0'-terminated.  Use \c name_len for len.
    ///                 - value must not be freed.
    pub fn mbedtls_ssl_get_hs_sni(
        ssl: *mut mbedtls_ssl_context,
        name_len: *mut usize,
    ) -> *const crate::c_types::c_uchar;
}
extern "C" {
    /// \brief          Set own certificate and key for the current handshake
    ///
    /// \note           Same as \c mbedtls_ssl_conf_own_cert() but for use within
    ///                 the SNI callback or the certificate selection callback.
    ///
    /// \note           Passing null \c own_cert clears the certificate list for
    ///                 the current handshake.
    ///
    /// \param ssl      SSL context
    /// \param own_cert own public certificate chain
    /// \param pk_key   own private key
    ///
    /// \return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED
    pub fn mbedtls_ssl_set_hs_own_cert(
        ssl: *mut mbedtls_ssl_context,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Set the data required to verify peer certificate for the
    ///                 current handshake
    ///
    /// \note           Same as \c mbedtls_ssl_conf_ca_chain() but for use within
    ///                 the SNI callback or the certificate selection callback.
    ///
    /// \param ssl      SSL context
    /// \param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)
    /// \param ca_crl   trusted CA CRLs
    pub fn mbedtls_ssl_set_hs_ca_chain(
        ssl: *mut mbedtls_ssl_context,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    /// \brief          Set DN hints sent to client in CertificateRequest message
    ///
    /// \note           Same as \c mbedtls_ssl_conf_dn_hints() but for use within
    ///                 the SNI callback or the certificate selection callback.
    ///
    /// \param ssl      SSL context
    /// \param crt      crt chain whose subject DNs are issuer DNs of client certs
    ///                 from which the client should select client peer certificate.
    pub fn mbedtls_ssl_set_hs_dn_hints(ssl: *mut mbedtls_ssl_context, crt: *const mbedtls_x509_crt);
}
extern "C" {
    /// \brief          Set authmode for the current handshake.
    ///
    /// \note           Same as \c mbedtls_ssl_conf_authmode() but for use within
    ///                 the SNI callback or the certificate selection callback.
    ///
    /// \param ssl      SSL context
    /// \param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or
    ///                 MBEDTLS_SSL_VERIFY_REQUIRED
    pub fn mbedtls_ssl_set_hs_authmode(
        ssl: *mut mbedtls_ssl_context,
        authmode: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Set server side ServerName TLS extension callback
    ///                 (optional, server-side only).
    ///
    ///                 If set, the ServerName callback is called whenever the
    ///                 server receives a ServerName TLS extension from the client
    ///                 during a handshake. The ServerName callback has the
    ///                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,
    ///                 const unsigned char *hostname, size_t len). If a suitable
    ///                 certificate is found, the callback must set the
    ///                 certificate(s) and key(s) to use with \c
    ///                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),
    ///                 and may optionally adjust the CA and associated CRL with \c
    ///                 mbedtls_ssl_set_hs_ca_chain() as well as the client
    ///                 authentication mode with \c mbedtls_ssl_set_hs_authmode(),
    ///                 then must return 0. If no matching name is found, the
    ///                 callback may return non-zero to abort the handshake.
    ///
    /// \param conf     SSL configuration
    /// \param f_sni    verification function
    /// \param p_sni    verification parameter
    pub fn mbedtls_ssl_conf_sni(
        conf: *mut mbedtls_ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const crate::c_types::c_uchar,
                arg4: usize,
            ) -> crate::c_types::c_int,
        >,
        p_sni: *mut crate::c_types::c_void,
    );
}
extern "C" {
    /// \brief          Set the supported Application Layer Protocols.
    ///
    /// \param conf     SSL configuration
    /// \param protos   Pointer to a NULL-terminated list of supported protocols,
    ///                 in decreasing preference order. The pointer to the list is
    ///                 recorded by the library for later reference as required, so
    ///                 the lifetime of the table must be at least as long as the
    ///                 lifetime of the SSL configuration structure.
    ///
    /// \return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA.
    pub fn mbedtls_ssl_conf_alpn_protocols(
        conf: *mut mbedtls_ssl_config,
        protos: *mut *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Get the name of the negotiated Application Layer Protocol.
    ///                 This function should be called after the handshake is
    ///                 completed.
    ///
    /// \param ssl      SSL context
    ///
    /// \return         Protocol name, or NULL if no protocol was negotiated.
    pub fn mbedtls_ssl_get_alpn_protocol(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    /// \brief          Set the maximum supported version sent from the client side
    ///                 and/or accepted at the server side.
    ///
    ///                 See also the documentation of mbedtls_ssl_conf_min_version().
    ///
    /// \note           This ignores ciphersuites from higher versions.
    ///
    /// \note           This function is deprecated and has been replaced by
    ///                 \c mbedtls_ssl_conf_max_tls_version().
    ///
    /// \param conf     SSL configuration
    /// \param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)
    /// \param minor    Minor version number
    ///                 (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,
    ///                 #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)
    pub fn mbedtls_ssl_conf_max_version(
        conf: *mut mbedtls_ssl_config,
        major: crate::c_types::c_int,
        minor: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Set the minimum accepted SSL/TLS protocol version
    ///
    /// \note           By default, all supported versions are accepted.
    ///                 Future versions of the library may disable older
    ///                 protocol versions by default if they become deprecated.
    ///
    /// \note           The following versions are supported (if enabled at
    ///                 compile time):
    ///                 - (D)TLS 1.2: \p major = #MBEDTLS_SSL_MAJOR_VERSION_3,
    ///                   \p minor = #MBEDTLS_SSL_MINOR_VERSION_3
    ///                 - TLS 1.3: \p major = #MBEDTLS_SSL_MAJOR_VERSION_3,
    ///                   \p minor = #MBEDTLS_SSL_MINOR_VERSION_4
    ///
    ///                 Note that the numbers in the constant names are the
    ///                 TLS internal protocol numbers, and the minor versions
    ///                 differ by one from the human-readable versions!
    ///
    /// \note           Input outside of the SSL_MAX_XXXXX_VERSION and
    ///                 SSL_MIN_XXXXX_VERSION range is ignored.
    ///
    /// \note           After the handshake, you can call
    ///                 mbedtls_ssl_get_version_number() to see what version was
    ///                 negotiated.
    ///
    /// \note           This function is deprecated and has been replaced by
    ///                 \c mbedtls_ssl_conf_min_tls_version().
    ///
    /// \param conf     SSL configuration
    /// \param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)
    /// \param minor    Minor version number
    ///                 (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,
    ///                 #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)
    pub fn mbedtls_ssl_conf_min_version(
        conf: *mut mbedtls_ssl_config,
        major: crate::c_types::c_int,
        minor: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief           Enable or disable Encrypt-then-MAC
    ///                  (Default: MBEDTLS_SSL_ETM_ENABLED)
    ///
    /// \note            This should always be enabled, it is a security
    ///                  improvement, and should not cause any interoperability
    ///                  issue (used only if the peer supports it too).
    ///
    /// \param conf      SSL configuration
    /// \param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED
    pub fn mbedtls_ssl_conf_encrypt_then_mac(
        conf: *mut mbedtls_ssl_config,
        etm: crate::c_types::c_char,
    );
}
extern "C" {
    /// \brief           Enable or disable Extended Master Secret negotiation.
    ///                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)
    ///
    /// \note            This should always be enabled, it is a security fix to the
    ///                  protocol, and should not cause any interoperability issue
    ///                  (used only if the peer supports it too).
    ///
    /// \param conf      SSL configuration
    /// \param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED
    pub fn mbedtls_ssl_conf_extended_master_secret(
        conf: *mut mbedtls_ssl_config,
        ems: crate::c_types::c_char,
    );
}
extern "C" {
    /// \brief          Whether to send a list of acceptable CAs in
    ///                 CertificateRequest messages.
    ///                 (Default: do send)
    ///
    /// \param conf     SSL configuration
    /// \param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or
    ///                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED
    pub fn mbedtls_ssl_conf_cert_req_ca_list(
        conf: *mut mbedtls_ssl_config,
        cert_req_ca_list: crate::c_types::c_char,
    );
}
extern "C" {
    /// \brief          Set the maximum fragment length to emit and/or negotiate.
    ///                 (Typical: the smaller of #MBEDTLS_SSL_IN_CONTENT_LEN and
    ///                 #MBEDTLS_SSL_OUT_CONTENT_LEN, usually `2^14` bytes)
    ///                 (Server: set maximum fragment length to emit,
    ///                 usually negotiated by the client during handshake)
    ///                 (Client: set maximum fragment length to emit *and*
    ///                 negotiate with the server during handshake)
    ///                 (Default: #MBEDTLS_SSL_MAX_FRAG_LEN_NONE)
    ///
    /// \note           On the client side, the maximum fragment length extension
    ///                 *will not* be used, unless the maximum fragment length has
    ///                 been set via this function to a value different than
    ///                 #MBEDTLS_SSL_MAX_FRAG_LEN_NONE.
    ///
    /// \note           With TLS, this currently only affects ApplicationData (sent
    ///                 with \c mbedtls_ssl_read()), not handshake messages.
    ///                 With DTLS, this affects both ApplicationData and handshake.
    ///
    /// \note           This sets the maximum length for a record's payload,
    ///                 excluding record overhead that will be added to it, see
    ///                 \c mbedtls_ssl_get_record_expansion().
    ///
    /// \note           For DTLS, it is also possible to set a limit for the total
    ///                 size of datagrams passed to the transport layer, including
    ///                 record overhead, see \c mbedtls_ssl_set_mtu().
    ///
    /// \param conf     SSL configuration
    /// \param mfl_code Code for maximum fragment length (allowed values:
    ///                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,
    ///                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)
    ///
    /// \return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA
    pub fn mbedtls_ssl_conf_max_frag_len(
        conf: *mut mbedtls_ssl_config,
        mfl_code: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Pick the ciphersuites order according to the second parameter
    ///                 in the SSL Server module (MBEDTLS_SSL_SRV_C).
    ///                 (Default, if never called: MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER)
    ///
    /// \param conf     SSL configuration
    /// \param order    Server or client (MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER
    ///                                or MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT)
    pub fn mbedtls_ssl_conf_preference_order(
        conf: *mut mbedtls_ssl_config,
        order: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Enable / Disable session tickets (client only).
    ///                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)
    ///
    /// \note           On server, use \c mbedtls_ssl_conf_session_tickets_cb().
    ///
    /// \param conf     SSL configuration
    /// \param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or
    ///                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)
    pub fn mbedtls_ssl_conf_session_tickets(
        conf: *mut mbedtls_ssl_config,
        use_tickets: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief   Number of NewSessionTicket messages for the server to send
    ///          after handshake completion.
    ///
    /// \note    The default value is
    ///          \c MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS.
    ///
    /// \note    In case of a session resumption, this setting only partially apply.
    ///          At most one ticket is sent in that case to just renew the pool of
    ///          tickets of the client. The rationale is to avoid the number of
    ///          tickets on the server to become rapidly out of control when the
    ///          server has the same configuration for all its connection instances.
    ///
    /// \param conf    SSL configuration
    /// \param num_tickets    Number of NewSessionTicket.
    pub fn mbedtls_ssl_conf_new_session_tickets(conf: *mut mbedtls_ssl_config, num_tickets: u16);
}
extern "C" {
    /// \brief          Enable / Disable renegotiation support for connection when
    ///                 initiated by peer
    ///                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)
    ///
    /// \warning        It is recommended to always disable renegotiation unless you
    ///                 know you need it and you know what you're doing. In the
    ///                 past, there have been several issues associated with
    ///                 renegotiation or a poor understanding of its properties.
    ///
    /// \note           Server-side, enabling renegotiation also makes the server
    ///                 susceptible to a resource DoS by a malicious client.
    ///
    /// \param conf    SSL configuration
    /// \param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or
    ///                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)
    pub fn mbedtls_ssl_conf_renegotiation(
        conf: *mut mbedtls_ssl_config,
        renegotiation: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Prevent or allow legacy renegotiation.
    ///                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)
    ///
    ///                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to
    ///                 be established even if the peer does not support
    ///                 secure renegotiation, but does not allow renegotiation
    ///                 to take place if not secure.
    ///                 (Interoperable and secure option)
    ///
    ///                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations
    ///                 with non-upgraded peers. Allowing legacy renegotiation
    ///                 makes the connection vulnerable to specific man in the
    ///                 middle attacks. (See RFC 5746)
    ///                 (Most interoperable and least secure option)
    ///
    ///                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections
    ///                 if peer does not support secure renegotiation. Results
    ///                 in interoperability issues with non-upgraded peers
    ///                 that do not support renegotiation altogether.
    ///                 (Most secure option, interoperability issues)
    ///
    /// \param conf     SSL configuration
    /// \param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,
    ///                                        SSL_ALLOW_LEGACY_RENEGOTIATION or
    ///                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)
    pub fn mbedtls_ssl_conf_legacy_renegotiation(
        conf: *mut mbedtls_ssl_config,
        allow_legacy: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Enforce renegotiation requests.
    ///                 (Default: enforced, max_records = 16)
    ///
    ///                 When we request a renegotiation, the peer can comply or
    ///                 ignore the request. This function allows us to decide
    ///                 whether to enforce our renegotiation requests by closing
    ///                 the connection if the peer doesn't comply.
    ///
    ///                 However, records could already be in transit from the peer
    ///                 when the request is emitted. In order to increase
    ///                 reliability, we can accept a number of records before the
    ///                 expected handshake records.
    ///
    ///                 The optimal value is highly dependent on the specific usage
    ///                 scenario.
    ///
    /// \note           With DTLS and server-initiated renegotiation, the
    ///                 HelloRequest is retransmitted every time mbedtls_ssl_read() times
    ///                 out or receives Application Data, until:
    ///                 - max_records records have beens seen, if it is >= 0, or
    ///                 - the number of retransmits that would happen during an
    ///                 actual handshake has been reached.
    ///                 Please remember the request might be lost a few times
    ///                 if you consider setting max_records to a really low value.
    ///
    /// \warning        On client, the grace period can only happen during
    ///                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()
    ///                 which always behave as if max_record was 0. The reason is,
    ///                 if we receive application data from the server, we need a
    ///                 place to write it, which only happens during mbedtls_ssl_read().
    ///
    /// \param conf     SSL configuration
    /// \param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to
    ///                 enforce renegotiation, or a non-negative value to enforce
    ///                 it but allow for a grace period of max_records records.
    pub fn mbedtls_ssl_conf_renegotiation_enforced(
        conf: *mut mbedtls_ssl_config,
        max_records: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief          Set record counter threshold for periodic renegotiation.
    ///                 (Default: 2^48 - 1)
    ///
    ///                 Renegotiation is automatically triggered when a record
    ///                 counter (outgoing or incoming) crosses the defined
    ///                 threshold. The default value is meant to prevent the
    ///                 connection from being closed when the counter is about to
    ///                 reached its maximal value (it is not allowed to wrap).
    ///
    ///                 Lower values can be used to enforce policies such as "keys
    ///                 must be refreshed every N packets with cipher X".
    ///
    ///                 The renegotiation period can be disabled by setting
    ///                 conf->disable_renegotiation to
    ///                 MBEDTLS_SSL_RENEGOTIATION_DISABLED.
    ///
    /// \note           When the configured transport is
    ///                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation
    ///                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,
    ///                 the maximum renegotiation period is 2^64 - 1.
    ///
    /// \param conf     SSL configuration
    /// \param period   The threshold value: a big-endian 64-bit number.
    pub fn mbedtls_ssl_conf_renegotiation_period(
        conf: *mut mbedtls_ssl_config,
        period: *const crate::c_types::c_uchar,
    );
}
extern "C" {
    /// \brief          Check if there is data already read from the
    ///                 underlying transport but not yet processed.
    ///
    /// \param ssl      SSL context
    ///
    /// \return         0 if nothing's pending, 1 otherwise.
    ///
    /// \note           This is different in purpose and behaviour from
    ///                 \c mbedtls_ssl_get_bytes_avail in that it considers
    ///                 any kind of unprocessed data, not only unread
    ///                 application data. If \c mbedtls_ssl_get_bytes
    ///                 returns a non-zero value, this function will
    ///                 also signal pending data, but the converse does
    ///                 not hold. For example, in DTLS there might be
    ///                 further records waiting to be processed from
    ///                 the current underlying transport's datagram.
    ///
    /// \note           If this function returns 1 (data pending), this
    ///                 does not imply that a subsequent call to
    ///                 \c mbedtls_ssl_read will provide any data;
    ///                 e.g., the unprocessed data might turn out
    ///                 to be an alert or a handshake message.
    ///
    /// \note           This function is useful in the following situation:
    ///                 If the SSL/TLS module successfully returns from an
    ///                 operation - e.g. a handshake or an application record
    ///                 read - and you're awaiting incoming data next, you
    ///                 must not immediately idle on the underlying transport
    ///                 to have data ready, but you need to check the value
    ///                 of this function first. The reason is that the desired
    ///                 data might already be read but not yet processed.
    ///                 If, in contrast, a previous call to the SSL/TLS module
    ///                 returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary
    ///                 to call this function, as the latter error code entails
    ///                 that all internal data has been processed.
    pub fn mbedtls_ssl_check_pending(ssl: *const mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Return the number of application data bytes
    ///                 remaining to be read from the current record.
    ///
    /// \param ssl      SSL context
    ///
    /// \return         How many bytes are available in the application
    ///                 data record read buffer.
    ///
    /// \note           When working over a datagram transport, this is
    ///                 useful to detect the current datagram's boundary
    ///                 in case \c mbedtls_ssl_read has written the maximal
    ///                 amount of data fitting into the input buffer.
    pub fn mbedtls_ssl_get_bytes_avail(ssl: *const mbedtls_ssl_context) -> usize;
}
extern "C" {
    /// \brief          Return the result of the certificate verification
    ///
    /// \param ssl      The SSL context to use.
    ///
    /// \return         \c 0 if the certificate verification was successful.
    /// \return         \c -1u if the result is not available. This may happen
    ///                 e.g. if the handshake aborts early, or a verification
    ///                 callback returned a fatal error.
    /// \return         A bitwise combination of \c MBEDTLS_X509_BADCERT_XXX
    ///                 and \c MBEDTLS_X509_BADCRL_XXX failure flags; see x509.h.
    pub fn mbedtls_ssl_get_verify_result(ssl: *const mbedtls_ssl_context) -> u32;
}
extern "C" {
    /// \brief          Return the id of the current ciphersuite
    ///
    /// \param ssl      SSL context
    ///
    /// \return         a ciphersuite id
    pub fn mbedtls_ssl_get_ciphersuite_id_from_ssl(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Return the name of the current ciphersuite
    ///
    /// \param ssl      SSL context
    ///
    /// \return         a string containing the ciphersuite name
    pub fn mbedtls_ssl_get_ciphersuite(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    /// \brief          Return the current TLS version
    ///
    /// \param ssl      SSL context
    ///
    /// \return         a string containing the TLS version
    pub fn mbedtls_ssl_get_version(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    /// \brief          Return the (maximum) number of bytes added by the record
    ///                 layer: header + encryption/MAC overhead (inc. padding)
    ///
    /// \param ssl      SSL context
    ///
    /// \return         Current maximum record expansion in bytes
    pub fn mbedtls_ssl_get_record_expansion(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Return the current maximum outgoing record payload in bytes.
    ///
    /// \note           The logic to determine the maximum outgoing record payload is
    ///                 version-specific. It takes into account various factors, such as
    ///                 the mbedtls_config.h setting \c MBEDTLS_SSL_OUT_CONTENT_LEN, extensions
    ///                 such as the max fragment length or record size limit extension if
    ///                 used, and for DTLS the path MTU as configured and current
    ///                 record expansion.
    ///
    /// \note           With DTLS, \c mbedtls_ssl_write() will return an error if
    ///                 called with a larger length value.
    ///                 With TLS, \c mbedtls_ssl_write() will fragment the input if
    ///                 necessary and return the number of bytes written; it is up
    ///                 to the caller to call \c mbedtls_ssl_write() again in
    ///                 order to send the remaining bytes if any.
    ///
    /// \sa             mbedtls_ssl_get_max_out_record_payload()
    /// \sa             mbedtls_ssl_get_record_expansion()
    ///
    /// \param ssl      SSL context
    ///
    /// \return         Current maximum payload for an outgoing record,
    ///                 or a negative error code.
    pub fn mbedtls_ssl_get_max_out_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Return the current maximum incoming record payload in bytes.
    ///
    /// \note           The logic to determine the maximum incoming record payload is
    ///                 version-specific. It takes into account various factors, such as
    ///                 the mbedtls_config.h setting \c MBEDTLS_SSL_IN_CONTENT_LEN, extensions
    ///                 such as the max fragment length extension or record size limit
    ///                 extension if used, and the current record expansion.
    ///
    /// \sa             mbedtls_ssl_set_mtu()
    /// \sa             mbedtls_ssl_get_max_in_record_payload()
    /// \sa             mbedtls_ssl_get_record_expansion()
    ///
    /// \param ssl      SSL context
    ///
    /// \return         Current maximum payload for an incoming record,
    ///                 or a negative error code.
    pub fn mbedtls_ssl_get_max_in_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Return the peer certificate from the current connection.
    ///
    /// \param  ssl     The SSL context to use. This must be initialized and setup.
    ///
    /// \return         The current peer certificate, if available.
    ///                 The returned certificate is owned by the SSL context and
    ///                 is valid only until the next call to the SSL API.
    /// \return         \c NULL if no peer certificate is available. This might
    ///                 be because the chosen ciphersuite doesn't use CRTs
    ///                 (PSK-based ciphersuites, for example), or because
    ///                 #MBEDTLS_SSL_KEEP_PEER_CERTIFICATE has been disabled,
    ///                 allowing the stack to free the peer's CRT to save memory.
    ///
    /// \note           For one-time inspection of the peer's certificate during
    ///                 the handshake, consider registering an X.509 CRT verification
    ///                 callback through mbedtls_ssl_conf_verify() instead of calling
    ///                 this function. Using mbedtls_ssl_conf_verify() also comes at
    ///                 the benefit of allowing you to influence the verification
    ///                 process, for example by masking expected and tolerated
    ///                 verification failures.
    ///
    /// \warning        You must not use the pointer returned by this function
    ///                 after any further call to the SSL API, including
    ///                 mbedtls_ssl_read() and mbedtls_ssl_write(); this is
    ///                 because the pointer might change during renegotiation,
    ///                 which happens transparently to the user.
    ///                 If you want to use the certificate across API calls,
    ///                 you must make a copy.
    pub fn mbedtls_ssl_get_peer_cert(ssl: *const mbedtls_ssl_context) -> *const mbedtls_x509_crt;
}
extern "C" {
    /// \brief          Export a session in order to resume it later.
    ///
    /// \param ssl      The SSL context representing the connection for which to
    ///                 to export a session structure for later resumption.
    /// \param session  The target structure in which to store the exported session.
    ///                 This must have been initialized with mbedtls_ssl_init_session()
    ///                 but otherwise be unused.
    ///
    /// \note           This function can handle a variety of mechanisms for session
    ///                 resumption: For TLS 1.2, both session ID-based resumption and
    ///                 ticket-based resumption will be considered. For TLS 1.3,
    ///                 once implemented, sessions equate to tickets, and calling
    ///                 this function multiple times will export the available
    ///                 tickets one a time until no further tickets are available,
    ///                 in which case MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE will
    ///                 be returned.
    ///
    /// \note           Calling this function multiple times will only be useful
    ///                 once TLS 1.3 is supported. For TLS 1.2 connections, this
    ///                 function should be called at most once.
    ///
    /// \return         \c 0 if successful. In this case, \p session can be used for
    ///                 session resumption by passing it to mbedtls_ssl_set_session(),
    ///                 and serialized for storage via mbedtls_ssl_session_save().
    /// \return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no further session
    ///                 is available for export.
    ///                 This error is a non-fatal, and has no observable effect on
    ///                 the SSL context or the destination session.
    /// \return         Another negative error code on other kinds of failure.
    ///
    /// \sa             mbedtls_ssl_set_session()
    /// \sa             mbedtls_ssl_session_save()
    pub fn mbedtls_ssl_get_session(
        ssl: *const mbedtls_ssl_context,
        session: *mut mbedtls_ssl_session,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform the SSL handshake
    ///
    /// \param ssl      SSL context
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
    ///                 if the handshake is incomplete and waiting for data to
    ///                 be available for reading from or writing to the underlying
    ///                 transport - in this case you must call this function again
    ///                 when the underlying transport is ready for the operation.
    /// \return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
    ///                 operation is in progress (see
    ///                 mbedtls_ssl_conf_async_private_cb()) - in this case you
    ///                 must call this function again when the operation is ready.
    /// \return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
    ///                 operation is in progress (see mbedtls_ecp_set_max_ops()) -
    ///                 in this case you must call this function again to complete
    ///                 the handshake when you're done attending other tasks.
    /// \return         #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use
    ///                 and the client did not demonstrate reachability yet - in
    ///                 this case you must stop using the context (see below).
    /// \return         Another SSL error code - in this case you must stop using
    ///                 the context (see below).
    ///
    /// \warning        If this function returns something other than
    ///                 \c 0,
    ///                 #MBEDTLS_ERR_SSL_WANT_READ,
    ///                 #MBEDTLS_ERR_SSL_WANT_WRITE,
    ///                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or
    ///                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,
    ///                 you must stop using the SSL context for reading or writing,
    ///                 and either free it or call \c mbedtls_ssl_session_reset()
    ///                 on it before re-using it for a new connection; the current
    ///                 connection must be closed.
    ///
    /// \note           If DTLS is in use, then you may choose to handle
    ///                 #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging
    ///                 purposes, as it is an expected return value rather than an
    ///                 actual error, but you still need to reset/free the context.
    ///
    /// \note           Remarks regarding event-driven DTLS:
    ///                 If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram
    ///                 from the underlying transport layer is currently being processed,
    ///                 and it is safe to idle until the timer or the underlying transport
    ///                 signal a new event. This is not true for a successful handshake,
    ///                 in which case the datagram of the underlying transport that is
    ///                 currently being processed might or might not contain further
    ///                 DTLS records.
    ///
    /// \note           If the context is configured to allow TLS 1.3, or if
    ///                 #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
    ///                 subsystem must have been initialized by calling
    ///                 psa_crypto_init() before calling this function.
    pub fn mbedtls_ssl_handshake(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Perform a single step of the SSL handshake
    ///
    /// \note           The state of the context (ssl->state) will be at
    ///                 the next state after this function returns \c 0. Do not
    ///                 call this function if mbedtls_ssl_is_handshake_over()
    ///                 returns \c 1.
    ///
    /// \warning        Whilst in the past you may have used direct access to the
    ///                 context state (ssl->state) in order to ascertain when to
    ///                 stop calling this function and although you can still do
    ///                 so with something like ssl->MBEDTLS_PRIVATE(state) or by
    ///                 defining MBEDTLS_ALLOW_PRIVATE_ACCESS, this is now
    ///                 considered deprecated and could be broken in any future
    ///                 release. If you still find you have good reason for such
    ///                 direct access, then please do contact the team to explain
    ///                 this (raise an issue or post to the mailing list), so that
    ///                 we can add a solution to your problem that will be
    ///                 guaranteed to work in the future.
    ///
    /// \param ssl      SSL context
    ///
    /// \return         See mbedtls_ssl_handshake().
    ///
    /// \warning        If this function returns something other than \c 0,
    ///                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,
    ///                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or
    ///                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using
    ///                 the SSL context for reading or writing, and either free it
    ///                 or call \c mbedtls_ssl_session_reset() on it before
    ///                 re-using it for a new connection; the current connection
    ///                 must be closed.
    pub fn mbedtls_ssl_handshake_step(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Initiate an SSL renegotiation on the running connection.
    ///                 Client: perform the renegotiation right now.
    ///                 Server: request renegotiation, which will be performed
    ///                 during the next call to mbedtls_ssl_read() if honored by
    ///                 client.
    ///
    /// \param ssl      SSL context
    ///
    /// \return         0 if successful, or any mbedtls_ssl_handshake() return
    ///                 value except #MBEDTLS_ERR_SSL_CLIENT_RECONNECT that can't
    ///                 happen during a renegotiation.
    ///
    /// \warning        If this function returns something other than \c 0,
    ///                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,
    ///                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or
    ///                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using
    ///                 the SSL context for reading or writing, and either free it
    ///                 or call \c mbedtls_ssl_session_reset() on it before
    ///                 re-using it for a new connection; the current connection
    ///                 must be closed.
    pub fn mbedtls_ssl_renegotiate(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Read at most 'len' application data bytes
    ///
    /// \param ssl      SSL context
    /// \param buf      buffer that will hold the data
    /// \param len      maximum number of bytes to read
    ///
    /// \return         The (positive) number of bytes read if successful.
    /// \return         \c 0 if the read end of the underlying transport was closed
    ///                 without sending a CloseNotify beforehand, which might happen
    ///                 because of various reasons (internal error of an underlying
    ///                 stack, non-conformant peer not sending a CloseNotify and
    ///                 such) - in this case you must stop using the context
    ///                 (see below).
    /// \return         #MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY if the underlying
    ///                 transport is still functional, but the peer has
    ///                 acknowledged to not send anything anymore.
    /// \return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
    ///                 if the handshake is incomplete and waiting for data to
    ///                 be available for reading from or writing to the underlying
    ///                 transport - in this case you must call this function again
    ///                 when the underlying transport is ready for the operation.
    /// \return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
    ///                 operation is in progress (see
    ///                 mbedtls_ssl_conf_async_private_cb()) - in this case you
    ///                 must call this function again when the operation is ready.
    /// \return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
    ///                 operation is in progress (see mbedtls_ecp_set_max_ops()) -
    ///                 in this case you must call this function again to complete
    ///                 the handshake when you're done attending other tasks.
    /// \return         #MBEDTLS_ERR_SSL_CLIENT_RECONNECT if we're at the server
    ///                 side of a DTLS connection and the client is initiating a
    ///                 new connection using the same source port. See below.
    /// \return         Another SSL error code - in this case you must stop using
    ///                 the context (see below).
    ///
    /// \warning        If this function returns something other than
    ///                 a positive value,
    ///                 #MBEDTLS_ERR_SSL_WANT_READ,
    ///                 #MBEDTLS_ERR_SSL_WANT_WRITE,
    ///                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,
    ///                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or
    ///                 #MBEDTLS_ERR_SSL_CLIENT_RECONNECT,
    ///                 you must stop using the SSL context for reading or writing,
    ///                 and either free it or call \c mbedtls_ssl_session_reset()
    ///                 on it before re-using it for a new connection; the current
    ///                 connection must be closed.
    ///
    /// \note           When this function returns #MBEDTLS_ERR_SSL_CLIENT_RECONNECT
    ///                 (which can only happen server-side), it means that a client
    ///                 is initiating a new connection using the same source port.
    ///                 You can either treat that as a connection close and wait
    ///                 for the client to resend a ClientHello, or directly
    ///                 continue with \c mbedtls_ssl_handshake() with the same
    ///                 context (as it has been reset internally). Either way, you
    ///                 must make sure this is seen by the application as a new
    ///                 connection: application state, if any, should be reset, and
    ///                 most importantly the identity of the client must be checked
    ///                 again. WARNING: not validating the identity of the client
    ///                 again, or not transmitting the new identity to the
    ///                 application layer, would allow authentication bypass!
    ///
    /// \note           Remarks regarding event-driven DTLS:
    ///                 - If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram
    ///                   from the underlying transport layer is currently being processed,
    ///                   and it is safe to idle until the timer or the underlying transport
    ///                   signal a new event.
    ///                 - This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was
    ///                   initially available on the underlying transport, as this data may have
    ///                   been only e.g. duplicated messages or a renegotiation request.
    ///                   Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even
    ///                   when reacting to an incoming-data event from the underlying transport.
    ///                 - On success, the datagram of the underlying transport that is currently
    ///                   being processed may contain further DTLS records. You should call
    ///                   \c mbedtls_ssl_check_pending to check for remaining records.
    pub fn mbedtls_ssl_read(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Try to write exactly 'len' application data bytes
    ///
    /// \warning        This function will do partial writes in some cases. If the
    ///                 return value is non-negative but less than length, the
    ///                 function must be called again with updated arguments:
    ///                 buf + ret, len - ret (if ret is the return value) until
    ///                 it returns a value equal to the last 'len' argument.
    ///
    /// \param ssl      SSL context
    /// \param buf      buffer holding the data
    /// \param len      how many bytes must be written
    ///
    /// \return         The (non-negative) number of bytes actually written if
    ///                 successful (may be less than \p len).
    /// \return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
    ///                 if the handshake is incomplete and waiting for data to
    ///                 be available for reading from or writing to the underlying
    ///                 transport - in this case you must call this function again
    ///                 when the underlying transport is ready for the operation.
    /// \return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
    ///                 operation is in progress (see
    ///                 mbedtls_ssl_conf_async_private_cb()) - in this case you
    ///                 must call this function again when the operation is ready.
    /// \return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
    ///                 operation is in progress (see mbedtls_ecp_set_max_ops()) -
    ///                 in this case you must call this function again to complete
    ///                 the handshake when you're done attending other tasks.
    /// \return         Another SSL error code - in this case you must stop using
    ///                 the context (see below).
    ///
    /// \warning        If this function returns something other than
    ///                 a non-negative value,
    ///                 #MBEDTLS_ERR_SSL_WANT_READ,
    ///                 #MBEDTLS_ERR_SSL_WANT_WRITE,
    ///                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or
    ///                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,
    ///                 you must stop using the SSL context for reading or writing,
    ///                 and either free it or call \c mbedtls_ssl_session_reset()
    ///                 on it before re-using it for a new connection; the current
    ///                 connection must be closed.
    ///
    /// \note           When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ,
    ///                 it must be called later with the *same* arguments,
    ///                 until it returns a value greater than or equal to 0. When
    ///                 the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be
    ///                 some partial data in the output buffer, however this is not
    ///                 yet sent.
    ///
    /// \note           If the requested length is greater than the maximum
    ///                 fragment length (either the built-in limit or the one set
    ///                 or negotiated with the peer), then:
    ///                 - with TLS, less bytes than requested are written.
    ///                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned.
    ///                 \c mbedtls_ssl_get_max_out_record_payload() may be used to
    ///                 query the active maximum fragment length.
    ///
    /// \note           Attempting to write 0 bytes will result in an empty TLS
    ///                 application record being sent.
    pub fn mbedtls_ssl_write(
        ssl: *mut mbedtls_ssl_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Send an alert message
    ///
    /// \param ssl       SSL context
    /// \param level     The alert level of the message
    ///                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)
    /// \param message   The alert message (SSL_ALERT_MSG_*)
    ///
    /// \return          0 if successful, or a specific SSL error code.
    ///
    /// \note           If this function returns something other than 0 or
    ///                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using
    ///                 the SSL context for reading or writing, and either free it or
    ///                 call \c mbedtls_ssl_session_reset() on it before re-using it
    ///                 for a new connection; the current connection must be closed.
    pub fn mbedtls_ssl_send_alert_message(
        ssl: *mut mbedtls_ssl_context,
        level: crate::c_types::c_uchar,
        message: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Notify the peer that the connection is being closed
    ///
    /// \param ssl      SSL context
    ///
    /// \return          0 if successful, or a specific SSL error code.
    ///
    /// \note           If this function returns something other than 0 or
    ///                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using
    ///                 the SSL context for reading or writing, and either free it or
    ///                 call \c mbedtls_ssl_session_reset() on it before re-using it
    ///                 for a new connection; the current connection must be closed.
    pub fn mbedtls_ssl_close_notify(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Free referenced items in an SSL context and clear memory
    ///
    /// \param ssl      SSL context
    pub fn mbedtls_ssl_free(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    /// \brief          Save an active connection as serialized data in a buffer.
    ///                 This allows the freeing or re-using of the SSL context
    ///                 while still picking up the connection later in a way that
    ///                 it entirely transparent to the peer.
    ///
    /// \see            mbedtls_ssl_context_load()
    ///
    /// \note           The serialized data only contains the data that is
    ///                 necessary to resume the connection: negotiated protocol
    ///                 options, session identifier, keys, etc.
    ///                 Loading a saved SSL context does not restore settings and
    ///                 state related to how the application accesses the context,
    ///                 such as configured callback functions, user data, pending
    ///                 incoming or outgoing data, etc.
    ///
    /// \note           This feature is currently only available under certain
    ///                 conditions, see the documentation of the return value
    ///                 #MBEDTLS_ERR_SSL_BAD_INPUT_DATA for details.
    ///
    /// \note           When this function succeeds, it calls
    ///                 mbedtls_ssl_session_reset() on \p ssl which as a result is
    ///                 no longer associated with the connection that has been
    ///                 serialized. This avoids creating copies of the connection
    ///                 state. You're then free to either re-use the context
    ///                 structure for a different connection, or call
    ///                 mbedtls_ssl_free() on it. See the documentation of
    ///                 mbedtls_ssl_session_reset() for more details.
    ///
    /// \param ssl      The SSL context to save. On success, it is no longer
    ///                 associated with the connection that has been serialized.
    /// \param buf      The buffer to write the serialized data to. It must be a
    ///                 writeable buffer of at least \p buf_len bytes, or may be \c
    ///                 NULL if \p buf_len is \c 0.
    /// \param buf_len  The number of bytes available for writing in \p buf.
    /// \param olen     The size in bytes of the data that has been or would have
    ///                 been written. It must point to a valid \c size_t.
    ///
    /// \note           \p olen is updated to the correct value regardless of
    ///                 whether \p buf_len was large enough. This makes it possible
    ///                 to determine the necessary size by calling this function
    ///                 with \p buf set to \c NULL and \p buf_len to \c 0. However,
    ///                 the value of \p olen is only guaranteed to be correct when
    ///                 the function returns #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL or
    ///                 \c 0. If the return value is different, then the value of
    ///                 \p olen is undefined.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \p buf is too small.
    /// \return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed
    ///                 while resetting the context.
    /// \return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if a handshake is in
    ///                 progress, or there is pending data for reading or sending,
    ///                 or the connection does not use DTLS 1.2 with an AEAD
    ///                 ciphersuite, or renegotiation is enabled.
    pub fn mbedtls_ssl_context_save(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Load serialized connection data to an SSL context.
    ///
    /// \see            mbedtls_ssl_context_save()
    ///
    /// \warning        The same serialized data must never be loaded into more
    ///                 that one context. In order to ensure that, after
    ///                 successfully loading serialized data to an SSL context, you
    ///                 should immediately destroy or invalidate all copies of the
    ///                 serialized data that was loaded. Loading the same data in
    ///                 more than one context would cause severe security failures
    ///                 including but not limited to loss of confidentiality.
    ///
    /// \note           Before calling this function, the SSL context must be
    ///                 prepared in one of the two following ways. The first way is
    ///                 to take a context freshly initialised with
    ///                 mbedtls_ssl_init() and call mbedtls_ssl_setup() on it with
    ///                 the same ::mbedtls_ssl_config structure that was used in
    ///                 the original connection. The second way is to
    ///                 call mbedtls_ssl_session_reset() on a context that was
    ///                 previously prepared as above but used in the meantime.
    ///                 Either way, you must not use the context to perform a
    ///                 handshake between calling mbedtls_ssl_setup() or
    ///                 mbedtls_ssl_session_reset() and calling this function. You
    ///                 may however call other setter functions in that time frame
    ///                 as indicated in the note below.
    ///
    /// \note           Before or after calling this function successfully, you
    ///                 also need to configure some connection-specific callbacks
    ///                 and settings before you can use the connection again
    ///                 (unless they were already set before calling
    ///                 mbedtls_ssl_session_reset() and the values are suitable for
    ///                 the present connection). Specifically, you want to call
    ///                 at least mbedtls_ssl_set_bio(),
    ///                 mbedtls_ssl_set_timer_cb(), and
    ///                 mbedtls_ssl_set_user_data_n() or
    ///                 mbedtls_ssl_set_user_data_p() if they were set originally.
    ///                 All other SSL setter functions
    ///                 are not necessary to call, either because they're only used
    ///                 in handshakes, or because the setting is already saved. You
    ///                 might choose to call them anyway, for example in order to
    ///                 share code between the cases of establishing a new
    ///                 connection and the case of loading an already-established
    ///                 connection.
    ///
    /// \note           If you have new information about the path MTU, you want to
    ///                 call mbedtls_ssl_set_mtu() after calling this function, as
    ///                 otherwise this function would overwrite your
    ///                 newly-configured value with the value that was active when
    ///                 the context was saved.
    ///
    /// \note           When this function returns an error code, it calls
    ///                 mbedtls_ssl_free() on \p ssl. In this case, you need to
    ///                 prepare the context with the usual sequence starting with a
    ///                 call to mbedtls_ssl_init() if you want to use it again.
    ///
    /// \param ssl      The SSL context structure to be populated. It must have
    ///                 been prepared as described in the note above.
    /// \param buf      The buffer holding the serialized connection data. It must
    ///                 be a readable buffer of at least \p len bytes.
    /// \param len      The size of the serialized data in bytes.
    ///
    /// \return         \c 0 if successful.
    /// \return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed.
    /// \return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data
    ///                 comes from a different Mbed TLS version or build.
    /// \return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid.
    pub fn mbedtls_ssl_context_load(
        ssl: *mut mbedtls_ssl_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Initialize an SSL configuration context
    ///                 Just makes the context ready for
    ///                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free().
    ///
    /// \note           You need to call mbedtls_ssl_config_defaults() unless you
    ///                 manually set all of the relevant fields yourself.
    ///
    /// \param conf     SSL configuration context
    pub fn mbedtls_ssl_config_init(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    /// \brief          Load reasonable default SSL configuration values.
    ///                 (You need to call mbedtls_ssl_config_init() first.)
    ///
    /// \param conf     SSL configuration context
    /// \param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER
    /// \param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or
    ///                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS
    /// \param preset   a MBEDTLS_SSL_PRESET_XXX value
    ///
    /// \note           See \c mbedtls_ssl_conf_transport() for notes on DTLS.
    ///
    /// \return         0 if successful, or
    ///                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error.
    pub fn mbedtls_ssl_config_defaults(
        conf: *mut mbedtls_ssl_config,
        endpoint: crate::c_types::c_int,
        transport: crate::c_types::c_int,
        preset: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Free an SSL configuration context
    ///
    /// \param conf     SSL configuration context
    pub fn mbedtls_ssl_config_free(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    /// \brief          Initialize SSL session structure
    ///
    /// \param session  SSL session
    pub fn mbedtls_ssl_session_init(session: *mut mbedtls_ssl_session);
}
extern "C" {
    /// \brief          Free referenced items in an SSL session including the
    ///                 peer certificate and clear memory
    ///
    /// \note           A session object can be freed even if the SSL context
    ///                 that was used to retrieve the session is still in use.
    ///
    /// \param session  SSL session
    pub fn mbedtls_ssl_session_free(session: *mut mbedtls_ssl_session);
}
extern "C" {
    /// \brief          TLS-PRF function for key derivation.
    ///
    /// \param prf      The tls_prf type function type to be used.
    /// \param secret   Secret for the key derivation function.
    /// \param slen     Length of the secret.
    /// \param label    String label for the key derivation function,
    ///                 terminated with null character.
    /// \param random   Random bytes.
    /// \param rlen     Length of the random bytes buffer.
    /// \param dstbuf   The buffer holding the derived key.
    /// \param dlen     Length of the output buffer.
    ///
    /// \return         0 on success. An SSL specific error on failure.
    pub fn mbedtls_ssl_tls_prf(
        prf: mbedtls_tls_prf_types,
        secret: *const crate::c_types::c_uchar,
        slen: usize,
        label: *const crate::c_types::c_char,
        random: *const crate::c_types::c_uchar,
        rlen: usize,
        dstbuf: *mut crate::c_types::c_uchar,
        dlen: usize,
    ) -> crate::c_types::c_int;
}
/// \brief           Entropy poll callback pointer
///
/// \param data      Callback-specific data pointer
/// \param output    Data to fill
/// \param len       Maximum size to provide
/// \param olen      The actual amount of bytes put into the buffer (Can be 0)
///
/// \return          0 if no critical failures occurred,
///                  MBEDTLS_ERR_ENTROPY_SOURCE_FAILED otherwise
pub type mbedtls_entropy_f_source_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int,
>;
/// \brief           Entropy source state
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_entropy_source_state {
    ///< The entropy source callback
    pub private_f_source: mbedtls_entropy_f_source_ptr,
    ///< The callback data pointer
    pub private_p_source: *mut crate::c_types::c_void,
    ///< Amount received in bytes
    pub private_size: usize,
    ///< Minimum bytes required before release
    pub private_threshold: usize,
    ///< Is the source strong?
    pub private_strong: crate::c_types::c_int,
}
/// \brief           Entropy context structure
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_entropy_context {
    pub private_accumulator_started: crate::c_types::c_int,
    pub private_accumulator: mbedtls_sha512_context,
    pub private_source_count: crate::c_types::c_int,
    pub private_source: [mbedtls_entropy_source_state; 20usize],
}
extern "C" {
    /// \brief           Initialize the context
    ///
    /// \param ctx       Entropy context to initialize
    pub fn mbedtls_entropy_init(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    /// \brief           Free the data in the context
    ///
    /// \param ctx       Entropy context to free
    pub fn mbedtls_entropy_free(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    /// \brief           Adds an entropy source to poll
    ///                  (Thread-safe if MBEDTLS_THREADING_C is enabled)
    ///
    /// \param ctx       Entropy context
    /// \param f_source  Entropy function
    /// \param p_source  Function data
    /// \param threshold Minimum required from source before entropy is released
    ///                  ( with mbedtls_entropy_func() ) (in bytes)
    /// \param strong    MBEDTLS_ENTROPY_SOURCE_STRONG or
    ///                  MBEDTLS_ENTROPY_SOURCE_WEAK.
    ///                  At least one strong source needs to be added.
    ///                  Weaker sources (such as the cycle counter) can be used as
    ///                  a complement.
    ///
    /// \return          0 if successful or MBEDTLS_ERR_ENTROPY_MAX_SOURCES
    pub fn mbedtls_entropy_add_source(
        ctx: *mut mbedtls_entropy_context,
        f_source: mbedtls_entropy_f_source_ptr,
        p_source: *mut crate::c_types::c_void,
        threshold: usize,
        strong: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Trigger an extra gather poll for the accumulator
    ///                  (Thread-safe if MBEDTLS_THREADING_C is enabled)
    ///
    /// \param ctx       Entropy context
    ///
    /// \return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED
    pub fn mbedtls_entropy_gather(ctx: *mut mbedtls_entropy_context) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Retrieve entropy from the accumulator
    ///                  (Maximum length: MBEDTLS_ENTROPY_BLOCK_SIZE)
    ///                  (Thread-safe if MBEDTLS_THREADING_C is enabled)
    ///
    /// \param data      Entropy context
    /// \param output    Buffer to fill
    /// \param len       Number of bytes desired, must be at most MBEDTLS_ENTROPY_BLOCK_SIZE
    ///
    /// \return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED
    pub fn mbedtls_entropy_func(
        data: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Add data to the accumulator manually
    ///                  (Thread-safe if MBEDTLS_THREADING_C is enabled)
    ///
    /// \param ctx       Entropy context
    /// \param data      Data to add
    /// \param len       Length of data
    ///
    /// \return          0 if successful
    pub fn mbedtls_entropy_update_manual(
        ctx: *mut mbedtls_entropy_context,
        data: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Checkup routine
    ///
    ///                 This module self-test also calls the entropy self-test,
    ///                 mbedtls_entropy_source_self_test();
    ///
    /// \return         0 if successful, or 1 if a test failed
    pub fn mbedtls_entropy_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief   Set the threshold error level to handle globally all debug output.
    ///          Debug messages that have a level over the threshold value are
    ///          discarded.
    ///          (Default value: 0 = No debug )
    ///
    /// \param threshold     threshold level of messages to filter on. Messages at a
    ///                      higher level will be discarded.
    ///                          - Debug levels
    ///                              - 0 No debug
    ///                              - 1 Error
    ///                              - 2 State change
    ///                              - 3 Informational
    ///                              - 4 Verbose
    pub fn mbedtls_debug_set_threshold(threshold: crate::c_types::c_int);
}
extern "C" {
    /// \brief    Print a message to the debug output. This function is always used
    ///          through the MBEDTLS_SSL_DEBUG_MSG() macro, which supplies the ssl
    ///          context, file and line number parameters.
    ///
    /// \param ssl       SSL context
    /// \param level     error level of the debug message
    /// \param file      file the message has occurred in
    /// \param line      line number the message has occurred at
    /// \param format    format specifier, in printf format
    /// \param ...       variables used by the format specifier
    ///
    /// \attention       This function is intended for INTERNAL usage within the
    ///                  library only.
    pub fn mbedtls_debug_print_msg(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        format: *const crate::c_types::c_char,
        ...
    );
}
extern "C" {
    /// \brief   Print the return value of a function to the debug output. This
    ///          function is always used through the MBEDTLS_SSL_DEBUG_RET() macro,
    ///          which supplies the ssl context, file and line number parameters.
    ///
    /// \param ssl       SSL context
    /// \param level     error level of the debug message
    /// \param file      file the error has occurred in
    /// \param line      line number the error has occurred in
    /// \param text      the name of the function that returned the error
    /// \param ret       the return code value
    ///
    /// \attention       This function is intended for INTERNAL usage within the
    ///                  library only.
    pub fn mbedtls_debug_print_ret(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        ret: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief   Output a buffer of size len bytes to the debug output. This function
    ///          is always used through the MBEDTLS_SSL_DEBUG_BUF() macro,
    ///          which supplies the ssl context, file and line number parameters.
    ///
    /// \param ssl       SSL context
    /// \param level     error level of the debug message
    /// \param file      file the error has occurred in
    /// \param line      line number the error has occurred in
    /// \param text      a name or label for the buffer being dumped. Normally the
    ///                  variable or buffer name
    /// \param buf       the buffer to be outputted
    /// \param len       length of the buffer
    ///
    /// \attention       This function is intended for INTERNAL usage within the
    ///                  library only.
    pub fn mbedtls_debug_print_buf(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    );
}
extern "C" {
    /// \brief   Print a MPI variable to the debug output. This function is always
    ///          used through the MBEDTLS_SSL_DEBUG_MPI() macro, which supplies the
    ///          ssl context, file and line number parameters.
    ///
    /// \param ssl       SSL context
    /// \param level     error level of the debug message
    /// \param file      file the error has occurred in
    /// \param line      line number the error has occurred in
    /// \param text      a name or label for the MPI being output. Normally the
    ///                  variable name
    /// \param X         the MPI variable
    ///
    /// \attention       This function is intended for INTERNAL usage within the
    ///                  library only.
    pub fn mbedtls_debug_print_mpi(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        X: *const mbedtls_mpi,
    );
}
extern "C" {
    /// \brief   Print an ECP point to the debug output. This function is always
    ///          used through the MBEDTLS_SSL_DEBUG_ECP() macro, which supplies the
    ///          ssl context, file and line number parameters.
    ///
    /// \param ssl       SSL context
    /// \param level     error level of the debug message
    /// \param file      file the error has occurred in
    /// \param line      line number the error has occurred in
    /// \param text      a name or label for the ECP point being output. Normally the
    ///                  variable name
    /// \param X         the ECP point
    ///
    /// \attention       This function is intended for INTERNAL usage within the
    ///                  library only.
    pub fn mbedtls_debug_print_ecp(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        X: *const mbedtls_ecp_point,
    );
}
extern "C" {
    /// \brief   Print a X.509 certificate structure to the debug output. This
    ///          function is always used through the MBEDTLS_SSL_DEBUG_CRT() macro,
    ///          which supplies the ssl context, file and line number parameters.
    ///
    /// \param ssl       SSL context
    /// \param level     error level of the debug message
    /// \param file      file the error has occurred in
    /// \param line      line number the error has occurred in
    /// \param text      a name or label for the certificate being output
    /// \param crt       X.509 certificate structure
    ///
    /// \attention       This function is intended for INTERNAL usage within the
    ///                  library only.
    pub fn mbedtls_debug_print_crt(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        crt: *const mbedtls_x509_crt,
    );
}
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_Q: mbedtls_debug_ecdh_attr = 0;
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_QP: mbedtls_debug_ecdh_attr = 1;
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_Z: mbedtls_debug_ecdh_attr = 2;
pub type mbedtls_debug_ecdh_attr = crate::c_types::c_uint;
extern "C" {
    /// \brief   Print a field of the ECDH structure in the SSL context to the debug
    ///          output. This function is always used through the
    ///          MBEDTLS_SSL_DEBUG_ECDH() macro, which supplies the ssl context, file
    ///          and line number parameters.
    ///
    /// \param ssl       SSL context
    /// \param level     error level of the debug message
    /// \param file      file the error has occurred in
    /// \param line      line number the error has occurred in
    /// \param ecdh      the ECDH context
    /// \param attr      the identifier of the attribute being output
    ///
    /// \attention       This function is intended for INTERNAL usage within the
    ///                  library only.
    pub fn mbedtls_debug_printf_ecdh(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        ecdh: *const mbedtls_ecdh_context,
        attr: mbedtls_debug_ecdh_attr,
    );
}
/// \brief The AES context-type definition.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_context {
    ///< The number of rounds.
    pub private_nr: crate::c_types::c_int,
    ///< The offset in array elements to AES
    ///round keys in the buffer.
    pub private_rk_offset: usize,
    ///< Unaligned data buffer. This buffer can
    ///hold 32 extra Bytes, which can be used for
    ///one of the following purposes:
    ///<ul><li>Alignment if VIA padlock is
    ///used.</li>
    ///<li>Simplifying key expansion in the 256-bit
    ///case by generating an extra round key.
    ///</li></ul>
    pub private_buf: [u32; 68usize],
}
/// \brief The AES XTS context-type definition.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_xts_context {
    ///< The AES context to use for AES block
    ///encryption or decryption.
    pub private_crypt: mbedtls_aes_context,
    ///< The AES context used for tweak
    ///computation.
    pub private_tweak: mbedtls_aes_context,
}
extern "C" {
    /// \brief          This function initializes the specified AES context.
    ///
    ///                 It must be the first API called before using
    ///                 the context.
    ///
    /// \param ctx      The AES context to initialize. This must not be \c NULL.
    pub fn mbedtls_aes_init(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    /// \brief          This function releases and clears the specified AES context.
    ///
    /// \param ctx      The AES context to clear.
    ///                 If this is \c NULL, this function does nothing.
    ///                 Otherwise, the context must have been at least initialized.
    pub fn mbedtls_aes_free(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    /// \brief          This function initializes the specified AES XTS context.
    ///
    ///                 It must be the first API called before using
    ///                 the context.
    ///
    /// \param ctx      The AES XTS context to initialize. This must not be \c NULL.
    pub fn mbedtls_aes_xts_init(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    /// \brief          This function releases and clears the specified AES XTS context.
    ///
    /// \param ctx      The AES XTS context to clear.
    ///                 If this is \c NULL, this function does nothing.
    ///                 Otherwise, the context must have been at least initialized.
    pub fn mbedtls_aes_xts_free(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    /// \brief          This function sets the encryption key.
    ///
    /// \param ctx      The AES context to which the key should be bound.
    ///                 It must be initialized.
    /// \param key      The encryption key.
    ///                 This must be a readable buffer of size \p keybits bits.
    /// \param keybits  The size of data passed in bits. Valid options are:
    ///                 <ul><li>128 bits</li>
    ///                 <li>192 bits</li>
    ///                 <li>256 bits</li></ul>
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
    pub fn mbedtls_aes_setkey_enc(
        ctx: *mut mbedtls_aes_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function sets the decryption key.
    ///
    /// \param ctx      The AES context to which the key should be bound.
    ///                 It must be initialized.
    /// \param key      The decryption key.
    ///                 This must be a readable buffer of size \p keybits bits.
    /// \param keybits  The size of data passed. Valid options are:
    ///                 <ul><li>128 bits</li>
    ///                 <li>192 bits</li>
    ///                 <li>256 bits</li></ul>
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
    pub fn mbedtls_aes_setkey_dec(
        ctx: *mut mbedtls_aes_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function prepares an XTS context for encryption and
    ///                 sets the encryption key.
    ///
    /// \param ctx      The AES XTS context to which the key should be bound.
    ///                 It must be initialized.
    /// \param key      The encryption key. This is comprised of the XTS key1
    ///                 concatenated with the XTS key2.
    ///                 This must be a readable buffer of size \p keybits bits.
    /// \param keybits  The size of \p key passed in bits. Valid options are:
    ///                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>
    ///                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
    pub fn mbedtls_aes_xts_setkey_enc(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function prepares an XTS context for decryption and
    ///                 sets the decryption key.
    ///
    /// \param ctx      The AES XTS context to which the key should be bound.
    ///                 It must be initialized.
    /// \param key      The decryption key. This is comprised of the XTS key1
    ///                 concatenated with the XTS key2.
    ///                 This must be a readable buffer of size \p keybits bits.
    /// \param keybits  The size of \p key passed in bits. Valid options are:
    ///                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>
    ///                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
    pub fn mbedtls_aes_xts_setkey_dec(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          This function performs an AES single-block encryption or
    ///                 decryption operation.
    ///
    ///                 It performs the operation defined in the \p mode parameter
    ///                 (encrypt or decrypt), on the input data buffer defined in
    ///                 the \p input parameter.
    ///
    ///                 mbedtls_aes_init(), and either mbedtls_aes_setkey_enc() or
    ///                 mbedtls_aes_setkey_dec() must be called before the first
    ///                 call to this API with the same context.
    ///
    /// \param ctx      The AES context to use for encryption or decryption.
    ///                 It must be initialized and bound to a key.
    /// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
    ///                 #MBEDTLS_AES_DECRYPT.
    /// \param input    The buffer holding the input data.
    ///                 It must be readable and at least \c 16 Bytes long.
    /// \param output   The buffer where the output data will be written.
    ///                 It must be writeable and at least \c 16 Bytes long.
    ///
    /// \return         \c 0 on success.
    pub fn mbedtls_aes_crypt_ecb(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief  This function performs an AES-CBC encryption or decryption operation
    ///         on full blocks.
    ///
    ///         It performs the operation defined in the \p mode
    ///         parameter (encrypt/decrypt), on the input data buffer defined in
    ///         the \p input parameter.
    ///
    ///         It can be called as many times as needed, until all the input
    ///         data is processed. mbedtls_aes_init(), and either
    ///         mbedtls_aes_setkey_enc() or mbedtls_aes_setkey_dec() must be called
    ///         before the first call to this API with the same context.
    ///
    /// \note   This function operates on full blocks, that is, the input size
    ///         must be a multiple of the AES block size of \c 16 Bytes.
    ///
    /// \note   Upon exit, the content of the IV is updated so that you can
    ///         call the same function again on the next
    ///         block(s) of data and get the same result as if it was
    ///         encrypted in one call. This allows a "streaming" usage.
    ///         If you need to retain the contents of the IV, you should
    ///         either save it manually or use the cipher module instead.
    ///
    ///
    /// \param ctx      The AES context to use for encryption or decryption.
    ///                 It must be initialized and bound to a key.
    /// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
    ///                 #MBEDTLS_AES_DECRYPT.
    /// \param length   The length of the input data in Bytes. This must be a
    ///                 multiple of the block size (\c 16 Bytes).
    /// \param iv       Initialization vector (updated after use).
    ///                 It must be a readable and writeable buffer of \c 16 Bytes.
    /// \param input    The buffer holding the input data.
    ///                 It must be readable and of size \p length Bytes.
    /// \param output   The buffer holding the output data.
    ///                 It must be writeable and of size \p length Bytes.
    ///
    /// \return         \c 0 on success.
    /// \return         #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH
    ///                 on failure.
    pub fn mbedtls_aes_crypt_cbc(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief      This function performs an AES-XTS encryption or decryption
    ///             operation for an entire XTS data unit.
    ///
    ///             AES-XTS encrypts or decrypts blocks based on their location as
    ///             defined by a data unit number. The data unit number must be
    ///             provided by \p data_unit.
    ///
    ///             NIST SP 800-38E limits the maximum size of a data unit to 2^20
    ///             AES blocks. If the data unit is larger than this, this function
    ///             returns #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH.
    ///
    /// \param ctx          The AES XTS context to use for AES XTS operations.
    ///                     It must be initialized and bound to a key.
    /// \param mode         The AES operation: #MBEDTLS_AES_ENCRYPT or
    ///                     #MBEDTLS_AES_DECRYPT.
    /// \param length       The length of a data unit in Bytes. This can be any
    ///                     length between 16 bytes and 2^24 bytes inclusive
    ///                     (between 1 and 2^20 block cipher blocks).
    /// \param data_unit    The address of the data unit encoded as an array of 16
    ///                     bytes in little-endian format. For disk encryption, this
    ///                     is typically the index of the block device sector that
    ///                     contains the data.
    /// \param input        The buffer holding the input data (which is an entire
    ///                     data unit). This function reads \p length Bytes from \p
    ///                     input.
    /// \param output       The buffer holding the output data (which is an entire
    ///                     data unit). This function writes \p length Bytes to \p
    ///                     output.
    ///
    /// \return             \c 0 on success.
    /// \return             #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH if \p length is
    ///                     smaller than an AES block in size (16 Bytes) or if \p
    ///                     length is larger than 2^20 blocks (16 MiB).
    pub fn mbedtls_aes_crypt_xts(
        ctx: *mut mbedtls_aes_xts_context,
        mode: crate::c_types::c_int,
        length: usize,
        data_unit: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief This function performs an AES-CFB128 encryption or decryption
    ///        operation.
    ///
    ///        It performs the operation defined in the \p mode
    ///        parameter (encrypt or decrypt), on the input data buffer
    ///        defined in the \p input parameter.
    ///
    ///        For CFB, you must set up the context with mbedtls_aes_setkey_enc(),
    ///        regardless of whether you are performing an encryption or decryption
    ///        operation, that is, regardless of the \p mode parameter. This is
    ///        because CFB mode uses the same key schedule for encryption and
    ///        decryption.
    ///
    /// \note  Upon exit, the content of the IV is updated so that you can
    ///        call the same function again on the next
    ///        block(s) of data and get the same result as if it was
    ///        encrypted in one call. This allows a "streaming" usage.
    ///        If you need to retain the contents of the
    ///        IV, you must either save it manually or use the cipher
    ///        module instead.
    ///
    ///
    /// \param ctx      The AES context to use for encryption or decryption.
    ///                 It must be initialized and bound to a key.
    /// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
    ///                 #MBEDTLS_AES_DECRYPT.
    /// \param length   The length of the input data in Bytes.
    /// \param iv_off   The offset in IV (updated after use).
    ///                 It must point to a valid \c size_t.
    /// \param iv       The initialization vector (updated after use).
    ///                 It must be a readable and writeable buffer of \c 16 Bytes.
    /// \param input    The buffer holding the input data.
    ///                 It must be readable and of size \p length Bytes.
    /// \param output   The buffer holding the output data.
    ///                 It must be writeable and of size \p length Bytes.
    ///
    /// \return         \c 0 on success.
    pub fn mbedtls_aes_crypt_cfb128(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief This function performs an AES-CFB8 encryption or decryption
    ///        operation.
    ///
    ///        It performs the operation defined in the \p mode
    ///        parameter (encrypt/decrypt), on the input data buffer defined
    ///        in the \p input parameter.
    ///
    ///        Due to the nature of CFB, you must use the same key schedule for
    ///        both encryption and decryption operations. Therefore, you must
    ///        use the context initialized with mbedtls_aes_setkey_enc() for
    ///        both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT.
    ///
    /// \note  Upon exit, the content of the IV is updated so that you can
    ///        call the same function again on the next
    ///        block(s) of data and get the same result as if it was
    ///        encrypted in one call. This allows a "streaming" usage.
    ///        If you need to retain the contents of the
    ///        IV, you should either save it manually or use the cipher
    ///        module instead.
    ///
    ///
    /// \param ctx      The AES context to use for encryption or decryption.
    ///                 It must be initialized and bound to a key.
    /// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
    ///                 #MBEDTLS_AES_DECRYPT
    /// \param length   The length of the input data.
    /// \param iv       The initialization vector (updated after use).
    ///                 It must be a readable and writeable buffer of \c 16 Bytes.
    /// \param input    The buffer holding the input data.
    ///                 It must be readable and of size \p length Bytes.
    /// \param output   The buffer holding the output data.
    ///                 It must be writeable and of size \p length Bytes.
    ///
    /// \return         \c 0 on success.
    pub fn mbedtls_aes_crypt_cfb8(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief       This function performs an AES-OFB (Output Feedback Mode)
    ///              encryption or decryption operation.
    ///
    ///              For OFB, you must set up the context with
    ///              mbedtls_aes_setkey_enc(), regardless of whether you are
    ///              performing an encryption or decryption operation. This is
    ///              because OFB mode uses the same key schedule for encryption and
    ///              decryption.
    ///
    ///              The OFB operation is identical for encryption or decryption,
    ///              therefore no operation mode needs to be specified.
    ///
    /// \note        Upon exit, the content of iv, the Initialisation Vector, is
    ///              updated so that you can call the same function again on the next
    ///              block(s) of data and get the same result as if it was encrypted
    ///              in one call. This allows a "streaming" usage, by initialising
    ///              iv_off to 0 before the first call, and preserving its value
    ///              between calls.
    ///
    ///              For non-streaming use, the iv should be initialised on each call
    ///              to a unique value, and iv_off set to 0 on each call.
    ///
    ///              If you need to retain the contents of the initialisation vector,
    ///              you must either save it manually or use the cipher module
    ///              instead.
    ///
    /// \warning     For the OFB mode, the initialisation vector must be unique
    ///              every encryption operation. Reuse of an initialisation vector
    ///              will compromise security.
    ///
    /// \param ctx      The AES context to use for encryption or decryption.
    ///                 It must be initialized and bound to a key.
    /// \param length   The length of the input data.
    /// \param iv_off   The offset in IV (updated after use).
    ///                 It must point to a valid \c size_t.
    /// \param iv       The initialization vector (updated after use).
    ///                 It must be a readable and writeable buffer of \c 16 Bytes.
    /// \param input    The buffer holding the input data.
    ///                 It must be readable and of size \p length Bytes.
    /// \param output   The buffer holding the output data.
    ///                 It must be writeable and of size \p length Bytes.
    ///
    /// \return         \c 0 on success.
    pub fn mbedtls_aes_crypt_ofb(
        ctx: *mut mbedtls_aes_context,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief      This function performs an AES-CTR encryption or decryption
    ///             operation.
    ///
    ///             Due to the nature of CTR, you must use the same key schedule
    ///             for both encryption and decryption operations. Therefore, you
    ///             must use the context initialized with mbedtls_aes_setkey_enc()
    ///             for both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT.
    ///
    /// \warning    You must never reuse a nonce value with the same key. Doing so
    ///             would void the encryption for the two messages encrypted with
    ///             the same nonce and key.
    ///
    ///             There are two common strategies for managing nonces with CTR:
    ///
    ///             1. You can handle everything as a single message processed over
    ///             successive calls to this function. In that case, you want to
    ///             set \p nonce_counter and \p nc_off to 0 for the first call, and
    ///             then preserve the values of \p nonce_counter, \p nc_off and \p
    ///             stream_block across calls to this function as they will be
    ///             updated by this function.
    ///
    ///             With this strategy, you must not encrypt more than 2**128
    ///             blocks of data with the same key.
    ///
    ///             2. You can encrypt separate messages by dividing the \p
    ///             nonce_counter buffer in two areas: the first one used for a
    ///             per-message nonce, handled by yourself, and the second one
    ///             updated by this function internally.
    ///
    ///             For example, you might reserve the first 12 bytes for the
    ///             per-message nonce, and the last 4 bytes for internal use. In that
    ///             case, before calling this function on a new message you need to
    ///             set the first 12 bytes of \p nonce_counter to your chosen nonce
    ///             value, the last 4 to 0, and \p nc_off to 0 (which will cause \p
    ///             stream_block to be ignored). That way, you can encrypt at most
    ///             2**96 messages of up to 2**32 blocks each with the same key.
    ///
    ///             The per-message nonce (or information sufficient to reconstruct
    ///             it) needs to be communicated with the ciphertext and must be unique.
    ///             The recommended way to ensure uniqueness is to use a message
    ///             counter. An alternative is to generate random nonces, but this
    ///             limits the number of messages that can be securely encrypted:
    ///             for example, with 96-bit random nonces, you should not encrypt
    ///             more than 2**32 messages with the same key.
    ///
    ///             Note that for both strategies, sizes are measured in blocks and
    ///             that an AES block is 16 bytes.
    ///
    /// \warning    Upon return, \p stream_block contains sensitive data. Its
    ///             content must not be written to insecure storage and should be
    ///             securely discarded as soon as it's no longer needed.
    ///
    /// \param ctx              The AES context to use for encryption or decryption.
    ///                         It must be initialized and bound to a key.
    /// \param length           The length of the input data.
    /// \param nc_off           The offset in the current \p stream_block, for
    ///                         resuming within the current cipher stream. The
    ///                         offset pointer should be 0 at the start of a stream.
    ///                         It must point to a valid \c size_t.
    /// \param nonce_counter    The 128-bit nonce and counter.
    ///                         It must be a readable-writeable buffer of \c 16 Bytes.
    /// \param stream_block     The saved stream block for resuming. This is
    ///                         overwritten by the function.
    ///                         It must be a readable-writeable buffer of \c 16 Bytes.
    /// \param input            The buffer holding the input data.
    ///                         It must be readable and of size \p length Bytes.
    /// \param output           The buffer holding the output data.
    ///                         It must be writeable and of size \p length Bytes.
    ///
    /// \return                 \c 0 on success.
    pub fn mbedtls_aes_crypt_ctr(
        ctx: *mut mbedtls_aes_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut crate::c_types::c_uchar,
        stream_block: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Internal AES block encryption function. This is only
    ///                  exposed to allow overriding it using
    ///                  \c MBEDTLS_AES_ENCRYPT_ALT.
    ///
    /// \param ctx       The AES context to use for encryption.
    /// \param input     The plaintext block.
    /// \param output    The output (ciphertext) block.
    ///
    /// \return          \c 0 on success.
    pub fn mbedtls_internal_aes_encrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief           Internal AES block decryption function. This is only
    ///                  exposed to allow overriding it using see
    ///                  \c MBEDTLS_AES_DECRYPT_ALT.
    ///
    /// \param ctx       The AES context to use for decryption.
    /// \param input     The ciphertext block.
    /// \param output    The output (plaintext) block.
    ///
    /// \return          \c 0 on success.
    pub fn mbedtls_internal_aes_decrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief          Checkup routine.
    ///
    /// \return         \c 0 on success.
    /// \return         \c 1 on failure.
    pub fn mbedtls_aes_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
/// \brief          The CTR_DRBG context structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ctr_drbg_context {
    ///< The counter (V).
    pub private_counter: [crate::c_types::c_uchar; 16usize],
    ///< The reseed counter.
    /// This is the number of requests that have
    /// been made since the last (re)seeding,
    /// minus one.
    /// Before the initial seeding, this field
    /// contains the amount of entropy in bytes
    /// to use as a nonce for the initial seeding,
    /// or -1 if no nonce length has been explicitly
    /// set (see mbedtls_ctr_drbg_set_nonce_len()).
    pub private_reseed_counter: crate::c_types::c_int,
    ///< This determines whether prediction
    ///resistance is enabled, that is
    ///whether to systematically reseed before
    ///each random generation.
    pub private_prediction_resistance: crate::c_types::c_int,
    ///< The amount of entropy grabbed on each
    ///seed or reseed operation, in bytes.
    pub private_entropy_len: usize,
    ///< The reseed interval.
    /// This is the maximum number of requests
    /// that can be made between reseedings.
    pub private_reseed_interval: crate::c_types::c_int,
    ///< The AES context.
    pub private_aes_ctx: mbedtls_aes_context,
    pub private_f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut crate::c_types::c_uchar,
            arg3: usize,
        ) -> crate::c_types::c_int,
    >,
    ///< The context for the entropy function.
    pub private_p_entropy: *mut crate::c_types::c_void,
}
extern "C" {
    /// \brief               This function initializes the CTR_DRBG context,
    ///                      and prepares it for mbedtls_ctr_drbg_seed()
    ///                      or mbedtls_ctr_drbg_free().
    ///
    /// \note                The reseed interval is
    ///                      #MBEDTLS_CTR_DRBG_RESEED_INTERVAL by default.
    ///                      You can override it by calling
    ///                      mbedtls_ctr_drbg_set_reseed_interval().
    ///
    /// \param ctx           The CTR_DRBG context to initialize.
    pub fn mbedtls_ctr_drbg_init(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    /// - The \p custom string.
    ///
    /// \note                To achieve the nominal security strength permitted
    ///                      by CTR_DRBG, the entropy length must be:
    ///                      - at least 16 bytes for a 128-bit strength
    ///                      (maximum achievable strength when using AES-128);
    ///                      - at least 32 bytes for a 256-bit strength
    ///                      (maximum achievable strength when using AES-256).
    ///
    ///                      In addition, if you do not pass a nonce in \p custom,
    ///                      the sum of the entropy length
    ///                      and the entropy nonce length must be:
    ///                      - at least 24 bytes for a 128-bit strength
    ///                      (maximum achievable strength when using AES-128);
    ///                      - at least 48 bytes for a 256-bit strength
    ///                      (maximum achievable strength when using AES-256).
    ///
    /// \param ctx           The CTR_DRBG context to seed.
    ///                      It must have been initialized with
    ///                      mbedtls_ctr_drbg_init().
    ///                      After a successful call to mbedtls_ctr_drbg_seed(),
    ///                      you may not call mbedtls_ctr_drbg_seed() again on
    ///                      the same context unless you call
    ///                      mbedtls_ctr_drbg_free() and mbedtls_ctr_drbg_init()
    ///                      again first.
    ///                      After a failed call to mbedtls_ctr_drbg_seed(),
    ///                      you must call mbedtls_ctr_drbg_free().
    /// \param f_entropy     The entropy callback, taking as arguments the
    ///                      \p p_entropy context, the buffer to fill, and the
    ///                      length of the buffer.
    ///                      \p f_entropy is always called with a buffer size
    ///                      less than or equal to the entropy length.
    /// \param p_entropy     The entropy context to pass to \p f_entropy.
    /// \param custom        The personalization string.
    ///                      This can be \c NULL, in which case the personalization
    ///                      string is empty regardless of the value of \p len.
    /// \param len           The length of the personalization string.
    ///                      This must be at most
    ///                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT
    ///                      - #MBEDTLS_CTR_DRBG_ENTROPY_LEN.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure.
    pub fn mbedtls_ctr_drbg_seed(
        ctx: *mut mbedtls_ctr_drbg_context,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_entropy: *mut crate::c_types::c_void,
        custom: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function resets CTR_DRBG context to the state immediately
    ///                      after initial call of mbedtls_ctr_drbg_init().
    ///
    /// \param ctx           The CTR_DRBG context to clear.
    pub fn mbedtls_ctr_drbg_free(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    /// \brief               This function turns prediction resistance on or off.
    ///                      The default value is off.
    ///
    /// \note                If enabled, entropy is gathered at the beginning of
    ///                      every call to mbedtls_ctr_drbg_random_with_add()
    ///                      or mbedtls_ctr_drbg_random().
    ///                      Only use this if your entropy source has sufficient
    ///                      throughput.
    ///
    /// \param ctx           The CTR_DRBG context.
    /// \param resistance    #MBEDTLS_CTR_DRBG_PR_ON or #MBEDTLS_CTR_DRBG_PR_OFF.
    pub fn mbedtls_ctr_drbg_set_prediction_resistance(
        ctx: *mut mbedtls_ctr_drbg_context,
        resistance: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief               This function sets the amount of entropy grabbed on each
    ///                      seed or reseed.
    ///
    /// The default value is #MBEDTLS_CTR_DRBG_ENTROPY_LEN.
    ///
    /// \note                The security strength of CTR_DRBG is bounded by the
    ///                      entropy length. Thus:
    ///                      - When using AES-256
    ///                        (\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is disabled,
    ///                        which is the default),
    ///                        \p len must be at least 32 (in bytes)
    ///                        to achieve a 256-bit strength.
    ///                      - When using AES-128
    ///                        (\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is enabled)
    ///                        \p len must be at least 16 (in bytes)
    ///                        to achieve a 128-bit strength.
    ///
    /// \param ctx           The CTR_DRBG context.
    /// \param len           The amount of entropy to grab, in bytes.
    ///                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT
    ///                      and at most the maximum length accepted by the
    ///                      entropy function that is set in the context.
    pub fn mbedtls_ctr_drbg_set_entropy_len(ctx: *mut mbedtls_ctr_drbg_context, len: usize);
}
extern "C" {
    /// \brief               This function sets the amount of entropy grabbed
    ///                      as a nonce for the initial seeding.
    ///
    /// Call this function before calling mbedtls_ctr_drbg_seed() to read
    /// a nonce from the entropy source during the initial seeding.
    ///
    /// \param ctx           The CTR_DRBG context.
    /// \param len           The amount of entropy to grab for the nonce, in bytes.
    ///                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT
    ///                      and at most the maximum length accepted by the
    ///                      entropy function that is set in the context.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if \p len is
    ///                      more than #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.
    /// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED
    ///                      if the initial seeding has already taken place.
    pub fn mbedtls_ctr_drbg_set_nonce_len(
        ctx: *mut mbedtls_ctr_drbg_context,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               This function sets the reseed interval.
    ///
    /// The reseed interval is the number of calls to mbedtls_ctr_drbg_random()
    /// or mbedtls_ctr_drbg_random_with_add() after which the entropy function
    /// is called again.
    ///
    /// The default value is #MBEDTLS_CTR_DRBG_RESEED_INTERVAL.
    ///
    /// \param ctx           The CTR_DRBG context.
    /// \param interval      The reseed interval.
    pub fn mbedtls_ctr_drbg_set_reseed_interval(
        ctx: *mut mbedtls_ctr_drbg_context,
        interval: crate::c_types::c_int,
    );
}
extern "C" {
    /// \brief               This function reseeds the CTR_DRBG context, that is
    ///                      extracts data from the entropy source.
    ///
    /// \note                This function is not thread-safe. It is not safe
    ///                      to call this function if another thread might be
    ///                      concurrently obtaining random numbers from the same
    ///                      context or updating or reseeding the same context.
    ///
    /// \param ctx           The CTR_DRBG context.
    /// \param additional    Additional data to add to the state. Can be \c NULL.
    /// \param len           The length of the additional data.
    ///                      This must be less than
    ///                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \c entropy_len
    ///                      where \c entropy_len is the entropy length
    ///                      configured for the context.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure.
    pub fn mbedtls_ctr_drbg_reseed(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief              This function updates the state of the CTR_DRBG context.
    ///
    /// \note                This function is not thread-safe. It is not safe
    ///                      to call this function if another thread might be
    ///                      concurrently obtaining random numbers from the same
    ///                      context or updating or reseeding the same context.
    ///
    /// \param ctx          The CTR_DRBG context.
    /// \param additional   The data to update the state with. This must not be
    ///                     \c NULL unless \p add_len is \c 0.
    /// \param add_len      Length of \p additional in bytes. This must be at
    ///                     most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.
    ///
    /// \return             \c 0 on success.
    /// \return             #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if
    ///                     \p add_len is more than
    ///                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.
    /// \return             An error from the underlying AES cipher on failure.
    pub fn mbedtls_ctr_drbg_update(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const crate::c_types::c_uchar,
        add_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief   This function updates a CTR_DRBG instance with additional
    ///          data and uses it to generate random data.
    ///
    /// This function automatically reseeds if the reseed counter is exceeded
    /// or prediction resistance is enabled.
    ///
    /// \note                This function is not thread-safe. It is not safe
    ///                      to call this function if another thread might be
    ///                      concurrently obtaining random numbers from the same
    ///                      context or updating or reseeding the same context.
    ///
    /// \param p_rng         The CTR_DRBG context. This must be a pointer to a
    ///                      #mbedtls_ctr_drbg_context structure.
    /// \param output        The buffer to fill.
    /// \param output_len    The length of the buffer in bytes.
    /// \param additional    Additional data to update. Can be \c NULL, in which
    ///                      case the additional data is empty regardless of
    ///                      the value of \p add_len.
    /// \param add_len       The length of the additional data
    ///                      if \p additional is not \c NULL.
    ///                      This must be less than #MBEDTLS_CTR_DRBG_MAX_INPUT
    ///                      and less than
    ///                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \c entropy_len
    ///                      where \c entropy_len is the entropy length
    ///                      configured for the context.
    ///
    /// \return    \c 0 on success.
    /// \return    #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or
    ///            #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure.
    pub fn mbedtls_ctr_drbg_random_with_add(
        p_rng: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
        additional: *const crate::c_types::c_uchar,
        add_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \param p_rng         The CTR_DRBG context. This must be a pointer to a
    ///                      #mbedtls_ctr_drbg_context structure.
    /// \param output        The buffer to fill.
    /// \param output_len    The length of the buffer in bytes.
    ///
    /// \return              \c 0 on success.
    /// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or
    ///                      #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure.
    pub fn mbedtls_ctr_drbg_random(
        p_rng: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    /// \brief               The CTR_DRBG checkup routine.
    ///
    /// \return              \c 0 on success.
    /// \return              \c 1 on failure.
    pub fn mbedtls_ctr_drbg_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_exp_mod_soft(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        prec_RR: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
